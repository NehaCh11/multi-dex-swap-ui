{"version":3,"sources":["/Users/jg/Documents/code/balancer-maths/typescript/dist/index.js","../src/constants.ts","../src/utils/math.ts","../src/vault/utils.ts","../src/stable/stableMath.ts","../src/vault/types.ts","../src/stable/stablePool.ts","../src/vault/basePoolMath.ts","../src/weighted/weightedMath.ts","../src/weighted/weightedPool.ts","../src/gyro/gyroPoolMath.ts","../src/gyro/gyro2CLPMath.ts","../src/gyro/gyro2CLPPool.ts","../src/gyro/signedFixedPoint.ts","../src/gyro/gyroECLPMath.ts","../src/gyro/gyroECLPPool.ts","../src/utils/ozMath.ts","../src/reClamm/reClammMath.ts","../src/reClamm/reClammPool.ts","../src/reClammV2/reClammV2Math.ts","../src/reClammV2/reClammV2Pool.ts","../src/quantAmm/quantAmmMath.ts","../src/quantAmm/quantAmmPool.ts","../src/liquidityBootstrapping/liquidityBootstrappingMath.ts","../src/liquidityBootstrapping/liquidityBootstrapping.ts","../src/buffer/bufferMath.ts","../src/buffer/erc4626BufferWrapOrUnwrap.ts","../src/hooks/constants.ts","../src/hooks/exitFeeHook.ts","../src/hooks/directionalFeeHook.ts","../src/hooks/stableSurgeHook.ts","../src/hooks/akron/akronWeightedMath.ts","../src/hooks/akron/akronHook.ts","../src/vault/vault.ts"],"names":["MAX_UINT256","b","a","SwapKind","Rounding","AddKind","RemoveKind","computeInvariant"],"mappings":"AAAA,6EAAI,UAAU,EAAE,MAAM,CAAC,cAAc;AACrC,IAAI,gBAAgB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,IAAI,GAAG,IAAI,EAAE,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,EAAE,EAAE,KAAK;AAC/J,IAAI,cAAc,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,eAAe,CAAC,GAAG,EAAE,OAAO,IAAI,IAAI,SAAS,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,CAAC;AAC9G;AACA;ACJO,IAAM,YAAA,EACT,+EAAA;AAGG,IAAM,YAAA,EAAc,MAAA,CAAO,EAAA,GAAK,IAAA,EAAM,CAAC,CAAA;ADG9C;AACA;AERO,IAAM,IAAA,EAAM,oBAAA;AACZ,IAAM,IAAA,EAAM,sCAAA;AAEZ,IAAM,QAAA,EAAU,oBAAA;AAChB,IAAM,SAAA,EAAW,oBAAA;AACjB,IAAM,YAAA,EAAc,sBAAA;AACpB,IAAMA,aAAAA,EAAc,MAAA;AAAA,EACvB;AACJ,CAAA;AAUO,IAAM,SAAA,EAAW,CAACC,EAAAA,EAAY,OAAA,EAAA,GAAoB;AACrD,EAAA,GAAA,CAAI,CAACA,EAAAA,EAAG,MAAM,IAAI,KAAA,CAAM,OAAO,CAAA;AACnC,CAAA;AAIO,IAAM,SAAA,EAAN,MAAM,SAAQ;AAAA,EACjB,OAAO,GAAA,CAAIC,EAAAA,EAAWD,EAAAA,EAAmB;AACrC,IAAA,OAAOC,GAAAA,GAAKD,GAAAA,EAAIC,GAAAA,EAAID,EAAAA;AAAA,EACxB;AAAA,EAEA,OAAO,GAAA,CAAIC,EAAAA,EAAWD,EAAAA,EAAmB;AACrC,IAAA,OAAOC,GAAAA,EAAID,GAAAA,EAAIC,GAAAA,EAAID,EAAAA;AAAA,EACvB;AAAA,EAIA,OAAO,YAAA,CAAaC,EAAAA,EAAWD,EAAAA,EAAmB;AAC9C,IAAA,MAAM,QAAA,EAAUC,GAAAA,EAAID,EAAAA;AACpB,IAAA,OAAO,QAAA,EAAU,GAAA;AAAA,EACrB;AAAA,EAEA,OAAO,UAAA,CAAWC,EAAAA,EAAWD,EAAAA,EAAmB;AAC5C,IAAA,MAAM,QAAA,EAAUC,GAAAA,EAAID,EAAAA;AAEpB,IAAA,GAAA,CAAI,QAAA,IAAY,EAAA,EAAI;AAChB,MAAA,OAAO,EAAA;AAAA,IACX;AACA,IAAA,OAAA,CAAQ,QAAA,EAAU,EAAA,EAAA,EAAM,IAAA,EAAM,EAAA;AAAA,EAClC;AAAA;AAAA,EAGA,OAAO,aAAA,CAAcC,EAAAA,EAAWD,EAAAA,EAAW,CAAA,EAAmB;AAE1D,IAAA,MAAM,QAAA,EAAUC,GAAAA,EAAID,EAAAA;AAUpB,IAAA,OAAA,CAAQ,QAAA,EAAU,EAAA,EAAA,EAAM,EAAA,EAAI,EAAA;AAAA,EAChC;AAAA,EAEA,OAAO,YAAA,CAAaC,EAAAA,EAAWD,EAAAA,EAAmB;AAC9C,IAAA,GAAA,CAAIC,GAAAA,IAAM,EAAA,EAAI;AACV,MAAA,OAAO,EAAA;AAAA,IACX;AACA,IAAA,MAAM,UAAA,EAAYA,GAAAA,EAAI,GAAA;AACtB,IAAA,OAAO,UAAA,EAAYD,EAAAA;AAAA,EACvB;AAAA,EAEA,OAAO,UAAA,CAAWC,EAAAA,EAAWD,EAAAA,EAAmB;AAC5C,IAAA,GAAA,CAAIC,GAAAA,IAAM,EAAA,EAAI;AACV,MAAA,OAAO,EAAA;AAAA,IACX;AACA,IAAA,MAAM,UAAA,EAAYA,GAAAA,EAAI,GAAA;AACtB,IAAA,OAAA,CAAQ,UAAA,EAAY,EAAA,EAAA,EAAMD,GAAAA,EAAI,EAAA;AAAA,EAClC;AAAA;AAAA,EAGA,OAAO,KAAA,CAAMC,EAAAA,EAAWD,EAAAA,EAAmB;AACvC,IAAA,GAAA,CAAIA,GAAAA,IAAM,EAAA,EAAI;AACV,MAAA,OAAO,EAAA;AAAA,IACX;AACA,IAAA,OAAO,GAAA,EAAA,CAAMC,GAAAA,EAAI,EAAA,EAAA,EAAMD,EAAAA;AAAA,EAC3B;AAAA;AAAA,EAGA,OAAO,UAAA,CAAW,CAAA,EAAW,CAAA,EAAW,OAAA,EAA0B;AAC9D,IAAA,GAAA,CAAI,EAAA,IAAM,IAAA,GAAO,QAAA,IAAY,CAAA,EAAG;AAC5B,MAAA,OAAO,CAAA;AAAA,IACX;AACA,IAAA,GAAA,CAAI,EAAA,IAAM,QAAA,GAAW,QAAA,IAAY,CAAA,EAAG;AAChC,MAAA,OAAO,QAAA,CAAQ,UAAA,CAAW,CAAA,EAAG,CAAC,CAAA;AAAA,IAClC;AACA,IAAA,GAAA,CAAI,EAAA,IAAM,SAAA,GAAY,QAAA,IAAY,CAAA,EAAG;AACjC,MAAA,MAAM,OAAA,EAAS,QAAA,CAAQ,UAAA,CAAW,CAAA,EAAG,CAAC,CAAA;AACtC,MAAA,OAAO,QAAA,CAAQ,UAAA,CAAW,MAAA,EAAQ,MAAM,CAAA;AAAA,IAC5C;AACA,IAAA,MAAM,IAAA,EAAM,UAAA,CAAW,GAAA,CAAI,CAAA,EAAG,CAAC,CAAA;AAC/B,IAAA,MAAM,SAAA,EACF,QAAA,CAAQ,UAAA,CAAW,GAAA,EAAK,QAAA,CAAQ,sBAAsB,EAAA,EAAI,EAAA;AAC9D,IAAA,OAAO,IAAA,EAAM,QAAA;AAAA,EACjB;AAAA;AAAA,EAGA,OAAO,YAAA,CAAa,CAAA,EAAW,CAAA,EAAW,OAAA,EAA0B;AAChE,IAAA,GAAA,CAAI,EAAA,IAAM,IAAA,GAAO,QAAA,IAAY,CAAA,EAAG;AAC5B,MAAA,OAAO,CAAA;AAAA,IACX;AACA,IAAA,GAAA,CAAI,EAAA,IAAM,QAAA,GAAW,QAAA,IAAY,CAAA,EAAG;AAChC,MAAA,OAAO,QAAA,CAAQ,UAAA,CAAW,CAAA,EAAG,CAAC,CAAA;AAAA,IAClC;AACA,IAAA,GAAA,CAAI,EAAA,IAAM,SAAA,GAAY,QAAA,IAAY,CAAA,EAAG;AACjC,MAAA,MAAM,OAAA,EAAS,QAAA,CAAQ,UAAA,CAAW,CAAA,EAAG,CAAC,CAAA;AACtC,MAAA,OAAO,QAAA,CAAQ,UAAA,CAAW,MAAA,EAAQ,MAAM,CAAA;AAAA,IAC5C;AACA,IAAA,MAAM,IAAA,EAAM,UAAA,CAAW,GAAA,CAAI,CAAA,EAAG,CAAC,CAAA;AAC/B,IAAA,MAAM,SAAA,EACF,QAAA,CAAQ,UAAA,CAAW,GAAA,EAAK,QAAA,CAAQ,sBAAsB,EAAA,EAAI,EAAA;AAC9D,IAAA,GAAA,CAAI,IAAA,EAAM,QAAA,EAAU;AAChB,MAAA,OAAO,EAAA;AAAA,IACX;AACA,IAAA,OAAO,IAAA,EAAM,QAAA;AAAA,EACjB;AAAA,EAEA,OAAO,eAAA,CAAgB,CAAA,EAAmB;AACtC,IAAA,OAAO,EAAA,EAAI,IAAA,EAAM,IAAA,EAAM,EAAA,EAAI,EAAA;AAAA,EAC/B;AACJ,CAAA;AAlGI,aAAA,CATS,QAAA,EASF,wBAAA,EAAyB,MAAA,CAAA;AAT7B,IAAM,QAAA,EAAN,QAAA;AA6GA,IAAM,YAAA,EAAN,MAAM,YAAW;AAAA;AAAA;AAAA,EAqDpB,OAAO,GAAA,CAAI,CAAA,EAAW,CAAA,EAAmB;AACrC,IAAA,GAAA,CAAI,EAAA,IAAM,EAAA,EAAI;AAEV,MAAA,OAAO,GAAA;AAAA,IACX;AAEA,IAAA,GAAA,CAAI,EAAA,IAAM,EAAA,EAAI;AACV,MAAA,OAAO,EAAA;AAAA,IACX;AAOA,IAAA,QAAA;AAAA,MACI,EAAA,EACI,8EAAA;AAAA,MAEJ;AAAA,IACJ,CAAA;AACA,IAAA,MAAM,SAAA,EAAW,CAAA;AAMjB,IAAA,QAAA,CAAS,EAAA,EAAI,WAAA,CAAW,mBAAA,EAAqB,wBAAwB,CAAA;AACrE,IAAA,MAAM,SAAA,EAAW,CAAA;AAEjB,IAAA,IAAI,YAAA;AACJ,IAAA,GAAA,CACI,WAAA,CAAW,kBAAA,EAAoB,SAAA,GAC/B,SAAA,EAAW,WAAA,CAAW,iBAAA,EACxB;AACE,MAAA,MAAM,QAAA,EAAU,WAAA,CAAW,MAAA,CAAO,QAAQ,CAAA;AAM1C,MAAA,aAAA,EACK,QAAA,EAAU,IAAA,EAAO,SAAA,EAAa,QAAA,EAAU,IAAA,EAAO,SAAA,EAAY,GAAA;AAAA,IACpE,EAAA,KAAO;AACH,MAAA,aAAA,EAAe,WAAA,CAAW,GAAA,CAAI,QAAQ,EAAA,EAAI,QAAA;AAAA,IAC9C;AACA,IAAA,aAAA,GAAgB,GAAA;AAGhB,IAAA,QAAA;AAAA,MACI,WAAA,CAAW,qBAAA,GAAwB,aAAA,GAC/B,aAAA,GAAgB,WAAA,CAAW,oBAAA;AAAA,MAC/B;AAAA,IACJ,CAAA;AAGA,IAAA,OAAO,WAAA,CAAW,GAAA,CAAI,YAAY,CAAA;AAAA,EACtC;AAAA,EAEA,OAAO,GAAA,CAAI,EAAA,EAAoB;AAC3B,IAAA,IAAI,EAAA,EAAI,EAAA;AACR,IAAA,QAAA;AAAA,MACI,EAAA,GAAK,WAAA,CAAW,qBAAA,GACZ,EAAA,GAAK,WAAA,CAAW,oBAAA;AAAA,MACpB;AAAA,IACJ,CAAA;AAEA,IAAA,GAAA,CAAI,EAAA,EAAI,CAAA,EAAG;AAIP,MAAA,OAAQ,IAAA,EAAM,IAAA,EAAO,WAAA,CAAW,GAAA,CAAI,CAAC,GAAA,EAAK,CAAC,CAAA;AAAA,IAC/C;AAmBA,IAAA,IAAI,OAAA;AACJ,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAU,WAAA,CAAW,EAAA;AAAA,IACzB,EAAA,KAAA,GAAA,CAAW,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AAC3B,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAU,WAAA,CAAW,EAAA;AAAA,IACzB,EAAA,KAAO;AACH,MAAA,QAAA,EAAU,EAAA;AAAA,IACd;AAIA,IAAA,EAAA,GAAK,IAAA;AAIL,IAAA,IAAI,QAAA,EAAU,WAAA;AAEd,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AACA,IAAA,GAAA,CAAI,EAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAA,EAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,QAAA,EAAW,QAAA,EAAU,WAAA,CAAW,GAAA,EAAM,WAAA;AAAA,IAC1C;AAOA,IAAA,IAAI,UAAA,EAAY,WAAA;AAChB,IAAA,IAAI,IAAA;AAGJ,IAAA,KAAA,EAAO,CAAA;AACP,IAAA,UAAA,GAAa,IAAA;AAKb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,EAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,GAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,GAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AAEb,IAAA,KAAA,EAAQ,KAAA,EAAO,EAAA,EAAK,YAAA,EAAc,GAAA;AAClC,IAAA,UAAA,GAAa,IAAA;AASb,IAAA,OAAU,QAAA,EAAU,UAAA,EAAa,YAAA,EAAe,QAAA,EAAW,IAAA;AAAA,EAC/D;AAAA,EAEA,OAAO,MAAA,CAAO,EAAA,EAAoB;AAC9B,IAAA,IAAI,EAAA,EAAI,EAAA;AAKR,IAAA,EAAA,GAAK,GAAA;AAOL,IAAA,MAAM,EAAA,EAAA,CAAM,EAAA,EAAI,GAAA,EAAA,EAAO,IAAA,EAAA,CAAQ,EAAA,EAAI,GAAA,CAAA;AACnC,IAAA,MAAM,UAAA,EAAa,EAAA,EAAI,EAAA,EAAK,GAAA;AAG5B,IAAA,IAAI,IAAA,EAAM,CAAA;AAGV,IAAA,IAAI,UAAA,EAAY,GAAA;AAGhB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,GAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,GAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,GAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,GAAA;AAKnB,IAAA,OAAO,UAAA,EAAY,EAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,GAAA,CAAI,EAAA,EAAoB;AAC3B,IAAA,IAAIC,GAAAA,EAAI,EAAA;AACR,IAAA,GAAA,CAAIA,GAAAA,EAAI,GAAA,EAAK;AAIT,MAAA,OAAO,CAAC,GAAA,EAAK,WAAA,CAAW,GAAA,CAAK,IAAA,EAAM,IAAA,EAAOA,EAAC,CAAA;AAAA,IAC/C;AAiBA,IAAA,IAAI,IAAA,EAAM,EAAA;AACV,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,GAAA,EAAK,GAAA,EAAK;AAC1B,MAAAA,GAAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,GAAA,EAAK,GAAA,EAAK;AAC1B,MAAAA,GAAAA,GAAK,WAAA,CAAW,EAAA;AAChB,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAGA,IAAA,IAAA,GAAO,IAAA;AACP,IAAAA,GAAAA,GAAK,IAAA;AAIL,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,EAAA,EAAI;AACpB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,EAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,EAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,GAAA,EAAK;AACrB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,GAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,GAAA;AAAA,IACtB;AAEA,IAAA,GAAA,CAAIA,GAAAA,GAAK,WAAA,CAAW,GAAA,EAAK;AACrB,MAAAA,GAAAA,EAAKA,GAAAA,EAAI,YAAA,EAAe,WAAA,CAAW,GAAA;AACnC,MAAA,IAAA,GAAO,WAAA,CAAW,GAAA;AAAA,IACtB;AASA,IAAA,MAAM,EAAA,EAAA,CAAMA,GAAAA,EAAI,WAAA,EAAA,EAAe,YAAA,EAAA,CAAgBA,GAAAA,EAAI,WAAA,CAAA;AACnD,IAAA,MAAM,UAAA,EAAa,EAAA,EAAI,EAAA,EAAK,WAAA;AAG5B,IAAA,IAAI,IAAA,EAAM,CAAA;AAGV,IAAA,IAAI,UAAA,EAAY,GAAA;AAGhB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,WAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,WAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,WAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,WAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,EAAA;AAEnB,IAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAa,WAAA;AAC1B,IAAA,UAAA,GAAa,IAAA,EAAM,GAAA;AAKnB,IAAA,UAAA,GAAa,EAAA;AAMb,IAAA,OAAA,CAAQ,IAAA,EAAM,SAAA,EAAA,EAAa,IAAA;AAAA,EAC/B;AACJ,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9aI,aAAA,CAXS,WAAA,EAWF,sBAAA,EAAuB,sBAAA,CAAA;AAC9B,aAAA,CAZS,WAAA,EAYF,sBAAA,EAAuB,CAAC,qBAAA,CAAA;AAAA;AAAA;AAI/B,aAAA,CAhBS,WAAA,EAgBF,mBAAA,EAA4B,IAAA,EAAM,mBAAA,CAAA;AACzC,aAAA,CAjBS,WAAA,EAiBF,mBAAA,EAA4B,IAAA,EAAM,mBAAA,CAAA;AAAA;AAAA;AAIzC,aAAA,CArBS,WAAA,EAqBF,qBAAA,EACH,0DAAA,CAAA;AAAA;AAGJ,aAAA,CAzBS,WAAA,EAyBF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CA1BS,WAAA,EA0BF,IAAA,EAAK,yDAAA,CAAA;AAAA;AACZ,aAAA,CA3BS,WAAA,EA2BF,IAAA,EAAK,qBAAA,CAAA;AAAA;AACZ,aAAA,CA5BS,WAAA,EA4BF,IAAA,EAAK,6BAAA,CAAA;AAAA;AAAA;AAGZ,aAAA,CA/BS,WAAA,EA+BF,IAAA,EAAK,uBAAA,CAAA;AAAA;AACZ,aAAA,CAhCS,WAAA,EAgCF,IAAA,EAAK,mCAAA,CAAA;AAAA;AACZ,aAAA,CAjCS,WAAA,EAiCF,IAAA,EAAK,uBAAA,CAAA;AAAA;AACZ,aAAA,CAlCS,WAAA,EAkCF,IAAA,EAAK,4BAAA,CAAA;AAAA;AACZ,aAAA,CAnCS,WAAA,EAmCF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CApCS,WAAA,EAoCF,IAAA,EAAK,yBAAA,CAAA;AAAA;AACZ,aAAA,CArCS,WAAA,EAqCF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CAtCS,WAAA,EAsCF,IAAA,EAAK,uBAAA,CAAA;AAAA;AACZ,aAAA,CAvCS,WAAA,EAuCF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CAxCS,WAAA,EAwCF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CAzCS,WAAA,EAyCF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CA1CS,WAAA,EA0CF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CA3CS,WAAA,EA2CF,IAAA,EAAK,qBAAA,CAAA;AAAA;AACZ,aAAA,CA5CS,WAAA,EA4CF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CA7CS,WAAA,EA6CF,IAAA,EAAK,qBAAA,CAAA;AAAA;AACZ,aAAA,CA9CS,WAAA,EA8CF,IAAA,EAAK,sBAAA,CAAA;AAAA;AACZ,aAAA,CA/CS,WAAA,EA+CF,KAAA,EAAM,qBAAA,CAAA;AAAA;AACb,aAAA,CAhDS,WAAA,EAgDF,KAAA,EAAM,sBAAA,CAAA;AAAA;AACb,aAAA,CAjDS,WAAA,EAiDF,KAAA,EAAM,oBAAA,CAAA;AAAA;AACb,aAAA,CAlDS,WAAA,EAkDF,KAAA,EAAM,sBAAA,CAAA;AAlDV,IAAM,WAAA,EAAN,WAAA;AF4PP;AACA;AGhYO,SAAS,aAAA,CAAc,UAAA,EAAoB,UAAA,EAAoB;AAClE,EAAA,OAAO,UAAA,CAAW,WAAA,CAAY,EAAA,IAAM,UAAA,CAAW,WAAA,CAAY,CAAA;AAC/D;AAMO,SAAS,sBAAA,CACZ,MAAA,EACA,aAAA,EACA,SAAA,EACM;AAGN,EAAA,OAAO,OAAA,CAAQ,YAAA,CAAa,MAAA,EAAQ,cAAA,EAAgB,SAAS,CAAA;AACjE;AAMO,SAAS,oBAAA,CACZ,MAAA,EACA,aAAA,EACA,SAAA,EACM;AAGN,EAAA,OAAO,OAAA,CAAQ,UAAA,CAAW,MAAA,EAAQ,cAAA,EAAgB,SAAS,CAAA;AAC/D;AAMO,SAAS,4BAAA,CACZ,MAAA,EACA,aAAA,EACA,SAAA,EACM;AACN,EAAA,OAAO,OAAA,CAAQ,YAAA,CAAa,OAAA,EAAS,aAAA,EAAe,SAAS,CAAA;AACjE;AAMO,SAAS,0BAAA,CACZ,MAAA,EACA,aAAA,EACA,SAAA,EACM;AACN,EAAA,OAAO,OAAA,CAAQ,UAAA,CAAW,OAAA,EAAS,aAAA,EAAe,SAAS,CAAA;AAC/D;AH0VA;AACA;AIhZO,IAAM,qBAAA,EAAuB,MAAA,CAAO,oBAAoB,CAAA;AAExD,IAAM,qBAAA,EAAuB,MAAA,CAAO,qBAAqB,CAAA;AAKhE,IAAM,cAAA,EAAgB,KAAA;AAsBf,IAAM,kBAAA,EAAoB,CAC7B,sBAAA,EACA,QAAA,EAAA,GACS;AAWT,EAAA,IAAI,IAAA,EAAM,EAAA;AACV,EAAA,MAAM,UAAA,EAAY,QAAA,CAAS,MAAA;AAC3B,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,SAAA,EAAW,CAAA,EAAA,EAAK;AAChC,IAAA,IAAA,EAAM,IAAA,EAAM,QAAA,CAAS,CAAC,CAAA;AAAA,EAC1B;AACA,EAAA,GAAA,CAAI,IAAA,IAAQ,EAAA,EAAI;AACZ,IAAA,OAAO,EAAA;AAAA,EACX;AAEA,EAAA,IAAI,aAAA;AACJ,EAAA,IAAI,UAAA,EAAY,GAAA;AAChB,EAAA,MAAM,cAAA,EAAgB,uBAAA,EAAyB,MAAA,CAAO,SAAS,CAAA;AAE/D,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,GAAA,EAAK,CAAA,EAAA,EAAK;AAC1B,IAAA,IAAI,IAAA,EAAM,SAAA;AACV,IAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,SAAA,EAAW,EAAE,CAAA,EAAG;AAChC,MAAA,IAAA,EAAO,IAAA,EAAM,UAAA,EAAA,CAAc,QAAA,CAAS,CAAC,EAAA,EAAI,MAAA,CAAO,SAAS,CAAA,CAAA;AAAA,IAC7D;AAEA,IAAA,cAAA,EAAgB,SAAA;AAEhB,IAAA,UAAA,EAAA,CACO,cAAA,EAAgB,IAAA,EAAO,cAAA,EAAgB,IAAA,EAAM,MAAA,CAAO,SAAS,CAAA,EAAA,EAC5D,UAAA,EAAA,CAAA,CACD,cAAA,EAAgB,aAAA,EAAA,EAAiB,UAAA,EAAa,cAAA,EAAA,CAC5C,MAAA,CAAO,SAAS,EAAA,EAAI,EAAA,EAAA,EAAM,GAAA,CAAA;AAGnC,IAAA,GAAA,CAAI,UAAA,EAAY,aAAA,EAAe;AAC3B,MAAA,GAAA,CAAI,UAAA,EAAY,cAAA,GAAiB,CAAA,EAAG;AAChC,QAAA,OAAO,SAAA;AAAA,MACX;AAAA,IACJ,EAAA,KAAA,GAAA,CAAW,cAAA,EAAgB,UAAA,GAAa,CAAA,EAAG;AACvC,MAAA,OAAO,SAAA;AAAA,IACX;AAAA,EACJ;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,gCAAgC,CAAA;AACpD,CAAA;AAIO,SAAS,uBAAA,CACZ,sBAAA,EACA,QAAA,EACA,YAAA,EACA,aAAA,EACA,aAAA,EACA,SAAA,EACM;AAcN,EAAA,QAAA,CAAS,YAAY,EAAA,GAAK,aAAA;AAE1B,EAAA,MAAM,gBAAA,EAAkB,eAAA;AAAA,IACpB,sBAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,EACJ,CAAA;AAIA,EAAA,QAAA,CAAS,YAAY,EAAA,GAAK,aAAA;AAE1B,EAAA,OAAO,QAAA,CAAS,aAAa,EAAA,EAAI,gBAAA,EAAkB,EAAA;AACvD;AAKO,SAAS,uBAAA,CACZ,sBAAA,EACA,QAAA,EACA,YAAA,EACA,aAAA,EACA,cAAA,EACA,SAAA,EACM;AAcN,EAAA,GAAA,CAAI,QAAA,CAAS,aAAa,EAAA,GAAK,cAAA,EAAgB;AAC3C,IAAA,MAAM,IAAI,KAAA;AAAA,MACN;AAAA,IACJ,CAAA;AAAA,EACJ;AAGA,EAAA,QAAA,CAAS,aAAa,EAAA,GAAK,cAAA;AAE3B,EAAA,MAAM,eAAA,EAAiB,eAAA;AAAA,IACnB,sBAAA;AAAA,IACA,QAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,EACJ,CAAA;AAIA,EAAA,QAAA,CAAS,aAAa,EAAA,GAAK,cAAA;AAE3B,EAAA,OAAO,eAAA,EAAiB,QAAA,CAAS,YAAY,EAAA,EAAI,EAAA;AACrD;AAIO,SAAS,eAAA,CACZ,sBAAA,EACA,QAAA,EACA,SAAA,EACA,UAAA,EACM;AAEN,EAAA,MAAM,UAAA,EAAY,QAAA,CAAS,MAAA;AAC3B,EAAA,MAAM,cAAA,EAAgB,uBAAA,EAAyB,MAAA,CAAO,SAAS,CAAA;AAC/D,EAAA,IAAI,IAAA,EAAM,QAAA,CAAS,CAAC,CAAA;AACpB,EAAA,IAAI,IAAA,EAAM,QAAA,CAAS,CAAC,EAAA,EAAI,MAAA,CAAO,SAAS,CAAA;AACxC,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,SAAA,EAAW,EAAE,CAAA,EAAG;AAChC,IAAA,IAAA,EAAO,IAAA,EAAM,QAAA,CAAS,CAAC,EAAA,EAAI,MAAA,CAAO,SAAS,EAAA,EAAK,SAAA;AAChD,IAAA,IAAA,EAAM,IAAA,EAAM,QAAA,CAAS,CAAC,CAAA;AAAA,EAC1B;AACA,EAAA,IAAA,EAAM,IAAA,EAAM,QAAA,CAAS,UAAU,CAAA;AAG/B,EAAA,MAAM,KAAA,EAAO,UAAA,EAAY,SAAA;AAEzB,EAAA,MAAM,EAAA,EACF,OAAA,CAAQ,KAAA,CAAM,KAAA,EAAO,aAAA,EAAe,cAAA,EAAgB,GAAG,EAAA,EACvD,QAAA,CAAS,UAAU,CAAA;AAEvB,EAAA,MAAMD,GAAAA,EAAI,IAAA,EAAO,UAAA,EAAY,cAAA,EAAiB,aAAA;AAE9C,EAAA,IAAI,iBAAA,EAAmB,EAAA;AAGvB,EAAA,IAAI,aAAA,EAAe,OAAA,CAAQ,KAAA,CAAM,KAAA,EAAO,CAAA,EAAG,UAAA,EAAYA,EAAC,CAAA;AAExD,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,GAAA,EAAK,EAAE,CAAA,EAAG;AAC1B,IAAA,iBAAA,EAAmB,YAAA;AAGnB,IAAA,aAAA,EAAe,OAAA,CAAQ,KAAA;AAAA,MACnB,aAAA,EAAe,aAAA,EAAe,CAAA;AAAA,MAC9B,aAAA,EAAe,GAAA,EAAKA,GAAAA,EAAI;AAAA,IAC5B,CAAA;AAGA,IAAA,GAAA,CAAI,aAAA,EAAe,gBAAA,EAAkB;AACjC,MAAA,GAAA,CAAI,aAAA,EAAe,iBAAA,GAAoB,CAAA,EAAG;AACtC,QAAA,OAAO,YAAA;AAAA,MACX;AAAA,IACJ,EAAA,KAAA,GAAA,CAAW,iBAAA,EAAmB,aAAA,GAAgB,CAAA,EAAG;AAC7C,MAAA,OAAO,YAAA;AAAA,IACX;AAAA,EACJ;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,iCAAiC,CAAA;AACrD;AJ6QA;AACA;AKhdO,IAAK,SAAA,kBAAL,CAAA,CAAKE,SAAAA,EAAAA,GAAL;AACH,EAAAA,SAAAA,CAAAA,SAAAA,CAAA,SAAA,EAAA,EAAU,CAAA,EAAA,EAAV,SAAA;AACA,EAAAA,SAAAA,CAAAA,SAAAA,CAAA,UAAA,EAAA,EAAW,CAAA,EAAA,EAAX,UAAA;AAFQ,EAAA,OAAAA,SAAAA;AAAA,CAAA,CAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA;AAKL,IAAK,SAAA,kBAAL,CAAA,CAAKC,SAAAA,EAAAA,GAAL;AACH,EAAAA,SAAAA,CAAAA,SAAAA,CAAA,UAAA,EAAA,EAAW,CAAA,EAAA,EAAX,UAAA;AACA,EAAAA,SAAAA,CAAAA,SAAAA,CAAA,YAAA,EAAA,EAAa,CAAA,EAAA,EAAb,YAAA;AAFQ,EAAA,OAAAA,SAAAA;AAAA,CAAA,CAAA,CAAA,SAAA,GAAA,CAAA,CAAA,CAAA;AAiEL,IAAK,QAAA,kBAAL,CAAA,CAAKC,QAAAA,EAAAA,GAAL;AACH,EAAAA,QAAAA,CAAAA,QAAAA,CAAA,YAAA,EAAA,EAAa,CAAA,EAAA,EAAb,YAAA;AACA,EAAAA,QAAAA,CAAAA,QAAAA,CAAA,wBAAA,EAAA,EAAyB,CAAA,EAAA,EAAzB,wBAAA;AAFQ,EAAA,OAAAA,QAAAA;AAAA,CAAA,CAAA,CAAA,QAAA,GAAA,CAAA,CAAA,CAAA;AAYL,IAAK,WAAA,kBAAL,CAAA,CAAKC,WAAAA,EAAAA,GAAL;AACH,EAAAA,WAAAA,CAAAA,WAAAA,CAAA,cAAA,EAAA,EAAe,CAAA,EAAA,EAAf,cAAA;AACA,EAAAA,WAAAA,CAAAA,WAAAA,CAAA,uBAAA,EAAA,EAAwB,CAAA,EAAA,EAAxB,uBAAA;AACA,EAAAA,WAAAA,CAAAA,WAAAA,CAAA,wBAAA,EAAA,EAAyB,CAAA,EAAA,EAAzB,wBAAA;AAHQ,EAAA,OAAAA,WAAAA;AAAA,CAAA,CAAA,CAAA,WAAA,GAAA,CAAA,CAAA,CAAA;ALoZZ;AACA;AMlfO,IAAM,OAAA,EAAN,MAAiC;AAAA,EAGpC,WAAA,CAAY,SAAA,EAA0B;AAFtC,IAAA,aAAA,CAAA,IAAA,EAAO,KAAA,CAAA;AAGH,IAAA,IAAA,CAAK,IAAA,EAAM,SAAA,CAAU,GAAA;AAAA,EACzB;AAAA,EAEA,wBAAA,CAAA,EAAmC;AAC/B,IAAA,OAAO,oBAAA;AAAA,EACX;AAAA,EAEA,wBAAA,CAAA,EAAmC;AAC/B,IAAA,OAAO,oBAAA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAA,CAAiB,aAAA,EAAsC;AACnD,IAAA,MAAM;AAAA,MACF,oBAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA,UAAA;AAAA,MACA,cAAA;AAAA,MACA;AAAA,IACJ,EAAA,EAAI,aAAA;AACJ,IAAA,GAAA,CAAI,SAAA,IAAA,eAAA,EAA+B;AAE/B,MAAA,MAAM,KAAA,EAAO,YAAA,EAAc,oBAAA,CAAqB,OAAO,CAAA;AAEvD,MAAA,OAAO,sBAAA;AAAA,QACH,IAAA;AAAA,QACA,cAAA,CAAe,OAAO,CAAA;AAAA,QACtB,UAAA,CAAW,OAAO;AAAA,MACtB,CAAA;AAAA,IACJ;AAEA,IAAA,MAAM,IAAA,EAAM,OAAA,CAAQ,YAAA;AAAA,MAChB,mBAAA;AAAA,MACA,oBAAA,CAAqB,QAAQ;AAAA,IACjC,CAAA;AAEA,IAAA,OAAO,sBAAA;AAAA,MACH,GAAA;AAAA,MACA,cAAA,CAAe,QAAQ,CAAA;AAAA,MACvB,UAAA,CAAW,QAAQ;AAAA,IACvB,CAAA;AAAA,EACJ;AAAA,EAEA,0BAAA,CAAA,EAAqC;AACjC,IAAA,OAAO,WAAA;AAAA,EACX;AAAA,EAEA,6BAAA,CACI,eAAA,EACM;AACN,IAAA,MAAM;AAAA,MACF,SAAA;AAAA,MACA,WAAA;AAAA,MACA,eAAA;AAAA,MACA,qBAAA;AAAA,MACA;AAAA,IACJ,EAAA,EAAI,eAAA;AACJ,IAAA,OAAO,IAAA,CAAK,gBAAA,CAAiB;AAAA,MACzB,QAAA,EAAU,UAAA,EAAA,gBAAA,EAAA,gBAAA;AAAA,MACV,oBAAA,EAAsB,CAAC,WAAA,EAAa,eAAe,CAAA;AAAA,MACnD,UAAA,EAAY,CAAC,oBAAA,EAAsB,YAAY,CAAA;AAAA,MAC/C,cAAA,EAAgB,CAAC,oBAAA,EAAsB,qBAAqB,CAAA;AAAA,MAC5D,OAAA,EAAS,CAAA;AAAA,MACT,QAAA,EAAU;AAAA,IACd,CAAC,CAAA;AAAA,EACL;AAAA,EAEA,MAAA,CAAO,UAAA,EAAgC;AACnC,IAAA,MAAM;AAAA,MACF,QAAA;AAAA,MACA,oBAAA,EAAsB,gBAAA;AAAA,MACtB,OAAA;AAAA,MACA,QAAA;AAAA,MACA;AAAA,IACJ,EAAA,EAAI,UAAA;AACJ,IAAA,MAAM,UAAA,EAAY,iBAAA,CAAkB,IAAA,CAAK,GAAA,EAAK,gBAAgB,CAAA;AAE9D,IAAA,GAAA,CAAI,SAAA,IAAA,eAAA,EAA+B;AAC/B,MAAA,OAAO,uBAAA;AAAA,QACH,IAAA,CAAK,GAAA;AAAA,QACL,gBAAA;AAAA,QACA,OAAA;AAAA,QACA,QAAA;AAAA,QACA,mBAAA;AAAA,QACA;AAAA,MACJ,CAAA;AAAA,IACJ;AACA,IAAA,OAAO,uBAAA;AAAA,MACH,IAAA,CAAK,GAAA;AAAA,MACL,gBAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA,mBAAA;AAAA,MACA;AAAA,IACJ,CAAA;AAAA,EACJ;AAAA,EACA,gBAAA,CACI,oBAAA,EACA,QAAA,EACM;AACN,IAAA,IAAI,UAAA,EAAY,iBAAA,CAAkB,IAAA,CAAK,GAAA,EAAK,oBAAoB,CAAA;AAChE,IAAA,GAAA,CAAI,UAAA,EAAY,CAAA,EAAG;AACf,MAAA,UAAA,EACI,SAAA,GAAA,mBAAA,EAAkC,UAAA,EAAY,UAAA,EAAY,EAAA;AAAA,IAClE;AACA,IAAA,OAAO,SAAA;AAAA,EACX;AAAA,EACA,cAAA,CACI,oBAAA,EACA,YAAA,EACA,cAAA,EACM;AACN,IAAA,OAAO,eAAA;AAAA,MACH,IAAA,CAAK,GAAA;AAAA,MACL,oBAAA;AAAA,MACA,OAAA,CAAQ,UAAA;AAAA,QACJ,IAAA,CAAK,gBAAA,CAAiB,oBAAA,EAAA,gBAAuC,CAAA;AAAA,QAC7D;AAAA,MACJ,CAAA;AAAA,MACA;AAAA,IACJ,CAAA;AAAA,EACJ;AACJ,CAAA;AN8dA;AACA;AOnnBO,SAAS,6BAAA,CACZ,eAAA,EACA,YAAA,EACA,WAAA,EACA,iBAAA,EACA,iBAAA,EACAC,iBAAAA,EACkD;AAYlD,EAAA,MAAM,UAAA,EAAY,eAAA,CAAgB,MAAA;AAGlC,EAAA,MAAM,YAAA,EAAwB,IAAI,KAAA,CAAM,SAAS,CAAA;AAEjD,EAAA,MAAM,eAAA,EAA2B,IAAI,KAAA,CAAM,SAAS,CAAA,CAAE,IAAA,CAAK,EAAE,CAAA;AAG7D,EAAA,IAAA,CAAA,IAAS,MAAA,EAAQ,CAAA,EAAG,MAAA,EAAQ,eAAA,CAAgB,MAAA,EAAQ,KAAA,EAAA,EAAS;AACzD,IAAA,WAAA,CAAY,KAAK,EAAA,EAAI,eAAA,CAAgB,KAAK,EAAA,EAAI,YAAA,CAAa,KAAK,EAAA,EAAI,EAAA;AAAA,EACxE;AAGA,EAAA,MAAM,iBAAA,EAAmBA,iBAAAA;AAAA,IACrB,eAAA;AAAA,IAAA;AAAA,EAEJ,CAAA;AAGA,EAAA,MAAM,aAAA,EAAeA,iBAAAA,CAAiB,WAAA,EAAA,kBAAgC,CAAA;AAGtE,EAAA,MAAM,eAAA,EAAiB,OAAA,CAAQ,YAAA,CAAa,YAAA,EAAc,gBAAgB,CAAA;AAG1E,EAAA,GAAA,CAAI,eAAA,EAAiB,iBAAA,EAAmB;AACpC,IAAA,MAAM,KAAA;AAAA,MACF,CAAA,uBAAA,EAA0B,cAAc,CAAA,CAAA,EAAI,iBAAiB,CAAA;AAAA,IAAA;AACjE,EAAA;AAIJ,EAAA;AAMI,IAAA;AAAyC,MAAA;AACrC,MAAA;AACqB,IAAA;AAEzB,IAAA;AACI,MAAA;AAEA,MAAA;AAAgC,QAAA;AAC5B,QAAA;AACA,MAAA;AAIJ,MAAA;AAA8D,IAAA;AAClE,EAAA;AAIJ,EAAA;AAAiC,IAAA;AAC7B,IAAA;AAAA,EAAA;AAgBJ,EAAA;AAGA,EAAA;AACJ;AAEO;AAiBH,EAAA;AAEA,EAAA;AAEA,EAAA;AACI,IAAA;AAAM,MAAA;AAC2D,IAAA;AACjE,EAAA;AAKJ,EAAA;AAAmB,IAAA;AACf,IAAA;AACA,IAAA;AACA,EAAA;AAEJ,EAAA;AAIA,EAAA;AAAkC,IAAA;AAC+B,IAAA;AAC7D,EAAA;AAGJ,EAAA;AAIA,EAAA;AACY,IAAA;AACJ,IAAA;AACyC,EAAA;AAIjD,EAAA;AACA,EAAA;AAGA,EAAA;AACA,EAAA;AACJ;AAgBO;AAeH,EAAA;AACA,EAAA;AAGI,IAAA;AAA4D,EAAA;AAEhE,EAAA;AACJ;AAeO;AAcH,EAAA;AAEA,EAAA;AACA,EAAA;AACI,IAAA;AAAM,MAAA;AAC2D,IAAA;AACjE,EAAA;AAKJ,EAAA;AAAmB,IAAA;AACf,IAAA;AACA,IAAA;AACA,EAAA;AAIJ,EAAA;AAEA,EAAA;AAAoC,IAAA;AAChC,IAAA;AAC6B,IAAA;AAC7B,EAAA;AAIJ,EAAA;AAGA,EAAA;AAGA,EAAA;AACA,EAAA;AAGA,EAAA;AAEA,EAAA;AAAO,IAAA;AACH,IAAA;AACA,EAAA;AAER;AAYO;AAaH,EAAA;AAGA,EAAA;AAGA,EAAA;AACI,IAAA;AAA8C,EAAA;AAGlD,EAAA;AAGA,EAAA;AAAyB,IAAA;AACrB,IAAA;AAAA,EAAA;AAQJ,EAAA;AAA+B,IAAA;AACoB,IAAA;AAC/C,EAAA;AAGJ,EAAA;AACI,IAAA;AAAM,MAAA;AAC2D,IAAA;AACjE,EAAA;AAIJ,EAAA;AAIA,EAAA;AACY,IAAA;AACJ,IAAA;AACyC,EAAA;AAIjD,EAAA;AAGA,EAAA;AAAiC,IAAA;AAC7B,IAAA;AAAA,EAAA;AAKJ,EAAA;AACA,EAAA;AAWA,EAAA;AAA4B,IAAA;AACxB,IAAA;AACmB,IAAA;AACnB,EAAA;AAGJ,EAAA;AAAO,IAAA;AACH,IAAA;AACA,EAAA;AAER;APoZA;AACA;AQrwBO;AAMA;AACA;AAGA;AAEA;AAYA;AAWH,EAAA;AACA,EAAA;AACI,IAAA;AAAoB,MAAA;AAChB,MAAA;AACsD,IAAA;AAC1D,EAAA;AAEJ,EAAA;AACI,IAAA;AAA+B,EAAA;AAEnC,EAAA;AACJ;AAYO;AAWH,EAAA;AACA,EAAA;AACI,IAAA;AAAoB,MAAA;AAChB,MAAA;AACoD,IAAA;AACxD,EAAA;AAGJ,EAAA;AACI,IAAA;AAA+B,EAAA;AAEnC,EAAA;AACJ;AAEO;AAgBH,EAAA;AAA6B,IAAA;AACzB,IAAA;AAC8B,EAAA;AAGlC,EAAA;AACJ;AAIO;AAiBH,EAAA;AACI,IAAA;AAAqC,EAAA;AAGzC,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AAGA,EAAA;AACJ;AAIO;AAiBH,EAAA;AACI,IAAA;AAAsC,EAAA;AAG1C,EAAA;AACA,EAAA;AACA,EAAA;AAIA,EAAA;AAEA,EAAA;AACJ;ARqpBA;AACA;AS9yBO;AAAmC,EAAA;AACtC,IAAA;AAGI,IAAA;AAAmC,EAAA;AACvC,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AACI,MAAA;AAAsB,QAAA;AACU,QAAA;AAC5B,MAAA;AAGJ,MAAA;AAAO,QAAA;AACH,QAAA;AACsB,QAAA;AACJ,MAAA;AACtB,IAAA;AAGJ,IAAA;AAAsB,MAAA;AACW,MAAA;AAC7B,IAAA;AAGJ,IAAA;AAAO,MAAA;AACH,MAAA;AACuB,MAAA;AACJ,IAAA;AACvB,EAAA;AACJ,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAA6B,MAAA;AACf,MAAA;AACyC,MAAA;AACJ,MAAA;AACa,MAAA;AACnD,MAAA;AACC,IAAA;AACb,EAAA;AACL,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACsB,MAAA;AACtB,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AACI,MAAA;AAAO,QAAA;AACqB,QAAA;AACM,QAAA;AACL,QAAA;AACM,QAAA;AAC/B,MAAA;AACJ,IAAA;AAEJ,IAAA;AAAO,MAAA;AACqB,MAAA;AACM,MAAA;AACL,MAAA;AACM,MAAA;AAC/B,IAAA;AACJ,EAAA;AACJ,EAAA;AAKI,IAAA;AACI,MAAA;AAAO,QAAA;AACE,QAAA;AACL,MAAA;AACJ,IAAA;AAEA,MAAA;AAAO,QAAA;AACE,QAAA;AACL,MAAA;AACJ,EAAA;AACR,EAAA;AAMI,IAAA;AAAO,MAAA;AAC8B,MAAA;AACE,MAAA;AACnC,IAAA;AACJ,EAAA;AAER;AT6xBA;AACA;AUp7BO;AAAmB;AAAA,EAAA;AAalB,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AAMA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAMA,IAAA;AACA,IAAA;AAMI,MAAA;AAA0B,IAAA;AAG9B,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACI,MAAA;AAAkD,IAAA;AAElD,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAAO,IAAA;AACX,EAAA;AACJ,EAAA;AAGI,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAET,IAAA;AACI,MAAA;AACA,MAAA;AAAK,IAAA;AAGT,IAAA;AAAO,EAAA;AAEf;AA1GI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AVkgCJ;AACA;AWrgCO;AAiBH,EAAA;AAA+B,IAAA;AAC3B,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AAGJ,EAAA;AACJ;AAgBA;AAMI,EAAA;AAKA,EAAA;AAKA,EAAA;AASA,EAAA;AAGA,EAAA;AACA,EAAA;AACA,EAAA;AAEA,EAAA;AAIA,EAAA;AAAc,IAAA;AACoD,IAAA;AAC9D,EAAA;AAEJ,EAAA;AAAa,IAAA;AAC0D,IAAA;AACnE,EAAA;AAEJ,EAAA;AAAa,IAAA;AAC4B,IAAA;AACN,EAAA;AAEnC,EAAA;AACA,EAAA;AACJ;AAYA;AAMI,EAAA;AAEA,EAAA;AAEA,EAAA;AACA,EAAA;AAEA,EAAA;AACA,EAAA;AACA,EAAA;AACJ;AAkBO;AAyBH,EAAA;AAEA,EAAA;AAGA,EAAA;AAA0B,IAAA;AACqB,IAAA;AAC9B,EAAA;AAIjB,EAAA;AACI,IAAA;AAAiC,EAAA;AAErC,EAAA;AACJ;AAMO;AAsBH,EAAA;AACI,IAAA;AAAiC,EAAA;AAKrC,EAAA;AAEA,EAAA;AAGA,EAAA;AAAyB,IAAA;AACmB,IAAA;AACzB,EAAA;AAEnB,EAAA;AACJ;AAGO;AAKH,EAAA;AAGJ;AAGO;AAKH,EAAA;AAGJ;AX21BA;AACA;AYpkCO;AAAmC,EAAA;AACtC,IAAA;AACA,IAAA;AAGI,IAAA;AACI,MAAA;AAA6B,IAAA;AAGjC,IAAA;AACA,IAAA;AAA2B,EAAA;AAC/B,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAEI,MAAA;AAEA,MAAA;AAAO,QAAA;AACH,QAAA;AACsB,QAAA;AACJ,MAAA;AACtB,IAAA;AAGJ,IAAA;AAAoB,MAAA;AAChB,MAAA;AAC6B,IAAA;AAGjC,IAAA;AAAO,MAAA;AACH,MAAA;AACuB,MAAA;AACJ,IAAA;AACvB,EAAA;AACJ,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAA6B,MAAA;AACf,MAAA;AACyC,MAAA;AACJ,MAAA;AACa,MAAA;AACnD,MAAA;AACC,IAAA;AACb,EAAA;AACL,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACsB,MAAA;AACtB,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AACA,IAAA;AACA,IAAA;AAEA,IAAA;AAAqD,MAAA;AACjD,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AACI,MAAA;AAA0B,QAAA;AACtB,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAEJ,MAAA;AAAO,IAAA;AAEX,IAAA;AAAyB,MAAA;AACrB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAO,EAAA;AACX,EAAA;AAMI,IAAA;AAAO,MAAA;AACH,MAAA;AACK,MAAA;AACA,MAAA;AACL,IAAA;AACJ,EAAA;AACJ,EAAA;AA+BI,IAAA;AAAgB,MAAA;AACZ,MAAA;AACK,MAAA;AACA,MAAA;AAAA,IAAA;AAIT,IAAA;AACA,IAAA;AAEA,IAAA;AAEA,IAAA;AAEA,IAAA;AACA,IAAA;AAEI,MAAA;AAC+D,IAAA;AAG/D,MAAA;AAC+D,IAAA;AAEnE,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAaI,IAAA;AACA,IAAA;AAGA,IAAA;AAIA,IAAA;AAAyB,MAAA;AACrB,MAAA;AACK,MAAA;AACA,MAAA;AAAA,IAAA;AAUT,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AAAmB,QAAA;AACf,QAAA;AACK,QAAA;AAAA,MAAA;AAGT,MAAA;AAAoB,QAAA;AAChB,QAAA;AACK,QAAA;AAAA,MAAA;AAET,IAAA;AAEA,MAAA;AAAmB,QAAA;AACf,QAAA;AACK,QAAA;AAAA,MAAA;AAGT,MAAA;AAAoB,QAAA;AAChB,QAAA;AACK,QAAA;AAAA,MAAA;AAET,IAAA;AAGJ,IAAA;AAAO,MAAA;AACH,MAAA;AACA,IAAA;AACJ,EAAA;AAER;AZy/BA;AACA;Aa3wCA;AAAoC,EAAA;AAE5B,IAAA;AACA,IAAA;AAAY,EAAA;AAEpB;AAEO;AAAuB;AAAA,EAAA;AAOtB,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAA8C,EAAA;AAClD,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAAsB,EAAA;AAC1B,EAAA;AAGI,IAAA;AAAsB,EAAA;AAC1B,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAG3C,IAAA;AACI,MAAA;AAAmC,IAAA;AAEnC,MAAA;AAAmC,IAAA;AAEvC,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AAAmC,IAAA;AAEnC,MAAA;AAAmC,IAAA;AAEvC,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAG3C,IAAA;AAAmB,EAAA;AACvB,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AAAwB,EAAA;AAC5B,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AACA,MAAA;AAAU,IAAA;AAGd,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAG3C,IAAA;AACI,MAAA;AAAmC,IAAA;AAEvC,IAAA;AAAmC,EAAA;AACvC,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AACA,MAAA;AAAU,IAAA;AAGd,IAAA;AACI,MAAA;AAA2C,IAAA;AAE/C,IAAA;AAA2C,EAAA;AAC/C,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAAsB,EAAA;AAC1B,EAAA;AAGI,IAAA;AAAsB,EAAA;AAC1B,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAG3C,IAAA;AAAmB,EAAA;AACvB,EAAA;AAGI,IAAA;AACI,MAAA;AAAwC,IAAA;AAE5C,IAAA;AAA2B,EAAA;AAC/B,EAAA;AAGI,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAEyC,EAAA;AAC7C,EAAA;AAGI,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAEyC,EAAA;AAC7C,EAAA;AAGI,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AACA,IAAA;AACA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AAEyC,EAAA;AAC7C,EAAA;AAGI,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAEyC,EAAA;AAC7C,EAAA;AAGI,IAAA;AACI,MAAA;AAAO,IAAA;AAEX,IAAA;AAAkB,EAAA;AAE1B;AApOI;AAAyD;AACzD;AAAgC,EAAA;AAEhC;Aby8CJ;AACA;Act8CA;AAA6C,EAAA;AAErC,IAAA;AACA,IAAA;AAAY,EAAA;AAEpB;AAEA;AAA8C,EAAA;AAEtC,IAAA;AACA,IAAA;AAAY,EAAA;AAEpB;AAqBO;AAAmB;AAAA,EAAA;AAgClB,IAAA;AAAA,MAAA;AACsC,MAAA;AACA,IAAA;AAEtC,IAAA;AAAA,MAAA;AACsC,MAAA;AACA,IAAA;AAGtC,IAAA;AACA,IAAA;AAEA,IAAA;AAAA,MAAA;AAEoC,MAAA;AAChC,IAAA;AAEJ,IAAA;AAAA,MAAA;AACgD,MAAA;AACU,IAAA;AAC1D,EAAA;AACJ,EAAA;AAMI,IAAA;AACA,IAAA;AACA,IAAA;AAAA,MAAA;AACyC,MAAA;AACrC,IAAA;AAGJ,IAAA;AAEA,IAAA;AAAA,MAAA;AAEqC,MAAA;AACjC,IAAA;AAEJ,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAEA,IAAA;AAAA,MAAA;AAGgC,MAAA;AAC5B,IAAA;AAGJ,IAAA;AAAwC,MAAA;AAC/B,MAAA;AACyC,IAAA;AAElD,IAAA;AAAA,MAAA;AAC2B,MAAA;AAC4C,IAAA;AACvE,EAAA;AACJ,EAAA;AAGI,IAAA;AACA,IAAA;AACA,IAAA;AAAe,EAAA;AACnB,EAAA;AAGI,IAAA;AAEqC,EAAA;AAEzC,EAAA;AAGI,IAAA;AAAO,MAAA;AACiB,QAAA;AAE+B,QAAA;AACxC,MAAA;AACX,MAAA;AAG+C,IAAA;AACnD,EAAA;AACJ,EAAA;AAOI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AAAqB,QAAA;AACA,UAAA;AAC2B,UAAA;AACtC,QAAA;AACN,QAAA;AACA,MAAA;AACJ,IAAA;AAEA,MAAA;AAAqB,QAAA;AACA,UAAA;AAC6B,UAAA;AACxC,QAAA;AACN,QAAA;AACA,MAAA;AACJ,IAAA;AAGJ,IAAA;AAEqB,MAAA;AACsB,MAAA;AACO,IAAA;AAC9C,EAAA;AAER,EAAA;AAOI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AAAqB,QAAA;AACA,UAAA;AAC2B,UAAA;AACtC,QAAA;AACN,QAAA;AACC,MAAA;AACL,IAAA;AAEA,MAAA;AAAqB,QAAA;AACA,UAAA;AAC8B,UAAA;AACzC,QAAA;AACN,QAAA;AACA,MAAA;AACJ,IAAA;AAGJ,IAAA;AAEqB,MAAA;AACsB,MAAA;AACQ,IAAA;AAC/C,EAAA;AAER,EAAA;AAOI,IAAA;AAAiC,MAAA;AACJ,MAAA;AACvB,IAAA;AAEN,IAAA;AAAiC,MAAA;AACJ,MAAA;AACvB,IAAA;AAGN,IAAA;AAA4B,MAAA;AACP,QAAA;AAC6B,QAAA;AACxC,MAAA;AACN,MAAA;AACA,IAAA;AAGJ,IAAA;AAKA,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAOI,IAAA;AAAiC,MAAA;AACJ,MAAA;AACvB,IAAA;AAEN,IAAA;AAAiC,MAAA;AACJ,MAAA;AACvB,IAAA;AAGN,IAAA;AAA4B,MAAA;AACP,QAAA;AAC6B,QAAA;AACxC,MAAA;AACN,MAAA;AACA,IAAA;AAGJ,IAAA;AAKA,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAQI,IAAA;AAIA,IAAA;AAAgC,MAAA;AACX,QAAA;AACmC,QAAA;AAC9C,MAAA;AACN,MAAA;AACA,IAAA;AAGJ,IAAA;AAA2B,MAAA;AAEgB,MAAA;AACvC,IAAA;AAIJ,IAAA;AACqB,MAAA;AAC2B,MAAA;AACtC,IAAA;AAEW,MAAA;AAC2B,MAAA;AACtC,IAAA;AAEV,IAAA;AAEqB,MAAA;AACb,MAAA;AACiC,IAAA;AAIzC,IAAA;AAGA,IAAA;AAEqB,MAAA;AACb,MAAA;AACiC,IAAA;AAEzC,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAA8B,MAAA;AACU,MAAA;AAClC,IAAA;AAGN,IAAA;AAA2B,MAAA;AACrB,MAAA;AACe,QAAA;AACwB,QAAA;AACrC,MAAA;AACJ,IAAA;AAGJ,IAAA;AAAwB,MAAA;AACH,QAAA;AACI,UAAA;AAC6B,UAAA;AAC1C,QAAA;AACJ,QAAA;AACE,MAAA;AACN,MAAA;AACE,IAAA;AAGN,IAAA;AAEA,IAAA;AACA,IAAA;AAAwB,MAAA;AACkB,MAAA;AACtC,IAAA;AAGJ,IAAA;AAAO,EAAA;AACX,EAAA;AAOI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AAAmC,IAAA;AAGvC,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAGA,IAAA;AAEI,MAAA;AAAoD,IAAA;AAKpD,MAAA;AAAgE,IAAA;AAGpE,IAAA;AAMA,IAAA;AAGA,IAAA;AAAwC,MAAA;AAC/B,MAAA;AACW,IAAA;AAIpB,IAAA;AAAmC,MAAA;AACf,MAAA;AAChB,IAAA;AAMJ,IAAA;AAOA,IAAA;AAQA,IAAA;AACI,MAAA;AAAoC,IAAA;AAGxC,IAAA;AAAsB,EAAA;AAC1B,EAAA;AAQI,IAAA;AACqB,MAAA;AACI,QAAA;AACkB,QAAA;AAC7B,MAAA;AACN,MAAA;AACE,IAAA;AAEW,MAAA;AACI,QAAA;AACkB,QAAA;AAC7B,MAAA;AACN,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AACI,QAAA;AACoB,QAAA;AAC3B,MAAA;AACV,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AACwB,MAAA;AACnC,IAAA;AAEW,MAAA;AACI,QAAA;AACmB,QAAA;AAC9B,MAAA;AACN,MAAA;AACE,IAAA;AAGV,IAAA;AAA0B,MAAA;AACtB,MAAA;AACiB,QAAA;AACI,UAAA;AACuB,UAAA;AAClC,QAAA;AACN,QAAA;AACE,MAAA;AACN,IAAA;AAGJ,IAAA;AAEA,IAAA;AAEqB,MAAA;AACI,QAAA;AACqC,QAAA;AAChD,MAAA;AACN,MAAA;AACsD,IAAA;AAG9D,IAAA;AAAO,EAAA;AACX,EAAA;AAQI,IAAA;AAA8B,MAAA;AACT,QAAA;AAEsB,QAAA;AAC5B,MAAA;AACX,MAAA;AACE,IAAA;AAGN,IAAA;AAEA,IAAA;AAEqB,MAAA;AACuB,MAAA;AAClC,IAAA;AAEW,MAAA;AACuB,MAAA;AAClC,IAAA;AAGV,IAAA;AAEqB,MAAA;AACI,QAAA;AACmB,QAAA;AAC9B,MAAA;AACN,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AAEuB,MAAA;AAClC,IAAA;AAGV,IAAA;AAA0B,MAAA;AACtB,MAAA;AACiB,QAAA;AACI,UAAA;AACuB,UAAA;AAClC,QAAA;AACN,QAAA;AACE,MAAA;AACN,IAAA;AAGJ,IAAA;AAAqD,EAAA;AACzD,EAAA;AAQI,IAAA;AACqB,MAAA;AACI,QAAA;AACkB,QAAA;AAC7B,MAAA;AACN,MAAA;AACE,IAAA;AAEW,MAAA;AACI,QAAA;AACkB,QAAA;AAC7B,MAAA;AACN,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AACI,QAAA;AACkB,QAAA;AACzB,MAAA;AACV,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AACI,QAAA;AACmB,QAAA;AAC9B,MAAA;AACN,MAAA;AACE,IAAA;AAGV,IAAA;AAEqB,MAAA;AACwB,MAAA;AACnC,IAAA;AAGV,IAAA;AAA0B,MAAA;AACtB,MAAA;AACiB,QAAA;AACI,UAAA;AACuB,UAAA;AAClC,QAAA;AACN,QAAA;AACE,MAAA;AACN,IAAA;AAGJ,IAAA;AAEA,IAAA;AAEqB,MAAA;AACJ,MAAA;AAC6C,IAAA;AAG9D,IAAA;AAAO,EAAA;AACX,EAAA;AAQI,IAAA;AAKA,IAAA;AAKA,IAAA;AAEA,IAAA;AAAgB,EAAA;AACpB,EAAA;AAQI,IAAA;AACA,IAAA;AAAoB,MAAA;AACyB,MAAA;AACA,IAAA;AAE7C,IAAA;AAAqB,MAAA;AACG,MAAA;AACA,IAAA;AAGxB,IAAA;AACA,IAAA;AAAoB,MAAA;AACkD,MAAA;AAC1D,IAAA;AAGZ,IAAA;AAAiB,MAAA;AACb,MAAA;AACyC,IAAA;AAE7C,IAAA;AAAwB,MAAA;AACpB,MAAA;AAC8D,IAAA;AAClE,EAAA;AACJ,EAAA;AASI,IAAA;AACI,MAAA;AACA,MAAA;AACI,QAAA;AAAuC,MAAA;AAC3C,IAAA;AAEA,MAAA;AACA,MAAA;AACI,QAAA;AAAuC,MAAA;AAC3C,IAAA;AACJ,EAAA;AACJ,EAAA;AAUI,IAAA;AAIA,IAAA;AACA,IAAA;AACA,IAAA;AAA4B,MAAA;AACxB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAAyB,EAAA;AAC7B,EAAA;AAUI,IAAA;AAIA,IAAA;AACI,MAAA;AAAuC,IAAA;AAE3C,IAAA;AACA,IAAA;AAA2B,MAAA;AACvB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AACA,IAAA;AAA+B,EAAA;AACnC,EAAA;AAYI,IAAA;AAAwB,MAAA;AAGC,QAAA;AACI,UAAA;AACI,UAAA;AACjB,QAAA;AACJ,QAAA;AACA,MAAA;AACJ,MAAA;AAGiB,QAAA;AAC6C,QAAA;AAC1D,MAAA;AACJ,IAAA;AAGR,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AAAuB,QAAA;AACF,UAAA;AACsB,UAAA;AACnC,QAAA;AACJ,QAAA;AACqC,MAAA;AACzC,IAAA;AAEA,MAAA;AAAuB,QAAA;AACF,UAAA;AACoB,UAAA;AACjC,QAAA;AACJ,QAAA;AACyC,MAAA;AAC7C,IAAA;AAGJ,IAAA;AAAuB,MAAA;AACC,QAAA;AACC,UAAA;AAC2B,UAAA;AACxC,QAAA;AACJ,QAAA;AACA,MAAA;AACJ,MAAA;AAEqB,QAAA;AACI,UAAA;AACyB,UAAA;AACtC,QAAA;AACJ,QAAA;AACM,MAAA;AACN,IAAA;AAGZ,IAAA;AACA,IAAA;AAEA,IAAA;AACA,IAAA;AAEqB,MAAA;AACwB,MAAA;AAC/B,IAAA;AAGd,IAAA;AAEA,IAAA;AACI,MAAA;AAAuB,QAAA;AACX,QAAA;AACoD,MAAA;AAChE,IAAA;AAEA,MAAA;AAAuB,QAAA;AACX,QAAA;AACgD,MAAA;AAC5D,IAAA;AAGJ,IAAA;AAAgB,EAAA;AACpB,EAAA;AAWI,IAAA;AAAwB,MAAA;AACe,MAAA;AACG,IAAA;AAG1C,IAAA;AACA,IAAA;AAAgC,MAAA;AACgB,MAAA;AACrC,IAAA;AAGX,IAAA;AACI,MAAA;AACA,MAAA;AAAuB,QAAA;AACc,QAAA;AACxB,MAAA;AACb,IAAA;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAAuB,QAAA;AACgB,QAAA;AACnC,MAAA;AACJ,IAAA;AAGJ,IAAA;AACI,MAAA;AAAuB,QAAA;AACF,UAAA;AACoB,UAAA;AAC5B,QAAA;AACT,QAAA;AAC2C,MAAA;AAC/C,IAAA;AAEA,MAAA;AAAuB,QAAA;AACF,UAAA;AACuB,UAAA;AAC/B,QAAA;AACT,QAAA;AACsC,MAAA;AAC1C,IAAA;AAEJ,IAAA;AAEA,IAAA;AACqB,MAAA;AAC+B,MAAA;AACrC,IAAA;AAGf,IAAA;AACA,IAAA;AAAuB,MAAA;AACc,MAAA;AACjC,IAAA;AAGJ,IAAA;AAAuB,MAAA;AACF,QAAA;AACuB,QAAA;AAC/B,MAAA;AACT,MAAA;AACsC,IAAA;AAG1C,IAAA;AACA,IAAA;AAKA,IAAA;AACA,IAAA;AAKA,IAAA;AACqB,MAAA;AAC+B,MAAA;AACrC,IAAA;AAEf,IAAA;AAA6B,MAAA;AACa,MAAA;AACtC,IAAA;AAEJ,IAAA;AAAuD,EAAA;AAC3D,EAAA;AAQI,IAAA;AAAoB,MAAA;AACmB,MAAA;AACA,IAAA;AAEvC,IAAA;AAAY,MAAA;AACD,MAAA;AACP,MAAA;AACO,MAAA;AACA,MAAA;AACP,MAAA;AACA,MAAA;AACE,MAAA;AACA,IAAA;AACN,EAAA;AACJ,EAAA;AAQI,IAAA;AAAoB,MAAA;AACmB,MAAA;AACA,IAAA;AAEvC,IAAA;AAAY,MAAA;AACD,MAAA;AACP,MAAA;AACO,MAAA;AACA,MAAA;AACP,MAAA;AACA,MAAA;AACoC,MAAA;AAClC,IAAA;AACN,EAAA;AAER;AAj9BI;AAAsD;AACtD;AAAmD;AACnD;AAA0E;AAAA;AAG1E;AAA8D;AAC9D;AAA0E;AAC1E;AAAgD,EAAA;AAEhD;AAAA;AACA;AAAoD,EAAA;AAEpD;AAAA;AACA;AAAgD,EAAA;AAEhD;AAAA;AAAA;AAGA;AAAgC,EAAA;AAEhC;AAAA;AACA;AAAiC,EAAA;AAEjC;AAAA;AAAA;AAGA;AAAiE;AAAA;AAEjE;AdqjEJ;AACA;Ae3mEO;AAAmC,EAAA;AACtC,IAAA;AAGI,IAAA;AAAkB,MAAA;AACF,QAAA;AACS,QAAA;AACD,QAAA;AACH,QAAA;AACA,QAAA;AACK,MAAA;AACtB,MAAA;AACmB,QAAA;AACL,UAAA;AACO,UAAA;AACA,QAAA;AACjB,QAAA;AACS,UAAA;AACQ,UAAA;AACA,QAAA;AACjB,QAAA;AACa,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACE,MAAA;AACnB,IAAA;AACJ,EAAA;AACJ,EAAA;AAGI,IAAA;AAAoB,EAAA;AACxB,EAAA;AAGI,IAAA;AAAoB,EAAA;AACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAEI,MAAA;AAEA,MAAA;AAAO,QAAA;AACH,QAAA;AACsB,QAAA;AACJ,MAAA;AACtB,IAAA;AAGJ,IAAA;AAAoB,MAAA;AAChB,MAAA;AAC6B,IAAA;AAGjC,IAAA;AAAO,MAAA;AACH,MAAA;AACuB,MAAA;AACJ,IAAA;AACvB,EAAA;AACJ,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAA6B,MAAA;AACf,MAAA;AACyC,MAAA;AACJ,MAAA;AACa,MAAA;AACnD,MAAA;AACC,IAAA;AACb,EAAA;AACL,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACsB,MAAA;AACtB,MAAA;AACA,IAAA;AAGJ,IAAA;AAEA,IAAA;AAEA,IAAA;AACiB,MAAA;AACT,MAAA;AACA,MAAA;AACA,IAAA;AAIR,IAAA;AAA2B,MAAA;AACI,MAAA;AACxB,IAAA;AAGP,IAAA;AACI,MAAA;AAAuC,QAAA;AACnC,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAGJ,MAAA;AAAO,IAAA;AAGX,IAAA;AAAsC,MAAA;AAClC,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAO,EAAA;AACX,EAAA;AAMI,IAAA;AACA,IAAA;AACiB,MAAA;AACT,MAAA;AACA,MAAA;AACA,IAAA;AAGR,IAAA;AACI,MAAA;AAA0B,IAAA;AAE1B,MAAA;AAA0B,IAAA;AAC9B,EAAA;AACJ,EAAA;AAOI,IAAA;AAEA,IAAA;AACiB,MAAA;AACT,MAAA;AACA,MAAA;AACA,IAAA;AAMR,IAAA;AAA2B,MAAA;AACwC,MAAA;AACA,IAAA;AAKnE,IAAA;AACI,MAAA;AAEJ,IAAA;AACI,MAAA;AAAoB,QAAA;AACM,QAAA;AACtB,QAAA;AACA,QAAA;AACA,MAAA;AACJ,IAAA;AAEA,MAAA;AAAoB,QAAA;AACM,QAAA;AACtB,QAAA;AACA,QAAA;AACA,MAAA;AACJ,IAAA;AACJ,EAAA;AAER;AfikEA;AACA;AgBvyEO;AAEH,EAAA;AACI,IAAA;AAAO,EAAA;AAKX,EAAA;AACA,EAAA;AAEA,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AACA,IAAA;AAAO,EAAA;AAEX,EAAA;AACI,IAAA;AAAO,EAAA;AAIX,EAAA;AAIA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AAGA,EAAA;AACJ;AhB6xEA;AACA;AiB90EA;AACA;AAEO;AAcH,EAAA;AACI,IAAA;AAAO,MAAA;AACqB,MAAA;AACA,MAAA;AACf,IAAA;AACb,EAAA;AAGJ,EAAA;AACA,EAAA;AAEA,EAAA;AAAoC,IAAA;AAChC,IAAA;AACgB,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AAGpB,EAAA;AAGA,EAAA;AAII,IAAA;AAAC,MAAA;AACoB,MAAA;AACA,IAAA;AACjB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAU,EAAA;AAGd,EAAA;AACI,IAAA;AACI,IAAA;AACA,IAAA;AACA,EAAA;AAIR,EAAA;AACI,IAAA;AACI,MAAA;AACI,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGR,IAAA;AAAU,EAAA;AAGd,EAAA;AAAO,IAAA;AACH,IAAA;AACA,IAAA;AACA,EAAA;AAER;AAsBA;AAOI,EAAA;AAAgD,IAAA;AAC5C,IAAA;AACA,IAAA;AACA,EAAA;AAIJ,EAAA;AAAM,IAAA;AACF,IAAA;AACA,IAAA;AACA,EAAA;AAEE,IAAA;AAC+C,IAAA;AACZ,IAAA;AACD,EAAA;AAElC,IAAA;AAC+C,IAAA;AACZ,IAAA;AACD,EAAA;AAWxC,EAAA;AAA+B,IAAA;AAC3B,IAAA;AACA,EAAA;AAKJ,EAAA;AAIY,IAAA;AAKQ,EAAA;AAIpB,EAAA;AAIA,EAAA;AACM,IAAA;AACqB,IAAA;AACA,EAAA;AAErB,IAAA;AACqB,IAAA;AACA,EAAA;AAG3B,EAAA;AACJ;AAEA;AASI,EAAA;AAAuB,IAAA;AAEf,EAAA;AAIR,EAAA;AAIA,EAAA;AAOA,EAAA;AAAmC,IAAA;AAC/B,IAAA;AACQ,MAAA;AACJ,MAAA;AACqC,IAAA;AACzC,EAAA;AAGJ,EAAA;AAMA,EAAA;AAGJ;AAYA;AAKI,EAAA;AAA+B,IAAA;AAC3B,IAAA;AACA,IAAA;AACA,EAAA;AAGJ,EAAA;AACJ;AAeA;AAKI,EAAA;AAAyB,IAAA;AACrB,IAAA;AACA,IAAA;AACA,IAAA;AAAA,EAAA;AAQJ,EAAA;AAMA,EAAA;AAAyB,IAAA;AACrB,IAAA;AACqD,EAAA;AAGzD,EAAA;AACJ;AAEA;AAQI,EAAA;AACI,IAAA;AAAO,EAAA;AAEP,IAAA;AAAO,EAAA;AAGX,EAAA;AAAyB,IAAA;AACP,IAAA;AACY,EAAA;AAG9B,EAAA;AAA4C,IAAA;AACxC,IAAA;AACQ,MAAA;AACI,QAAA;AACJ,QAAA;AACA,MAAA;AACJ,MAAA;AACA,IAAA;AACJ,EAAA;AAIJ,EAAA;AAA4C,IAAA;AACxC,IAAA;AACA,EAAA;AAEJ,EAAA;AAAe,IAAA;AACX,IAAA;AACA,EAAA;AAER;AAEA;AAKI,EAAA;AAEI,IAAA;AAAwD,EAAA;AAExD,IAAA;AAAuD,EAAA;AAG3D,EAAA;AACA,EAAA;AAEA,EAAA;AACA,EAAA;AAGA,EAAA;AACI,IAAA;AACA,IAAA;AAAoB,EAAA;AAEpB,IAAA;AACA,IAAA;AAAoB,EAAA;AAGxB,EAAA;AACJ;AAEA;AAMI,EAAA;AAKA,EAAA;AAAO,IAAA;AACmB,IAAA;AACA,EAAA;AAE9B;AAYO;AAiCH,EAAA;AAEU,IAAA;AAC2B,IAAA;AACC,EAAA;AAE5B,IAAA;AAC2B,IAAA;AACC,EAAA;AAGtC,EAAA;AAOA,EAAA;AAEI,IAAA;AAA0D,EAAA;AAG9D,EAAA;AACJ;AAYO;AAkCH,EAAA;AAEI,IAAA;AAA0D,EAAA;AAG9D,EAAA;AAEU,IAAA;AAC2B,IAAA;AACC,EAAA;AAE5B,IAAA;AAC2B,IAAA;AACC,EAAA;AAItC,EAAA;AAAiC,IAAA;AACI,IAAA;AACjC,IAAA;AAGI,EAAA;AAGR,EAAA;AACJ;AjB+hEA;AACA;AkBtiFO;AAAkC,EAAA;AACrC,IAAA;AAEI,IAAA;AAAoB,EAAA;AACxB,EAAA;AAKI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AAGA,IAAA;AACI,MAAA;AAEA,MAAA;AAAoB,QAAA;AAChB,QAAA;AACc,QAAA;AACA,QAAA;AACd,QAAA;AACA,QAAA;AAC6B,MAAA;AAEjC,MAAA;AACA,MAAA;AAEM,IAAA;AAEV,IAAA;AACA,IAAA;AAA6C,EAAA;AACjD,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAKA,IAAA;AACI,MAAA;AAAiC,QAAA;AAC7B,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAGJ,MAAA;AAAO,IAAA;AAGX,IAAA;AAAiC,MAAA;AAC7B,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAOI,IAAA;AAAO,MAAA;AACe,MAAA;AAClB,MAAA;AACuC,MAAA;AACA,MAAA;AACrB,MAAA;AACA,MAAA;AACA,MAAA;AAClB,QAAA;AAE0B,QAAA;AAEA,QAAA;AAEA,QAAA;AAEA,MAAA;AAC1B,IAAA;AACJ,EAAA;AAER;AlBkgFA;AACA;AmBxoFA;AACA;AAEA;AAEO;AAcH,EAAA;AACI,IAAA;AAAO,MAAA;AACqB,MAAA;AACA,MAAA;AACf,IAAA;AACb,EAAA;AAGJ,EAAA;AACA,EAAA;AAEA,EAAA;AAAoC,IAAA;AAChC,IAAA;AACgB,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AAGpB,EAAA;AAGA,EAAA;AAII,IAAA;AAAC,MAAA;AACoB,MAAA;AACA,IAAA;AACjB,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAU,EAAA;AAGd,EAAA;AACI,IAAA;AACI,IAAA;AACA,IAAA;AACA,EAAA;AAIR,EAAA;AACI,IAAA;AACI,MAAA;AACI,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGR,IAAA;AAAU,EAAA;AAGd,EAAA;AAAO,IAAA;AACH,IAAA;AACA,IAAA;AACA,EAAA;AAER;AAsBA;AAOI,EAAA;AAAgD,IAAA;AAC5C,IAAA;AACA,IAAA;AACA,EAAA;AAIJ,EAAA;AAAM,IAAA;AACF,IAAA;AACA,IAAA;AACA,EAAA;AAEE,IAAA;AAC+C,IAAA;AACZ,IAAA;AACD,EAAA;AAElC,IAAA;AAC+C,IAAA;AACZ,IAAA;AACD,EAAA;AAWxC,EAAA;AAA+B,IAAA;AAC3B,IAAA;AACA,EAAA;AAKJ,EAAA;AAIY,IAAA;AAKQ,EAAA;AAIpB,EAAA;AAIA,EAAA;AACM,IAAA;AACqB,IAAA;AACA,EAAA;AAErB,IAAA;AACqB,IAAA;AACA,EAAA;AAG3B,EAAA;AACJ;AAEA;AASI,EAAA;AAAuB,IAAA;AACiD,EAAA;AAIxE,EAAA;AAIA,EAAA;AA4BA,EAAA;AAAyB,IAAA;AACF,IAAA;AACnB,EAAA;AAGJ,EAAA;AAAmC,IAAA;AAC/B,IAAA;AACwD,EAAA;AAI5D,EAAA;AAAmC,IAAA;AAC/B,IAAA;AACQ,MAAA;AACJ,MAAA;AAC+B,IAAA;AACnC,EAAA;AAGJ,EAAA;AAMA,EAAA;AAGJ;AAYA;AAKI,EAAA;AAA+B,IAAA;AAC3B,IAAA;AACA,IAAA;AACA,EAAA;AAGJ,EAAA;AACJ;AAeA;AAKI,EAAA;AAAyB,IAAA;AACrB,IAAA;AACA,IAAA;AACA,IAAA;AAAA,EAAA;AAQJ,EAAA;AAMA,EAAA;AAAyB,IAAA;AACrB,IAAA;AACqD,EAAA;AAGzD,EAAA;AACJ;AAEA;AAQI,EAAA;AACI,IAAA;AAAO,EAAA;AAEP,IAAA;AAAO,EAAA;AAGX,EAAA;AAAyB,IAAA;AACP,IAAA;AACY,EAAA;AAG9B,EAAA;AAA4C,IAAA;AACxC,IAAA;AACQ,MAAA;AACI,QAAA;AACJ,QAAA;AACA,MAAA;AACJ,MAAA;AACA,IAAA;AACJ,EAAA;AAIJ,EAAA;AAA4C,IAAA;AACxC,IAAA;AACA,EAAA;AAEJ,EAAA;AAAe,IAAA;AACX,IAAA;AACA,EAAA;AAER;AAEA;AAKI,EAAA;AAEI,IAAA;AAAwD,EAAA;AAExD,IAAA;AAAuD,EAAA;AAG3D,EAAA;AACA,EAAA;AAEA,EAAA;AACA,EAAA;AAGA,EAAA;AACI,IAAA;AACA,IAAA;AAAoB,EAAA;AAEpB,IAAA;AACA,IAAA;AAAoB,EAAA;AAGxB,EAAA;AACJ;AAEA;AAMI,EAAA;AAKA,EAAA;AAAO,IAAA;AACmB,IAAA;AACA,EAAA;AAE9B;AAYO;AAiCH,EAAA;AAEU,IAAA;AAC2B,IAAA;AACC,EAAA;AAE5B,IAAA;AAC2B,IAAA;AACC,EAAA;AAGtC,EAAA;AAOA,EAAA;AAEI,IAAA;AAA0D,EAAA;AAG9D,EAAA;AACJ;AAYO;AAkCH,EAAA;AAEI,IAAA;AAA0D,EAAA;AAG9D,EAAA;AAEU,IAAA;AAC2B,IAAA;AACC,EAAA;AAE5B,IAAA;AAC2B,IAAA;AACC,EAAA;AAItC,EAAA;AAAiC,IAAA;AACI,IAAA;AACjC,IAAA;AAGI,EAAA;AAGR,EAAA;AACJ;AAOA;AACI,EAAA;AACJ;AnB2zEA;AACA;AoB52FO;AAAoC,EAAA;AACvC,IAAA;AAEI,IAAA;AAAoB,EAAA;AACxB,EAAA;AAKI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AAGA,IAAA;AACI,MAAA;AAEA,MAAA;AAAoB,QAAA;AAChB,QAAA;AACc,QAAA;AACA,QAAA;AACd,QAAA;AACA,QAAA;AAC6B,MAAA;AAEjC,MAAA;AACA,MAAA;AAEM,IAAA;AAEV,IAAA;AACA,IAAA;AAA6C,EAAA;AACjD,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAKA,IAAA;AACI,MAAA;AAAiC,QAAA;AAC7B,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAGJ,MAAA;AAAO,IAAA;AAGX,IAAA;AAAiC,MAAA;AAC7B,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAII,IAAA;AAAO,EAAA;AACX,EAAA;AAOI,IAAA;AAAO,MAAA;AACe,MAAA;AAClB,MAAA;AACuC,MAAA;AACA,MAAA;AACrB,MAAA;AACA,MAAA;AACA,MAAA;AAClB,QAAA;AAE0B,QAAA;AAEA,QAAA;AAEA,QAAA;AAEA,MAAA;AAC1B,IAAA;AACJ,EAAA;AAER;ApBw0FA;AACA;AqBh9FO;AAMH,EAAA;AAEA,EAAA;AACI,IAAA;AAEgE,EAAA;AAGhE,IAAA;AAEiE,EAAA;AAGzE;AASO;AAIH,EAAA;AAEA,EAAA;AACA,EAAA;AAEA,EAAA;AACI,IAAA;AACA,IAAA;AAC4D,EAAA;AAGhE,EAAA;AACJ;AAEO;AAIH,EAAA;AACI,IAAA;AAAsC,EAAA;AAG1C,EAAA;AAEA,EAAA;AACA,EAAA;AAEA,EAAA;AACI,IAAA;AACA,IAAA;AAC6D,EAAA;AAGjE,EAAA;AACJ;ArB86FA;AACA;AsBh+FO;AAAmC,EAAA;AAIlB,IAAA;AAHpB,IAAA;AACA,IAAA;AAGI,IAAA;AAAc,MAAA;AACI,MAAA;AACA,IAAA;AAElB,IAAA;AAAe,MAAA;AACG,MAAA;AACA,IAAA;AAGlB,IAAA;AACA,IAAA;AAA+D,EAAA;AACnE,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AACI,MAAA;AAAsB,QAAA;AACU,QAAA;AACT,MAAA;AAGvB,MAAA;AAAO,QAAA;AACH,QAAA;AACsB,QAAA;AACJ,MAAA;AACtB,IAAA;AAGJ,IAAA;AAAsB,MAAA;AACW,MAAA;AACV,IAAA;AAGvB,IAAA;AAAO,MAAA;AACH,MAAA;AACuB,MAAA;AACJ,IAAA;AACvB,EAAA;AACJ,EAAA;AAGI,IAAA;AAAO,EAAA;AACX,EAAA;AAKI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAEJ,IAAA;AAA6B,MAAA;AACf,MAAA;AACyC,MAAA;AACJ,MAAA;AACa,MAAA;AACnD,MAAA;AACC,IAAA;AACb,EAAA;AACL,EAAA;AAGI,IAAA;AAAM,MAAA;AACF,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAGJ,IAAA;AAEA,IAAA;AAII,MAAA;AAAoC,IAAA;AAGxC,IAAA;AAIA,IAAA;AAA+C,MAAA;AAC3C,MAAA;AACA,MAAA;AACA,MAAA;AACK,MAAA;AACA,IAAA;AAGT,IAAA;AAEI,MAAA;AAEY,QAAA;AACwB,QAAA;AACT,MAAA;AAGvB,QAAA;AAA4C,MAAA;AAGhD,MAAA;AAA0B,QAAA;AACM,QAAA;AAC5B,QAAA;AAC6B,QAAA;AAC7B,QAAA;AACA,MAAA;AAIJ,MAAA;AAEY,QAAA;AACyB,QAAA;AACV,MAAA;AAGvB,QAAA;AAA4C,MAAA;AAGhD,MAAA;AAAO,IAAA;AAKP,MAAA;AAEY,QAAA;AACyB,QAAA;AACV,MAAA;AAGvB,QAAA;AAA4C,MAAA;AAGhD,MAAA;AAAyB,QAAA;AACO,QAAA;AAC5B,QAAA;AAC6B,QAAA;AAC7B,QAAA;AACA,MAAA;AAIJ,MAAA;AAEY,QAAA;AACwB,QAAA;AACT,MAAA;AAGvB,QAAA;AAA4C,MAAA;AAGhD,MAAA;AAAO,IAAA;AACX,EAAA;AACJ,EAAA;AAMI,IAAA;AAEA,IAAA;AAII,MAAA;AAAoC,IAAA;AAGxC,IAAA;AAGA,IAAA;AAA+B,MAAA;AAC3B,MAAA;AACK,MAAA;AACA,IAAA;AAET,IAAA;AACI,MAAA;AAAkE,IAAA;AAEtE,IAAA;AAAoE,EAAA;AACxE,EAAA;AAOI,IAAA;AAEA,IAAA;AAII,MAAA;AAAoC,IAAA;AAGxC,IAAA;AAGA,IAAA;AAA+B,MAAA;AAC3B,MAAA;AACK,MAAA;AACA,IAAA;AAET,IAAA;AAAO,MAAA;AAC8B,MAAA;AACH,MAAA;AAC9B,IAAA;AACJ,EAAA;AACJ,EAAA;AAUI,IAAA;AAAsB,MAAA;AACH,MAAA;AACI,MAAA;AACnB,IAAA;AAGJ,IAAA;AAAuB,MAAA;AACH,MAAA;AACI,MAAA;AACpB,IAAA;AAGJ,IAAA;AAAuC,EAAA;AAC3C,EAAA;AAOI,IAAA;AAEA,IAAA;AACI,MAAA;AAAuB,QAAA;AACV,QAAA;AACI,QAAA;AACb,MAAA;AACJ,IAAA;AAGJ,IAAA;AAAO,EAAA;AAEf;AtB24FA;AACA;AuBlrGO;AAQH,EAAA;AAGA,EAAA;AAGA,EAAA;AAAuC,IAAA;AACnC,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,EAAA;AAIJ,EAAA;AAGA,EAAA;AACJ;AAOA;AAOI,EAAA;AAAoB,IAAA;AAChB,IAAA;AACA,IAAA;AACA,EAAA;AAGJ,EAAA;AACJ;AAKA;AAKI,EAAA;AACI,IAAA;AAAO,EAAA;AAEP,IAAA;AAAO,EAAA;AAGX,EAAA;AACA,EAAA;AAGA,EAAA;AACA,EAAA;AACJ;AAKA;AAKI,EAAA;AACI,IAAA;AAAO,EAAA;AAGX,EAAA;AACI,IAAA;AAAO,EAAA;AAGX,EAAA;AACI,IAAA;AACA,IAAA;AAAoB,EAAA;AAEpB,IAAA;AACA,IAAA;AAAoB,EAAA;AAE5B;AvBmoGA;AACA;AwBxuGO;AAA8C,EAAA;AAI7C,IAAA;AAEA,IAAA;AAGA,IAAA;AAGA,IAAA;AAAgB,MAAA;AACF,MAAA;AACV,MAAA;AACU,MAAA;AACA,MAAA;AACV,MAAA;AACA,IAAA;AAIJ,IAAA;AArBJ,IAAA;AAuBI,IAAA;AAAgB,EAAA;AACpB,EAAA;AAII,IAAA;AACI,MAAA;AAAqC,IAAA;AAIzC,IAAA;AAKI,MAAA;AAAkD,IAAA;AAItD,IAAA;AAA8B,EAAA;AAEtC;AxButGA;AACA;AyB7vGO;AAQH,EAAA;AAEI,IAAA;AAEI,MAAA;AACA,MAAA;AACI,QAAA;AAAU,UAAA;AAC6C,QAAA;AACvD,MAAA;AAEJ,MAAA;AAAsD,IAAA;AAGtD,MAAA;AACA,MAAA;AACI,QAAA;AAAU,UAAA;AACwC,QAAA;AAClD,MAAA;AAEJ,MAAA;AAAoD,IAAA;AACxD,EAAA;AAGA,IAAA;AAEI,MAAA;AAAsD,IAAA;AAGtD,MAAA;AAAoD,IAAA;AACxD,EAAA;AAER;AAGA;AAKI,EAAA;AACA,EAAA;AACJ;AAEA;AAKI,EAAA;AACA,EAAA;AACJ;AzBuuGA;AACA;A0B3yGA;AAEO;AAIH,EAAA;AAII,IAAA;AAAoC,EAAA;AAExC,EAAA;AAA0B,IAAA;AAChB,IAAA;AACI,EAAA;AAKd,EAAA;AAAO,IAAA;AACH,IAAA;AACM,IAAA;AACA,IAAA;AACI,IAAA;AACA,IAAA;AACA,EAAA;AAElB;A1BmyGA;AACA;A2Bn0GO;AAA8B,EAAA;AACA,EAAA;AACX,EAAA;AACD,EAAA;AACS,EAAA;AACD,EAAA;AACI,EAAA;AACD,EAAA;AACL,EAAA;AAEvB,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAEI,IAAA;AAAsD,EAAA;AAC1D,EAAA;AAEI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAEI,IAAA;AAAuD,EAAA;AAC3D,EAAA;AAEI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAEI,IAAA;AAA6D,EAAA;AACjE,EAAA;AAEI,IAAA;AAA4C,EAAA;AAEpD;A3Bq0GA;AACA;A4Bz1GO;AAAsC,EAAA;AACzC,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAAmC,EAAA;AAAA,EAAA;AAG/B,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAEI,IAAA;AAAsD,EAAA;AAC1D,EAAA;AAEI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AASI,IAAA;AAQI,MAAA;AAKJ,IAAA;AACI,MAAA;AAA8D,IAAA;AAElE,IAAA;AACA,IAAA;AACA,IAAA;AAEI,MAAA;AACI,QAAA;AAAwB,UAAA;AACL,UAAA;AACL,QAAA;AAEd,QAAA;AACA,QAAA;AAAgC,MAAA;AAEpC,IAAA;AAeJ,IAAA;AAAO,MAAA;AACM,MAAA;AACT,IAAA;AACJ,EAAA;AACJ,EAAA;AAEI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAEI,IAAA;AAA6D,EAAA;AACjE,EAAA;AAEI,IAAA;AAA4C,EAAA;AAEpD;A5B2zGA;AACA;A6Bz5GO;AAA6C,EAAA;AAChD,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAAmC,EAAA;AAAA,EAAA;AAO/B,IAAA;AACS,MAAA;AACM,MAAA;AACA,MAAA;AACA,MAAA;AACA,IAAA;AAIf,IAAA;AAKA,IAAA;AAAO,MAAA;AACM,MAAA;AACT,IAAA;AACJ,EAAA;AACJ;AAAA,EAAA;AASI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AAEA,MAAA;AAAgD,IAAA;AAGpD,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAsD,EAAA;AAC1D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAuD,EAAA;AAC3D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAA6D,EAAA;AAErE;A7Bk4GA;AACA;A8Bx8GO;AAA0C,EAAA;AAC7C,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAAmC,EAAA;AAAA,EAAA;AAQ/B,IAAA;AAEA,IAAA;AAAO,MAAA;AACM,MAAA;AACY,QAAA;AACjB,QAAA;AACA,QAAA;AACU,QAAA;AACA,QAAA;AACV,MAAA;AACJ,IAAA;AACJ,EAAA;AACJ,EAAA;AASI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AAAgC,IAAA;AAEhC,MAAA;AACA,MAAA;AAAuC,IAAA;AAG3C,IAAA;AAGA,IAAA;AACI,MAAA;AAAO,IAAA;AAGX,IAAA;AAAkD,MAAA;AACpC,IAAA;AAGd,IAAA;AAII,MAAA;AAAO,IAAA;AAWX,IAAA;AAEY,MAAA;AACoB,MAAA;AAChB,QAAA;AACgB,QAAA;AAC4B,MAAA;AACpD,IAAA;AAER,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AAEA,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AAA4C,IAAA;AAGhD,IAAA;AAAmD,EAAA;AACvD,EAAA;AAGI,IAAA;AACI,MAAA;AACA,MAAA;AACA,MAAA;AAAO,IAAA;AAEX,IAAA;AAEA,IAAA;AACI,MAAA;AAAyD,IAAA;AAEzD,MAAA;AAAyB,IAAA;AAC7B,EAAA;AACJ,EAAA;AAGI,IAAA;AAA2B,EAAA;AAC/B,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAsD,EAAA;AAC1D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAuD,EAAA;AAC3D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAA6D,EAAA;AAErE;A9B65GA;AACA;A+BrjHO;AAKA;AAgBH,EAAA;AAA8B,IAAA;AAClB,MAAA;AACQ,MAAA;AACmB,IAAA;AACnC,IAAA;AACA,EAAA;AAEJ,EAAA;AAAiC,IAAA;AACqB,IAAA;AAClD,EAAA;AAGJ,EAAA;AAAe,IAAA;AACX,IAAA;AACQ,MAAA;AACQ,MAAA;AACI,MAAA;AAChB,IAAA;AACJ,IAAA;AACA,EAAA;AAER;AAEO;AAiBH,EAAA;AAA8B,IAAA;AAClB,MAAA;AACS,MAAA;AACoB,IAAA;AACrC,IAAA;AACA,EAAA;AAEJ,EAAA;AAAiC,IAAA;AACwB,IAAA;AACrD,EAAA;AAGJ,EAAA;AAAe,IAAA;AACK,IAAA;AACA,EAAA;AAExB;A/BihHA;AACA;AgCrlHO;AAAoC,EAAA;AACvC,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAAmC,EAAA;AAAA,EAAA;AAQ/B,IAAA;AAEU,MAAA;AAC8C,MAAA;AAClC,QAAA;AAC4B,QAAA;AACC,MAAA;AACrC,MAAA;AACO,IAAA;AAEX,MAAA;AAC+C,MAAA;AACnC,QAAA;AAC6B,QAAA;AACD,MAAA;AACpC,MAAA;AACO,IAAA;AAIrB,IAAA;AAKA,IAAA;AAAO,MAAA;AACM,MAAA;AACT,IAAA;AACJ,EAAA;AACJ,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAsD,EAAA;AAC1D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAAuD,EAAA;AAC3D,EAAA;AAGI,IAAA;AAA0D,EAAA;AAC9D,EAAA;AAGI,IAAA;AAA6D,EAAA;AAErE;AhCokHA;AACA;AiC7mHA;AAQO;AAAY,EAAA;AACf,IAAA;AACA,IAAA;AAMI,IAAA;AAEA,IAAA;AAAmB,MAAA;AACL,MAAA;AACF,MAAA;AACD,MAAA;AACE,MAAA;AACG,MAAA;AACa,MAAA;AACL;AAAA,MAAA;AAEjB,IAAA;AAEP,IAAA;AAAmB,MAAA;AACN,MAAA;AACO,MAAA;AACH,MAAA;AACN;AAAA,MAAA;AAEJ,IAAA;AACP,EAAA;AACJ,EAAA;AAGI,IAAA;AACA,IAAA;AACI,MAAA;AACJ,IAAA;AAA8B,EAAA;AAClC,EAAA;AAMI,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAA8B,EAAA;AAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AACA,IAAA;AAAuC,EAAA;AAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAQI,IAAA;AACA,IAAA;AAAuC,EAAA;AAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAYI,IAAA;AACA,IAAA;AAAyD,EAAA;AAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAqBI,IAAA;AAGA,IAAA;AACI,MAAA;AAAqD,IAAA;AAGzD,IAAA;AACA,IAAA;AAEA,IAAA;AAAoC,MAAA;AACE,IAAA;AAEtC,IAAA;AAEA,IAAA;AAAqC,MAAA;AACE,IAAA;AAEvC,IAAA;AAEA,IAAA;AAAiC,MAAA;AACnB,MAAA;AACA,MAAA;AACV,MAAA;AACA,MAAA;AACU,MAAA;AACA,IAAA;AAGd,IAAA;AAEA,IAAA;AAA+B,MAAA;AACP,MAAA;AACpB,MAAA;AACsB,MAAA;AACb,MAAA;AACC,IAAA;AAGd,IAAA;AAMI,MAAA;AAAuD,QAAA;AACnD,UAAA;AACO,UAAA;AACH,QAAA;AACJ,MAAA;AAEJ,MAAA;AACA,MAAA;AAA6B,QAAA;AACmB,MAAA;AAChD,IAAA;AAGJ,IAAA;AACA,IAAA;AACI,MAAA;AAAyC,QAAA;AACrC,QAAA;AACU,QAAA;AACA,QAAA;AACV,MAAA;AAEJ,MAAA;AAAuB,IAAA;AAK3B,IAAA;AACA,IAAA;AAEI,MAAA;AAAqC,QAAA;AACtB,QAAA;AACX,MAAA;AAEJ,MAAA;AAAkC,IAAA;AAGtC,IAAA;AAEA,IAAA;AAEA,IAAA;AAEA,IAAA;AACA,IAAA;AAEI,MAAA;AAAsB,QAAA;AAClB,QAAA;AACoC;AAAA;AAAA;AAAA;AAAA,QAAA;AAKsB,MAAA;AAC9D,IAAA;AAKA,MAAA;AAAqC,QAAA;AACjC,QAAA;AACA,QAAA;AAC+B,MAAA;AAGnC,MAAA;AAGA,MAAA;AAAsB,QAAA;AAClB,QAAA;AACmC,QAAA;AACJ,MAAA;AACnC,IAAA;AAGJ,IAAA;AACS,MAAA;AACD,MAAA;AACU,MAAA;AACA,MAAA;AACA,MAAA;AACV,IAAA;AAOR,IAAA;AAAe,MAAA;AACS,MAAA;AACC,IAAA;AAIzB,IAAA;AAEU,MAAA;AAC0B,MAAA;AACtB,IAAA;AAEJ,MAAA;AAC+B,MAAA;AAC3B,IAAA;AAGd,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACqB,QAAA;AACG,QAAA;AACG,QAAA;AACC,QAAA;AAIV,QAAA;AAIA,QAAA;AAEgC,QAAA;AAEC,QAAA;AAC3C,QAAA;AACA,QAAA;AACA,MAAA;AAER,MAAA;AACI,QAAA;AAAU,UAAA;AAC4D,QAAA;AACtE,MAAA;AAGJ,MAAA;AACI,QAAA;AAAsB,IAAA;AAG9B,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAoBI,IAAA;AACI,MAAA;AAEJ,IAAA;AACA,IAAA;AAMA,IAAA;AACS,MAAA;AACiB,MAAA;AACR,MAAA;AACA,IAAA;AAGlB,IAAA;AAEA,IAAA;AAMI,MAAA;AACS,QAAA;AACiB,QAAA;AACA,QAAA;AACA,QAAA;AAClB,QAAA;AACA,MAAA;AAER,MAAA;AACA,MAAA;AAA6B,QAAA;AACmB,MAAA;AAChD,IAAA;AAGJ,IAAA;AACA,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AACA,MAAA;AAAiB,QAAA;AACb,QAAA;AACA,QAAA;AACU,QAAA;AACA,QAAA;AACoB,QAAA;AAE0B,MAAA;AAE5D,MAAA;AACA,MAAA;AAAkC,IAAA;AAElC,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAAiB,QAAA;AACb,QAAA;AACA,QAAA;AACA,QAAA;AACU,QAAA;AACA,QAAA;AACoB,QAAA;AAErB,UAAA;AACD,UAAA;AACA,UAAA;AACA,QAAA;AACJ,MAAA;AAER,MAAA;AACA,MAAA;AAAkC,IAAA;AAGtC,IAAA;AACA,IAAA;AAEI,MAAA;AAAkB,QAAA;AACK,QAAA;AACO,QAAA;AACJ,MAAA;AAK1B,MAAA;AACS,QAAA;AACuB,QAAA;AACd,QAAA;AACA,QAAA;AACA,QAAA;AACV,MAAA;AAGR,MAAA;AAGI,IAAA;AAGR,IAAA;AACI,MAAA;AACS,QAAA;AACiB,QAAA;AAClB,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAGR,MAAA;AAII,QAAA;AAAU,UAAA;AACiE,QAAA;AAC3E,MAAA;AAIJ,MAAA;AACI,QAAA;AAAyB,UAAA;AACQ,QAAA;AACjC,IAAA;AAGR,IAAA;AAAO,MAAA;AACH,MAAA;AACiB,IAAA;AACrB,EAAA;AACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAqBI,IAAA;AACI,MAAA;AAEJ,IAAA;AACA,IAAA;AAUA,IAAA;AAAmC,MAAA;AACV,MAAA;AACX,MAAA;AACA,IAAA;AAGd,IAAA;AACA,IAAA;AAMI,MAAA;AACS,QAAA;AACoB,QAAA;AACA,QAAA;AACA,QAAA;AACrB,QAAA;AACA,MAAA;AAER,MAAA;AACA,MAAA;AAA6B,QAAA;AACmB,MAAA;AAChD,IAAA;AAGJ,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACA,MAAA;AAA4D,QAAA;AACxD,MAAA;AAEJ,MAAA;AAAqB,QAAA;AACjB,QAAA;AACU,QAAA;AACW,MAAA;AACzB,IAAA;AAIA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAAqB,QAAA;AACI,MAAA;AAEzB,MAAA;AAAiB,QAAA;AACb,QAAA;AACA,QAAA;AACqB,QAAA;AACX,QAAA;AACA,QAAA;AACoB,QAAA;AAErB,UAAA;AACD,UAAA;AACA,UAAA;AACA,QAAA;AACJ,MAAA;AAER,MAAA;AACA,MAAA;AAAkC,IAAA;AAIlC,MAAA;AACA,MAAA;AACA,MAAA;AAAqB,QAAA;AACI,MAAA;AAEzB,MAAA;AAAiB,QAAA;AACb,QAAA;AACA,QAAA;AACgC,QAAA;AACtB,QAAA;AACA,QAAA;AACoB,QAAA;AAE0B,MAAA;AAE5D,MAAA;AACA,MAAA;AAAkC,IAAA;AAGtC,IAAA;AAEA,IAAA;AAEI,MAAA;AAAmB,QAAA;AACK,QAAA;AACM,QAAA;AACJ,MAAA;AAK1B,MAAA;AACS,QAAA;AACuB,QAAA;AACd,QAAA;AACA,QAAA;AACA,QAAA;AACV,MAAA;AAGR,MAAA;AAE6B,IAAA;AAIjC,IAAA;AACI,MAAA;AACS,QAAA;AACoB,QAAA;AACrB,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AACA,MAAA;AAGR,MAAA;AAII,QAAA;AAAU,UAAA;AACoE,QAAA;AAC9E,MAAA;AAIJ,MAAA;AACI,QAAA;AAA0B,UAAA;AACQ,QAAA;AAClC,IAAA;AAGR,IAAA;AAAO,MAAA;AACH,MAAA;AACgB,IAAA;AACpB,EAAA;AACJ,EAAA;AASI,IAAA;AAII,MAAA;AAA8B,QAAA;AAC1B,QAAA;AAC2B,QAAA;AACX,MAAA;AAGpB,MAAA;AAAe,QAAA;AACX,QAAA;AACA,MAAA;AACJ,IAAA;AAEJ,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACA,IAAA;AAEA,IAAA;AACI,MAAA;AACI,QAAA;AACI,UAAA;AAAU,YAAA;AACN,UAAA;AACJ,QAAA;AAEJ,QAAA;AAAa,MAAA;AACjB,IAAA;AAGJ,IAAA;AACI,MAAA;AAAsD,IAAA;AAG1D,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA,EAAA;AAUI,IAAA;AAAe,MAAA;AACqD,IAAA;AACpE,EAAA;AACJ;AAAA;AAAA;AAAA,EAAA;AAUI,IAAA;AAAe,MAAA;AACmD,IAAA;AAClE,EAAA;AACJ,EAAA;AAYI,IAAA;AAEU,MAAA;AACI,MAAA;AACsB,MAAA;AACJ,IAAA;AAEtB,MAAA;AACI,MAAA;AACuB,MAAA;AACsB,IAAA;AAE3D,IAAA;AAAO,EAAA;AACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAYI,IAAA;AAEA,IAAA;AAA2C,EAAA;AAC/C;AAAA;AAAA,EAAA;AAKI,IAAA;AACI,MAAA;AAAoD,IAAA;AAExD,IAAA;AAAO,EAAA;AACX,EAAA;AAGI,IAAA;AACI,MAAA;AAAmD,IAAA;AACvD,EAAA;AAER;AjCk5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/Users/jg/Documents/code/balancer-maths/typescript/dist/index.js","sourcesContent":[null,"export const MAX_UINT256 =\n    115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n\n// https://github.com/balancer/balancer-v3-monorepo/blob/7c7baa6815128043f0d32775e351d4d45b4059be/pkg/solidity-utils/contracts/helpers/PackedTokenBalance.sol\nexport const MAX_BALANCE = BigInt(2 ** 128 - 1);\n","export const WAD = 1000000000000000000n;\nexport const RAY = 1000000000000000000000000000000000000n;\n\nexport const TWO_WAD = 2000000000000000000n;\nexport const FOUR_WAD = 4000000000000000000n;\nexport const HUNDRED_WAD = 100000000000000000000n;\nexport const MAX_UINT256 = BigInt(\n    '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n);\n\nexport const abs = (n: bigint): bigint => (n < 0n ? -n : n);\n\nexport const min = (values: bigint[]): bigint =>\n    values.reduce((a, b) => (a < b ? a : b));\n\nexport const max = (values: bigint[]): bigint =>\n    values.reduce((a, b) => (a > b ? a : b));\n\nexport const _require = (b: boolean, message: string) => {\n    if (!b) throw new Error(message);\n};\n\nexport type FixedPointFunction = (a: bigint, b: bigint) => bigint;\n\nexport class MathSol {\n    static max(a: bigint, b: bigint): bigint {\n        return a >= b ? a : b;\n    }\n\n    static min(a: bigint, b: bigint): bigint {\n        return a < b ? a : b;\n    }\n\n    static MAX_POW_RELATIVE_ERROR = 10000n;\n\n    static mulDownFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        return product / WAD;\n    }\n\n    static mulUpFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n\n        if (product === 0n) {\n            return 0n;\n        }\n        return (product - 1n) / WAD + 1n;\n    }\n\n    /// @dev Return (a * b) / c, rounding up.\n    static mulDivUpFixed(a: bigint, b: bigint, c: bigint): bigint {\n        // Multiple overflow protection is done by Solidity 0.8x\n        const product = a * b;\n\n        // The traditional divUp formula is:\n        // divUp(x, y) := (x + y - 1) / y\n        // To avoid intermediate overflow in the addition, we distribute the division and get:\n        // divUp(x, y) := (x - 1) / y + 1\n        // Note that this requires x != 0, if x == 0 then the result is zero\n        //\n        // Equivalent to:\n        // result = a == 0 ? 0 : (a * b - 1) / c + 1;\n        return (product - 1n) / c + 1n;\n    }\n\n    static divDownFixed(a: bigint, b: bigint): bigint {\n        if (a === 0n) {\n            return 0n;\n        }\n        const aInflated = a * WAD;\n        return aInflated / b;\n    }\n\n    static divUpFixed(a: bigint, b: bigint): bigint {\n        if (a === 0n) {\n            return 0n;\n        }\n        const aInflated = a * WAD;\n        return (aInflated - 1n) / b + 1n;\n    }\n\n    // also called divUpRaw in stable maths\n    static divUp(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            return 0n;\n        }\n        return 1n + (a - 1n) / b;\n    }\n\n    // version = poolTypeVersion\n    static powUpFixed(x: bigint, y: bigint, version?: number): bigint {\n        if (y === WAD && version !== 1) {\n            return x;\n        }\n        if (y === TWO_WAD && version !== 1) {\n            return MathSol.mulUpFixed(x, x);\n        }\n        if (y === FOUR_WAD && version !== 1) {\n            const square = MathSol.mulUpFixed(x, x);\n            return MathSol.mulUpFixed(square, square);\n        }\n        const raw = LogExpMath.pow(x, y);\n        const maxError =\n            MathSol.mulUpFixed(raw, MathSol.MAX_POW_RELATIVE_ERROR) + 1n;\n        return raw + maxError;\n    }\n\n    // version = poolTypeVersion\n    static powDownFixed(x: bigint, y: bigint, version?: number): bigint {\n        if (y === WAD && version !== 1) {\n            return x;\n        }\n        if (y === TWO_WAD && version !== 1) {\n            return MathSol.mulUpFixed(x, x);\n        }\n        if (y === FOUR_WAD && version !== 1) {\n            const square = MathSol.mulUpFixed(x, x);\n            return MathSol.mulUpFixed(square, square);\n        }\n        const raw = LogExpMath.pow(x, y);\n        const maxError =\n            MathSol.mulUpFixed(raw, MathSol.MAX_POW_RELATIVE_ERROR) + 1n;\n        if (raw < maxError) {\n            return 0n;\n        }\n        return raw - maxError;\n    }\n\n    static complementFixed(x: bigint): bigint {\n        return x < WAD ? WAD - x : 0n;\n    }\n}\n\nexport class LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    static MAX_NATURAL_EXPONENT = 130000000000000000000n;\n    static MIN_NATURAL_EXPONENT = -41000000000000000000n;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    static LN_36_LOWER_BOUND: bigint = WAD - 100000000000000000n;\n    static LN_36_UPPER_BOUND: bigint = WAD + 100000000000000000n;\n\n    // static MILD_EXPONENT_BOUND: bigint = 2 ** 254 / HUNDRED_WAD;\n    // Precomputed value of the above expression\n    static MILD_EXPONENT_BOUND =\n        289480223093290488558927462521719769633174961664101410098n;\n\n    // 18 decimal constants\n    static x0 = 128000000000000000000n; // 2ˆ7\n    static a0 = 38877084059945950922200000000000000000000000000000000000n; // eˆ(x0) (no decimals)\n    static x1 = 64000000000000000000n; // 2ˆ6\n    static a1 = 6235149080811616882910000000n; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    static x2 = 3200000000000000000000n; // 2ˆ5\n    static a2 = 7896296018268069516100000000000000n; // eˆ(x2)\n    static x3 = 1600000000000000000000n; // 2ˆ4\n    static a3 = 888611052050787263676000000n; // eˆ(x3)\n    static x4 = 800000000000000000000n; // 2ˆ3\n    static a4 = 298095798704172827474000n; // eˆ(x4)\n    static x5 = 400000000000000000000n; // 2ˆ2\n    static a5 = 5459815003314423907810n; // eˆ(x5)\n    static x6 = 200000000000000000000n; // 2ˆ1\n    static a6 = 738905609893065022723n; // eˆ(x6)\n    static x7 = 100000000000000000000n; // 2ˆ0\n    static a7 = 271828182845904523536n; // eˆ(x7)\n    static x8 = 50000000000000000000n; // 2ˆ-1\n    static a8 = 164872127070012814685n; // eˆ(x8)\n    static x9 = 25000000000000000000n; // 2ˆ-2\n    static a9 = 128402541668774148407n; // eˆ(x9)\n    static x10 = 12500000000000000000n; // 2ˆ-3\n    static a10 = 113314845306682631683n; // eˆ(x10)\n    static x11 = 6250000000000000000n; // 2ˆ-4\n    static a11 = 106449445891785942956n; // eˆ(x11)\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static pow(x: bigint, y: bigint): bigint {\n        if (y === 0n) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return WAD;\n        }\n\n        if (x === 0n) {\n            return 0n;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(\n            x <\n                57896044618658097711785492504343953926634992332820282019728792003956564819968n,\n\n            'Errors.X_OUT_OF_BOUNDS',\n        );\n        const x_int256 = x;\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < LogExpMath.MILD_EXPONENT_BOUND, 'Errors.Y_OUT_OF_BOUNDS');\n        const y_int256 = y;\n\n        let logx_times_y: bigint;\n        if (\n            LogExpMath.LN_36_LOWER_BOUND < x_int256 &&\n            x_int256 < LogExpMath.LN_36_UPPER_BOUND\n        ) {\n            const ln_36_x = LogExpMath._ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y =\n                (ln_36_x / WAD) * y_int256 + ((ln_36_x % WAD) * y_int256) / WAD;\n        } else {\n            logx_times_y = LogExpMath._ln(x_int256) * y_int256;\n        }\n        logx_times_y /= WAD;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            LogExpMath.MIN_NATURAL_EXPONENT <= logx_times_y &&\n                logx_times_y <= LogExpMath.MAX_NATURAL_EXPONENT,\n            'Errors.PRODUCT_OUT_OF_BOUNDS',\n        );\n\n        // return uint256(exp(logx_times_y));\n        return LogExpMath.exp(logx_times_y);\n    }\n\n    static exp(x_: bigint): bigint {\n        let x = x_;\n        _require(\n            x >= LogExpMath.MIN_NATURAL_EXPONENT &&\n                x <= LogExpMath.MAX_NATURAL_EXPONENT,\n            'Errors.INVALID_EXPONENT',\n        );\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return (WAD * WAD) / LogExpMath.exp(-1n * x);\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of MathSol process we will have the product of all e^x_n = a_n that apply, and the remainder of MathSol\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        let firstAN: bigint;\n        if (x >= LogExpMath.x0) {\n            x -= LogExpMath.x0;\n            firstAN = LogExpMath.a0;\n        } else if (x >= LogExpMath.x1) {\n            x -= LogExpMath.x1;\n            firstAN = LogExpMath.a1;\n        } else {\n            firstAN = 1n;\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100n;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        let product = HUNDRED_WAD;\n\n        if (x >= LogExpMath.x2) {\n            x -= LogExpMath.x2;\n            product = (product * LogExpMath.a2) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x3) {\n            x -= LogExpMath.x3;\n            product = (product * LogExpMath.a3) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x4) {\n            x -= LogExpMath.x4;\n            product = (product * LogExpMath.a4) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x5) {\n            x -= LogExpMath.x5;\n            product = (product * LogExpMath.a5) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x6) {\n            x -= LogExpMath.x6;\n            product = (product * LogExpMath.a6) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x7) {\n            x -= LogExpMath.x7;\n            product = (product * LogExpMath.a7) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x8) {\n            x -= LogExpMath.x8;\n            product = (product * LogExpMath.a8) / HUNDRED_WAD;\n        }\n        if (x >= LogExpMath.x9) {\n            x -= LogExpMath.x9;\n            product = (product * LogExpMath.a9) / HUNDRED_WAD;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        let seriesSum = HUNDRED_WAD; // The initial one in the sum, with 20 decimal places.\n        let term: bigint; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by HUNDRED_WAD, but dividing by the non-fixed point n values does not.\n\n        term = (term * x) / HUNDRED_WAD / 2n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 3n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 4n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 5n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 6n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 7n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 8n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 9n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 10n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 11n;\n        seriesSum += term;\n\n        term = (term * x) / HUNDRED_WAD / 12n;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by HUNDRED_WAD, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / HUNDRED_WAD) * firstAN) / 100n;\n    }\n\n    static _ln_36(x_: bigint): bigint {\n        let x = x_;\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= WAD;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        const z = ((x - RAY) * RAY) / (x + RAY);\n        const z_squared = (z * z) / RAY;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 3n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 5n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 7n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 9n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 11n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 13n;\n\n        num = (num * z_squared) / RAY;\n        seriesSum += num / 15n;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2n;\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    static _ln(a_: bigint): bigint {\n        let a = a_;\n        if (a < WAD) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and MathSol if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by MathSol.ONE_18.\n            return -1n * LogExpMath._ln((WAD * WAD) / a);\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of MathSol process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of MathSol\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // MathSol.ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        let sum = 0n;\n        if (a >= LogExpMath.a0 * WAD) {\n            a /= LogExpMath.a0; // Integer, not fixed point division\n            sum += LogExpMath.x0;\n        }\n\n        if (a >= LogExpMath.a1 * WAD) {\n            a /= LogExpMath.a1; // Integer, not fixed point division\n            sum += LogExpMath.x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to MathSol format.\n        sum *= 100n;\n        a *= 100n;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= LogExpMath.a2) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a2;\n            sum += LogExpMath.x2;\n        }\n\n        if (a >= LogExpMath.a3) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a3;\n            sum += LogExpMath.x3;\n        }\n\n        if (a >= LogExpMath.a4) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a4;\n            sum += LogExpMath.x4;\n        }\n\n        if (a >= LogExpMath.a5) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a5;\n            sum += LogExpMath.x5;\n        }\n\n        if (a >= LogExpMath.a6) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a6;\n            sum += LogExpMath.x6;\n        }\n\n        if (a >= LogExpMath.a7) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a7;\n            sum += LogExpMath.x7;\n        }\n\n        if (a >= LogExpMath.a8) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a8;\n            sum += LogExpMath.x8;\n        }\n\n        if (a >= LogExpMath.a9) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a9;\n            sum += LogExpMath.x9;\n        }\n\n        if (a >= LogExpMath.a10) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a10;\n            sum += LogExpMath.x10;\n        }\n\n        if (a >= LogExpMath.a11) {\n            a = (a * HUNDRED_WAD) / LogExpMath.a11;\n            sum += LogExpMath.x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        const z = ((a - HUNDRED_WAD) * HUNDRED_WAD) / (a + HUNDRED_WAD);\n        const z_squared = (z * z) / HUNDRED_WAD;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / HUNDRED_WAD;\n        seriesSum += num / 3n;\n\n        num = (num * z_squared) / HUNDRED_WAD;\n        seriesSum += num / 5n;\n\n        num = (num * z_squared) / HUNDRED_WAD;\n        seriesSum += num / 7n;\n\n        num = (num * z_squared) / HUNDRED_WAD;\n        seriesSum += num / 9n;\n\n        num = (num * z_squared) / HUNDRED_WAD;\n        seriesSum += num / 11n;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2n;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100n;\n    }\n}\n","import { MathSol } from '../utils/math';\n\nexport function isSameAddress(addressOne: string, addressTwo: string) {\n    return addressOne.toLowerCase() === addressTwo.toLowerCase();\n}\n\n/**\n * @dev Reverses the `scalingFactor` and `tokenRate` applied to `amount`, resulting in a smaller or equal value\n * depending on whether it needed scaling/rate adjustment or not. The result is rounded down.\n */\nexport function toRawUndoRateRoundDown(\n    amount: bigint,\n    scalingFactor: bigint,\n    tokenRate: bigint,\n): bigint {\n    // Do division last. Scaling factor is not a FP18, but a FP18 normalized by FP(1).\n    // `scalingFactor * tokenRate` is a precise FP18, so there is no rounding direction here.\n    return MathSol.divDownFixed(amount, scalingFactor * tokenRate);\n}\n\n/**\n * @dev Reverses the `scalingFactor` and `tokenRate` applied to `amount`, resulting in a smaller or equal value\n * depending on whether it needed scaling/rate adjustment or not. The result is rounded up.\n */\nexport function toRawUndoRateRoundUp(\n    amount: bigint,\n    scalingFactor: bigint,\n    tokenRate: bigint,\n): bigint {\n    // Do division last. Scaling factor is not a FP18, but a FP18 normalized by FP(1).\n    // `scalingFactor * tokenRate` is a precise FP18, so there is no rounding direction here.\n    return MathSol.divUpFixed(amount, scalingFactor * tokenRate);\n}\n\n/**\n * @dev Applies `scalingFactor` and `tokenRate` to `amount`, resulting in a larger or equal value depending on\n * whether it needed scaling/rate adjustment or not. The result is rounded down.\n */\nexport function toScaled18ApplyRateRoundDown(\n    amount: bigint,\n    scalingFactor: bigint,\n    tokenRate: bigint,\n): bigint {\n    return MathSol.mulDownFixed(amount * scalingFactor, tokenRate);\n}\n\n/**\n * @dev Applies `scalingFactor` and `tokenRate` to `amount`, resulting in a larger or equal value depending on\n * whether it needed scaling/rate adjustment or not. The result is rounded up.\n */\nexport function toScaled18ApplyRateRoundUp(\n    amount: bigint,\n    scalingFactor: bigint,\n    tokenRate: bigint,\n): bigint {\n    return MathSol.mulUpFixed(amount * scalingFactor, tokenRate);\n}\n","import { MathSol } from '../utils/math';\n\n// Invariant growth limit: non-proportional add cannot cause the invariant to increase by more than this ratio.\nexport const _MIN_INVARIANT_RATIO = BigInt('600000000000000000'); // 60%\n// Invariant shrink limit: non-proportional remove cannot cause the invariant to decrease by less than this ratio.\nexport const _MAX_INVARIANT_RATIO = BigInt('5000000000000000000'); // 500%\n\n// For security reasons, to help ensure that for all possible \"round trip\" paths\n// the caller always receives the same or fewer tokens than supplied,\n// we have chosen the rounding direction to favor the protocol in all cases.\nconst AMP_PRECISION = 1000n;\n\n// Note on unchecked arithmetic:\n// This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n// loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n// not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic,\n// including:\n//  - the amplification parameter is bounded by MAX_AMP * AMP_PRECISION, which fits in 23 bits\n//\n// This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n// About swap fees on add and remove liquidity:\n// Any add or remove that is not perfectly balanced (e.g. all single token operations) is mathematically\n// equivalent to a perfectly balanced add or remove followed by a series of swaps. Since these swaps would charge\n// swap fees, it follows that unbalanced adds and removes should as well.\n// On these operations, we split the token amounts in 'taxable' and 'non-taxable' portions, where the 'taxable' part\n// is the one to which swap fees are applied.\n\n// Computes the invariant given the current balances, using the Newton-Raphson approximation.\n// The amplification parameter equals: A n^(n-1)\n// See: https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pool-templates/base/SwapTemplateBase.vy#L206\n// solhint-disable-previous-line max-line-length\nexport const _computeInvariant = (\n    amplificationParameter: bigint,\n    balances: bigint[],\n): bigint => {\n    /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        **********************************************************************************************/\n\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n    let sum = 0n; // S in the Curve version\n    const numTokens = balances.length;\n    for (let i = 0; i < numTokens; i++) {\n        sum = sum + balances[i];\n    }\n    if (sum === 0n) {\n        return 0n;\n    }\n\n    let prevInvariant: bigint; // Dprev in the Curve version\n    let invariant = sum; // D in the Curve version\n    const ampTimesTotal = amplificationParameter * BigInt(numTokens); // Ann in the Curve version\n\n    for (let i = 0; i < 255; i++) {\n        let D_P = invariant;\n        for (let j = 0; j < numTokens; ++j) {\n            D_P = (D_P * invariant) / (balances[j] * BigInt(numTokens));\n        }\n\n        prevInvariant = invariant;\n\n        invariant =\n            (((ampTimesTotal * sum) / AMP_PRECISION + D_P * BigInt(numTokens)) *\n                invariant) /\n            (((ampTimesTotal - AMP_PRECISION) * invariant) / AMP_PRECISION +\n                (BigInt(numTokens) + 1n) * D_P);\n\n        // We are explicitly checking the magnitudes here, so can use unchecked math.\n        if (invariant > prevInvariant) {\n            if (invariant - prevInvariant <= 1) {\n                return invariant;\n            }\n        } else if (prevInvariant - invariant <= 1) {\n            return invariant;\n        }\n    }\n\n    throw new Error('StableInvariantDidntConverge()');\n};\n\n// Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n// The amplification parameter equals: A n^(n-1)\nexport function _computeOutGivenExactIn(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    tokenAmountIn: bigint,\n    invariant: bigint,\n): bigint {\n    /**************************************************************************************************************\n        // outGivenExactIn token x for y - polynomial equation to solve                                              //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S + ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n    // Amount out, so we round down overall.\n    balances[tokenIndexIn] += tokenAmountIn;\n\n    const finalBalanceOut = _computeBalance(\n        amplificationParameter,\n        balances,\n        invariant,\n        tokenIndexOut,\n    );\n\n    // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n    // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n    balances[tokenIndexIn] -= tokenAmountIn;\n\n    return balances[tokenIndexOut] - finalBalanceOut - 1n;\n}\n\n// Computes how many tokens must be sent to a pool if `tokenAmountOut` are sent given the\n// current balances, using the Newton-Raphson approximation.\n// The amplification parameter equals: A n^(n-1)\nexport function _computeInGivenExactOut(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    tokenAmountOut: bigint,\n    invariant: bigint,\n): bigint {\n    /**************************************************************************************************************\n        // inGivenExactOut token x for y - polynomial equation to solve                                              //\n        // ax = amount in to calculate                                                                               //\n        // bx = balance token in                                                                                     //\n        // x = bx + ax (finalBalanceIn)                                                                              //\n        // D = invariant                                                D                     D^(n+1)                //\n        // A = amplification coefficient               x^2 + ( S + ----------  - D) * x -  ------------- = 0         //\n        // n = number of tokens                                     (A * n^n)               A * n^2n * P             //\n        // S = sum of final balances but x                                                                           //\n        // P = product of final balances but x                                                                       //\n        **************************************************************************************************************/\n\n    // this guard is only needed on balancer-maths because SC relies on uint256 and implicitly fails due to overflow/underflow\n    if (balances[tokenIndexOut] <= tokenAmountOut) {\n        throw new Error(\n            'tokenAmountOut is greater than the balance available in the pool',\n        );\n    }\n\n    // Amount in, so we round up overall.\n    balances[tokenIndexOut] -= tokenAmountOut;\n\n    const finalBalanceIn = _computeBalance(\n        amplificationParameter,\n        balances,\n        invariant,\n        tokenIndexIn,\n    );\n\n    // No need to use checked arithmetic since `tokenAmountOut` was actually subtracted from the same balance right\n    // before calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n    balances[tokenIndexOut] += tokenAmountOut;\n\n    return finalBalanceIn - balances[tokenIndexIn] + 1n;\n}\n\n// This function calculates the balance of a given token (tokenIndex)\n// given all the other balances and the invariant.\nexport function _computeBalance(\n    amplificationParameter: bigint,\n    balances: bigint[],\n    invariant: bigint,\n    tokenIndex: number,\n): bigint {\n    // Rounds result up overall.\n    const numTokens = balances.length;\n    const ampTimesTotal = amplificationParameter * BigInt(numTokens);\n    let sum = balances[0];\n    let P_D = balances[0] * BigInt(numTokens);\n    for (let j = 1; j < numTokens; ++j) {\n        P_D = (P_D * balances[j] * BigInt(numTokens)) / invariant;\n        sum = sum + balances[j];\n    }\n    sum = sum - balances[tokenIndex];\n\n    // Use divUpRaw with inv2, as it is a \"raw\" 36 decimal value.\n    const inv2 = invariant * invariant;\n    // We remove the balance from c by multiplying it.\n    const c =\n        MathSol.divUp(inv2 * AMP_PRECISION, ampTimesTotal * P_D) *\n        balances[tokenIndex];\n\n    const b = sum + (invariant * AMP_PRECISION) / ampTimesTotal;\n    // We iterate to find the balance.\n    let prevTokenBalance = 0n;\n    // We multiply the first iteration outside the loop with the invariant to set the value of the\n    // initial approximation.\n    let tokenBalance = MathSol.divUp(inv2 + c, invariant + b);\n\n    for (let i = 0; i < 255; ++i) {\n        prevTokenBalance = tokenBalance;\n\n        // Use divUpRaw with tokenBalance, as it is a \"raw\" 36 decimal value.\n        tokenBalance = MathSol.divUp(\n            tokenBalance * tokenBalance + c,\n            tokenBalance * 2n + b - invariant,\n        );\n\n        // We are explicitly checking the magnitudes here, so can use unchecked math.\n        if (tokenBalance > prevTokenBalance) {\n            if (tokenBalance - prevTokenBalance <= 1) {\n                return tokenBalance;\n            }\n        } else if (prevTokenBalance - tokenBalance <= 1) {\n            return tokenBalance;\n        }\n    }\n\n    throw new Error('StableGetBalanceDidntConverge()');\n}\n","import { GyroECLPState } from '@/gyro';\nimport { StableState } from '@/stable';\nimport { WeightedState } from '@/weighted';\nimport { ReClammState } from '@/reClamm';\nimport { QuantAmmState } from '@/quantAmm';\n\n/**\n * State of a pool. Note - rates, fees, totalSupply use scaled 18.\n */\nexport type BasePoolState = {\n    poolAddress: string;\n    poolType: string;\n    tokens: string[];\n    scalingFactors: bigint[];\n    tokenRates: bigint[];\n    balancesLiveScaled18: bigint[];\n    swapFee: bigint;\n    aggregateSwapFee: bigint;\n    totalSupply: bigint;\n    supportsUnbalancedLiquidity: boolean;\n    hookType?: string;\n};\n\nexport type PoolState =\n    | BasePoolState\n    | WeightedState\n    | StableState\n    | GyroECLPState\n    | ReClammState\n    | QuantAmmState;\n\nexport enum SwapKind {\n    GivenIn = 0,\n    GivenOut = 1,\n}\n\nexport enum Rounding {\n    ROUND_UP = 0,\n    ROUND_DOWN = 1,\n}\n\nexport interface PoolBase {\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint;\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint;\n    getMaxSingleTokenAddAmount(): bigint;\n    onSwap(swapParams: SwapParams): bigint;\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint;\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint;\n    getMaximumInvariantRatio(): bigint;\n    getMinimumInvariantRatio(): bigint;\n}\n\nexport type MaxSwapParams = {\n    swapKind: SwapKind;\n    balancesLiveScaled18: bigint[];\n    tokenRates: bigint[];\n    scalingFactors: bigint[];\n    indexIn: number;\n    indexOut: number;\n};\n\nexport type MaxSingleTokenRemoveParams = {\n    isExactIn: boolean;\n    totalSupply: bigint;\n    tokenOutBalance: bigint;\n    tokenOutScalingFactor: bigint;\n    tokenOutRate: bigint;\n};\n\nexport type SwapParams = {\n    swapKind: SwapKind;\n    amountGivenScaled18: bigint;\n    balancesLiveScaled18: bigint[];\n    indexIn: number;\n    indexOut: number;\n};\n\n/**\n * User defined input for a swap operation.\n *\n * @property {bigint} amountRaw - Raw amount for swap (e.g. 1USDC=1000000).\n * @property {string} tokenIn - Address of token in.\n * @property {string} tokenOut - Address of token out.\n * @property {SwapKind} swapKind - GivenIn or GivenOut.\n */\nexport type SwapInput = {\n    amountRaw: bigint;\n    tokenIn: string;\n    tokenOut: string;\n    swapKind: SwapKind;\n};\n\nexport enum AddKind {\n    UNBALANCED = 0,\n    SINGLE_TOKEN_EXACT_OUT = 1,\n}\n\nexport type AddLiquidityInput = {\n    pool: string;\n    maxAmountsInRaw: bigint[];\n    minBptAmountOutRaw: bigint;\n    kind: AddKind;\n};\n\nexport enum RemoveKind {\n    PROPORTIONAL = 0,\n    SINGLE_TOKEN_EXACT_IN = 1,\n    SINGLE_TOKEN_EXACT_OUT = 2,\n}\n\nexport type RemoveLiquidityInput = {\n    pool: string;\n    minAmountsOutRaw: bigint[];\n    maxBptAmountInRaw: bigint;\n    kind: RemoveKind;\n};\n","import { MAX_UINT256, MAX_BALANCE } from '../constants';\nimport { MathSol } from '../utils/math';\nimport { toRawUndoRateRoundDown } from '../vault/utils';\nimport { _MAX_INVARIANT_RATIO, _MIN_INVARIANT_RATIO } from './stableMath';\nimport {\n    MaxSingleTokenRemoveParams,\n    MaxSwapParams,\n    type PoolBase,\n    Rounding,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport { StableMutable } from './data';\nimport {\n    _computeOutGivenExactIn,\n    _computeInGivenExactOut,\n    _computeInvariant,\n    _computeBalance,\n} from './stableMath';\n\nexport class Stable implements PoolBase {\n    public amp: bigint;\n\n    constructor(poolState: StableMutable) {\n        this.amp = poolState.amp;\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        return _MAX_INVARIANT_RATIO;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        return _MIN_INVARIANT_RATIO;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const {\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            tokenRates,\n            scalingFactors,\n            swapKind,\n        } = maxSwapParams;\n        if (swapKind === SwapKind.GivenIn) {\n            // MAX_BALANCE comes from SC limit and is max pool can hold\n            const diff = MAX_BALANCE - balancesLiveScaled18[indexIn];\n            // Scale to token in (and remove rate)\n            return toRawUndoRateRoundDown(\n                diff,\n                scalingFactors[indexIn],\n                tokenRates[indexIn],\n            );\n        }\n        // 99% of token out balance\n        const max = MathSol.mulDownFixed(\n            990000000000000000n,\n            balancesLiveScaled18[indexOut],\n        );\n        // Scale to token out\n        return toRawUndoRateRoundDown(\n            max,\n            scalingFactors[indexOut],\n            tokenRates[indexOut],\n        );\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint {\n        const {\n            isExactIn,\n            totalSupply,\n            tokenOutBalance,\n            tokenOutScalingFactor,\n            tokenOutRate,\n        } = maxRemoveParams;\n        return this.getMaxSwapAmount({\n            swapKind: isExactIn ? SwapKind.GivenIn : SwapKind.GivenOut,\n            balancesLiveScaled18: [totalSupply, tokenOutBalance],\n            tokenRates: [1000000000000000000n, tokenOutRate],\n            scalingFactors: [1000000000000000000n, tokenOutScalingFactor],\n            indexIn: 0,\n            indexOut: 1,\n        });\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18: balancesScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n        const invariant = _computeInvariant(this.amp, balancesScaled18);\n\n        if (swapKind === SwapKind.GivenIn) {\n            return _computeOutGivenExactIn(\n                this.amp,\n                balancesScaled18,\n                indexIn,\n                indexOut,\n                amountGivenScaled18,\n                invariant,\n            );\n        }\n        return _computeInGivenExactOut(\n            this.amp,\n            balancesScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n            invariant,\n        );\n    }\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint {\n        let invariant = _computeInvariant(this.amp, balancesLiveScaled18);\n        if (invariant > 0) {\n            invariant =\n                rounding == Rounding.ROUND_DOWN ? invariant : invariant + 1n;\n        }\n        return invariant;\n    }\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint {\n        return _computeBalance(\n            this.amp,\n            balancesLiveScaled18,\n            MathSol.mulUpFixed(\n                this.computeInvariant(balancesLiveScaled18, Rounding.ROUND_UP),\n                invariantRatio,\n            ),\n            tokenInIndex,\n        );\n    }\n}\n","import { MathSol } from '../utils/math';\nimport { Rounding } from './types';\n\nexport function computeAddLiquidityUnbalanced(\n    currentBalances: bigint[],\n    exactAmounts: bigint[],\n    totalSupply: bigint,\n    swapFeePercentage: bigint,\n    maxInvariantRatio: bigint,\n    computeInvariant: (balances: bigint[], rounding: Rounding) => bigint,\n): { bptAmountOut: bigint; swapFeeAmounts: bigint[] } {\n    /***********************************************************************\n        //                                                                    //\n        // s = totalSupply                                 (iFees - iCur)     //\n        // b = tokenBalance                  bptOut = s *  --------------     //\n        // bptOut = bptAmountOut                                iCur          //\n        // iFees = invariantWithFeesApplied                                   //\n        // iCur = currentInvariant                                            //\n        // iNew = newInvariant                                                //\n        ***********************************************************************/\n\n    // Determine the number of tokens in the pool.\n    const numTokens = currentBalances.length;\n\n    // Create a new array to hold the updated balances after the addition.\n    const newBalances: bigint[] = new Array(numTokens);\n    // Create a new array to hold the swap fee amount for each token.\n    const swapFeeAmounts: bigint[] = new Array(numTokens).fill(0n);\n\n    // Loop through each token, updating the balance with the added amount.\n    for (let index = 0; index < currentBalances.length; index++) {\n        newBalances[index] = currentBalances[index] + exactAmounts[index] - 1n;\n    }\n\n    // Calculate the invariant using the current balances (before the addition).\n    const currentInvariant = computeInvariant(\n        currentBalances,\n        Rounding.ROUND_UP,\n    );\n\n    // Calculate the new invariant using the new balances (after the addition).\n    const newInvariant = computeInvariant(newBalances, Rounding.ROUND_DOWN);\n\n    // Calculate the new invariant ratio by dividing the new invariant by the old invariant.\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    // ensureInvariantRatioBelowMaximumBound(pool, invariantRatio);\n    if (invariantRatio > maxInvariantRatio) {\n        throw Error(\n            `InvariantRatioAboveMax ${invariantRatio} ${maxInvariantRatio}`,\n        );\n    }\n\n    // Loop through each token to apply fees if necessary.\n    for (let index = 0; index < currentBalances.length; index++) {\n        // Check if the new balance is greater than the equivalent proportional balance.\n        // If so, calculate the taxable amount, rounding in favor of the protocol.\n        // We round the second term down to subtract less and get a higher `taxableAmount`,\n        // which charges higher swap fees. This will lower `newBalances`, which in turn lowers\n        // `invariantWithFeesApplied` below.\n        const proportionalTokenBalance = MathSol.mulDownFixed(\n            invariantRatio,\n            currentBalances[index],\n        );\n        if (newBalances[index] > proportionalTokenBalance) {\n            const taxableAmount = newBalances[index] - proportionalTokenBalance;\n            // Calculate fee amount\n            swapFeeAmounts[index] = MathSol.mulUpFixed(\n                taxableAmount,\n                swapFeePercentage,\n            );\n            // Subtract the fee from the new balance.\n            // We are essentially imposing swap fees on non-proportional incoming amounts.\n            newBalances[index] = newBalances[index] - swapFeeAmounts[index];\n        }\n    }\n\n    // Calculate the new invariant with fees applied.\n    const invariantWithFeesApplied = computeInvariant(\n        newBalances,\n        Rounding.ROUND_DOWN,\n    );\n\n    // Calculate the amount of BPT to mint. This is done by multiplying the\n    // total supply with the ratio of the change in invariant.\n    // Since we multiply and divide we don't need to use FP math.\n    // Round down since we're calculating BPT amount out. This is the most important result of this function,\n    // equivalent to:\n    // `totalSupply * (invariantWithFeesApplied / currentInvariant - 1)`\n\n    // Then, to round `bptAmountOut` down we use `invariantWithFeesApplied` rounded down and `currentInvariant`\n    // rounded up.\n    // If rounding makes `invariantWithFeesApplied` smaller or equal to `currentInvariant`, this would effectively\n    // be a donation. In that case we just let checked math revert for simplicity; it's not a valid use-case to\n    // support at this point.\n    const bptAmountOut =\n        (totalSupply * (invariantWithFeesApplied - currentInvariant)) /\n        currentInvariant;\n    return { bptAmountOut, swapFeeAmounts };\n}\n\nexport function computeAddLiquiditySingleTokenExactOut(\n    currentBalances: bigint[],\n    tokenInIndex: number,\n    exactBptAmountOut: bigint,\n    totalSupply: bigint,\n    swapFeePercentage: bigint,\n    maxInvariantRatio: bigint,\n    computeBalance: (\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        newSupply: bigint,\n    ) => bigint,\n): {\n    amountInWithFee: bigint;\n    swapFeeAmounts: bigint[];\n} {\n    // Calculate new supply after minting exactBptAmountOut\n    const newSupply = exactBptAmountOut + totalSupply;\n\n    const invariantRatio = MathSol.divUpFixed(newSupply, totalSupply);\n    // ensureInvariantRatioBelowMaximumBound(pool, invariantRatio);\n    if (invariantRatio > maxInvariantRatio) {\n        throw Error(\n            `InvariantRatioAboveMax ${invariantRatio} ${maxInvariantRatio}`,\n        );\n    }\n    // Calculate the initial amount of the input token needed for the desired amount of BPT out\n    // \"divUp\" leads to a higher \"newBalance,\" which in turn results in a larger \"amountIn.\"\n    // This leads to receiving more tokens for the same amount of BTP minted.\n    const newBalance = computeBalance(\n        currentBalances,\n        tokenInIndex,\n        invariantRatio,\n    );\n    const amountIn = newBalance - currentBalances[tokenInIndex];\n\n    // Calculate the taxable amount, which is the difference\n    // between the actual amount in and the non-taxable balance\n    const nonTaxableBalance = MathSol.divDownFixed(\n        MathSol.mulDownFixed(newSupply, currentBalances[tokenInIndex]),\n        totalSupply,\n    );\n\n    const taxableAmount =\n        amountIn + currentBalances[tokenInIndex] - nonTaxableBalance;\n\n    // Calculate the swap fee based on the taxable amount and the swap fee percentage\n    const fee =\n        MathSol.divUpFixed(\n            taxableAmount,\n            MathSol.complementFixed(swapFeePercentage),\n        ) - taxableAmount;\n\n    // Create swap fees amount array and set the single fee we charge\n    const swapFeeAmounts: bigint[] = new Array(currentBalances.length);\n    swapFeeAmounts[tokenInIndex] = fee;\n\n    // Return the total amount of input token needed, including the swap fee\n    const amountInWithFee = amountIn + fee;\n    return { amountInWithFee, swapFeeAmounts };\n}\n\n/**\n * @notice Computes the proportional amounts of tokens to be withdrawn from the pool.\n * @dev This function computes the amount of each token that will be withdrawn in exchange for burning\n * a specific amount of pool tokens (BPT). It ensures that the amounts of tokens withdrawn are proportional\n * to the current pool balances.\n *\n * Calculation: For each token, amountOut = balance * (bptAmountIn / bptTotalSupply).\n * Rounding down is used to prevent withdrawing more than the pool can afford.\n *\n * @param balances Array of current token balances in the pool.\n * @param bptTotalSupply Total supply of the pool tokens (BPT).\n * @param bptAmountIn The amount of pool tokens that will be burned.\n * @return amountsOut Array of amounts for each token to be withdrawn.\n */\nexport function computeProportionalAmountsOut(\n    balances: bigint[],\n    bptTotalSupply: bigint,\n    bptAmountIn: bigint,\n): bigint[] {\n    /**********************************************************************************************\n    // computeProportionalAmountsOut                                                             //\n    // (per token)                                                                               //\n    // aO = tokenAmountOut             /        bptIn         \\                                  //\n    // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n    // bpt = bptTotalSupply                                                                      //\n    **********************************************************************************************/\n\n    // Create a new array to hold the amounts of each token to be withdrawn.\n    const amountsOut: bigint[] = [];\n    for (let i = 0; i < balances.length; ++i) {\n        // Since we multiply and divide we don't need to use FP math.\n        // Round down since we're calculating amounts out.\n        amountsOut.push((balances[i] * bptAmountIn) / bptTotalSupply);\n    }\n    return amountsOut;\n}\n\n/**\n * @notice Computes the amount of a single token to withdraw for a given amount of BPT to burn.\n * @dev It computes the output token amount for an exact input of BPT, considering current balances,\n * total supply, and swap fees.\n *\n * @param currentBalances The current token balances in the pool.\n * @param tokenOutIndex The index of the token to be withdrawn.\n * @param exactBptAmountIn The exact amount of BPT the user wants to burn.\n * @param totalSupply The total supply of BPT in the pool.\n * @param swapFeePercentage The swap fee percentage applied to the taxable amount.\n * @param computeBalance A function pointer to the balance calculation function.\n * @return amountOutWithFee The amount of the output token the user receives, accounting for swap fees.\n */\nexport function computeRemoveLiquiditySingleTokenExactIn(\n    currentBalances: bigint[],\n    tokenOutIndex: number,\n    exactBptAmountIn: bigint,\n    totalSupply: bigint,\n    swapFeePercentage: bigint,\n    minInvariantRatio: bigint,\n    computeBalance: (\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        newSupply: bigint,\n    ) => bigint,\n): { amountOutWithFee: bigint; swapFeeAmounts: bigint[] } {\n    // Calculate new supply accounting for burning exactBptAmountIn\n    const newSupply = totalSupply - exactBptAmountIn;\n\n    const invariantRatio = MathSol.divUpFixed(newSupply, totalSupply);\n    if (invariantRatio < minInvariantRatio) {\n        throw Error(\n            `InvariantRatioBelowMin ${invariantRatio} ${minInvariantRatio}`,\n        );\n    }\n    // Calculate the new balance of the output token after the BPT burn.\n    // \"divUp\" leads to a higher \"newBalance,\" which in turn results in a lower \"amountOut.\"\n    // This leads to giving less tokens for the same amount of BTP burned.\n    const newBalance = computeBalance(\n        currentBalances,\n        tokenOutIndex,\n        invariantRatio,\n    );\n\n    // Compute the amount to be withdrawn from the pool.\n    const amountOut = currentBalances[tokenOutIndex] - newBalance;\n\n    const newBalanceBeforeTax = MathSol.mulDivUpFixed(\n        newSupply,\n        currentBalances[tokenOutIndex],\n        totalSupply,\n    );\n\n    // Compute the taxable amount: the difference between the new proportional and disproportional balances.\n    const taxableAmount = newBalanceBeforeTax - newBalance;\n\n    // Calculate the swap fee on the taxable amount.\n    const fee = MathSol.mulUpFixed(taxableAmount, swapFeePercentage);\n\n    // Create swap fees amount array and set the single fee we charge.\n    const swapFeeAmounts = new Array(currentBalances.length);\n    swapFeeAmounts[tokenOutIndex] = fee;\n\n    // Return the net amount after subtracting the fee.\n    const amountOutWithFee = amountOut - fee;\n\n    return {\n        amountOutWithFee,\n        swapFeeAmounts,\n    };\n}\n\n/**\n * @notice Computes the amount of pool tokens to burn to receive exact amount out.\n * @param currentBalances Current pool balances, in token registration order\n * @param tokenOutIndex Index of the token to receive in exchange for pool tokens burned\n * @param exactAmountOut Exact amount of tokens to receive\n * @param totalSupply Current total supply of the pool tokens (BPT)\n * @param swapFeePercentage The swap fee percentage applied to the taxable amount\n * @return bptAmountIn Amount of pool tokens to burn\n * @return swapFeeAmounts The amount of swap fees charged for each token\n */\nexport function computeRemoveLiquiditySingleTokenExactOut(\n    currentBalances: bigint[],\n    tokenOutIndex: number,\n    exactAmountOut: bigint,\n    totalSupply: bigint,\n    swapFeePercentage: bigint,\n    minInvariantRatio: bigint,\n    computeInvariant: (balances: bigint[], rounding: Rounding) => bigint,\n): {\n    bptAmountIn: bigint;\n    swapFeeAmounts: bigint[];\n} {\n    // Determine the number of tokens in the pool.\n    const numTokens = currentBalances.length;\n\n    // Create a new array to hold the updated balances.\n    const newBalances = new Array(numTokens);\n\n    // Copy currentBalances to newBalances\n    for (let index = 0; index < currentBalances.length; index++) {\n        newBalances[index] = currentBalances[index] - 1n;\n    }\n    // Update the balance of tokenOutIndex with exactAmountOut.\n    newBalances[tokenOutIndex] = newBalances[tokenOutIndex] - exactAmountOut;\n\n    // Calculate the invariant using the current balances.\n    const currentInvariant = computeInvariant(\n        currentBalances,\n        Rounding.ROUND_UP,\n    );\n\n    // We round invariant ratio up (see reason below).\n    // This invariant ratio could be rounded up even more by rounding `currentInvariant` down. But since it only\n    // affects the taxable amount and the fee calculation, whereas `currentInvariant` affects BPT in more directly,\n    // we use `currentInvariant` rounded up here as well.\n    const invariantRatio = MathSol.divUpFixed(\n        computeInvariant(newBalances, Rounding.ROUND_UP),\n        currentInvariant,\n    );\n\n    if (invariantRatio < minInvariantRatio) {\n        throw Error(\n            `InvariantRatioBelowMin ${invariantRatio} ${minInvariantRatio}`,\n        );\n    }\n\n    // Taxable amount is proportional to invariant ratio; a larger taxable amount rounds in the Vault's favor.\n    const taxableAmount =\n        MathSol.mulUpFixed(invariantRatio, currentBalances[tokenOutIndex]) -\n        newBalances[tokenOutIndex];\n\n    const fee =\n        MathSol.divUpFixed(\n            taxableAmount,\n            MathSol.complementFixed(swapFeePercentage),\n        ) - taxableAmount;\n\n    // Update new balances array with a fee\n    newBalances[tokenOutIndex] = newBalances[tokenOutIndex] - fee;\n\n    // Calculate the new invariant with fees applied.\n    const invariantWithFeesApplied = computeInvariant(\n        newBalances,\n        Rounding.ROUND_DOWN,\n    );\n\n    // Create swap fees amount array and set the single fee we charge\n    const swapFeeAmounts = new Array(numTokens);\n    swapFeeAmounts[tokenOutIndex] = fee;\n    // Calculate the amount of BPT to burn. This is done by multiplying the total supply by the ratio of the\n    // invariant delta to the current invariant.\n    //\n    // Calculating BPT amount in, so we round up. This is the most important result of this function, equivalent to:\n    // `totalSupply * (1 - invariantWithFeesApplied / currentInvariant)`.\n    // Then, to round `bptAmountIn` up we use `invariantWithFeesApplied` rounded down and `currentInvariant`\n    // rounded up.\n    //\n    // Since `currentInvariant` is rounded up and `invariantWithFeesApplied` is rounded down, the difference\n    // should always be positive. The checked math will revert if that is not the case.\n    const bptAmountIn = MathSol.mulDivUpFixed(\n        totalSupply,\n        currentInvariant - invariantWithFeesApplied,\n        currentInvariant,\n    );\n\n    return {\n        bptAmountIn,\n        swapFeeAmounts,\n    };\n}\n","import { MathSol, WAD } from '../utils/math';\n\n// A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n// implementation of the power function, as these ratios are often exponents.\nexport const _MIN_WEIGHT = BigInt('10000000000000000'); // 0.01e18\n\n// Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n// ratio).\n\n// Swap limits: amounts swapped may not be larger than this percentage of the total balance.\nexport const _MAX_IN_RATIO = BigInt('300000000000000000'); // 0.3e18\nexport const _MAX_OUT_RATIO = BigInt('300000000000000000'); // 0.3e18\n\n// Invariant growth limit: non-proportional joins cannot cause the invariant to increase by more than this ratio.\nexport const _MAX_INVARIANT_RATIO = BigInt('3000000000000000000'); // 3e18\n// Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\nexport const _MIN_INVARIANT_RATIO = BigInt('700000000000000000'); // 0.7e18\n\n/**\n * @notice Compute the invariant, rounding down.\n * @dev The invariant functions are called by the Vault during various liquidity operations, and require a specific\n * rounding direction in order to ensure safety (i.e., that the final result is always rounded in favor of the\n * protocol. The invariant (i.e., all token balances) must always be greater than 0, or it will revert.\n *\n * @param normalizedWeights The pool token weights, sorted in token registration order\n * @param balances The pool token balances, sorted in token registration order\n * @return invariant The invariant, rounded down\n */\nexport const _computeInvariantDown = (\n    normalizedWeights: bigint[],\n    balances: bigint[],\n): bigint => {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let invariant = WAD;\n    for (let i = 0; i < normalizedWeights.length; ++i) {\n        invariant = MathSol.mulDownFixed(\n            invariant,\n            MathSol.powDownFixed(balances[i], normalizedWeights[i]),\n        );\n    }\n    if (invariant === 0n) {\n        throw new Error('ZeroInvariant');\n    }\n    return invariant;\n};\n\n/**\n * @notice Compute the invariant, rounding up.\n * @dev The invariant functions are called by the Vault during various liquidity operations, and require a specific\n * rounding direction in order to ensure safety (i.e., that the final result is always rounded in favor of the\n * protocol. The invariant (i.e., all token balances) must always be greater than 0, or it will revert.\n *\n * @param normalizedWeights The pool token weights, sorted in token registration order\n * @param balances The pool token balances, sorted in token registration order\n * @return invariant The invariant, rounded up\n */\nexport const _computeInvariantUp = (\n    normalizedWeights: bigint[],\n    balances: bigint[],\n): bigint => {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let invariant = WAD;\n    for (let i = 0; i < normalizedWeights.length; ++i) {\n        invariant = MathSol.mulUpFixed(\n            invariant,\n            MathSol.powUpFixed(balances[i], normalizedWeights[i]),\n        );\n    }\n\n    if (invariant === 0n) {\n        throw new Error('ZeroInvariant');\n    }\n    return invariant;\n};\n\nexport const _computeBalanceOutGivenInvariant = (\n    currentBalance: bigint,\n    weight: bigint,\n    invariantRatio: bigint,\n): bigint => {\n    /******************************************************************************************\n    // calculateBalanceGivenInvariant                                                       //\n    // o = balanceOut                                                                        //\n    // b = balanceIn                      (1 / w)                                            //\n    // w = weight              o = b * i ^                                                   //\n    // i = invariantRatio                                                                    //\n    ******************************************************************************************/\n\n    // Rounds result up overall.\n\n    // Calculate by how much the token balance has to increase to match the invariantRatio.\n    const balanceRatio = MathSol.powUpFixed(\n        invariantRatio,\n        MathSol.divUpFixed(WAD, weight),\n    );\n\n    return MathSol.mulUpFixed(currentBalance, balanceRatio);\n};\n\n// Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n// current balances and weights.\nexport const _computeOutGivenExactIn = (\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n): bigint => {\n    /**********************************************************************************************\n    // outGivenExactIn                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /      /            bI             \\    (wI / wO) \\           //\n    // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n    // wI = weightIn               \\      \\       ( bI + aI )         /              /           //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    if (amountIn > MathSol.mulDownFixed(balanceIn, _MAX_IN_RATIO)) {\n        throw new Error('MaxInRatio exceeded');\n    }\n\n    const denominator = balanceIn + amountIn;\n    const base = MathSol.divUpFixed(balanceIn, denominator);\n    const exponent = MathSol.divDownFixed(weightIn, weightOut);\n    const power = MathSol.powUpFixed(base, exponent);\n\n    // Because of rounding up, power can be greater than one. Using complement prevents reverts.\n    return MathSol.mulDownFixed(balanceOut, MathSol.complementFixed(power));\n};\n\n// Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n// current balances and weights.\nexport const _computeInGivenExactOut = (\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n): bigint => {\n    /**********************************************************************************************\n    // inGivenExactOut                                                                                //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /  /            bO             \\    (wO / wI)      \\          //\n    // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n    // wI = weightIn               \\  \\       ( bO - aO )         /                   /          //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    if (amountOut > MathSol.mulDownFixed(balanceOut, _MAX_OUT_RATIO)) {\n        throw new Error('MaxOutRatio exceeded');\n    }\n\n    const base = MathSol.divUpFixed(balanceOut, balanceOut - amountOut);\n    const exponent = MathSol.divUpFixed(weightOut, weightIn);\n    const power = MathSol.powUpFixed(base, exponent);\n\n    // Because the base is larger than one (and the power rounds up), the power should always be larger than one, so\n    // the following subtraction should never revert.\n    const ratio = power - WAD;\n\n    return MathSol.mulUpFixed(balanceIn, ratio);\n};\n","import { MAX_UINT256 } from '../constants';\nimport { MathSol } from '../utils/math';\nimport { toRawUndoRateRoundDown } from '../vault/utils';\nimport {\n    MaxSingleTokenRemoveParams,\n    MaxSwapParams,\n    type PoolBase,\n    Rounding,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport {\n    _computeOutGivenExactIn,\n    _computeInGivenExactOut,\n    _computeBalanceOutGivenInvariant,\n    _MAX_IN_RATIO,\n    _MAX_OUT_RATIO,\n    _MAX_INVARIANT_RATIO,\n    _MIN_INVARIANT_RATIO,\n    _computeInvariantUp,\n    _computeInvariantDown,\n} from './weightedMath';\n\nexport class Weighted implements PoolBase {\n    public normalizedWeights: bigint[];\n\n    constructor(poolState: { weights: bigint[] }) {\n        this.normalizedWeights = poolState.weights;\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        return _MAX_INVARIANT_RATIO;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        return _MIN_INVARIANT_RATIO;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const {\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            tokenRates,\n            scalingFactors,\n            swapKind,\n        } = maxSwapParams;\n        if (swapKind === SwapKind.GivenIn) {\n            const max18 = MathSol.mulDownFixed(\n                balancesLiveScaled18[indexIn],\n                _MAX_IN_RATIO,\n            );\n            // Scale to token in (and remove rate)\n            return toRawUndoRateRoundDown(\n                max18,\n                scalingFactors[indexIn],\n                tokenRates[indexIn],\n            );\n        }\n\n        const max18 = MathSol.mulDownFixed(\n            balancesLiveScaled18[indexOut],\n            _MAX_OUT_RATIO,\n        );\n        // Scale to token out\n        return toRawUndoRateRoundDown(\n            max18,\n            scalingFactors[indexOut],\n            tokenRates[indexOut],\n        );\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint {\n        const {\n            isExactIn,\n            totalSupply,\n            tokenOutBalance,\n            tokenOutScalingFactor,\n            tokenOutRate,\n        } = maxRemoveParams;\n        return this.getMaxSwapAmount({\n            swapKind: isExactIn ? SwapKind.GivenIn : SwapKind.GivenOut,\n            balancesLiveScaled18: [totalSupply, tokenOutBalance],\n            tokenRates: [1000000000000000000n, tokenOutRate],\n            scalingFactors: [1000000000000000000n, tokenOutScalingFactor],\n            indexIn: 0,\n            indexOut: 1,\n        });\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18: balancesScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n        if (swapKind === SwapKind.GivenIn) {\n            return _computeOutGivenExactIn(\n                balancesScaled18[indexIn],\n                this.normalizedWeights[indexIn],\n                balancesScaled18[indexOut],\n                this.normalizedWeights[indexOut],\n                amountGivenScaled18,\n            );\n        }\n        return _computeInGivenExactOut(\n            balancesScaled18[indexIn],\n            this.normalizedWeights[indexIn],\n            balancesScaled18[indexOut],\n            this.normalizedWeights[indexOut],\n            amountGivenScaled18,\n        );\n    }\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint {\n        if (rounding === Rounding.ROUND_UP)\n            return _computeInvariantUp(\n                this.normalizedWeights,\n                balancesLiveScaled18,\n            );\n        else\n            return _computeInvariantDown(\n                this.normalizedWeights,\n                balancesLiveScaled18,\n            );\n    }\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint {\n        return _computeBalanceOutGivenInvariant(\n            balancesLiveScaled18[tokenInIndex],\n            this.normalizedWeights[tokenInIndex],\n            invariantRatio,\n        );\n    }\n}\n","import { MathSol, WAD } from '../utils/math';\n\nexport class GyroPoolMath {\n    static _SQRT_1E_NEG_1 = 316227766016837933n;\n    static _SQRT_1E_NEG_3 = 31622776601683793n;\n    static _SQRT_1E_NEG_5 = 3162277660168379n;\n    static _SQRT_1E_NEG_7 = 316227766016837n;\n    static _SQRT_1E_NEG_9 = 31622776601683n;\n    static _SQRT_1E_NEG_11 = 3162277660168n;\n    static _SQRT_1E_NEG_13 = 316227766016n;\n    static _SQRT_1E_NEG_15 = 31622776601n;\n    static _SQRT_1E_NEG_17 = 3162277660n;\n\n    /// @dev Implements a square root algorithm using Newton's method and a first-guess optimization.\n    static sqrt(input: bigint, tolerance: bigint): bigint {\n        if (input === 0n) {\n            return 0n;\n        }\n\n        let guess = this._makeInitialGuess(input);\n\n        // At this point `guess` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iterations to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n        guess = (guess + (input * WAD) / guess) / 2n;\n\n        // Check that squaredGuess (guess * guess) is close enough from input. `guess` has less than 1 wei error, but\n        // the loss of precision in the 18 decimal representation causes an error in the squared number, which must be\n        // less than `(guess * tolerance) / WAD`. Tolerance, in this case, is a very small number (< 10),\n        // so the tolerance will be very small too.\n        const guessSquared = MathSol.mulDownFixed(guess, guess);\n        if (\n            !(\n                guessSquared <= input + MathSol.mulUpFixed(guess, tolerance) &&\n                guessSquared >= input - MathSol.mulUpFixed(guess, tolerance)\n            )\n        ) {\n            throw Error('_sqrt FAILED');\n        }\n\n        return guess;\n    }\n\n    static _makeInitialGuess(input: bigint): bigint {\n        if (input >= WAD) {\n            return (1n << this._intLog2Halved(input / WAD)) * WAD;\n        } else {\n            if (input <= 10n) return this._SQRT_1E_NEG_17;\n            if (input <= 100n) return 10n ** 10n;\n            if (input <= 1000n) return this._SQRT_1E_NEG_15;\n            if (input <= 10000n) return 10n ** 11n;\n            if (input <= 100000n) return this._SQRT_1E_NEG_13;\n            if (input <= 1000000n) return 10n ** 12n;\n            if (input <= 10000000n) return this._SQRT_1E_NEG_11;\n            if (input <= 100000000n) return 10n ** 13n;\n            if (input <= 1000000000n) return this._SQRT_1E_NEG_9;\n            if (input <= 10000000000n) return 10n ** 14n;\n            if (input <= 100000000000n) return this._SQRT_1E_NEG_7;\n            if (input <= 1000000000000n) return 10n ** 15n;\n            if (input <= 10000000000000n) return this._SQRT_1E_NEG_5;\n            if (input <= 100000000000000n) return 10n ** 16n;\n            if (input <= 1000000000000000n) return this._SQRT_1E_NEG_3;\n            if (input <= 10000000000000000n) return 10n ** 17n;\n            if (input <= 100000000000000000n) return this._SQRT_1E_NEG_1;\n            return input;\n        }\n    }\n\n    static _intLog2Halved(x: bigint): bigint {\n        let n = 0n; // Initialize n as a BigInt\n\n        if (x >= 1n << 128n) {\n            x >>= 128n;\n            n += 64n;\n        }\n        if (x >= 1n << 64n) {\n            x >>= 64n;\n            n += 32n;\n        }\n        if (x >= 1n << 32n) {\n            x >>= 32n;\n            n += 16n;\n        }\n        if (x >= 1n << 16n) {\n            x >>= 16n;\n            n += 8n;\n        }\n        if (x >= 1n << 8n) {\n            x >>= 8n;\n            n += 4n;\n        }\n        if (x >= 1n << 4n) {\n            x >>= 4n;\n            n += 2n;\n        }\n        if (x >= 1n << 2n) {\n            x >>= 2n;\n            n += 1n;\n        }\n\n        return n;\n    }\n}\n","// The invariant is used to calculate the virtual offsets used in swaps.\n// It is also used to collect protocol swap fees by comparing its value between two times.\n// We can always round in the same direction. It is also used to initialize the BPT amount and,\n\nimport { FixedPointFunction, MathSol, WAD } from '../utils/math';\nimport { Rounding } from '../vault/types';\nimport { GyroPoolMath } from './gyroPoolMath';\n\n// because there is a minimum BPT, we round the invariant down.\nexport function calculateInvariant(\n    balances: bigint[],\n    sqrtAlpha: bigint,\n    sqrtBeta: bigint,\n    rounding: Rounding,\n): bigint {\n    /**********************************************************************************************\n    // Calculate with quadratic formula\n    // 0 = (1-sqrt(alpha/beta)*L^2 - (y/sqrt(beta)+x*sqrt(alpha))*L - x*y)\n    // 0 = a*L^2 + b*L + c\n    // here a > 0, b < 0, and c < 0, which is a special case that works well w/o negative numbers\n    // taking mb = -b and mc = -c:                               (1/2)\n    //                                  mb + (mb^2 + 4 * a * mc)^                   //\n    //                   L =    ------------------------------------------          //\n    //                                          2 * a                               //\n    //                                                                              //\n    **********************************************************************************************/\n    const { a, mb, bSquare, mc } = calculateQuadraticTerms(\n        balances,\n        sqrtAlpha,\n        sqrtBeta,\n        rounding,\n    );\n\n    return calculateQuadratic(a, mb, bSquare, mc);\n}\n\n/**\n * @notice Prepares quadratic terms for input to _calculateQuadratic.\n * @dev It uses a special case of the quadratic formula that works nicely without negative numbers, and\n * assumes a > 0, b < 0, and c <= 0.\n *\n * @param balances Pool balances\n * @param sqrtAlpha Square root of Gyro's 2CLP alpha parameter\n * @param sqrtBeta Square root of Gyro's 2CLP beta parameter\n * @param rounding Rounding direction of the invariant, which will be calculated using the quadratic terms\n * @return a Bhaskara's `a` term\n * @return mb Bhaskara's `b` term, negative (stands for minus b)\n * @return bSquare Bhaskara's `b^2` term. The calculation is optimized to be more precise than just b*b\n * @return mc Bhaskara's `c` term, negative (stands for minus c)\n */\nfunction calculateQuadraticTerms(\n    balances: bigint[],\n    sqrtAlpha: bigint,\n    sqrtBeta: bigint,\n    rounding: Rounding,\n): { a: bigint; mb: bigint; bSquare: bigint; mc: bigint } {\n    const _divUpOrDown: FixedPointFunction =\n        rounding === Rounding.ROUND_DOWN\n            ? MathSol.divDownFixed\n            : MathSol.divUpFixed;\n\n    const _mulUpOrDown: FixedPointFunction =\n        rounding === Rounding.ROUND_DOWN\n            ? MathSol.mulDownFixed\n            : MathSol.mulUpFixed;\n\n    const _mulDownOrUp: FixedPointFunction =\n        rounding === Rounding.ROUND_DOWN\n            ? MathSol.mulUpFixed\n            : MathSol.mulDownFixed;\n\n    // `a` follows the opposite rounding than `b` and `c`, since the most significant term is in the\n    // denominator of Bhaskara's formula. To round the invariant up, we need to round `a` down, which means that\n    // the division `sqrtAlpha/sqrtBeta` needs to be rounded up. In other words, if the given rounding\n    // direction is UP, 'a' will be rounded DOWN and vice versa.\n    const a = WAD - _divUpOrDown(sqrtAlpha, sqrtBeta);\n\n    // `b` is a term in the numerator and should be rounded up if we want to increase the invariant.\n    const bterm0 = _divUpOrDown(balances[1], sqrtBeta);\n    const bterm1 = _mulUpOrDown(balances[0], sqrtAlpha);\n    const mb = bterm0 + bterm1;\n    // `c` is a term in the numerator and should be rounded up if we want to increase the invariant.\n    const mc = _mulUpOrDown(balances[0], balances[1]);\n\n    // For better fixed point precision, calculate in expanded form, re-ordering multiplications.\n    // `b^2 = x^2 * alpha + x*y*2*sqrt(alpha/beta) + y^2 / beta`\n    let bSquare = _mulUpOrDown(\n        _mulUpOrDown(_mulUpOrDown(balances[0], balances[0]), sqrtAlpha),\n        sqrtAlpha,\n    );\n    const bSq2 = _divUpOrDown(\n        2n * _mulUpOrDown(_mulUpOrDown(balances[0], balances[1]), sqrtAlpha),\n        sqrtBeta,\n    );\n    const bSq3 = _divUpOrDown(\n        _mulUpOrDown(balances[1], balances[1]),\n        _mulDownOrUp(sqrtBeta, sqrtBeta),\n    );\n    bSquare = bSquare + bSq2 + bSq3;\n    return { a, mb, bSquare, mc };\n}\n\n/**\n * @dev Calculates the quadratic root for a special case of the quadratic formula.\n *   assumes a > 0, b < 0, and c <= 0, which is the case for a L^2 + b L + c = 0\n *   where   a = 1 - sqrt(alpha/beta)\n *           b = -(y/sqrt(beta) + x*sqrt(alpha))\n *           c = -x*y\n *   The special case works nicely without negative numbers.\n *   The args use the notation \"mb\" to represent -b, and \"mc\" to represent -c\n *   Note that this calculation underestimates the solution.\n */\nfunction calculateQuadratic(\n    a: bigint,\n    mb: bigint,\n    bSquare: bigint, // b^2 can be calculated separately with more precision\n    mc: bigint,\n): bigint {\n    const denominator = MathSol.mulUpFixed(a, 2n * WAD);\n    // Order multiplications for fixed point precision.\n    const addTerm = MathSol.mulDownFixed(MathSol.mulDownFixed(mc, 4n * WAD), a);\n    // The minus sign in the radicand cancels out in this special case.\n    const radicand = bSquare + addTerm;\n    const sqrResult = GyroPoolMath.sqrt(radicand, 5n);\n    // The minus sign in the numerator cancels out in this special case.\n    const numerator = mb + sqrResult;\n    const invariant = MathSol.divDownFixed(numerator, denominator);\n    return invariant;\n}\n\n/**\n * @dev Computes how many tokens can be taken out of a pool if `amountIn' are sent, given current balances.\n *   balanceIn = existing balance of input token\n *   balanceOut = existing balance of requested output token\n *   virtualParamIn = virtual reserve offset for input token\n *   virtualParamOut = virtual reserve offset for output token\n *   Offsets are L/sqrt(beta) and L*sqrt(alpha) depending on what the `in' and `out' tokens are respectively\n *   Note signs are changed compared to Prop. 4 in Section 2.2.4 Trade (Swap) Execution to account for dy < 0\n *\n *   The virtualOffset argument depends on the computed invariant. We add a very small margin to ensure that\n *   potential small errors are not to the detriment of the pool.\n *\n *   There is a corresponding function in the 3CLP, except that there we allow two different virtual \"in\" and\n *   \"out\" assets.\n *   SOMEDAY: This could be made literally the same function in the pool math library.\n */\nexport function calcOutGivenIn(\n    balanceIn: bigint,\n    balanceOut: bigint,\n    amountIn: bigint,\n    virtualOffsetIn: bigint,\n    virtualOffsetOut: bigint,\n): bigint {\n    /**********************************************************************************************\n     // Described for X = `in' asset and Y = `out' asset, but equivalent for the other case       //\n    // dX = incrX  = amountIn  > 0                                                               //\n    // dY = incrY = amountOut < 0                                                                //\n    // x = balanceIn             x' = x +  virtualParamX                                         //\n    // y = balanceOut            y' = y +  virtualParamY                                         //\n    // L  = inv.Liq                   /            x' * y'          \\          y' * dX           //\n    //                   |dy| = y' - |   --------------------------  |   = --------------  -     //\n    //  x' = virtIn                   \\          ( x' + dX)         /          x' + dX           //\n    //  y' = virtOut                                                                             //\n    // Note that -dy > 0 is what the trader receives.                                            //\n    // We exploit the fact that this formula is symmetric up to virtualOffset{X,Y}.               //\n    // We do not use L^2, but rather x' * y', to prevent a potential accumulation of errors.      //\n    // We add a very small safety margin to compensate for potential errors in the invariant.     //\n    **********************************************************************************************/\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // that is very slightly larger than 3e-18.\n    const virtInOver =\n        balanceIn + MathSol.mulUpFixed(virtualOffsetIn, WAD + 2n);\n    const virtOutUnder =\n        balanceOut + MathSol.mulDownFixed(virtualOffsetOut, WAD - 1n);\n\n    const amountOut = MathSol.divDownFixed(\n        MathSol.mulDownFixed(virtOutUnder, amountIn),\n        virtInOver + amountIn,\n    );\n\n    // This ensures amountOut < balanceOut.\n    if (!(amountOut <= balanceOut)) {\n        throw Error('AssetBoundsExceeded');\n    }\n    return amountOut;\n}\n\n/**\n * @dev Computes how many tokens must be sent to a pool in order to take `amountOut`, given current balances.\n * See also _calcOutGivenIn(). Adapted for negative values.\n */\nexport function calcInGivenOut(\n    balanceIn: bigint,\n    balanceOut: bigint,\n    amountOut: bigint,\n    virtualOffsetIn: bigint,\n    virtualOffsetOut: bigint,\n): bigint {\n    /**********************************************************************************************\n      // dX = incrX  = amountIn  > 0                                                                 //\n      // dY = incrY  = amountOut < 0                                                                 //\n      // x = balanceIn             x' = x +  virtualParamX                                           //\n      // y = balanceOut            y' = y +  virtualParamY                                           //\n      // x = balanceIn                                                                               //\n      // L  = inv.Liq               /            x' * y'          \\                x' * dy           //\n      //                     dx =  |   --------------------------  |  -  x'  = - -----------         //\n      // x' = virtIn               \\             y' + dy          /                y' + dy           //\n      // y' = virtOut                                                                                //\n      // Note that dy < 0 < dx.                                                                      //\n      // We exploit the fact that this formula is symmetric up to virtualOffset{X,Y}.                //\n      // We do not use L^2, but rather x' * y', to prevent a potential accumulation of errors.       //\n      // We add a very small safety margin to compensate for potential errors in the invariant.      //\n      **********************************************************************************************/\n    if (!(amountOut <= balanceOut)) {\n        throw Error('AssetBoundsExceeded');\n    }\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // that is very slightly larger than 3e-18.\n    const virtInOver =\n        balanceIn + MathSol.mulUpFixed(virtualOffsetIn, WAD + 2n);\n    const virtOutUnder =\n        balanceOut + MathSol.mulDownFixed(virtualOffsetOut, WAD - 1n);\n\n    const amountIn = MathSol.divUpFixed(\n        MathSol.mulUpFixed(virtInOver, amountOut),\n        virtOutUnder - amountOut,\n    );\n    return amountIn;\n}\n\n/// @dev Calculate the virtual offset `a` for reserves `x`, as in (x+a)*(y+b)=L^2.\nexport function calculateVirtualParameter0(\n    invariant: bigint,\n    _sqrtBeta: bigint,\n    rounding: Rounding,\n): bigint {\n    return rounding === Rounding.ROUND_DOWN\n        ? MathSol.divDownFixed(invariant, _sqrtBeta)\n        : MathSol.divUpFixed(invariant, _sqrtBeta);\n}\n\n/// @dev Calculate the virtual offset `b` for reserves `y`, as in (x+a)*(y+b)=L^2.\nexport function calculateVirtualParameter1(\n    invariant: bigint,\n    _sqrtAlpha: bigint,\n    rounding: Rounding,\n): bigint {\n    return rounding === Rounding.ROUND_DOWN\n        ? MathSol.mulDownFixed(invariant, _sqrtAlpha)\n        : MathSol.mulUpFixed(invariant, _sqrtAlpha);\n}\n","import { MAX_UINT256, MAX_BALANCE } from '../constants';\nimport {\n    MaxSingleTokenRemoveParams,\n    MaxSwapParams,\n    type PoolBase,\n    Rounding,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport { toRawUndoRateRoundDown } from '../vault/utils';\nimport { MathSol } from '../utils/math';\nimport { Gyro2CLPImmutable } from './gyro2CLPData';\nimport {\n    calcInGivenOut,\n    calcOutGivenIn,\n    calculateInvariant,\n    calculateVirtualParameter0,\n    calculateVirtualParameter1,\n} from './gyro2CLPMath';\n\nexport class Gyro2CLP implements PoolBase {\n    public _sqrtAlpha: bigint;\n    public _sqrtBeta: bigint;\n\n    constructor(poolState: Gyro2CLPImmutable) {\n        if (poolState.sqrtAlpha >= poolState.sqrtBeta) {\n            throw Error('SqrtParamsWrong');\n        }\n\n        this._sqrtAlpha = poolState.sqrtAlpha;\n        this._sqrtBeta = poolState.sqrtBeta;\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        return 0n;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const {\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            tokenRates,\n            scalingFactors,\n            swapKind,\n        } = maxSwapParams;\n        if (swapKind === SwapKind.GivenIn) {\n            // MAX_BALANCE comes from SC limit and is max pool can hold\n            const diff = MAX_BALANCE - balancesLiveScaled18[indexIn];\n            // Scale to token in (and remove rate)\n            return toRawUndoRateRoundDown(\n                diff,\n                scalingFactors[indexIn],\n                tokenRates[indexIn],\n            );\n        }\n        // 99% of token out balance\n        const max = MathSol.mulDownFixed(\n            990000000000000000n,\n            balancesLiveScaled18[indexOut],\n        );\n        // Scale to token out\n        return toRawUndoRateRoundDown(\n            max,\n            scalingFactors[indexOut],\n            tokenRates[indexOut],\n        );\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint {\n        const {\n            isExactIn,\n            totalSupply,\n            tokenOutBalance,\n            tokenOutScalingFactor,\n            tokenOutRate,\n        } = maxRemoveParams;\n        return this.getMaxSwapAmount({\n            swapKind: isExactIn ? SwapKind.GivenIn : SwapKind.GivenOut,\n            balancesLiveScaled18: [totalSupply, tokenOutBalance],\n            tokenRates: [1000000000000000000n, tokenOutRate],\n            scalingFactors: [1000000000000000000n, tokenOutScalingFactor],\n            indexIn: 0,\n            indexOut: 1,\n        });\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18: balancesScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n\n        const tokenInIsToken0 = indexIn == 0;\n        const balanceTokenInScaled18 = balancesScaled18[indexIn];\n        const balanceTokenOutScaled18 = balancesScaled18[indexOut];\n\n        const { virtualBalanceIn, virtualBalanceOut } = this._getVirtualOffsets(\n            balanceTokenInScaled18,\n            balanceTokenOutScaled18,\n            tokenInIsToken0,\n        );\n\n        if (swapKind === SwapKind.GivenIn) {\n            const amountOutScaled18 = calcOutGivenIn(\n                balanceTokenInScaled18,\n                balanceTokenOutScaled18,\n                amountGivenScaled18,\n                virtualBalanceIn,\n                virtualBalanceOut,\n            );\n            return amountOutScaled18;\n        }\n        const amountInScaled18 = calcInGivenOut(\n            balanceTokenInScaled18,\n            balanceTokenOutScaled18,\n            amountGivenScaled18,\n            virtualBalanceIn,\n            virtualBalanceOut,\n        );\n\n        return amountInScaled18;\n    }\n\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint {\n        return calculateInvariant(\n            balancesLiveScaled18,\n            this._sqrtAlpha,\n            this._sqrtBeta,\n            rounding,\n        );\n    }\n\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint {\n        /**********************************************************************************************\n        // Gyro invariant formula is:\n        //                                    Lˆ2 = (x + a)(y + b)\n        // where:\n        //   a = L / _sqrtBeta\n        //   b = L * _sqrtAlpha\n        //\n        // In computeBalance, we want to know the new balance of a token, given that the invariant\n        // changed and the other token balance didn't change. To calculate that for \"x\", we use:\n        //\n        //            (L*Lratio)ˆ2 = (newX + (L*Lratio) / _sqrtBeta)(y + (L*Lratio) * _sqrtAlpha)\n        //\n        // To simplify, let's rename a few terms:\n        //\n        //                                       squareNewInv = (newX + a)(y + b)\n        //\n        // Isolating newX:                       newX = (squareNewInv/(y + b)) - a\n        // For newY:                             newY = (squareNewInv/(x + a)) - b\n        **********************************************************************************************/\n\n        // `computeBalance` is used to calculate unbalanced adds and removes, when the BPT value is specified.\n        // A bigger invariant in `computeAddLiquiditySingleTokenExactOut` means that more tokens are required to\n        // fulfill the trade, and a bigger invariant in `computeRemoveLiquiditySingleTokenExactIn` means that the\n        // amount out is lower. So, the invariant should always be rounded up.\n        let invariant = calculateInvariant(\n            balancesLiveScaled18,\n            this._sqrtAlpha,\n            this._sqrtBeta,\n            Rounding.ROUND_UP,\n        );\n        // New invariant\n        invariant = MathSol.mulUpFixed(invariant, invariantRatio);\n        const squareNewInv = invariant * invariant;\n        // L / sqrt(beta)\n        const a = MathSol.divDownFixed(invariant, this._sqrtBeta);\n        // L * sqrt(alpha)\n        const b = MathSol.mulDownFixed(invariant, this._sqrtAlpha);\n\n        let newBalance = 0n;\n        if (tokenInIndex === 0) {\n            // if newBalance = newX\n            newBalance =\n                MathSol.divUp(squareNewInv, balancesLiveScaled18[1] + b) - a;\n        } else {\n            // if newBalance = newY\n            newBalance =\n                MathSol.divUp(squareNewInv, balancesLiveScaled18[0] + a) - b;\n        }\n        return newBalance;\n    }\n\n    /**\n     * @notice Return the virtual offsets of each token of the 2CLP pool.\n     * @dev The 2CLP invariant is defined as `L=(x+a)(y+b)`. \"x\" and \"y\" are the real balances, and \"a\" and \"b\" are\n     * offsets to concentrate the liquidity of the pool. The sum of real balance and offset is known as\n     * \"virtual balance\". Here we return the offsets a and b.\n     */\n    _getVirtualOffsets(\n        balanceTokenInScaled18: bigint,\n        balanceTokenOutScaled18: bigint,\n        tokenInIsToken0: boolean,\n    ): { virtualBalanceIn: bigint; virtualBalanceOut: bigint } {\n        const balances = new Array(2).fill(0n);\n        balances[0] = tokenInIsToken0\n            ? balanceTokenInScaled18\n            : balanceTokenOutScaled18;\n        balances[1] = tokenInIsToken0\n            ? balanceTokenOutScaled18\n            : balanceTokenInScaled18;\n\n        const currentInvariant = calculateInvariant(\n            balances,\n            this._sqrtAlpha,\n            this._sqrtBeta,\n            Rounding.ROUND_DOWN,\n        );\n\n        // virtualBalanceIn is always rounded up, because:\n        // * If swap is EXACT_IN: a bigger virtualBalanceIn leads to a lower amount out;\n        // * If swap is EXACT_OUT: a bigger virtualBalanceIn leads to a bigger amount in;\n        // virtualBalanceOut is always rounded down, because:\n        // * If swap is EXACT_IN: a lower virtualBalanceOut leads to a lower amount out;\n        // * If swap is EXACT_OUT: a lower virtualBalanceOut leads to a bigger amount in;\n        let virtualBalanceIn = 0n;\n        let virtualBalanceOut = 0n;\n        if (tokenInIsToken0) {\n            virtualBalanceIn = calculateVirtualParameter0(\n                currentInvariant,\n                this._sqrtBeta,\n                Rounding.ROUND_UP,\n            );\n            virtualBalanceOut = calculateVirtualParameter1(\n                currentInvariant,\n                this._sqrtAlpha,\n                Rounding.ROUND_DOWN,\n            );\n        } else {\n            virtualBalanceIn = calculateVirtualParameter1(\n                currentInvariant,\n                this._sqrtAlpha,\n                Rounding.ROUND_UP,\n            );\n            virtualBalanceOut = calculateVirtualParameter0(\n                currentInvariant,\n                this._sqrtBeta,\n                Rounding.ROUND_DOWN,\n            );\n        }\n\n        return {\n            virtualBalanceIn,\n            virtualBalanceOut,\n        };\n    }\n}\n","class FixedPointError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'FixedPointError';\n    }\n}\n\nexport class SignedFixedPoint {\n    public static readonly ONE = BigInt('1000000000000000000'); // 1e18\n    public static readonly ONE_XP = BigInt(\n        '100000000000000000000000000000000000000',\n    ); // 1e38\n\n    static add(a: bigint, b: bigint): bigint {\n        const c = a + b;\n        if (!(b >= 0n ? c >= a : c < a)) {\n            throw new FixedPointError('AddOverflow');\n        }\n        return c;\n    }\n\n    static addMag(a: bigint, b: bigint): bigint {\n        return a > 0n ? this.add(a, b) : this.sub(a, b);\n    }\n\n    static sub(a: bigint, b: bigint): bigint {\n        const c = a - b;\n        if (!(b <= 0n ? c >= a : c < a)) {\n            throw new FixedPointError('SubOverflow');\n        }\n        return c;\n    }\n\n    static mulDownMag(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        if (!(a === 0n || product / a === b)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        return product / this.ONE;\n    }\n\n    static mulDownMagU(a: bigint, b: bigint): bigint {\n        return (a * b) / this.ONE;\n    }\n\n    static mulUpMag(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        if (!(a === 0n || product / a === b)) {\n            throw new FixedPointError('MulOverflow');\n        }\n\n        if (product > 0n) {\n            return (product - 1n) / this.ONE + 1n;\n        } else if (product < 0n) {\n            return (product + 1n) / this.ONE - 1n;\n        }\n        return 0n;\n    }\n\n    static mulUpMagU(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        if (product > 0n) {\n            return (product - 1n) / this.ONE + 1n;\n        } else if (product < 0n) {\n            return (product + 1n) / this.ONE - 1n;\n        }\n        return 0n;\n    }\n\n    static divDownMag(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        if (a === 0n) {\n            return 0n;\n        }\n\n        const aInflated = a * this.ONE;\n        if (aInflated / a !== this.ONE) {\n            throw new FixedPointError('DivInterval');\n        }\n\n        return aInflated / b;\n    }\n\n    static divDownMagU(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        return (a * this.ONE) / b;\n    }\n\n    static divUpMag(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        if (a === 0n) {\n            return 0n;\n        }\n\n        let localA = a;\n        let localB = b;\n        if (b < 0n) {\n            localB = -b;\n            localA = -a;\n        }\n\n        const aInflated = localA * this.ONE;\n        if (aInflated / localA !== this.ONE) {\n            throw new FixedPointError('DivInterval');\n        }\n\n        if (aInflated > 0n) {\n            return (aInflated - 1n) / localB + 1n;\n        }\n        return (aInflated + 1n) / localB - 1n;\n    }\n\n    static divUpMagU(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        if (a === 0n) {\n            return 0n;\n        }\n\n        let localA = a;\n        let localB = b;\n        if (b < 0n) {\n            localB = -b;\n            localA = -a;\n        }\n\n        if (localA > 0n) {\n            return (localA * this.ONE - 1n) / localB + 1n;\n        }\n        return (localA * this.ONE + 1n) / localB - 1n;\n    }\n\n    static mulXp(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        if (!(a === 0n || product / a === b)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        return product / this.ONE_XP;\n    }\n\n    static mulXpU(a: bigint, b: bigint): bigint {\n        return (a * b) / this.ONE_XP;\n    }\n\n    static divXp(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        if (a === 0n) {\n            return 0n;\n        }\n\n        const aInflated = a * this.ONE_XP;\n        if (aInflated / a !== this.ONE_XP) {\n            throw new FixedPointError('DivInterval');\n        }\n\n        return aInflated / b;\n    }\n\n    static divXpU(a: bigint, b: bigint): bigint {\n        if (b === 0n) {\n            throw new FixedPointError('ZeroDivision');\n        }\n        return (a * this.ONE_XP) / b;\n    }\n\n    static mulDownXpToNp(a: bigint, b: bigint): bigint {\n        const E19 = BigInt('10000000000000000000');\n        const b1 = b / E19;\n        const prod1 = a * b1;\n        if (!(a === 0n || prod1 / a === b1)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        const b2 = b % E19;\n        const prod2 = a * b2;\n        if (!(a === 0n || prod2 / a === b2)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        return prod1 >= 0n && prod2 >= 0n\n            ? (prod1 + prod2 / E19) / E19\n            : (prod1 + prod2 / E19 + 1n) / E19 - 1n;\n    }\n\n    static mulDownXpToNpU(a: bigint, b: bigint): bigint {\n        const E19 = BigInt('10000000000000000000');\n        const b1 = b / E19;\n        const b2 = b % E19;\n        const prod1 = a * b1;\n        const prod2 = a * b2;\n        return prod1 >= 0n && prod2 >= 0n\n            ? (prod1 + prod2 / E19) / E19\n            : (prod1 + prod2 / E19 + 1n) / E19 - 1n;\n    }\n\n    static mulUpXpToNp(a: bigint, b: bigint): bigint {\n        const E19 = BigInt('10000000000000000000');\n        const b1 = b / E19;\n        const prod1 = a * b1;\n        if (!(a === 0n || prod1 / a === b1)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        const b2 = b % E19;\n        const prod2 = a * b2;\n        if (!(a === 0n || prod2 / a === b2)) {\n            throw new FixedPointError('MulOverflow');\n        }\n        return prod1 <= 0n && prod2 <= 0n\n            ? (prod1 + prod2 / E19) / E19\n            : (prod1 + prod2 / E19 - 1n) / E19 + 1n;\n    }\n\n    static mulUpXpToNpU(a: bigint, b: bigint): bigint {\n        const E19 = BigInt('10000000000000000000');\n        const b1 = b / E19;\n        const b2 = b % E19;\n        const prod1 = a * b1;\n        const prod2 = a * b2;\n        return prod1 <= 0n && prod2 <= 0n\n            ? (prod1 + prod2 / E19) / E19\n            : (prod1 + prod2 / E19 - 1n) / E19 + 1n;\n    }\n\n    static complement(x: bigint): bigint {\n        if (x >= this.ONE || x <= 0n) {\n            return 0n;\n        }\n        return this.ONE - x;\n    }\n}\n","import { GyroPoolMath } from './gyroPoolMath';\nimport { SignedFixedPoint } from './signedFixedPoint';\nimport { _require } from '../utils/math';\n\nexport interface Vector2 {\n    x: bigint;\n    y: bigint;\n}\n\ninterface QParams {\n    a: bigint;\n    b: bigint;\n    c: bigint;\n}\n\nclass MaxBalancesExceededError extends Error {\n    constructor() {\n        super('Max assets exceeded');\n        this.name = 'MaxBalancesExceededError';\n    }\n}\n\nclass MaxInvariantExceededError extends Error {\n    constructor() {\n        super('Max invariant exceeded');\n        this.name = 'MaxInvariantExceededError';\n    }\n}\n\n// Structs as interfaces\nexport interface EclpParams {\n    alpha: bigint;\n    beta: bigint;\n    c: bigint;\n    s: bigint;\n    lambda: bigint;\n}\n\nexport interface DerivedEclpParams {\n    tauAlpha: Vector2;\n    tauBeta: Vector2;\n    u: bigint;\n    v: bigint;\n    w: bigint;\n    z: bigint;\n    dSq: bigint;\n}\n\nexport class GyroECLPMath {\n    static readonly _ONEHALF = BigInt('500000000000000000'); // 0.5e18\n    static readonly _ONE = BigInt('1000000000000000000'); // 1e18\n    static readonly _ONE_XP = BigInt('100000000000000000000000000000000000000'); // 1e38\n\n    // Anti-overflow limits: Params and DerivedParams (static, only needs to be checked on pool creation)\n    static readonly _ROTATION_VECTOR_NORM_ACCURACY = BigInt('1000'); // 1e3 (1e-15 in normal precision)\n    static readonly _MAX_STRETCH_FACTOR = BigInt('100000000000000000000000000'); // 1e26 (1e8 in normal precision)\n    static readonly _DERIVED_TAU_NORM_ACCURACY_XP = BigInt(\n        '100000000000000000000000',\n    ); // 1e23 (1e-15 in extra precision)\n    static readonly _MAX_INV_INVARIANT_DENOMINATOR_XP = BigInt(\n        '10000000000000000000000000000000000000000000',\n    ); // 1e43 (1e5 in extra precision)\n    static readonly _DERIVED_DSQ_NORM_ACCURACY_XP = BigInt(\n        '100000000000000000000000',\n    ); // 1e23 (1e-15 in extra precision)\n\n    // Anti-overflow limits: Dynamic values (checked before operations that use them)\n    static readonly _MAX_BALANCES = BigInt(\n        '100000000000000000000000000000000000',\n    ); // 1e34 (1e16 in normal precision)\n    static readonly _MAX_INVARIANT = BigInt(\n        '3000000000000000000000000000000000000',\n    ); // 3e37 (3e19 in normal precision)\n\n    // Invariant growth limit: non-proportional add cannot cause the invariant to increase by more than this ratio\n    static readonly MIN_INVARIANT_RATIO = BigInt('600000000000000000'); // 60e16 (60%)\n    // Invariant shrink limit: non-proportional remove cannot cause the invariant to decrease by less than this ratio\n    static readonly MAX_INVARIANT_RATIO = BigInt('5000000000000000000'); // 500e16 (500%)\n\n    static validateParams(params: EclpParams): void {\n        _require(\n            0 <= params.s && params.s <= this._ONE,\n            `s must be >= 0 and <= ${this._ONE}`,\n        );\n        _require(\n            0 <= params.c && params.c <= this._ONE,\n            `c must be >= 0 and <= ${this._ONE}`,\n        );\n\n        const sc: Vector2 = { x: params.s, y: params.c };\n        const scnorm2 = this.scalarProd(sc, sc);\n\n        _require(\n            this._ONE - this._ROTATION_VECTOR_NORM_ACCURACY <= scnorm2 &&\n                scnorm2 <= this._ONE + this._ROTATION_VECTOR_NORM_ACCURACY,\n            'RotationVectorNotNormalized()',\n        );\n        _require(\n            0 <= params.lambda && params.lambda <= this._MAX_STRETCH_FACTOR,\n            `lambda must be >= 0 and <= ${this._MAX_STRETCH_FACTOR}`,\n        );\n    }\n\n    static validateDerivedParams(\n        params: EclpParams,\n        derived: DerivedEclpParams,\n    ): void {\n        _require(derived.tauAlpha.y > 0, 'tuaAlpha.y must be > 0');\n        _require(derived.tauBeta.y > 0, 'tauBeta.y must be > 0');\n        _require(\n            derived.tauBeta.x > derived.tauAlpha.x,\n            'tauBeta.x must be > tauAlpha.x',\n        );\n\n        const norm2 = this.scalarProdXp(derived.tauAlpha, derived.tauAlpha);\n\n        _require(\n            this._ONE_XP - this._DERIVED_TAU_NORM_ACCURACY_XP <= norm2 &&\n                norm2 <= this._ONE_XP + this._DERIVED_TAU_NORM_ACCURACY_XP,\n            'RotationVectorNotNormalized()',\n        );\n        _require(derived.u <= this._ONE_XP, `u must be <= ${this._ONE_XP}`);\n        _require(derived.v <= this._ONE_XP, `v must be <= ${this._ONE_XP}`);\n        _require(derived.w <= this._ONE_XP, `w must be <= ${this._ONE_XP}`);\n        _require(derived.z <= this._ONE_XP, `z must be <= ${this._ONE_XP}`);\n\n        _require(\n            this._ONE_XP - this._DERIVED_DSQ_NORM_ACCURACY_XP <= derived.dSq &&\n                derived.dSq <=\n                    this._ONE_XP + this._DERIVED_DSQ_NORM_ACCURACY_XP,\n            'DerivedDsqWrong()',\n        );\n\n        const mulDenominator = SignedFixedPoint.divXpU(\n            this._ONE_XP,\n            this.calcAChiAChiInXp(params, derived) - this._ONE_XP,\n        );\n        _require(\n            mulDenominator <= this._MAX_INV_INVARIANT_DENOMINATOR_XP,\n            `mulDenominator must be <= ${this._MAX_INV_INVARIANT_DENOMINATOR_XP}`,\n        );\n    }\n\n    static scalarProd(t1: Vector2, t2: Vector2): bigint {\n        const xProd = SignedFixedPoint.mulDownMag(t1.x, t2.x);\n        const yProd = SignedFixedPoint.mulDownMag(t1.y, t2.y);\n        return xProd + yProd;\n    }\n\n    static scalarProdXp(t1: Vector2, t2: Vector2): bigint {\n        return (\n            SignedFixedPoint.mulXp(t1.x, t2.x) +\n            SignedFixedPoint.mulXp(t1.y, t2.y)\n        );\n    }\n\n    static mulA(params: EclpParams, tp: Vector2): Vector2 {\n        return {\n            x: SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.mulDownMagU(params.c, tp.x) -\n                    SignedFixedPoint.mulDownMagU(params.s, tp.y),\n                params.lambda,\n            ),\n            y:\n                SignedFixedPoint.mulDownMagU(params.s, tp.x) +\n                SignedFixedPoint.mulDownMagU(params.c, tp.y),\n        };\n    }\n\n    static virtualOffset0(\n        p: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const termXp = SignedFixedPoint.divXpU(d.tauBeta.x, d.dSq);\n        let a: bigint;\n\n        if (d.tauBeta.x > 0n) {\n            a = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(r.x, p.lambda),\n                    p.c,\n                ),\n                termXp,\n            );\n        } else {\n            a = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(r.y, p.lambda),\n                    p.c,\n                ),\n                termXp,\n            );\n        }\n\n        return (\n            a +\n            SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(r.x, p.s),\n                SignedFixedPoint.divXpU(d.tauBeta.y, d.dSq),\n            )\n        );\n    }\n\n    static virtualOffset1(\n        p: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const termXp = SignedFixedPoint.divXpU(d.tauAlpha.x, d.dSq);\n        let b: bigint;\n\n        if (d.tauAlpha.x < 0n) {\n            b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(r.x, p.lambda),\n                    p.s,\n                ),\n                -termXp,\n            );\n        } else {\n            b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(-r.y, p.lambda),\n                    p.s,\n                ),\n                termXp,\n            );\n        }\n\n        return (\n            b +\n            SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(r.x, p.c),\n                SignedFixedPoint.divXpU(d.tauAlpha.y, d.dSq),\n            )\n        );\n    }\n\n    static maxBalances0(\n        p: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const termXp1 = SignedFixedPoint.divXpU(\n            d.tauBeta.x - d.tauAlpha.x,\n            d.dSq,\n        );\n        const termXp2 = SignedFixedPoint.divXpU(\n            d.tauBeta.y - d.tauAlpha.y,\n            d.dSq,\n        );\n\n        const xp = SignedFixedPoint.mulDownXpToNpU(\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(r.y, p.lambda),\n                p.c,\n            ),\n            termXp1,\n        );\n\n        const term2 =\n            termXp2 > 0n\n                ? SignedFixedPoint.mulDownMagU(r.y, p.s)\n                : SignedFixedPoint.mulUpMagU(r.x, p.s);\n\n        return xp + SignedFixedPoint.mulDownXpToNpU(term2, termXp2);\n    }\n\n    static maxBalances1(\n        p: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const termXp1 = SignedFixedPoint.divXpU(\n            d.tauBeta.x - d.tauAlpha.x,\n            d.dSq,\n        );\n        const termXp2 = SignedFixedPoint.divXpU(\n            d.tauAlpha.y - d.tauBeta.y,\n            d.dSq,\n        );\n\n        const yp = SignedFixedPoint.mulDownXpToNpU(\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(r.y, p.lambda),\n                p.s,\n            ),\n            termXp1,\n        );\n\n        const term2 =\n            termXp2 > 0n\n                ? SignedFixedPoint.mulDownMagU(r.y, p.c)\n                : SignedFixedPoint.mulUpMagU(r.x, p.c);\n\n        return yp + SignedFixedPoint.mulDownXpToNpU(term2, termXp2);\n    }\n\n    static calcAtAChi(\n        x: bigint,\n        y: bigint,\n        p: EclpParams,\n        d: DerivedEclpParams,\n    ): bigint {\n        const dSq2 = SignedFixedPoint.mulXpU(d.dSq, d.dSq);\n\n        // (cx - sy) * (w/lambda + z) / lambda\n        //      account for 2 factors of dSq (4 s,c factors)\n        const termXp = SignedFixedPoint.divXpU(\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.divDownMagU(d.w, p.lambda) + d.z,\n                p.lambda,\n            ),\n            dSq2,\n        );\n\n        let val = SignedFixedPoint.mulDownXpToNpU(\n            SignedFixedPoint.mulDownMagU(x, p.c) -\n                SignedFixedPoint.mulDownMagU(y, p.s),\n            termXp,\n        );\n\n        // (x lambda s + y lambda c) * u, note u > 0\n        let termNp =\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(x, p.lambda),\n                p.s,\n            ) +\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(y, p.lambda),\n                p.c,\n            );\n        val =\n            val +\n            SignedFixedPoint.mulDownXpToNpU(\n                termNp,\n                SignedFixedPoint.divXpU(d.u, dSq2),\n            );\n\n        // (sx+cy) * v, note v > 0\n        termNp =\n            SignedFixedPoint.mulDownMagU(x, p.s) +\n            SignedFixedPoint.mulDownMagU(y, p.c);\n        val =\n            val +\n            SignedFixedPoint.mulDownXpToNpU(\n                termNp,\n                SignedFixedPoint.divXpU(d.v, dSq2),\n            );\n        return val;\n    }\n\n    static calcAChiAChiInXp(p: EclpParams, d: DerivedEclpParams): bigint {\n        const dSq3 = SignedFixedPoint.mulXpU(\n            SignedFixedPoint.mulXpU(d.dSq, d.dSq),\n            d.dSq,\n        );\n\n        let val = SignedFixedPoint.mulUpMagU(\n            p.lambda,\n            SignedFixedPoint.divXpU(\n                SignedFixedPoint.mulXpU(2n * d.u, d.v),\n                dSq3,\n            ),\n        );\n\n        val += SignedFixedPoint.mulUpMagU(\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.divXpU(\n                    SignedFixedPoint.mulXpU(d.u + 1n, d.u + 1n),\n                    dSq3,\n                ),\n                p.lambda,\n            ),\n            p.lambda,\n        );\n\n        val += SignedFixedPoint.divXpU(SignedFixedPoint.mulXpU(d.v, d.v), dSq3);\n\n        const termXp = SignedFixedPoint.divUpMagU(d.w, p.lambda) + d.z;\n        val += SignedFixedPoint.divXpU(\n            SignedFixedPoint.mulXpU(termXp, termXp),\n            dSq3,\n        );\n\n        return val;\n    }\n\n    static calculateInvariantWithError(\n        balances: bigint[],\n        params: EclpParams,\n        derived: DerivedEclpParams,\n    ): [bigint, bigint] {\n        const x = balances[0];\n        const y = balances[1];\n\n        if (x + y > this._MAX_BALANCES) {\n            throw new MaxBalancesExceededError();\n        }\n\n        const atAChi = this.calcAtAChi(x, y, params, derived);\n        const invariantResult = this.calcInvariantSqrt(x, y, params, derived);\n        const sqrt = invariantResult[0];\n        let err = invariantResult[1];\n\n        // Note: the minimum non-zero value of sqrt is 1e-9 since the minimum argument is 1e-18\n        if (sqrt > 0) {\n            // err + 1 to account for O(eps_np) term ignored before\n            err = SignedFixedPoint.divUpMagU(err + 1n, 2n * sqrt);\n        } else {\n            // In the false case here, the extra precision error does not magnify, and so the error inside the sqrt is\n            // O(1e-18)\n            // somedayTODO: The true case will almost surely never happen (can it be removed)\n            err = err > 0 ? GyroPoolMath.sqrt(err, 5n) : BigInt('1000000000');\n        }\n        // Calculate the error in the numerator, scale the error by 20 to be sure all possible terms accounted for\n        err =\n            (SignedFixedPoint.mulUpMagU(params.lambda, x + y) / this._ONE_XP +\n                err +\n                1n) *\n            20n;\n\n        const achiachi = this.calcAChiAChiInXp(params, derived);\n        // A chi \\cdot A chi > 1, so round it up to round denominator up.\n        // Denominator uses extra precision, so we do * 1/denominator so we are sure the calculation doesn't overflow.\n        const mulDenominator = SignedFixedPoint.divXpU(\n            this._ONE_XP,\n            achiachi - this._ONE_XP,\n        );\n\n        // As alternative, could do, but could overflow: invariant = (AtAChi.add(sqrt) - err).divXp(denominator);\n        const invariant = SignedFixedPoint.mulDownXpToNpU(\n            atAChi + sqrt - err,\n            mulDenominator,\n        );\n        // Error scales if denominator is small.\n        // NB: This error calculation computes the error in the expression \"numerator / denominator\", but in this code\n        // We actually use the formula \"numerator * (1 / denominator)\" to compute the invariant. This affects this line\n        // and the one below.\n        err = SignedFixedPoint.mulUpXpToNpU(err, mulDenominator);\n        // Account for relative error due to error in the denominator.\n        // Error in denominator is O(epsilon) if lambda<1e11, scale up by 10 to be sure we catch it, and add O(eps).\n        // Error in denominator is lambda^2 * 2e-37 and scales relative to the result / denominator.\n        // Scale by a constant to account for errors in the scaling factor itself and limited compounding.\n        // Calculating lambda^2 without decimals so that the calculation will never overflow, the lost precision isn't\n        // important.\n        err =\n            err +\n            (SignedFixedPoint.mulUpXpToNpU(invariant, mulDenominator) *\n                ((params.lambda * params.lambda) / BigInt('1000000000000000000000000000000000000')) *\n                40n) /\n                this._ONE_XP +\n            1n;\n\n        if (invariant + err > this._MAX_INVARIANT) {\n            throw new MaxInvariantExceededError();\n        }\n\n        return [invariant, err];\n    }\n\n    static calcMinAtxAChiySqPlusAtxSq(\n        x: bigint,\n        y: bigint,\n        p: EclpParams,\n        d: DerivedEclpParams,\n    ): bigint {\n        let termNp =\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(x, x),\n                    p.c,\n                ),\n                p.c,\n            ) +\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(y, y),\n                    p.s,\n                ),\n                p.s,\n            );\n\n        termNp =\n            termNp -\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(x, y),\n                    p.c * 2n,\n                ),\n                p.s,\n            );\n\n        let termXp =\n            SignedFixedPoint.mulXpU(d.u, d.u) +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.mulXpU(d.u * 2n, d.v),\n                p.lambda,\n            ) +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.divDownMagU(\n                    SignedFixedPoint.mulXpU(d.v, d.v),\n                    p.lambda,\n                ),\n                p.lambda,\n            );\n\n        termXp = SignedFixedPoint.divXpU(\n            termXp,\n            SignedFixedPoint.mulXpU(\n                SignedFixedPoint.mulXpU(\n                    SignedFixedPoint.mulXpU(d.dSq, d.dSq),\n                    d.dSq,\n                ),\n                d.dSq,\n            ),\n        );\n\n        let val = SignedFixedPoint.mulDownXpToNpU(-termNp, termXp);\n\n        val =\n            val +\n            SignedFixedPoint.mulDownXpToNpU(\n                SignedFixedPoint.divDownMagU(\n                    SignedFixedPoint.divDownMagU(termNp - 9n, p.lambda),\n                    p.lambda,\n                ),\n                SignedFixedPoint.divXpU(SignedFixedPoint.ONE_XP, d.dSq),\n            );\n\n        return val;\n    }\n\n    static calc2AtxAtyAChixAChiy(\n        x: bigint,\n        y: bigint,\n        p: EclpParams,\n        d: DerivedEclpParams,\n    ): bigint {\n        let termNp = SignedFixedPoint.mulDownMagU(\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(x, x) -\n                    SignedFixedPoint.mulUpMagU(y, y),\n                2n * p.c,\n            ),\n            p.s,\n        );\n\n        const xy = SignedFixedPoint.mulDownMagU(y, 2n * x);\n\n        termNp =\n            termNp +\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(xy, p.c),\n                p.c,\n            ) -\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(xy, p.s),\n                p.s,\n            );\n\n        let termXp =\n            SignedFixedPoint.mulXpU(d.z, d.u) +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.divDownMagU(\n                    SignedFixedPoint.mulXpU(d.w, d.v),\n                    p.lambda,\n                ),\n                p.lambda,\n            );\n\n        termXp =\n            termXp +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.mulXpU(d.w, d.u) +\n                    SignedFixedPoint.mulXpU(d.z, d.v),\n                p.lambda,\n            );\n\n        termXp = SignedFixedPoint.divXpU(\n            termXp,\n            SignedFixedPoint.mulXpU(\n                SignedFixedPoint.mulXpU(\n                    SignedFixedPoint.mulXpU(d.dSq, d.dSq),\n                    d.dSq,\n                ),\n                d.dSq,\n            ),\n        );\n\n        return SignedFixedPoint.mulDownXpToNpU(termNp, termXp);\n    }\n\n    static calcMinAtyAChixSqPlusAtySq(\n        x: bigint,\n        y: bigint,\n        p: EclpParams,\n        d: DerivedEclpParams,\n    ): bigint {\n        let termNp =\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(x, x),\n                    p.s,\n                ),\n                p.s,\n            ) +\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(y, y),\n                    p.c,\n                ),\n                p.c,\n            );\n\n        termNp =\n            termNp +\n            SignedFixedPoint.mulUpMagU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(x, y),\n                    p.s * 2n,\n                ),\n                p.c,\n            );\n\n        let termXp =\n            SignedFixedPoint.mulXpU(d.z, d.z) +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.divDownMagU(\n                    SignedFixedPoint.mulXpU(d.w, d.w),\n                    p.lambda,\n                ),\n                p.lambda,\n            );\n\n        termXp =\n            termXp +\n            SignedFixedPoint.divDownMagU(\n                SignedFixedPoint.mulXpU(2n * d.z, d.w),\n                p.lambda,\n            );\n\n        termXp = SignedFixedPoint.divXpU(\n            termXp,\n            SignedFixedPoint.mulXpU(\n                SignedFixedPoint.mulXpU(\n                    SignedFixedPoint.mulXpU(d.dSq, d.dSq),\n                    d.dSq,\n                ),\n                d.dSq,\n            ),\n        );\n\n        let val = SignedFixedPoint.mulDownXpToNpU(-termNp, termXp);\n\n        val =\n            val +\n            SignedFixedPoint.mulDownXpToNpU(\n                termNp - 9n,\n                SignedFixedPoint.divXpU(SignedFixedPoint.ONE_XP, d.dSq),\n            );\n\n        return val;\n    }\n\n    static calcInvariantSqrt(\n        x: bigint,\n        y: bigint,\n        p: EclpParams,\n        d: DerivedEclpParams,\n    ): [bigint, bigint] {\n        let val =\n            this.calcMinAtxAChiySqPlusAtxSq(x, y, p, d) +\n            this.calc2AtxAtyAChixAChiy(x, y, p, d) +\n            this.calcMinAtyAChixSqPlusAtySq(x, y, p, d);\n\n        const err =\n            (SignedFixedPoint.mulUpMagU(x, x) +\n                SignedFixedPoint.mulUpMagU(y, y)) /\n            BigInt('1000000000000000000000000000000000000000'); // 1e38\n\n        val = val > 0n ? GyroPoolMath.sqrt(val, 5n) : 0n;\n\n        return [val, err];\n    }\n\n    static calcSpotPrice0in1(\n        balances: bigint[],\n        params: EclpParams,\n        derived: DerivedEclpParams,\n        invariant: bigint,\n    ): bigint {\n        const r: Vector2 = { x: invariant, y: invariant };\n        const ab: Vector2 = {\n            x: this.virtualOffset0(params, derived, r),\n            y: this.virtualOffset1(params, derived, r),\n        };\n        const vec: Vector2 = {\n            x: balances[0] - ab.x,\n            y: balances[1] - ab.y,\n        };\n\n        const transformedVec = this.mulA(params, vec);\n        const pc: Vector2 = {\n            x: SignedFixedPoint.divDownMagU(transformedVec.x, transformedVec.y),\n            y: this._ONE,\n        };\n\n        const pgx = this.scalarProd(\n            pc,\n            this.mulA(params, { x: this._ONE, y: 0n }),\n        );\n        return SignedFixedPoint.divDownMag(\n            pgx,\n            this.scalarProd(pc, this.mulA(params, { x: 0n, y: this._ONE })),\n        );\n    }\n\n    static checkAssetBounds(\n        params: EclpParams,\n        derived: DerivedEclpParams,\n        invariant: Vector2,\n        newBal: bigint,\n        assetIndex: number,\n    ): void {\n        if (assetIndex === 0) {\n            const xPlus = this.maxBalances0(params, derived, invariant);\n            if (newBal > this._MAX_BALANCES || newBal > xPlus) {\n                throw new Error('Asset bounds exceeded');\n            }\n        } else {\n            const yPlus = this.maxBalances1(params, derived, invariant);\n            if (newBal > this._MAX_BALANCES || newBal > yPlus) {\n                throw new Error('Asset bounds exceeded');\n            }\n        }\n    }\n\n    static calcOutGivenIn(\n        balances: bigint[],\n        amountIn: bigint,\n        tokenInIsToken0: boolean,\n        params: EclpParams,\n        derived: DerivedEclpParams,\n        invariant: Vector2,\n    ): bigint {\n        const [ixIn, ixOut, calcGiven] = tokenInIsToken0\n            ? [0, 1, this.calcYGivenX]\n            : [1, 0, this.calcXGivenY];\n\n        const balInNew = balances[ixIn] + amountIn;\n        this.checkAssetBounds(params, derived, invariant, balInNew, ixIn);\n        const balOutNew = calcGiven.call(\n            this,\n            balInNew,\n            params,\n            derived,\n            invariant,\n        );\n        return balances[ixOut] - balOutNew;\n    }\n\n    static calcInGivenOut(\n        balances: bigint[],\n        amountOut: bigint,\n        tokenInIsToken0: boolean,\n        params: EclpParams,\n        derived: DerivedEclpParams,\n        invariant: Vector2,\n    ): bigint {\n        const [ixIn, ixOut, calcGiven] = tokenInIsToken0\n            ? [0, 1, this.calcXGivenY] // Note: reversed compared to calcOutGivenIn\n            : [1, 0, this.calcYGivenX]; // Note: reversed compared to calcOutGivenIn\n\n        if (amountOut > balances[ixOut]) {\n            throw new Error('Asset bounds exceeded');\n        }\n        const balOutNew = balances[ixOut] - amountOut;\n        const balInNew = calcGiven.call(\n            this,\n            balOutNew,\n            params,\n            derived,\n            invariant,\n        );\n        this.checkAssetBounds(params, derived, invariant, balInNew, ixIn);\n        return balInNew - balances[ixIn];\n    }\n\n    static solveQuadraticSwap(\n        lambda: bigint,\n        x: bigint,\n        s: bigint,\n        c: bigint,\n        r: Vector2,\n        ab: Vector2,\n        tauBeta: Vector2,\n        dSq: bigint,\n    ): bigint {\n        const lamBar: Vector2 = {\n            x:\n                SignedFixedPoint.ONE_XP -\n                SignedFixedPoint.divDownMagU(\n                    SignedFixedPoint.divDownMagU(\n                        SignedFixedPoint.ONE_XP,\n                        lambda,\n                    ),\n                    lambda,\n                ),\n            y:\n                SignedFixedPoint.ONE_XP -\n                SignedFixedPoint.divUpMagU(\n                    SignedFixedPoint.divUpMagU(SignedFixedPoint.ONE_XP, lambda),\n                    lambda,\n                ),\n        };\n\n        const q: QParams = { a: 0n, b: 0n, c: 0n };\n        const xp = x - ab.x;\n\n        if (xp > 0n) {\n            q.b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(-xp, s),\n                    c,\n                ),\n                SignedFixedPoint.divXpU(lamBar.y, dSq),\n            );\n        } else {\n            q.b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(-xp, s),\n                    c,\n                ),\n                SignedFixedPoint.divXpU(lamBar.x, dSq) + 1n,\n            );\n        }\n\n        const sTerm: Vector2 = {\n            x: SignedFixedPoint.divXpU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(lamBar.y, s),\n                    s,\n                ),\n                dSq,\n            ),\n            y:\n                SignedFixedPoint.divXpU(\n                    SignedFixedPoint.mulUpMagU(\n                        SignedFixedPoint.mulUpMagU(lamBar.x, s),\n                        s,\n                    ),\n                    dSq + 1n,\n                ) + 1n,\n        };\n\n        sTerm.x = SignedFixedPoint.ONE_XP - sTerm.x;\n        sTerm.y = SignedFixedPoint.ONE_XP - sTerm.y;\n\n        q.c = -this.calcXpXpDivLambdaLambda(x, r, lambda, s, c, tauBeta, dSq);\n        q.c =\n            q.c +\n            SignedFixedPoint.mulDownXpToNpU(\n                SignedFixedPoint.mulDownMagU(r.y, r.y),\n                sTerm.y,\n            );\n\n        q.c = q.c > 0n ? GyroPoolMath.sqrt(q.c, 5n) : 0n;\n\n        if (q.b - q.c > 0n) {\n            q.a = SignedFixedPoint.mulUpXpToNpU(\n                q.b - q.c,\n                SignedFixedPoint.divXpU(SignedFixedPoint.ONE_XP, sTerm.y) + 1n,\n            );\n        } else {\n            q.a = SignedFixedPoint.mulUpXpToNpU(\n                q.b - q.c,\n                SignedFixedPoint.divXpU(SignedFixedPoint.ONE_XP, sTerm.x),\n            );\n        }\n\n        return q.a + ab.y;\n    }\n\n    static calcXpXpDivLambdaLambda(\n        x: bigint,\n        r: Vector2,\n        lambda: bigint,\n        s: bigint,\n        c: bigint,\n        tauBeta: Vector2,\n        dSq: bigint,\n    ): bigint {\n        const sqVars: Vector2 = {\n            x: SignedFixedPoint.mulXpU(dSq, dSq),\n            y: SignedFixedPoint.mulUpMagU(r.x, r.x),\n        };\n\n        const q: QParams = { a: 0n, b: 0n, c: 0n };\n        const termXp = SignedFixedPoint.divXpU(\n            SignedFixedPoint.mulXpU(tauBeta.x, tauBeta.y),\n            sqVars.x,\n        );\n\n        if (termXp > 0n) {\n            q.a = SignedFixedPoint.mulUpMagU(sqVars.y, 2n * s);\n            q.a = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(q.a, c),\n                termXp + 7n,\n            );\n        } else {\n            q.a = SignedFixedPoint.mulDownMagU(r.y, r.y);\n            q.a = SignedFixedPoint.mulDownMagU(q.a, 2n * s);\n            q.a = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulDownMagU(q.a, c),\n                termXp,\n            );\n        }\n\n        if (tauBeta.x < 0n) {\n            q.b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulUpMagU(\n                    SignedFixedPoint.mulUpMagU(r.x, x),\n                    2n * c,\n                ),\n                -SignedFixedPoint.divXpU(tauBeta.x, dSq) + 3n,\n            );\n        } else {\n            q.b = SignedFixedPoint.mulUpXpToNpU(\n                SignedFixedPoint.mulDownMagU(\n                    SignedFixedPoint.mulDownMagU(-r.y, x),\n                    2n * c,\n                ),\n                SignedFixedPoint.divXpU(tauBeta.x, dSq),\n            );\n        }\n        q.a = q.a + q.b;\n\n        let termXp2 =\n            SignedFixedPoint.divXpU(\n                SignedFixedPoint.mulXpU(tauBeta.y, tauBeta.y),\n                sqVars.x,\n            ) + 7n;\n\n        q.b = SignedFixedPoint.mulUpMagU(sqVars.y, s);\n        q.b = SignedFixedPoint.mulUpXpToNpU(\n            SignedFixedPoint.mulUpMagU(q.b, s),\n            termXp2,\n        );\n\n        q.c = SignedFixedPoint.mulUpXpToNpU(\n            SignedFixedPoint.mulDownMagU(\n                SignedFixedPoint.mulDownMagU(-r.y, x),\n                2n * s,\n            ),\n            SignedFixedPoint.divXpU(tauBeta.y, dSq),\n        );\n\n        q.b = q.b + q.c + SignedFixedPoint.mulUpMagU(x, x);\n        q.b =\n            q.b > 0n\n                ? SignedFixedPoint.divUpMagU(q.b, lambda)\n                : SignedFixedPoint.divDownMagU(q.b, lambda);\n\n        q.a = q.a + q.b;\n        q.a =\n            q.a > 0n\n                ? SignedFixedPoint.divUpMagU(q.a, lambda)\n                : SignedFixedPoint.divDownMagU(q.a, lambda);\n\n        termXp2 =\n            SignedFixedPoint.divXpU(\n                SignedFixedPoint.mulXpU(tauBeta.x, tauBeta.x),\n                sqVars.x,\n            ) + 7n;\n        const val = SignedFixedPoint.mulUpMagU(\n            SignedFixedPoint.mulUpMagU(sqVars.y, c),\n            c,\n        );\n        return SignedFixedPoint.mulUpXpToNpU(val, termXp2) + q.a;\n    }\n\n    static calcYGivenX(\n        x: bigint,\n        params: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const ab: Vector2 = {\n            x: this.virtualOffset0(params, d, r),\n            y: this.virtualOffset1(params, d, r),\n        };\n        return this.solveQuadraticSwap(\n            params.lambda,\n            x,\n            params.s,\n            params.c,\n            r,\n            ab,\n            d.tauBeta,\n            d.dSq,\n        );\n    }\n\n    static calcXGivenY(\n        y: bigint,\n        params: EclpParams,\n        d: DerivedEclpParams,\n        r: Vector2,\n    ): bigint {\n        const ba: Vector2 = {\n            x: this.virtualOffset1(params, d, r),\n            y: this.virtualOffset0(params, d, r),\n        };\n        return this.solveQuadraticSwap(\n            params.lambda,\n            y,\n            params.c,\n            params.s,\n            r,\n            ba,\n            { x: -d.tauAlpha.x, y: d.tauAlpha.y },\n            d.dSq,\n        );\n    }\n}\n","import { MAX_UINT256, MAX_BALANCE } from '../constants';\nimport {\n    MaxSingleTokenRemoveParams,\n    MaxSwapParams,\n    type PoolBase,\n    Rounding,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport { toRawUndoRateRoundDown } from '../vault/utils';\nimport { MathSol } from '../utils/math';\nimport {\n    DerivedEclpParams,\n    EclpParams,\n    GyroECLPMath,\n    Vector2,\n} from './gyroECLPMath';\nimport { GyroECLPImmutable } from './gyroECLPData';\n\ntype PoolParams = {\n    eclpParams: EclpParams;\n    derivedECLPParams: DerivedEclpParams;\n};\n\nexport class GyroECLP implements PoolBase {\n    public poolParams: PoolParams;\n\n    constructor(poolState: GyroECLPImmutable) {\n        this.poolParams = {\n            eclpParams: {\n                alpha: poolState.paramsAlpha,\n                beta: poolState.paramsBeta,\n                c: poolState.paramsC,\n                s: poolState.paramsS,\n                lambda: poolState.paramsLambda,\n            },\n            derivedECLPParams: {\n                tauAlpha: {\n                    x: poolState.tauAlphaX,\n                    y: poolState.tauAlphaY,\n                },\n                tauBeta: {\n                    x: poolState.tauBetaX,\n                    y: poolState.tauBetaY,\n                },\n                u: poolState.u,\n                v: poolState.v,\n                w: poolState.w,\n                z: poolState.z,\n                dSq: poolState.dSq,\n            },\n        };\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        return GyroECLPMath.MAX_INVARIANT_RATIO;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        return GyroECLPMath.MIN_INVARIANT_RATIO;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const {\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            tokenRates,\n            scalingFactors,\n            swapKind,\n        } = maxSwapParams;\n        if (swapKind === SwapKind.GivenIn) {\n            // MAX_BALANCE comes from SC limit and is max pool can hold\n            const diff = MAX_BALANCE - balancesLiveScaled18[indexIn];\n            // Scale to token in (and remove rate)\n            return toRawUndoRateRoundDown(\n                diff,\n                scalingFactors[indexIn],\n                tokenRates[indexIn],\n            );\n        }\n        // 99% of token out balance\n        const max = MathSol.mulDownFixed(\n            990000000000000000n,\n            balancesLiveScaled18[indexOut],\n        );\n        // Scale to token out\n        return toRawUndoRateRoundDown(\n            max,\n            scalingFactors[indexOut],\n            tokenRates[indexOut],\n        );\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint {\n        const {\n            isExactIn,\n            totalSupply,\n            tokenOutBalance,\n            tokenOutScalingFactor,\n            tokenOutRate,\n        } = maxRemoveParams;\n        return this.getMaxSwapAmount({\n            swapKind: isExactIn ? SwapKind.GivenIn : SwapKind.GivenOut,\n            balancesLiveScaled18: [totalSupply, tokenOutBalance],\n            tokenRates: [1000000000000000000n, tokenOutRate],\n            scalingFactors: [1000000000000000000n, tokenOutScalingFactor],\n            indexIn: 0,\n            indexOut: 1,\n        });\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18: balancesScaled18,\n            indexIn,\n            amountGivenScaled18,\n        } = swapParams;\n\n        const tokenInIsToken0 = indexIn === 0;\n\n        const { eclpParams, derivedECLPParams } = this.poolParams;\n\n        const [currentInvariant, invErr] =\n            GyroECLPMath.calculateInvariantWithError(\n                balancesScaled18,\n                eclpParams,\n                derivedECLPParams,\n            );\n        // invariant = overestimate in x-component, underestimate in y-component\n        // No overflow in `+` due to constraints to the different values enforced in GyroECLPMath.\n        const invariant: Vector2 = {\n            x: currentInvariant + 2n * invErr,\n            y: currentInvariant,\n        };\n\n        if (swapKind === SwapKind.GivenIn) {\n            const amountOutScaled18 = GyroECLPMath.calcOutGivenIn(\n                balancesScaled18,\n                amountGivenScaled18,\n                tokenInIsToken0,\n                eclpParams,\n                derivedECLPParams,\n                invariant,\n            );\n\n            return amountOutScaled18;\n        }\n\n        const amountInScaled18 = GyroECLPMath.calcInGivenOut(\n            balancesScaled18,\n            amountGivenScaled18,\n            tokenInIsToken0,\n            eclpParams,\n            derivedECLPParams,\n            invariant,\n        );\n\n        return amountInScaled18;\n    }\n\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint {\n        const { eclpParams, derivedECLPParams } = this.poolParams;\n        const [currentInvariant, invErr] =\n            GyroECLPMath.calculateInvariantWithError(\n                balancesLiveScaled18,\n                eclpParams,\n                derivedECLPParams,\n            );\n\n        if (rounding == Rounding.ROUND_DOWN) {\n            return currentInvariant - invErr;\n        } else {\n            return currentInvariant + invErr;\n        }\n    }\n\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint {\n        const { eclpParams, derivedECLPParams } = this.poolParams;\n\n        const [currentInvariant, invErr] =\n            GyroECLPMath.calculateInvariantWithError(\n                balancesLiveScaled18,\n                eclpParams,\n                derivedECLPParams,\n            );\n\n        // The invariant vector contains the rounded up and rounded down invariant. Both are needed when computing\n        // the virtual offsets. Depending on tauAlpha and tauBeta values, we want to use the invariant rounded up\n        // or rounded down to make sure we're conservative in the output.\n        const invariant: Vector2 = {\n            x: MathSol.mulUpFixed(currentInvariant + invErr, invariantRatio),\n            y: MathSol.mulUpFixed(currentInvariant - invErr, invariantRatio),\n        };\n\n        // Edge case check. Should never happen except for insane tokens. If this is hit, actually adding the\n        // tokens would lead to a revert or (if it went through) a deadlock downstream, so we catch it here.\n        if (invariant.x > GyroECLPMath._MAX_INVARIANT)\n            throw Error(`GyroECLPMath.MaxInvariantExceeded`);\n\n        if (tokenInIndex === 0) {\n            return GyroECLPMath.calcXGivenY(\n                balancesLiveScaled18[1],\n                eclpParams,\n                derivedECLPParams,\n                invariant,\n            );\n        } else {\n            return GyroECLPMath.calcYGivenX(\n                balancesLiveScaled18[0],\n                eclpParams,\n                derivedECLPParams,\n                invariant,\n            );\n        }\n    }\n}\n","/**\n * Computes the integer square root of a number using Newton's method\n * Ported from OpenZeppelin's Solidity library to TypeScript\n * @param a The input number (must be a non-negative integer)\n * @returns The integer square root of a\n */\nexport function sqrt(a: bigint): bigint {\n    // Handle edge cases when a is 0 or 1\n    if (a <= 1n) {\n        return a;\n    }\n\n    // Find an initial approximation using bit manipulation\n    // This approximation is close to 2^(log2(a)/2)\n    let aa = a;\n    let xn = 1n;\n\n    if (aa >= 1n << 128n) {\n        aa >>= 128n;\n        xn <<= 64n;\n    }\n    if (aa >= 1n << 64n) {\n        aa >>= 64n;\n        xn <<= 32n;\n    }\n    if (aa >= 1n << 32n) {\n        aa >>= 32n;\n        xn <<= 16n;\n    }\n    if (aa >= 1n << 16n) {\n        aa >>= 16n;\n        xn <<= 8n;\n    }\n    if (aa >= 1n << 8n) {\n        aa >>= 8n;\n        xn <<= 4n;\n    }\n    if (aa >= 1n << 4n) {\n        aa >>= 4n;\n        xn <<= 2n;\n    }\n    if (aa >= 1n << 2n) {\n        xn <<= 1n;\n    }\n\n    // Refine the initial approximation\n    xn = (3n * xn) >> 1n;\n\n    // Apply Newton's method iterations\n    // Each iteration approximately doubles the number of correct bits\n    xn = (xn + a / xn) >> 1n;\n    xn = (xn + a / xn) >> 1n;\n    xn = (xn + a / xn) >> 1n;\n    xn = (xn + a / xn) >> 1n;\n    xn = (xn + a / xn) >> 1n;\n    xn = (xn + a / xn) >> 1n;\n\n    // Final adjustment: if xn > sqrt(a), decrement by 1\n    return xn - (xn > a / xn ? 1n : 0n);\n}\n","import { FixedPointFunction, MathSol, WAD } from '../utils/math';\nimport { sqrt } from '../utils/ozMath';\nimport { Rounding } from '../vault/types';\n\ntype PriceRatioState = {\n    priceRatioUpdateStartTime: bigint;\n    priceRatioUpdateEndTime: bigint;\n    startFourthRootPriceRatio: bigint;\n    endFourthRootPriceRatio: bigint;\n};\n\nconst a = 0;\nconst b = 1;\n\nexport function computeCurrentVirtualBalances(\n    currentTimestamp: bigint,\n    balancesScaled18: bigint[],\n    lastVirtualBalanceA: bigint,\n    lastVirtualBalanceB: bigint,\n    dailyPriceShiftBase: bigint,\n    lastTimestamp: bigint,\n    centerednessMargin: bigint,\n    priceRatioState: PriceRatioState,\n): {\n    currentVirtualBalanceA: bigint;\n    currentVirtualBalanceB: bigint;\n    changed: boolean;\n} {\n    if (lastTimestamp === currentTimestamp) {\n        return {\n            currentVirtualBalanceA: lastVirtualBalanceA,\n            currentVirtualBalanceB: lastVirtualBalanceB,\n            changed: false,\n        };\n    }\n\n    let currentVirtualBalanceA = lastVirtualBalanceA;\n    let currentVirtualBalanceB = lastVirtualBalanceB;\n\n    const currentFourthRootPriceRatio = computeFourthRootPriceRatio(\n        currentTimestamp,\n        priceRatioState.startFourthRootPriceRatio,\n        priceRatioState.endFourthRootPriceRatio,\n        priceRatioState.priceRatioUpdateStartTime,\n        priceRatioState.priceRatioUpdateEndTime,\n    );\n\n    let changed = false;\n\n    // If the price ratio is updating, shrink/expand the price interval by recalculating the virtual balances.\n    if (\n        currentTimestamp > priceRatioState.priceRatioUpdateStartTime &&\n        lastTimestamp < priceRatioState.priceRatioUpdateEndTime\n    ) {\n        ({\n            virtualBalanceA: currentVirtualBalanceA,\n            virtualBalanceB: currentVirtualBalanceB,\n        } = computeVirtualBalancesUpdatingPriceRatio(\n            currentFourthRootPriceRatio,\n            balancesScaled18,\n            lastVirtualBalanceA,\n            lastVirtualBalanceB,\n        ));\n\n        changed = true;\n    }\n\n    const { poolCenteredness: centeredness, isPoolAboveCenter } =\n        computeCenteredness(\n            balancesScaled18,\n            currentVirtualBalanceA,\n            currentVirtualBalanceB,\n        );\n\n    // If the pool is outside the target range, track the market price by moving the price interval.\n    if (centeredness < centerednessMargin) {\n        [currentVirtualBalanceA, currentVirtualBalanceB] =\n            computeVirtualBalancesUpdatingPriceRange(\n                balancesScaled18,\n                currentVirtualBalanceA,\n                currentVirtualBalanceB,\n                isPoolAboveCenter,\n                dailyPriceShiftBase,\n                currentTimestamp,\n                lastTimestamp,\n            );\n\n        changed = true;\n    }\n\n    return {\n        currentVirtualBalanceA,\n        currentVirtualBalanceB,\n        changed,\n    };\n}\n\n/**\n * @notice Compute the virtual balances of the pool when the price ratio is updating.\n * @dev This function uses a Bhaskara formula to shrink/expand the price interval by recalculating the virtual\n * balances. It'll keep the pool centeredness constant, and track the desired price ratio. To derive this formula,\n * we need to solve the following simultaneous equations:\n *\n * 1. centeredness = (Ra * Vb) / (Rb * Va)\n * 2. PriceRatio = invariant^2/(Va * Vb)^2 (maxPrice / minPrice)\n * 3. invariant = (Va + Ra) * (Vb + Rb)\n *\n * Substitute [3] in [2]. Then, isolate one of the V's. Finally, replace the isolated V in [1]. We get a quadratic\n * equation that will be solved in this function.\n *\n * @param currentFourthRootPriceRatio The current fourth root of the price ratio of the pool\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param lastVirtualBalanceA The last virtual balance of token A\n * @param lastVirtualBalanceB The last virtual balance of token B\n * @return virtualBalanceA The virtual balance of token A\n * @return virtualBalanceB The virtual balance of token B\n */\nfunction computeVirtualBalancesUpdatingPriceRatio(\n    currentFourthRootPriceRatio: bigint,\n    balancesScaled18: bigint[],\n    lastVirtualBalanceA: bigint,\n    lastVirtualBalanceB: bigint,\n): { virtualBalanceA: bigint; virtualBalanceB: bigint } {\n    // Compute the current pool centeredness, which will remain constant.\n    const { poolCenteredness, isPoolAboveCenter } = computeCenteredness(\n        balancesScaled18,\n        lastVirtualBalanceA,\n        lastVirtualBalanceB,\n    );\n\n    // The overvalued token is the one with a lower token balance (therefore, rarer and more valuable).\n    const {\n        balanceTokenUndervalued,\n        lastVirtualBalanceUndervalued,\n        lastVirtualBalanceOvervalued,\n    } = isPoolAboveCenter\n        ? {\n              balanceTokenUndervalued: balancesScaled18[a],\n              lastVirtualBalanceUndervalued: lastVirtualBalanceA,\n              lastVirtualBalanceOvervalued: lastVirtualBalanceB,\n          }\n        : {\n              balanceTokenUndervalued: balancesScaled18[b],\n              lastVirtualBalanceUndervalued: lastVirtualBalanceB,\n              lastVirtualBalanceOvervalued: lastVirtualBalanceA,\n          };\n\n    // The original formula was a quadratic equation, with terms:\n    // a = Q0 - 1\n    // b = - Ru (1 + C)\n    // c = - Ru^2 C\n    // where Q0 is the square root of the price ratio, Ru is the undervalued token balance, and C is the\n    // centeredness. Applying Bhaskara, we'd have: Vu = (-b + sqrt(b^2 - 4ac)) / 2a.\n    // The Bhaskara above can be simplified by replacing a, b and c with the terms above, which leads to:\n    // Vu = Ru(1 + C + sqrt(1 + C (C + 4 Q0 - 2))) / 2(Q0 - 1)\n    const sqrtPriceRatio = MathSol.mulDownFixed(\n        currentFourthRootPriceRatio,\n        currentFourthRootPriceRatio,\n    );\n\n    // Using FixedPoint math as little as possible to improve the precision of the result.\n    // Note: The input of Math.sqrt must be a 36-decimal number, so that the final result is 18 decimals.\n    const virtualBalanceUndervalued =\n        (balanceTokenUndervalued *\n            (WAD +\n                poolCenteredness +\n                sqrt(\n                    poolCenteredness *\n                        (poolCenteredness +\n                            4n * sqrtPriceRatio -\n                            2000000000000000000n) +\n                        1000000000000000000000000000000000000n,\n                ))) /\n        (2n * (sqrtPriceRatio - WAD));\n\n    const virtualBalanceOvervalued =\n        (virtualBalanceUndervalued * lastVirtualBalanceOvervalued) /\n        lastVirtualBalanceUndervalued;\n\n    const { virtualBalanceA, virtualBalanceB } = isPoolAboveCenter\n        ? {\n              virtualBalanceA: virtualBalanceUndervalued,\n              virtualBalanceB: virtualBalanceOvervalued,\n          }\n        : {\n              virtualBalanceA: virtualBalanceOvervalued,\n              virtualBalanceB: virtualBalanceUndervalued,\n          };\n\n    return { virtualBalanceA, virtualBalanceB };\n}\n\nfunction computeVirtualBalancesUpdatingPriceRange(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    isPoolAboveCenter: boolean,\n    dailyPriceShiftBase: bigint,\n    currentTimestamp: bigint,\n    lastTimestamp: bigint,\n): [bigint, bigint] {\n    const sqrtPriceRatio = sqrt(\n        computePriceRatio(balancesScaled18, virtualBalanceA, virtualBalanceB) *\n            WAD,\n    );\n\n    // // The overvalued token is the one with a lower token balance (therefore, rarer and more valuable).\n    const [balancesScaledUndervalued, balancesScaledOvervalued] =\n        isPoolAboveCenter\n            ? [balancesScaled18[0], balancesScaled18[1]]\n            : [balancesScaled18[1], balancesScaled18[0]];\n    let [virtualBalanceUndervalued, virtualBalanceOvervalued] =\n        isPoolAboveCenter\n            ? [virtualBalanceA, virtualBalanceB]\n            : [virtualBalanceB, virtualBalanceA];\n\n    // Vb = Vb * (1 - tau)^(T_curr - T_last)\n    // Vb = Vb * (dailyPriceShiftBase)^(T_curr - T_last)\n    virtualBalanceOvervalued = MathSol.mulDownFixed(\n        virtualBalanceOvervalued,\n        MathSol.powDownFixed(\n            dailyPriceShiftBase,\n            (currentTimestamp - lastTimestamp) * WAD,\n        ),\n    );\n    // // Va = (Ra * (Vb + Rb)) / (((priceRatio - 1) * Vb) - Rb)\n    virtualBalanceUndervalued =\n        (balancesScaledUndervalued *\n            (virtualBalanceOvervalued + balancesScaledOvervalued)) /\n        (MathSol.mulDownFixed(sqrtPriceRatio - WAD, virtualBalanceOvervalued) -\n            balancesScaledOvervalued);\n\n    return isPoolAboveCenter\n        ? [virtualBalanceUndervalued, virtualBalanceOvervalued]\n        : [virtualBalanceOvervalued, virtualBalanceUndervalued];\n}\n\n/**\n * @notice Compute the price ratio of the pool by dividing the maximum price by the minimum price.\n * @dev The price ratio is calculated as maxPrice/minPrice, where maxPrice and minPrice are obtained\n * from computePriceRange.\n *\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA Virtual balance of token A\n * @param virtualBalanceB Virtual balance of token B\n * @return priceRatio The ratio between the maximum and minimum prices of the pool\n */\nfunction computePriceRatio(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): bigint {\n    const { minPrice, maxPrice } = computePriceRange(\n        balancesScaled18,\n        virtualBalanceA,\n        virtualBalanceB,\n    );\n\n    return MathSol.divUpFixed(maxPrice, minPrice);\n}\n\n/**\n * @notice Compute the minimum and maximum prices for the pool based on virtual balances and current invariant.\n * @dev The minimum price is calculated as Vb^2/invariant, where Vb is the virtual balance of token B.\n * The maximum price is calculated as invariant/Va^2, where Va is the virtual balance of token A.\n * These calculations are derived from the invariant equation: invariant = (Ra + Va)(Rb + Vb),\n * where Ra and Rb are the real balances of tokens A and B respectively.\n *\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA Virtual balance of token A\n * @param virtualBalanceB Virtual balance of token B\n * @return minPrice The minimum price of token A in terms of token B\n * @return maxPrice The maximum price of token A in terms of token B\n */\nfunction computePriceRange(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): { minPrice: bigint; maxPrice: bigint } {\n    const currentInvariant = computeInvariant(\n        balancesScaled18,\n        virtualBalanceA,\n        virtualBalanceB,\n        Rounding.ROUND_DOWN,\n    );\n\n    // P_min(a) = Vb / (Va + Ra_max)\n    // We don't have Ra_max, but: invariant=(Ra_max + Va)(Vb)\n    // Then, (Va + Ra_max) = invariant/Vb, and:\n    // P_min(a) = Vb^2 / invariant\n    const minPrice = (virtualBalanceB * virtualBalanceB) / currentInvariant;\n\n    // Similarly, P_max(a) = (Rb_max + Vb)/Va\n    // We don't have Rb_max, but: invariant=(Rb_max + Vb)(Va)\n    // Then, (Rb_max + Vb) = invariant/Va, and:\n    // P_max(a) = invariant / Va^2\n    const maxPrice = MathSol.divDownFixed(\n        currentInvariant,\n        MathSol.mulDownFixed(virtualBalanceA, virtualBalanceA),\n    );\n\n    return { minPrice, maxPrice };\n}\n\nfunction computeFourthRootPriceRatio(\n    currentTime: bigint,\n    startFourthRootPriceRatio: bigint,\n    endFourthRootPriceRatio: bigint,\n    priceRatioUpdateStartTime: bigint,\n    priceRatioUpdateEndTime: bigint,\n): bigint {\n    // if start and end time are the same, return end value.\n    if (currentTime >= priceRatioUpdateEndTime) {\n        return endFourthRootPriceRatio;\n    } else if (currentTime <= priceRatioUpdateStartTime) {\n        return startFourthRootPriceRatio;\n    }\n\n    const exponent = MathSol.divDownFixed(\n        currentTime - priceRatioUpdateStartTime,\n        priceRatioUpdateEndTime - priceRatioUpdateStartTime,\n    );\n\n    const currentFourthRootPriceRatio = MathSol.mulDownFixed(\n        startFourthRootPriceRatio,\n        MathSol.powDownFixed(\n            MathSol.divDownFixed(\n                endFourthRootPriceRatio,\n                startFourthRootPriceRatio,\n            ),\n            exponent,\n        ),\n    );\n\n    // Since we're rounding current fourth root price ratio down, we only need to check the lower boundary.\n    const minimumFourthRootPriceRatio = MathSol.min(\n        startFourthRootPriceRatio,\n        endFourthRootPriceRatio,\n    );\n    return MathSol.max(\n        minimumFourthRootPriceRatio,\n        currentFourthRootPriceRatio,\n    );\n}\n\nfunction computeCenteredness(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): { poolCenteredness: bigint; isPoolAboveCenter: boolean } {\n    if (balancesScaled18[a] === 0n) {\n        // Also return false if both are 0 to be consistent with the logic below.\n        return { poolCenteredness: 0n, isPoolAboveCenter: false };\n    } else if (balancesScaled18[b] === 0n) {\n        return { poolCenteredness: 0n, isPoolAboveCenter: true };\n    }\n\n    const numerator = balancesScaled18[a] * virtualBalanceB;\n    const denominator = virtualBalanceA * balancesScaled18[b];\n\n    let poolCenteredness: bigint;\n    let isPoolAboveCenter: boolean;\n    // The centeredness is defined between 0 and 1. If the numerator is greater than the denominator, we compute\n    // the inverse ratio.\n    if (numerator <= denominator) {\n        poolCenteredness = MathSol.divDownFixed(numerator, denominator);\n        isPoolAboveCenter = false;\n    } else {\n        poolCenteredness = MathSol.divDownFixed(denominator, numerator);\n        isPoolAboveCenter = true;\n    }\n\n    return { poolCenteredness, isPoolAboveCenter };\n}\n\nfunction computeInvariant(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    rounding: Rounding,\n): bigint {\n    const _mulUpOrDown: FixedPointFunction =\n        rounding === Rounding.ROUND_DOWN\n            ? MathSol.mulDownFixed\n            : MathSol.mulUpFixed;\n\n    return _mulUpOrDown(\n        balancesScaled18[0] + virtualBalanceA,\n        balancesScaled18[1] + virtualBalanceB,\n    );\n}\n\n/**\n * @notice Compute the `amountOut` of tokenOut in a swap, given the current balances and virtual balances.\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA The last virtual balance of token A\n * @param virtualBalanceB The last virtual balance of token B\n * @param tokenInIndex Index of the token being swapped in\n * @param tokenOutIndex Index of the token being swapped out\n * @param amountInScaled18 The exact amount of `tokenIn` (i.e., the amount given in an ExactIn swap)\n * @return amountOutScaled18 The calculated amount of `tokenOut` returned in an ExactIn swap\n */\nexport function computeOutGivenIn(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    tokenInIndex: number,\n    tokenOutIndex: number,\n    amountInScaled18: bigint,\n): bigint {\n    // `amountOutScaled18 = currentTotalTokenOutPoolBalance - newTotalTokenOutPoolBalance`,\n    // where `currentTotalTokenOutPoolBalance = balancesScaled18[tokenOutIndex] + virtualBalanceTokenOut`\n    // and `newTotalTokenOutPoolBalance = invariant / (currentTotalTokenInPoolBalance + amountInScaled18)`.\n    // In other words,\n    // +--------------------------------------------------+\n    // |                         L                        |\n    // | Ao = Bo + Vo - ---------------------             |\n    // |                   (Bi + Vi + Ai)                 |\n    // +--------------------------------------------------+\n    // Simplify by:\n    // - replacing `L = (Bo + Vo) (Bi + Vi)`, and\n    // - multiplying `(Bo + Vo)` by `(Bi + Vi + Ai) / (Bi + Vi + Ai)`:\n    // +--------------------------------------------------+\n    // |              (Bo + Vo) Ai                        |\n    // | Ao = ------------------------------              |\n    // |             (Bi + Vi + Ai)                       |\n    // +--------------------------------------------------+\n    // | Where:                                           |\n    // |   Ao = Amount out                                |\n    // |   Bo = Balance token out                         |\n    // |   Vo = Virtual balance token out                 |\n    // |   Ai = Amount in                                 |\n    // |   Bi = Balance token in                          |\n    // |   Vi = Virtual balance token in                  |\n    // +--------------------------------------------------+\n    const { virtualBalanceTokenIn, virtualBalanceTokenOut } =\n        tokenInIndex === 0\n            ? {\n                  virtualBalanceTokenIn: virtualBalanceA,\n                  virtualBalanceTokenOut: virtualBalanceB,\n              }\n            : {\n                  virtualBalanceTokenIn: virtualBalanceB,\n                  virtualBalanceTokenOut: virtualBalanceA,\n              };\n\n    const amountOutScaled18 =\n        ((balancesScaled18[tokenOutIndex] + virtualBalanceTokenOut) *\n            amountInScaled18) /\n        (balancesScaled18[tokenInIndex] +\n            virtualBalanceTokenIn +\n            amountInScaled18);\n\n    if (amountOutScaled18 > balancesScaled18[tokenOutIndex]) {\n        // Amount out cannot be greater than the real balance of the token in the pool.\n        throw new Error('reClammMath: AmountOutGreaterThanBalance');\n    }\n\n    return amountOutScaled18;\n}\n\n/**\n * @notice Compute the `amountIn` of tokenIn in a swap, given the current balances and virtual balances.\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA The last virtual balances of token A\n * @param virtualBalanceB The last virtual balances of token B\n * @param tokenInIndex Index of the token being swapped in\n * @param tokenOutIndex Index of the token being swapped out\n * @param amountOutScaled18 The exact amount of `tokenOut` (i.e., the amount given in an ExactOut swap)\n * @return amountInScaled18 The calculated amount of `tokenIn` returned in an ExactOut swap\n */\nexport function computeInGivenOut(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    tokenInIndex: number,\n    tokenOutIndex: number,\n    amountOutScaled18: bigint,\n): bigint {\n    // `amountInScaled18 = newTotalTokenOutPoolBalance - currentTotalTokenInPoolBalance`,\n    // where `newTotalTokenOutPoolBalance = invariant / (currentTotalTokenOutPoolBalance - amountOutScaled18)`\n    // and `currentTotalTokenInPoolBalance = balancesScaled18[tokenInIndex] + virtualBalanceTokenIn`.\n    // In other words,\n    // +--------------------------------------------------+\n    // |               L                                  |\n    // | Ai = --------------------- - (Bi + Vi)           |\n    // |         (Bo + Vo - Ao)                           |\n    // +--------------------------------------------------+\n    // Simplify by:\n    // - replacing `L = (Bo + Vo) (Bi + Vi)`, and\n    // - multiplying `(Bi + Vi)` by `(Bo + Vo - Ao) / (Bo + Vo - Ao)`:\n    // +--------------------------------------------------+\n    // |              (Bi + Vi) Ao                        |\n    // | Ai = ------------------------------              |\n    // |             (Bo + Vo - Ao)                       |\n    // +--------------------------------------------------+\n    // | Where:                                           |\n    // |   Ao = Amount out                                |\n    // |   Bo = Balance token out                         |\n    // |   Vo = Virtual balance token out                 |\n    // |   Ai = Amount in                                 |\n    // |   Bi = Balance token in                          |\n    // |   Vi = Virtual balance token in                  |\n    // +--------------------------------------------------+\n\n    if (amountOutScaled18 > balancesScaled18[tokenOutIndex]) {\n        // Amount out cannot be greater than the real balance of the token in the pool.\n        throw new Error('reClammMath: AmountOutGreaterThanBalance');\n    }\n\n    const { virtualBalanceTokenIn, virtualBalanceTokenOut } =\n        tokenInIndex === 0\n            ? {\n                  virtualBalanceTokenIn: virtualBalanceA,\n                  virtualBalanceTokenOut: virtualBalanceB,\n              }\n            : {\n                  virtualBalanceTokenIn: virtualBalanceB,\n                  virtualBalanceTokenOut: virtualBalanceA,\n              };\n\n    // Round up to favor the vault (i.e. request larger amount in from the user).\n    const amountInScaled18 = MathSol.mulDivUpFixed(\n        balancesScaled18[tokenInIndex] + virtualBalanceTokenIn,\n        amountOutScaled18,\n        balancesScaled18[tokenOutIndex] +\n            virtualBalanceTokenOut -\n            amountOutScaled18,\n    );\n\n    return amountInScaled18;\n}\n","import {\n    MaxSwapParams,\n    type PoolBase,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport { ReClammMutable } from './reClammData';\nimport {\n    computeCurrentVirtualBalances,\n    computeInGivenOut,\n    computeOutGivenIn,\n} from './reClammMath';\n\nexport class ReClamm implements PoolBase {\n    public reClammState: ReClammMutable;\n    constructor(reClammState: ReClammMutable) {\n        this.reClammState = reClammState;\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        // The invariant ratio bounds are required by `IBasePool`, but are unused in this pool type, as liquidity can\n        // only be added or removed proportionally.\n        return 0n;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        // The invariant ratio bounds are required by `IBasePool`, but are unused in this pool type, as liquidity can\n        // only be added or removed proportionally.\n        return 0n;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const { balancesLiveScaled18, indexIn, indexOut, swapKind } =\n            maxSwapParams;\n\n        if (swapKind === SwapKind.GivenIn) {\n            const computeResult =\n                this._computeCurrentVirtualBalances(balancesLiveScaled18);\n            const maxAmountIn = computeInGivenOut(\n                balancesLiveScaled18,\n                computeResult.currentVirtualBalanceA,\n                computeResult.currentVirtualBalanceB,\n                indexIn,\n                indexOut,\n                balancesLiveScaled18[indexOut],\n            );\n            const maxAmountInWithTolerance = maxAmountIn - 10n; // 10 is a tolerance for rounding\n            return maxAmountInWithTolerance < 0n\n                ? 0n\n                : maxAmountInWithTolerance;\n        }\n        const maxAmountOutWithTolerance = balancesLiveScaled18[indexOut] - 10n; // 10 is a tolerance for rounding\n        return maxAmountOutWithTolerance < 0n ? 0n : maxAmountOutWithTolerance;\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        // liquidity can only be added or removed proportionally.\n        return 0n;\n    }\n\n    getMaxSingleTokenRemoveAmount(): bigint {\n        // liquidity can only be added or removed proportionally.\n        return 0n;\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n\n        const { currentVirtualBalanceA, currentVirtualBalanceB } =\n            this._computeCurrentVirtualBalances(balancesLiveScaled18);\n\n        // In SC it does: if (changed) _setLastVirtualBalances, but we don't need that as lastVirtualBalances isn't relevant going forward\n\n        if (swapKind === SwapKind.GivenIn) {\n            const amountCalculatedScaled18 = computeOutGivenIn(\n                balancesLiveScaled18,\n                currentVirtualBalanceA,\n                currentVirtualBalanceB,\n                indexIn,\n                indexOut,\n                amountGivenScaled18,\n            );\n\n            return amountCalculatedScaled18;\n        }\n\n        const amountCalculatedScaled18 = computeInGivenOut(\n            balancesLiveScaled18,\n            currentVirtualBalanceA,\n            currentVirtualBalanceB,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        );\n\n        return amountCalculatedScaled18;\n    }\n\n    computeInvariant(): bigint {\n        // Only needed for unbalanced liquidity and thats not possible in this pool\n        return 0n;\n    }\n\n    computeBalance(): bigint {\n        // Only needed for unbalanced liquidity and thats not possible in this pool\n        return 0n;\n    }\n\n    _computeCurrentVirtualBalances(balancesScaled18: bigint[]): {\n        currentVirtualBalanceA: bigint;\n        currentVirtualBalanceB: bigint;\n        changed: boolean;\n    } {\n        return computeCurrentVirtualBalances(\n            this.reClammState.currentTimestamp,\n            balancesScaled18,\n            this.reClammState.lastVirtualBalances[0],\n            this.reClammState.lastVirtualBalances[1],\n            this.reClammState.dailyPriceShiftBase,\n            this.reClammState.lastTimestamp,\n            this.reClammState.centerednessMargin,\n            {\n                priceRatioUpdateStartTime:\n                    this.reClammState.priceRatioUpdateStartTime,\n                priceRatioUpdateEndTime:\n                    this.reClammState.priceRatioUpdateEndTime,\n                startFourthRootPriceRatio:\n                    this.reClammState.startFourthRootPriceRatio,\n                endFourthRootPriceRatio:\n                    this.reClammState.endFourthRootPriceRatio,\n            },\n        );\n    }\n}\n","import { FixedPointFunction, MathSol, WAD } from '../utils/math';\nimport { sqrt } from '../utils/ozMath';\nimport { Rounding } from '../vault/types';\n\ntype PriceRatioState = {\n    priceRatioUpdateStartTime: bigint;\n    priceRatioUpdateEndTime: bigint;\n    startFourthRootPriceRatio: bigint;\n    endFourthRootPriceRatio: bigint;\n};\n\nconst a = 0;\nconst b = 1;\n\nconst thirtyDaysSeconds = 30n * 24n * 60n * 60n; // 2,592,000n seconds\n\nexport function computeCurrentVirtualBalances(\n    currentTimestamp: bigint,\n    balancesScaled18: bigint[],\n    lastVirtualBalanceA: bigint,\n    lastVirtualBalanceB: bigint,\n    dailyPriceShiftBase: bigint,\n    lastTimestamp: bigint,\n    centerednessMargin: bigint,\n    priceRatioState: PriceRatioState,\n): {\n    currentVirtualBalanceA: bigint;\n    currentVirtualBalanceB: bigint;\n    changed: boolean;\n} {\n    if (lastTimestamp === currentTimestamp) {\n        return {\n            currentVirtualBalanceA: lastVirtualBalanceA,\n            currentVirtualBalanceB: lastVirtualBalanceB,\n            changed: false,\n        };\n    }\n\n    let currentVirtualBalanceA = lastVirtualBalanceA;\n    let currentVirtualBalanceB = lastVirtualBalanceB;\n\n    const currentFourthRootPriceRatio = computeFourthRootPriceRatio(\n        currentTimestamp,\n        priceRatioState.startFourthRootPriceRatio,\n        priceRatioState.endFourthRootPriceRatio,\n        priceRatioState.priceRatioUpdateStartTime,\n        priceRatioState.priceRatioUpdateEndTime,\n    );\n\n    let changed = false;\n\n    // If the price ratio is updating, shrink/expand the price interval by recalculating the virtual balances.\n    if (\n        currentTimestamp > priceRatioState.priceRatioUpdateStartTime &&\n        lastTimestamp < priceRatioState.priceRatioUpdateEndTime\n    ) {\n        ({\n            virtualBalanceA: currentVirtualBalanceA,\n            virtualBalanceB: currentVirtualBalanceB,\n        } = computeVirtualBalancesUpdatingPriceRatio(\n            currentFourthRootPriceRatio,\n            balancesScaled18,\n            lastVirtualBalanceA,\n            lastVirtualBalanceB,\n        ));\n\n        changed = true;\n    }\n\n    const { poolCenteredness: centeredness, isPoolAboveCenter } =\n        computeCenteredness(\n            balancesScaled18,\n            currentVirtualBalanceA,\n            currentVirtualBalanceB,\n        );\n\n    // If the pool is outside the target range, track the market price by moving the price interval.\n    if (centeredness < centerednessMargin) {\n        [currentVirtualBalanceA, currentVirtualBalanceB] =\n            computeVirtualBalancesUpdatingPriceRange(\n                balancesScaled18,\n                currentVirtualBalanceA,\n                currentVirtualBalanceB,\n                isPoolAboveCenter,\n                dailyPriceShiftBase,\n                currentTimestamp,\n                lastTimestamp,\n            );\n\n        changed = true;\n    }\n\n    return {\n        currentVirtualBalanceA,\n        currentVirtualBalanceB,\n        changed,\n    };\n}\n\n/**\n * @notice Compute the virtual balances of the pool when the price ratio is updating.\n * @dev This function uses a Bhaskara formula to shrink/expand the price interval by recalculating the virtual\n * balances. It'll keep the pool centeredness constant, and track the desired price ratio. To derive this formula,\n * we need to solve the following simultaneous equations:\n *\n * 1. centeredness = (Ra * Vb) / (Rb * Va)\n * 2. PriceRatio = invariant^2/(Va * Vb)^2 (maxPrice / minPrice)\n * 3. invariant = (Va + Ra) * (Vb + Rb)\n *\n * Substitute [3] in [2]. Then, isolate one of the V's. Finally, replace the isolated V in [1]. We get a quadratic\n * equation that will be solved in this function.\n *\n * @param currentFourthRootPriceRatio The current fourth root of the price ratio of the pool\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param lastVirtualBalanceA The last virtual balance of token A\n * @param lastVirtualBalanceB The last virtual balance of token B\n * @return virtualBalanceA The virtual balance of token A\n * @return virtualBalanceB The virtual balance of token B\n */\nfunction computeVirtualBalancesUpdatingPriceRatio(\n    currentFourthRootPriceRatio: bigint,\n    balancesScaled18: bigint[],\n    lastVirtualBalanceA: bigint,\n    lastVirtualBalanceB: bigint,\n): { virtualBalanceA: bigint; virtualBalanceB: bigint } {\n    // Compute the current pool centeredness, which will remain constant.\n    const { poolCenteredness, isPoolAboveCenter } = computeCenteredness(\n        balancesScaled18,\n        lastVirtualBalanceA,\n        lastVirtualBalanceB,\n    );\n\n    // The overvalued token is the one with a lower token balance (therefore, rarer and more valuable).\n    const {\n        balanceTokenUndervalued,\n        lastVirtualBalanceUndervalued,\n        lastVirtualBalanceOvervalued,\n    } = isPoolAboveCenter\n        ? {\n              balanceTokenUndervalued: balancesScaled18[a],\n              lastVirtualBalanceUndervalued: lastVirtualBalanceA,\n              lastVirtualBalanceOvervalued: lastVirtualBalanceB,\n          }\n        : {\n              balanceTokenUndervalued: balancesScaled18[b],\n              lastVirtualBalanceUndervalued: lastVirtualBalanceB,\n              lastVirtualBalanceOvervalued: lastVirtualBalanceA,\n          };\n\n    // The original formula was a quadratic equation, with terms:\n    // a = Q0 - 1\n    // b = - Ru (1 + C)\n    // c = - Ru^2 C\n    // where Q0 is the square root of the price ratio, Ru is the undervalued token balance, and C is the\n    // centeredness. Applying Bhaskara, we'd have: Vu = (-b + sqrt(b^2 - 4ac)) / 2a.\n    // The Bhaskara above can be simplified by replacing a, b and c with the terms above, which leads to:\n    // Vu = Ru(1 + C + sqrt(1 + C (C + 4 Q0 - 2))) / 2(Q0 - 1)\n    const sqrtPriceRatio = MathSol.mulDownFixed(\n        currentFourthRootPriceRatio,\n        currentFourthRootPriceRatio,\n    );\n\n    // Using FixedPoint math as little as possible to improve the precision of the result.\n    // Note: The input of Math.sqrt must be a 36-decimal number, so that the final result is 18 decimals.\n    const virtualBalanceUndervalued =\n        (balanceTokenUndervalued *\n            (WAD +\n                poolCenteredness +\n                sqrt(\n                    poolCenteredness *\n                        (poolCenteredness +\n                            4n * sqrtPriceRatio -\n                            2000000000000000000n) +\n                        1000000000000000000000000000000000000n,\n                ))) /\n        (2n * (sqrtPriceRatio - WAD));\n\n    const virtualBalanceOvervalued =\n        (virtualBalanceUndervalued * lastVirtualBalanceOvervalued) /\n        lastVirtualBalanceUndervalued;\n\n    const { virtualBalanceA, virtualBalanceB } = isPoolAboveCenter\n        ? {\n              virtualBalanceA: virtualBalanceUndervalued,\n              virtualBalanceB: virtualBalanceOvervalued,\n          }\n        : {\n              virtualBalanceA: virtualBalanceOvervalued,\n              virtualBalanceB: virtualBalanceUndervalued,\n          };\n\n    return { virtualBalanceA, virtualBalanceB };\n}\n\nfunction computeVirtualBalancesUpdatingPriceRange(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    isPoolAboveCenter: boolean,\n    dailyPriceShiftBase: bigint,\n    currentTimestamp: bigint,\n    lastTimestamp: bigint,\n): [bigint, bigint] {\n    const sqrtPriceRatio = sqrtScaled18(\n        computePriceRatio(balancesScaled18, virtualBalanceA, virtualBalanceB),\n    );\n\n    // // The overvalued token is the one with a lower token balance (therefore, rarer and more valuable).\n    const [balancesScaledUndervalued, balancesScaledOvervalued] =\n        isPoolAboveCenter\n            ? [balancesScaled18[0], balancesScaled18[1]]\n            : [balancesScaled18[1], balancesScaled18[0]];\n    let [virtualBalanceUndervalued, virtualBalanceOvervalued] =\n        isPoolAboveCenter\n            ? [virtualBalanceA, virtualBalanceB]\n            : [virtualBalanceB, virtualBalanceA];\n\n    // +-----------------------------------------+\n    // |                      (Tc - Tl)          |\n    // |      Vo = Vo * (Psb)^                   |\n    // +-----------------------------------------+\n    // |  Where:                                 |\n    // |    Vo = Virtual balance overvalued      |\n    // |    Psb = Price shift daily rate base    |\n    // |    Tc = Current timestamp               |\n    // |    Tl = Last timestamp                  |\n    // +-----------------------------------------+\n    // |               Ru * (Vo + Ro)            |\n    // |      Vu = ----------------------        |\n    // |             (Qo - 1) * Vo - Ro          |\n    // +-----------------------------------------+\n    // |  Where:                                 |\n    // |    Vu = Virtual balance undervalued     |\n    // |    Vo = Virtual balance overvalued      |\n    // |    Ru = Real balance undervalued        |\n    // |    Ro = Real balance overvalued         |\n    // |    Qo = Square root of price ratio      |\n    // +-----------------------------------------+\n\n    // Cap the duration (time between operations) at 30 days, to ensure `powDown` does not overflow.\n    const duration = MathSol.min(\n        currentTimestamp - lastTimestamp,\n        thirtyDaysSeconds,\n    );\n\n    virtualBalanceOvervalued = MathSol.mulDownFixed(\n        virtualBalanceOvervalued,\n        MathSol.powDownFixed(dailyPriceShiftBase, duration * WAD),\n    );\n\n    // Ensure that Vo does not go below the minimum allowed value (corresponding to centeredness == 1).\n    virtualBalanceOvervalued = MathSol.max(\n        virtualBalanceOvervalued,\n        MathSol.divDownFixed(\n            balancesScaledOvervalued,\n            sqrtScaled18(sqrtPriceRatio) - WAD,\n        ),\n    );\n\n    virtualBalanceUndervalued =\n        (balancesScaledUndervalued *\n            (virtualBalanceOvervalued + balancesScaledOvervalued)) /\n        (MathSol.mulDownFixed(sqrtPriceRatio - WAD, virtualBalanceOvervalued) -\n            balancesScaledOvervalued);\n\n    return isPoolAboveCenter\n        ? [virtualBalanceUndervalued, virtualBalanceOvervalued]\n        : [virtualBalanceOvervalued, virtualBalanceUndervalued];\n}\n\n/**\n * @notice Compute the price ratio of the pool by dividing the maximum price by the minimum price.\n * @dev The price ratio is calculated as maxPrice/minPrice, where maxPrice and minPrice are obtained\n * from computePriceRange.\n *\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA Virtual balance of token A\n * @param virtualBalanceB Virtual balance of token B\n * @return priceRatio The ratio between the maximum and minimum prices of the pool\n */\nfunction computePriceRatio(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): bigint {\n    const { minPrice, maxPrice } = computePriceRange(\n        balancesScaled18,\n        virtualBalanceA,\n        virtualBalanceB,\n    );\n\n    return MathSol.divUpFixed(maxPrice, minPrice);\n}\n\n/**\n * @notice Compute the minimum and maximum prices for the pool based on virtual balances and current invariant.\n * @dev The minimum price is calculated as Vb^2/invariant, where Vb is the virtual balance of token B.\n * The maximum price is calculated as invariant/Va^2, where Va is the virtual balance of token A.\n * These calculations are derived from the invariant equation: invariant = (Ra + Va)(Rb + Vb),\n * where Ra and Rb are the real balances of tokens A and B respectively.\n *\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA Virtual balance of token A\n * @param virtualBalanceB Virtual balance of token B\n * @return minPrice The minimum price of token A in terms of token B\n * @return maxPrice The maximum price of token A in terms of token B\n */\nfunction computePriceRange(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): { minPrice: bigint; maxPrice: bigint } {\n    const currentInvariant = computeInvariant(\n        balancesScaled18,\n        virtualBalanceA,\n        virtualBalanceB,\n        Rounding.ROUND_DOWN,\n    );\n\n    // P_min(a) = Vb / (Va + Ra_max)\n    // We don't have Ra_max, but: invariant=(Ra_max + Va)(Vb)\n    // Then, (Va + Ra_max) = invariant/Vb, and:\n    // P_min(a) = Vb^2 / invariant\n    const minPrice = (virtualBalanceB * virtualBalanceB) / currentInvariant;\n\n    // Similarly, P_max(a) = (Rb_max + Vb)/Va\n    // We don't have Rb_max, but: invariant=(Rb_max + Vb)(Va)\n    // Then, (Rb_max + Vb) = invariant/Va, and:\n    // P_max(a) = invariant / Va^2\n    const maxPrice = MathSol.divDownFixed(\n        currentInvariant,\n        MathSol.mulDownFixed(virtualBalanceA, virtualBalanceA),\n    );\n\n    return { minPrice, maxPrice };\n}\n\nfunction computeFourthRootPriceRatio(\n    currentTime: bigint,\n    startFourthRootPriceRatio: bigint,\n    endFourthRootPriceRatio: bigint,\n    priceRatioUpdateStartTime: bigint,\n    priceRatioUpdateEndTime: bigint,\n): bigint {\n    // if start and end time are the same, return end value.\n    if (currentTime >= priceRatioUpdateEndTime) {\n        return endFourthRootPriceRatio;\n    } else if (currentTime <= priceRatioUpdateStartTime) {\n        return startFourthRootPriceRatio;\n    }\n\n    const exponent = MathSol.divDownFixed(\n        currentTime - priceRatioUpdateStartTime,\n        priceRatioUpdateEndTime - priceRatioUpdateStartTime,\n    );\n\n    const currentFourthRootPriceRatio = MathSol.mulDownFixed(\n        startFourthRootPriceRatio,\n        MathSol.powDownFixed(\n            MathSol.divDownFixed(\n                endFourthRootPriceRatio,\n                startFourthRootPriceRatio,\n            ),\n            exponent,\n        ),\n    );\n\n    // Since we're rounding current fourth root price ratio down, we only need to check the lower boundary.\n    const minimumFourthRootPriceRatio = MathSol.min(\n        startFourthRootPriceRatio,\n        endFourthRootPriceRatio,\n    );\n    return MathSol.max(\n        minimumFourthRootPriceRatio,\n        currentFourthRootPriceRatio,\n    );\n}\n\nfunction computeCenteredness(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n): { poolCenteredness: bigint; isPoolAboveCenter: boolean } {\n    if (balancesScaled18[a] === 0n) {\n        // Also return false if both are 0 to be consistent with the logic below.\n        return { poolCenteredness: 0n, isPoolAboveCenter: false };\n    } else if (balancesScaled18[b] === 0n) {\n        return { poolCenteredness: 0n, isPoolAboveCenter: true };\n    }\n\n    const numerator = balancesScaled18[a] * virtualBalanceB;\n    const denominator = virtualBalanceA * balancesScaled18[b];\n\n    let poolCenteredness: bigint;\n    let isPoolAboveCenter: boolean;\n    // The centeredness is defined between 0 and 1. If the numerator is greater than the denominator, we compute\n    // the inverse ratio.\n    if (numerator <= denominator) {\n        poolCenteredness = MathSol.divDownFixed(numerator, denominator);\n        isPoolAboveCenter = false;\n    } else {\n        poolCenteredness = MathSol.divDownFixed(denominator, numerator);\n        isPoolAboveCenter = true;\n    }\n\n    return { poolCenteredness, isPoolAboveCenter };\n}\n\nfunction computeInvariant(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    rounding: Rounding,\n): bigint {\n    const _mulUpOrDown: FixedPointFunction =\n        rounding === Rounding.ROUND_DOWN\n            ? MathSol.mulDownFixed\n            : MathSol.mulUpFixed;\n\n    return _mulUpOrDown(\n        balancesScaled18[0] + virtualBalanceA,\n        balancesScaled18[1] + virtualBalanceB,\n    );\n}\n\n/**\n * @notice Compute the `amountOut` of tokenOut in a swap, given the current balances and virtual balances.\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA The last virtual balance of token A\n * @param virtualBalanceB The last virtual balance of token B\n * @param tokenInIndex Index of the token being swapped in\n * @param tokenOutIndex Index of the token being swapped out\n * @param amountInScaled18 The exact amount of `tokenIn` (i.e., the amount given in an ExactIn swap)\n * @return amountOutScaled18 The calculated amount of `tokenOut` returned in an ExactIn swap\n */\nexport function computeOutGivenIn(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    tokenInIndex: number,\n    tokenOutIndex: number,\n    amountInScaled18: bigint,\n): bigint {\n    // `amountOutScaled18 = currentTotalTokenOutPoolBalance - newTotalTokenOutPoolBalance`,\n    // where `currentTotalTokenOutPoolBalance = balancesScaled18[tokenOutIndex] + virtualBalanceTokenOut`\n    // and `newTotalTokenOutPoolBalance = invariant / (currentTotalTokenInPoolBalance + amountInScaled18)`.\n    // In other words,\n    // +--------------------------------------------------+\n    // |                         L                        |\n    // | Ao = Bo + Vo - ---------------------             |\n    // |                   (Bi + Vi + Ai)                 |\n    // +--------------------------------------------------+\n    // Simplify by:\n    // - replacing `L = (Bo + Vo) (Bi + Vi)`, and\n    // - multiplying `(Bo + Vo)` by `(Bi + Vi + Ai) / (Bi + Vi + Ai)`:\n    // +--------------------------------------------------+\n    // |              (Bo + Vo) Ai                        |\n    // | Ao = ------------------------------              |\n    // |             (Bi + Vi + Ai)                       |\n    // +--------------------------------------------------+\n    // | Where:                                           |\n    // |   Ao = Amount out                                |\n    // |   Bo = Balance token out                         |\n    // |   Vo = Virtual balance token out                 |\n    // |   Ai = Amount in                                 |\n    // |   Bi = Balance token in                          |\n    // |   Vi = Virtual balance token in                  |\n    // +--------------------------------------------------+\n    const { virtualBalanceTokenIn, virtualBalanceTokenOut } =\n        tokenInIndex === 0\n            ? {\n                  virtualBalanceTokenIn: virtualBalanceA,\n                  virtualBalanceTokenOut: virtualBalanceB,\n              }\n            : {\n                  virtualBalanceTokenIn: virtualBalanceB,\n                  virtualBalanceTokenOut: virtualBalanceA,\n              };\n\n    const amountOutScaled18 =\n        ((balancesScaled18[tokenOutIndex] + virtualBalanceTokenOut) *\n            amountInScaled18) /\n        (balancesScaled18[tokenInIndex] +\n            virtualBalanceTokenIn +\n            amountInScaled18);\n\n    if (amountOutScaled18 > balancesScaled18[tokenOutIndex]) {\n        // Amount out cannot be greater than the real balance of the token in the pool.\n        throw new Error('reClammMath: AmountOutGreaterThanBalance');\n    }\n\n    return amountOutScaled18;\n}\n\n/**\n * @notice Compute the `amountIn` of tokenIn in a swap, given the current balances and virtual balances.\n * @param balancesScaled18 Current pool balances, sorted in token registration order\n * @param virtualBalanceA The last virtual balances of token A\n * @param virtualBalanceB The last virtual balances of token B\n * @param tokenInIndex Index of the token being swapped in\n * @param tokenOutIndex Index of the token being swapped out\n * @param amountOutScaled18 The exact amount of `tokenOut` (i.e., the amount given in an ExactOut swap)\n * @return amountInScaled18 The calculated amount of `tokenIn` returned in an ExactOut swap\n */\nexport function computeInGivenOut(\n    balancesScaled18: bigint[],\n    virtualBalanceA: bigint,\n    virtualBalanceB: bigint,\n    tokenInIndex: number,\n    tokenOutIndex: number,\n    amountOutScaled18: bigint,\n): bigint {\n    // `amountInScaled18 = newTotalTokenOutPoolBalance - currentTotalTokenInPoolBalance`,\n    // where `newTotalTokenOutPoolBalance = invariant / (currentTotalTokenOutPoolBalance - amountOutScaled18)`\n    // and `currentTotalTokenInPoolBalance = balancesScaled18[tokenInIndex] + virtualBalanceTokenIn`.\n    // In other words,\n    // +--------------------------------------------------+\n    // |               L                                  |\n    // | Ai = --------------------- - (Bi + Vi)           |\n    // |         (Bo + Vo - Ao)                           |\n    // +--------------------------------------------------+\n    // Simplify by:\n    // - replacing `L = (Bo + Vo) (Bi + Vi)`, and\n    // - multiplying `(Bi + Vi)` by `(Bo + Vo - Ao) / (Bo + Vo - Ao)`:\n    // +--------------------------------------------------+\n    // |              (Bi + Vi) Ao                        |\n    // | Ai = ------------------------------              |\n    // |             (Bo + Vo - Ao)                       |\n    // +--------------------------------------------------+\n    // | Where:                                           |\n    // |   Ao = Amount out                                |\n    // |   Bo = Balance token out                         |\n    // |   Vo = Virtual balance token out                 |\n    // |   Ai = Amount in                                 |\n    // |   Bi = Balance token in                          |\n    // |   Vi = Virtual balance token in                  |\n    // +--------------------------------------------------+\n\n    if (amountOutScaled18 > balancesScaled18[tokenOutIndex]) {\n        // Amount out cannot be greater than the real balance of the token in the pool.\n        throw new Error('reClammMath: AmountOutGreaterThanBalance');\n    }\n\n    const { virtualBalanceTokenIn, virtualBalanceTokenOut } =\n        tokenInIndex === 0\n            ? {\n                  virtualBalanceTokenIn: virtualBalanceA,\n                  virtualBalanceTokenOut: virtualBalanceB,\n              }\n            : {\n                  virtualBalanceTokenIn: virtualBalanceB,\n                  virtualBalanceTokenOut: virtualBalanceA,\n              };\n\n    // Round up to favor the vault (i.e. request larger amount in from the user).\n    const amountInScaled18 = MathSol.mulDivUpFixed(\n        balancesScaled18[tokenInIndex] + virtualBalanceTokenIn,\n        amountOutScaled18,\n        balancesScaled18[tokenOutIndex] +\n            virtualBalanceTokenOut -\n            amountOutScaled18,\n    );\n\n    return amountInScaled18;\n}\n\n/**\n * @notice Calculate the square root of a value scaled by 18 decimals.\n * @param valueScaled18 The value to calculate the square root of, scaled by 18 decimals\n * @return sqrtValueScaled18 The square root of the value scaled by 18 decimals\n */\nfunction sqrtScaled18(valueScaled18: bigint): bigint {\n    return sqrt(valueScaled18 * WAD);\n}\n","import {\n    MaxSwapParams,\n    type PoolBase,\n    SwapKind,\n    type SwapParams,\n} from '../vault/types';\nimport { ReClammV2Mutable } from './reClammV2Data';\nimport {\n    computeCurrentVirtualBalances,\n    computeInGivenOut,\n    computeOutGivenIn,\n} from './reClammV2Math';\n\nexport class ReClammV2 implements PoolBase {\n    public reClammState: ReClammV2Mutable;\n    constructor(reClammState: ReClammV2Mutable) {\n        this.reClammState = reClammState;\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        // The invariant ratio bounds are required by `IBasePool`, but are unused in this pool type, as liquidity can\n        // only be added or removed proportionally.\n        return 0n;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        // The invariant ratio bounds are required by `IBasePool`, but are unused in this pool type, as liquidity can\n        // only be added or removed proportionally.\n        return 0n;\n    }\n\n    /**\n     * Returns the max amount that can be swapped in relation to the swapKind.\n     * @param maxSwapParams\n     * @returns GivenIn: Returns the max amount in. GivenOut: Returns the max amount out.\n     */\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const { balancesLiveScaled18, indexIn, indexOut, swapKind } =\n            maxSwapParams;\n\n        if (swapKind === SwapKind.GivenIn) {\n            const computeResult =\n                this._computeCurrentVirtualBalances(balancesLiveScaled18);\n            const maxAmountIn = computeInGivenOut(\n                balancesLiveScaled18,\n                computeResult.currentVirtualBalanceA,\n                computeResult.currentVirtualBalanceB,\n                indexIn,\n                indexOut,\n                balancesLiveScaled18[indexOut],\n            );\n            const maxAmountInWithTolerance = maxAmountIn - 10n; // 10 is a tolerance for rounding\n            return maxAmountInWithTolerance < 0n\n                ? 0n\n                : maxAmountInWithTolerance;\n        }\n        const maxAmountOutWithTolerance = balancesLiveScaled18[indexOut] - 10n; // 10 is a tolerance for rounding\n        return maxAmountOutWithTolerance < 0n ? 0n : maxAmountOutWithTolerance;\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        // liquidity can only be added or removed proportionally.\n        return 0n;\n    }\n\n    getMaxSingleTokenRemoveAmount(): bigint {\n        // liquidity can only be added or removed proportionally.\n        return 0n;\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n\n        const { currentVirtualBalanceA, currentVirtualBalanceB } =\n            this._computeCurrentVirtualBalances(balancesLiveScaled18);\n\n        // In SC it does: if (changed) _setLastVirtualBalances, but we don't need that as lastVirtualBalances isn't relevant going forward\n\n        if (swapKind === SwapKind.GivenIn) {\n            const amountCalculatedScaled18 = computeOutGivenIn(\n                balancesLiveScaled18,\n                currentVirtualBalanceA,\n                currentVirtualBalanceB,\n                indexIn,\n                indexOut,\n                amountGivenScaled18,\n            );\n\n            return amountCalculatedScaled18;\n        }\n\n        const amountCalculatedScaled18 = computeInGivenOut(\n            balancesLiveScaled18,\n            currentVirtualBalanceA,\n            currentVirtualBalanceB,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        );\n\n        return amountCalculatedScaled18;\n    }\n\n    computeInvariant(): bigint {\n        // Only needed for unbalanced liquidity and thats not possible in this pool\n        return 0n;\n    }\n\n    computeBalance(): bigint {\n        // Only needed for unbalanced liquidity and thats not possible in this pool\n        return 0n;\n    }\n\n    _computeCurrentVirtualBalances(balancesScaled18: bigint[]): {\n        currentVirtualBalanceA: bigint;\n        currentVirtualBalanceB: bigint;\n        changed: boolean;\n    } {\n        return computeCurrentVirtualBalances(\n            this.reClammState.currentTimestamp,\n            balancesScaled18,\n            this.reClammState.lastVirtualBalances[0],\n            this.reClammState.lastVirtualBalances[1],\n            this.reClammState.dailyPriceShiftBase,\n            this.reClammState.lastTimestamp,\n            this.reClammState.centerednessMargin,\n            {\n                priceRatioUpdateStartTime:\n                    this.reClammState.priceRatioUpdateStartTime,\n                priceRatioUpdateEndTime:\n                    this.reClammState.priceRatioUpdateEndTime,\n                startFourthRootPriceRatio:\n                    this.reClammState.startFourthRootPriceRatio,\n                endFourthRootPriceRatio:\n                    this.reClammState.endFourthRootPriceRatio,\n            },\n        );\n    }\n}\n","import { MathSol } from '../utils/math';\n\n/**\n * @notice Calculate the current block weight based on time interpolation\n * @param weight The base weight\n * @param multiplier The weight multiplier\n * @param timeSinceLastUpdate The time since the last weight update\n * @return The interpolated weight\n */\nexport const calculateBlockNormalisedWeight = (\n    weight: bigint,\n    multiplier: bigint,\n    timeSinceLastUpdate: bigint,\n): bigint => {\n    // multiplier is always below 1, we multiply by 1e18 for rounding\n    const multiplierScaled18 = multiplier * BigInt('1000000000000000000');\n\n    if (multiplier > 0n) {\n        return (\n            weight +\n            MathSol.mulDownFixed(multiplierScaled18, timeSinceLastUpdate)\n        );\n    } else {\n        return (\n            weight -\n            MathSol.mulDownFixed(-multiplierScaled18, timeSinceLastUpdate)\n        );\n    }\n};\n\n/**\n * Both functions below are simplified versions of the SC implementation.\n * They extract weights and multipliers from mutable data fecthed on-chain, which\n * are packed and stored in 256-bit words for storage efficiency, but here can\n * be unpacked into separate weights and multipliers arrays.\n */\n\nexport const getFirstFourWeightsAndMultipliers = (\n    tokens: string[],\n    firstFourWeightsAndMultipliers: bigint[],\n): { weights: bigint[]; multipliers: bigint[] } => {\n    const lessThan4TokensOffset = tokens.length > 4 ? 4 : tokens.length;\n\n    const weights = new Array(lessThan4TokensOffset).fill(0n);\n    const multipliers = new Array(lessThan4TokensOffset).fill(0n);\n\n    for (let i = 0; i < lessThan4TokensOffset; i++) {\n        weights[i] = firstFourWeightsAndMultipliers[i];\n        multipliers[i] =\n            firstFourWeightsAndMultipliers[i + lessThan4TokensOffset];\n    }\n\n    return { weights, multipliers };\n};\n\nexport const getSecondFourWeightsAndMultipliers = (\n    tokens: string[],\n    secondFourWeightsAndMultipliers: bigint[],\n): { weights: bigint[]; multipliers: bigint[] } => {\n    if (tokens.length <= 4) {\n        return { weights: [], multipliers: [] };\n    }\n\n    const moreThan4TokensOffset = tokens.length - 4;\n\n    const weights = new Array(moreThan4TokensOffset).fill(0n);\n    const multipliers = new Array(moreThan4TokensOffset).fill(0n);\n\n    for (let i = 0; i < moreThan4TokensOffset; i++) {\n        weights[i] = secondFourWeightsAndMultipliers[i];\n        multipliers[i] =\n            secondFourWeightsAndMultipliers[i + moreThan4TokensOffset];\n    }\n\n    return { weights, multipliers };\n};\n","import {\n    _computeBalanceOutGivenInvariant,\n    _computeInGivenExactOut,\n    _computeInvariantDown,\n    _computeInvariantUp,\n    _computeOutGivenExactIn,\n    _MAX_INVARIANT_RATIO,\n    _MIN_INVARIANT_RATIO,\n} from '../weighted';\nimport {\n    SwapKind,\n    type SwapParams,\n    type MaxSwapParams,\n    Rounding,\n    PoolBase,\n    MaxSingleTokenRemoveParams,\n} from '../vault/types';\nimport { MathSol, MAX_UINT256 } from '../utils/math';\nimport {\n    calculateBlockNormalisedWeight,\n    getFirstFourWeightsAndMultipliers,\n    getSecondFourWeightsAndMultipliers,\n} from './quantAmmMath';\nimport { QuantAmmState } from './quantAmmData';\nimport { toRawUndoRateRoundDown } from '../vault/utils';\n\nexport class QuantAmm implements PoolBase {\n    private weights: bigint[];\n    private multipliers: bigint[];\n\n    constructor(private quantAmmState: QuantAmmState) {\n        const first = getFirstFourWeightsAndMultipliers(\n            quantAmmState.tokens,\n            quantAmmState.firstFourWeightsAndMultipliers,\n        );\n        const second = getSecondFourWeightsAndMultipliers(\n            quantAmmState.tokens,\n            quantAmmState.secondFourWeightsAndMultipliers,\n        );\n\n        this.weights = [...first.weights, ...second.weights];\n        this.multipliers = [...first.multipliers, ...second.multipliers];\n    }\n\n    getMaximumInvariantRatio(): bigint {\n        return _MAX_INVARIANT_RATIO;\n    }\n\n    getMinimumInvariantRatio(): bigint {\n        return _MIN_INVARIANT_RATIO;\n    }\n\n    getMaxSwapAmount(maxSwapParams: MaxSwapParams): bigint {\n        const {\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            tokenRates,\n            scalingFactors,\n            swapKind,\n        } = maxSwapParams;\n\n        if (swapKind === SwapKind.GivenIn) {\n            const max18 = MathSol.mulDownFixed(\n                balancesLiveScaled18[indexIn],\n                this.quantAmmState.maxTradeSizeRatio,\n            );\n            // Scale to token in (and remove rate)\n            return toRawUndoRateRoundDown(\n                max18,\n                scalingFactors[indexIn],\n                tokenRates[indexIn],\n            );\n        }\n\n        const max18 = MathSol.mulDownFixed(\n            balancesLiveScaled18[indexOut],\n            this.quantAmmState.maxTradeSizeRatio,\n        );\n        // Scale to token out\n        return toRawUndoRateRoundDown(\n            max18,\n            scalingFactors[indexOut],\n            tokenRates[indexOut],\n        );\n    }\n\n    getMaxSingleTokenAddAmount(): bigint {\n        return MAX_UINT256;\n    }\n\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n    ): bigint {\n        const {\n            isExactIn,\n            totalSupply,\n            tokenOutBalance,\n            tokenOutScalingFactor,\n            tokenOutRate,\n        } = maxRemoveParams;\n        return this.getMaxSwapAmount({\n            swapKind: isExactIn ? SwapKind.GivenIn : SwapKind.GivenOut,\n            balancesLiveScaled18: [totalSupply, tokenOutBalance],\n            tokenRates: [1000000000000000000n, tokenOutRate],\n            scalingFactors: [1000000000000000000n, tokenOutScalingFactor],\n            indexIn: 0,\n            indexOut: 1,\n        });\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        const {\n            swapKind,\n            balancesLiveScaled18,\n            indexIn,\n            indexOut,\n            amountGivenScaled18,\n        } = swapParams;\n\n        let multiplierTime = this.quantAmmState.currentTimestamp;\n\n        if (\n            this.quantAmmState.currentTimestamp >=\n            this.quantAmmState.lastInteropTime\n        ) {\n            multiplierTime = this.quantAmmState.lastInteropTime;\n        }\n\n        const timeSinceLastUpdate =\n            multiplierTime - this.quantAmmState.lastUpdateTime;\n\n        // Get current weights based on time interpolation\n        const { tokenInWeight, tokenOutWeight } = this._getNormalizedWeightPair(\n            indexIn,\n            indexOut,\n            timeSinceLastUpdate,\n            this.weights,\n            this.multipliers,\n        );\n\n        if (swapKind === SwapKind.GivenIn) {\n            // Check max trade size ratio\n            if (\n                amountGivenScaled18 >\n                MathSol.mulDownFixed(\n                    balancesLiveScaled18[indexIn],\n                    this.quantAmmState.maxTradeSizeRatio,\n                )\n            ) {\n                throw new Error('MaxTradeSizeRatio exceeded');\n            }\n\n            const amountOutScaled18 = _computeOutGivenExactIn(\n                balancesLiveScaled18[indexIn],\n                tokenInWeight,\n                balancesLiveScaled18[indexOut],\n                tokenOutWeight,\n                amountGivenScaled18,\n            );\n\n            // Check max trade size ratio for output\n            if (\n                amountOutScaled18 >\n                MathSol.mulDownFixed(\n                    balancesLiveScaled18[indexOut],\n                    this.quantAmmState.maxTradeSizeRatio,\n                )\n            ) {\n                throw new Error('MaxTradeSizeRatio exceeded');\n            }\n\n            return amountOutScaled18;\n        } else {\n            // Swap Given Out\n\n            // Check max trade size ratio for output\n            if (\n                amountGivenScaled18 >\n                MathSol.mulDownFixed(\n                    balancesLiveScaled18[indexOut],\n                    this.quantAmmState.maxTradeSizeRatio,\n                )\n            ) {\n                throw new Error('MaxTradeSizeRatio exceeded');\n            }\n\n            const amountInScaled18 = _computeInGivenExactOut(\n                balancesLiveScaled18[indexIn],\n                tokenInWeight,\n                balancesLiveScaled18[indexOut],\n                tokenOutWeight,\n                amountGivenScaled18,\n            );\n\n            // Check max trade size ratio for input\n            if (\n                amountInScaled18 >\n                MathSol.mulDownFixed(\n                    balancesLiveScaled18[indexIn],\n                    this.quantAmmState.maxTradeSizeRatio,\n                )\n            ) {\n                throw new Error('MaxTradeSizeRatio exceeded');\n            }\n\n            return amountInScaled18;\n        }\n    }\n\n    computeInvariant(\n        balancesLiveScaled18: bigint[],\n        rounding: Rounding,\n    ): bigint {\n        let multiplierTime = this.quantAmmState.currentTimestamp;\n\n        if (\n            this.quantAmmState.currentTimestamp >=\n            this.quantAmmState.lastInteropTime\n        ) {\n            multiplierTime = this.quantAmmState.lastInteropTime;\n        }\n\n        const timeSinceLastUpdate =\n            multiplierTime - this.quantAmmState.lastUpdateTime;\n\n        const normalizedWeights = this._getNormalizedWeights(\n            timeSinceLastUpdate,\n            this.weights,\n            this.multipliers,\n        );\n        if (rounding === Rounding.ROUND_UP) {\n            return _computeInvariantUp(normalizedWeights, balancesLiveScaled18);\n        }\n        return _computeInvariantDown(normalizedWeights, balancesLiveScaled18);\n    }\n\n    computeBalance(\n        balancesLiveScaled18: bigint[],\n        tokenInIndex: number,\n        invariantRatio: bigint,\n    ): bigint {\n        let multiplierTime = this.quantAmmState.currentTimestamp;\n\n        if (\n            this.quantAmmState.currentTimestamp >=\n            this.quantAmmState.lastInteropTime\n        ) {\n            multiplierTime = this.quantAmmState.lastInteropTime;\n        }\n\n        const timeSinceLastUpdate =\n            multiplierTime - this.quantAmmState.lastUpdateTime;\n\n        const normalizedWeights = this._getNormalizedWeights(\n            timeSinceLastUpdate,\n            this.weights,\n            this.multipliers,\n        );\n        return _computeBalanceOutGivenInvariant(\n            balancesLiveScaled18[tokenInIndex],\n            normalizedWeights[tokenInIndex],\n            invariantRatio,\n        );\n    }\n\n    private _getNormalizedWeightPair(\n        indexIn: number,\n        indexOut: number,\n        timeSinceLastUpdate: bigint,\n        weights: bigint[],\n        multipliers: bigint[],\n    ): { tokenInWeight: bigint; tokenOutWeight: bigint } {\n        // Calculate weights based on time interpolation\n        const tokenInWeight = calculateBlockNormalisedWeight(\n            weights[indexIn],\n            multipliers[indexIn],\n            timeSinceLastUpdate,\n        );\n\n        const tokenOutWeight = calculateBlockNormalisedWeight(\n            weights[indexOut],\n            multipliers[indexOut],\n            timeSinceLastUpdate,\n        );\n\n        return { tokenInWeight, tokenOutWeight };\n    }\n\n    private _getNormalizedWeights(\n        timeSinceLastUpdate: bigint,\n        weights: bigint[],\n        multipliers: bigint[],\n    ): bigint[] {\n        const normalizedWeights = new Array(weights.length).fill(0n);\n\n        for (let i = 0; i < weights.length; i++) {\n            normalizedWeights[i] = calculateBlockNormalisedWeight(\n                weights[i],\n                multipliers[i],\n                timeSinceLastUpdate,\n            );\n        }\n\n        return normalizedWeights;\n    }\n}\n","import { MathSol, WAD } from '../utils/math';\n\n/**\n * Calculates the normalized weights for a liquidity pool.\n * @param projectTokenIndex Index of the project token.\n * @param currentTime Current timestamp in seconds.\n * @param startTime Start time of the weight change.\n * @param endTime End time of the weight change.\n * @param projectTokenStartWeight Initial weight of the project token.\n * @param projectTokenEndWeight Final weight of the project token.\n * @returns An array of normalized weights for the tokens.\n */\nexport function getNormalizedWeights(\n    projectTokenIndex: number,\n    currentTime: bigint,\n    startTime: bigint,\n    endTime: bigint,\n    projectTokenStartWeight: bigint,\n    projectTokenEndWeight: bigint,\n): bigint[] {\n    const normalizedWeights: bigint[] = [0n, 0n];\n\n    // Infer the reserve token index\n    const reserveTokenIndex = projectTokenIndex === 0 ? 1 : 0;\n\n    // Calculate the normalized weight for the project token\n    normalizedWeights[projectTokenIndex] = getProjectTokenNormalizedWeight(\n        currentTime,\n        startTime,\n        endTime,\n        projectTokenStartWeight,\n        projectTokenEndWeight,\n    );\n\n    // Calculate the normalized weight for the reserve token\n    normalizedWeights[reserveTokenIndex] =\n        WAD - normalizedWeights[projectTokenIndex];\n\n    return normalizedWeights;\n}\n\n// Private helper functions (not exported)\n\n/**\n * Calculates the normalized weight of the project token.\n */\nfunction getProjectTokenNormalizedWeight(\n    currentTime: bigint,\n    startTime: bigint,\n    endTime: bigint,\n    startWeight: bigint,\n    endWeight: bigint,\n): bigint {\n    const pctProgress = calculateValueChangeProgress(\n        currentTime,\n        startTime,\n        endTime,\n    );\n\n    return interpolateValue(startWeight, endWeight, pctProgress);\n}\n\n/**\n * Calculates the progress of a value change as a fixed-point number.\n */\nfunction calculateValueChangeProgress(\n    currentTime: bigint,\n    startTime: bigint,\n    endTime: bigint,\n): bigint {\n    if (currentTime >= endTime) {\n        return WAD; // Fully completed\n    } else if (currentTime <= startTime) {\n        return 0n; // Not started\n    }\n\n    const totalSeconds = endTime - startTime;\n    const secondsElapsed = currentTime - startTime;\n\n    // Ensure MathSol.divDownFixed returns a BigInt\n    const progress = MathSol.divDownFixed(secondsElapsed, totalSeconds);\n    return progress;\n}\n\n/**\n * Interpolates a value based on the progress of a change.\n */\nfunction interpolateValue(\n    startValue: bigint,\n    endValue: bigint,\n    pctProgress: bigint,\n): bigint {\n    if (pctProgress >= WAD || startValue === endValue) {\n        return endValue;\n    }\n\n    if (pctProgress === 0n) {\n        return startValue;\n    }\n\n    if (startValue > endValue) {\n        const delta = MathSol.mulDownFixed(pctProgress, startValue - endValue);\n        return startValue - delta;\n    } else {\n        const delta = MathSol.mulDownFixed(pctProgress, endValue - startValue);\n        return startValue + delta;\n    }\n}\n","import { SwapParams } from '@/vault/types';\nimport { Weighted } from '../weighted/weightedPool';\n\nimport type { LiquidityBootstrappingState } from './data';\n\nimport { getNormalizedWeights } from './liquidityBootstrappingMath';\n\nexport class LiquidityBootstrapping extends Weighted {\n    lbpState: LiquidityBootstrappingState;\n\n    constructor(poolState: LiquidityBootstrappingState) {\n        const projectTokenStartWeight =\n            poolState.startWeights[poolState.projectTokenIndex];\n        const projectTokenEndWeight =\n            poolState.endWeights[poolState.projectTokenIndex];\n\n        const currentTime = poolState.currentTimestamp;\n\n        // calculate weights from the pool state\n        const weights = getNormalizedWeights(\n            poolState.projectTokenIndex,\n            currentTime,\n            poolState.startTime,\n            poolState.endTime,\n            projectTokenStartWeight,\n            projectTokenEndWeight,\n        );\n\n        // weighted pool only requires weights\n        super({ weights });\n\n        this.lbpState = poolState;\n    }\n\n    onSwap(swapParams: SwapParams): bigint {\n        // swap is enabled during the weight change only\n        if (!this.lbpState.isSwapEnabled) {\n            throw new Error('Swap is not enabled');\n        }\n\n        // a custom setting set during pool deployment\n        if (\n            this.lbpState.isProjectTokenSwapInBlocked &&\n            swapParams.indexIn === this.lbpState.projectTokenIndex\n        ) {\n            // regardless of the swap kind, the indexIn is the token going into the pool (being sold)\n            throw new Error('Project token swap in is blocked');\n        }\n\n        // process the swap request\n        return super.onSwap(swapParams);\n    }\n}\n","import { MathSol, MAX_UINT256 } from '../utils/math';\nimport { SwapKind } from '../vault/types';\nimport { WrappingDirection } from './types';\n\nenum Rounding {\n    UP = 0,\n    DOWN = 1,\n}\n\n/*\nSee VaultExtension for SC code.\nInstead of manually adding support for each ERC4626 implementation (e.g. stata with Ray maths)\nwe always use an 18 decimal scaled rate and do 18 decimal maths to convert. \nWe may end up loosing 100% accuracy but thats acceptable.\n*/\nexport function calculateBufferAmounts(\n    direction: WrappingDirection,\n    kind: SwapKind,\n    amountRaw: bigint,\n    rate: bigint,\n    maxDeposit?: bigint,\n    maxMint?: bigint,\n): bigint {\n    if (direction === WrappingDirection.WRAP) {\n        // Amount in is underlying tokens, amount out is wrapped tokens\n        if (kind === SwapKind.GivenIn) {\n            // previewDeposit\n            const maxAssets = maxDeposit ? maxDeposit : MAX_UINT256;\n            if (amountRaw > maxAssets) {\n                throw new Error(\n                    `ERC4626ExceededMaxDeposit ${amountRaw} ${maxAssets}`,\n                );\n            }\n            return _convertToShares(amountRaw, rate, Rounding.DOWN);\n        } else {\n            // previewMint\n            const maxShares = maxMint ? maxMint : MAX_UINT256;\n            if (amountRaw > maxShares) {\n                throw new Error(\n                    `ERC4626ExceededMaxMint ${amountRaw} ${maxMint}`,\n                );\n            }\n            return _convertToAssets(amountRaw, rate, Rounding.UP);\n        }\n    } else {\n        // Amount in is wrapped tokens, amount out is underlying tokens\n        if (kind === SwapKind.GivenIn) {\n            // previewRedeem\n            return _convertToAssets(amountRaw, rate, Rounding.DOWN);\n        } else {\n            // previewWithdraw\n            return _convertToShares(amountRaw, rate, Rounding.UP);\n        }\n    }\n}\n\n// https://github.com/bgd-labs/static-a-token-v3/blob/main/src/interfaces/IStaticATokenLM.sol\nfunction _convertToShares(\n    assets: bigint,\n    rate: bigint,\n    rounding: Rounding,\n): bigint {\n    if (rounding === Rounding.UP) return MathSol.divUpFixed(assets, rate);\n    return MathSol.divDownFixed(assets, rate);\n}\n\nfunction _convertToAssets(\n    shares: bigint,\n    rate: bigint,\n    rounding: Rounding,\n): bigint {\n    if (rounding === Rounding.UP) return MathSol.mulUpFixed(shares, rate);\n    return MathSol.mulDownFixed(shares, rate);\n}\n","import { BufferState } from '../buffer/data';\nimport { isSameAddress } from '../vault/utils';\nimport { SwapInput } from '../vault/types';\nimport { calculateBufferAmounts } from './bufferMath';\nimport { WrappingDirection } from './types';\n\nconst _MINIMUM_WRAP_AMOUNT = 1000n;\n\nexport function erc4626BufferWrapOrUnwrap(\n    input: SwapInput,\n    poolState: BufferState,\n): bigint {\n    if (input.amountRaw < _MINIMUM_WRAP_AMOUNT) {\n        // If amount given is too small, rounding issues can be introduced that favors the user and can drain\n        // the buffer. _MINIMUM_WRAP_AMOUNT prevents it. Most tokens have protections against it already, this\n        // is just an extra layer of security.\n        throw new Error('wrapAmountTooSmall');\n    }\n    const wrappingDirection = isSameAddress(\n        input.tokenIn,\n        poolState.poolAddress,\n    )\n        ? WrappingDirection.UNWRAP\n        : WrappingDirection.WRAP;\n\n    return calculateBufferAmounts(\n        wrappingDirection,\n        input.swapKind,\n        input.amountRaw,\n        poolState.rate,\n        poolState.maxDeposit,\n        poolState.maxMint,\n    );\n}\n","import { HookBase } from './types';\n\nexport const defaultHook: HookBase = {\n    shouldCallComputeDynamicSwapFee: false,\n    shouldCallBeforeSwap: false,\n    shouldCallAfterSwap: false,\n    shouldCallBeforeAddLiquidity: false,\n    shouldCallAfterAddLiquidity: false,\n    shouldCallBeforeRemoveLiquidity: false,\n    shouldCallAfterRemoveLiquidity: false,\n    enableHookAdjustedAmounts: false,\n    onBeforeAddLiquidity: () => {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    },\n    onAfterAddLiquidity: () => {\n        return { success: false, hookAdjustedAmountsInRaw: [] };\n    },\n    onBeforeRemoveLiquidity: () => {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    },\n    onAfterRemoveLiquidity: () => {\n        return { success: false, hookAdjustedAmountsOutRaw: [] };\n    },\n    onBeforeSwap: () => {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    },\n    onAfterSwap: () => {\n        return { success: false, hookAdjustedAmountCalculatedRaw: 0n };\n    },\n    onComputeDynamicSwapFee: () => {\n        return { success: false, dynamicSwapFee: 0n };\n    },\n};\n","import { RemoveKind } from '../vault/types';\nimport { HookBase, HookStateBase } from './types';\nimport { MathSol } from '../utils/math';\n\nexport type HookStateExitFee = HookStateBase & {\n    hookType: 'ExitFee';\n    tokens: string[];\n    removeLiquidityHookFeePercentage: bigint;\n};\n\n/**\n * This hook implements the ExitFeeHookExample found in mono-repo: https://github.com/balancer/balancer-v3-monorepo/blob/c848c849cb44dc35f05d15858e4fba9f17e92d5e/pkg/pool-hooks/contracts/ExitFeeHookExample.sol\n */\nexport class ExitFeeHook implements HookBase {\n    public shouldCallComputeDynamicSwapFee = false;\n    public shouldCallBeforeSwap = false;\n    public shouldCallAfterSwap = false;\n    public shouldCallBeforeAddLiquidity = false;\n    public shouldCallAfterAddLiquidity = false;\n    public shouldCallBeforeRemoveLiquidity = false;\n    public shouldCallAfterRemoveLiquidity = true;\n    public enableHookAdjustedAmounts = true;\n\n    onBeforeAddLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n    onAfterAddLiquidity() {\n        return { success: false, hookAdjustedAmountsInRaw: [] };\n    }\n    onBeforeRemoveLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n    onAfterRemoveLiquidity(\n        kind: RemoveKind,\n        bptAmountIn: bigint,\n        amountsOutScaled18: bigint[],\n        amountsOutRaw: bigint[],\n        balancesScaled18: bigint[],\n        hookState: HookStateExitFee,\n    ) {\n        if (\n            !(\n                typeof hookState === 'object' &&\n                hookState !== null &&\n                'removeLiquidityHookFeePercentage' in hookState &&\n                'tokens' in hookState\n            )\n        )\n            throw new Error('Unexpected hookState');\n\n        // Our current architecture only supports fees on tokens. Since we must always respect exact `amountsOut`, and\n        // non-proportional remove liquidity operations would require taking fees in BPT, we only support proportional\n        // removeLiquidity.\n        if (kind !== RemoveKind.PROPORTIONAL) {\n            throw new Error(`ExitFeeHook: Unsupported RemoveKind: ${kind}`);\n        }\n        const accruedFees = new Array(hookState.tokens.length).fill(0n);\n        const hookAdjustedAmountsOutRaw = [...amountsOutRaw];\n        if (hookState.removeLiquidityHookFeePercentage > 0) {\n            // Charge fees proportional to amounts out of each token\n            for (let i = 0; i < amountsOutRaw.length; i++) {\n                const hookFee = MathSol.mulDownFixed(\n                    amountsOutRaw[i],\n                    hookState.removeLiquidityHookFeePercentage,\n                );\n                accruedFees[i] = hookFee;\n                hookAdjustedAmountsOutRaw[i] -= hookFee;\n                // Fees don't need to be transferred to the hook, because donation will reinsert them in the vault\n            }\n\n            // In SC Hook Donates accrued fees back to LPs\n            // _vault.addLiquidity(\n            //     AddLiquidityParams({\n            //         pool: pool,\n            //         to: msg.sender, // It would mint BPTs to router, but it's a donation so no BPT is minted\n            //         maxAmountsIn: accruedFees, // Donate all accrued fees back to the pool (i.e. to the LPs)\n            //         minBptAmountOut: 0, // Donation does not return BPTs, any number above 0 will revert\n            //         kind: AddLiquidityKind.DONATION,\n            //         userData: bytes(''), // User data is not used by donation, so we can set to an empty string\n            //     }),\n            // );\n        }\n\n        return {\n            success: true,\n            hookAdjustedAmountsOutRaw,\n        };\n    }\n    onBeforeSwap() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n    onAfterSwap() {\n        return { success: false, hookAdjustedAmountCalculatedRaw: 0n };\n    }\n    onComputeDynamicSwapFee() {\n        return { success: false, dynamicSwapFee: 0n };\n    }\n}\n","import { HookBase } from './types';\nimport { MathSol } from '../utils/math';\nimport { SwapParams } from '@/vault/types';\n\nexport class DirectionalFeeHook implements HookBase {\n    public shouldCallComputeDynamicSwapFee = true;\n    public shouldCallBeforeSwap = false;\n    public shouldCallAfterSwap = false;\n    public shouldCallBeforeAddLiquidity = false;\n    public shouldCallAfterAddLiquidity = false;\n    public shouldCallBeforeRemoveLiquidity = false;\n    public shouldCallAfterRemoveLiquidity = false;\n    public enableHookAdjustedAmounts = false;\n\n    onComputeDynamicSwapFee(\n        params: SwapParams,\n        pool: string,\n        staticSwapFeePercentage: bigint,\n    ): { success: boolean; dynamicSwapFee: bigint } {\n        const calculatedSwapFeePercentage =\n            this.calculateExpectedSwapFeePercentage(\n                params.balancesLiveScaled18,\n                params.amountGivenScaled18,\n                params.indexIn,\n                params.indexOut,\n            );\n\n        // Charge the static or calculated fee, whichever is greater.\n        const dynamicSwapFee =\n            calculatedSwapFeePercentage > staticSwapFeePercentage\n                ? calculatedSwapFeePercentage\n                : staticSwapFeePercentage;\n\n        return {\n            success: true,\n            dynamicSwapFee: dynamicSwapFee,\n        };\n    }\n\n    // the bigger the swap ( relative to pool size ) the bigger the fee\n    private calculateExpectedSwapFeePercentage(\n        poolBalances: bigint[],\n        swapAmount: bigint,\n        indexIn: number,\n        indexOut: number,\n    ): bigint {\n        const finalBalanceTokenIn = poolBalances[indexIn] + swapAmount;\n        const finalBalanceTokenOut = poolBalances[indexOut] - swapAmount;\n\n        if (finalBalanceTokenIn > finalBalanceTokenOut) {\n            const diff = finalBalanceTokenIn - finalBalanceTokenOut;\n            const totalLiquidity = finalBalanceTokenIn + finalBalanceTokenOut;\n\n            return MathSol.divDownFixed(diff, totalLiquidity);\n        }\n\n        return 0n;\n    }\n\n    onBeforeAddLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterAddLiquidity() {\n        return { success: false, hookAdjustedAmountsInRaw: [] };\n    }\n\n    onBeforeRemoveLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterRemoveLiquidity() {\n        return { success: false, hookAdjustedAmountsOutRaw: [] };\n    }\n\n    onBeforeSwap() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterSwap() {\n        return { success: false, hookAdjustedAmountCalculatedRaw: 0n };\n    }\n}\n\nexport default DirectionalFeeHook;\n","import { HookBase, HookStateBase } from './types';\nimport { MathSol } from '../utils/math';\nimport { SwapKind, SwapParams } from '../vault/types';\nimport { Stable } from '../stable';\n\nexport type HookStateStableSurge = HookStateBase & {\n    hookType: 'StableSurge';\n    amp: bigint;\n    surgeThresholdPercentage: bigint;\n    maxSurgeFeePercentage: bigint;\n};\n\n// Implementation from mono-repo commit: 1c9d6a2913eb2d1210019455b44192760d9beb03\nexport class StableSurgeHook implements HookBase {\n    public shouldCallComputeDynamicSwapFee = true;\n    public shouldCallBeforeSwap = false;\n    public shouldCallAfterSwap = false;\n    public shouldCallBeforeAddLiquidity = false;\n    public shouldCallAfterAddLiquidity = false;\n    public shouldCallBeforeRemoveLiquidity = false;\n    public shouldCallAfterRemoveLiquidity = false;\n    public enableHookAdjustedAmounts = false;\n\n    onComputeDynamicSwapFee(\n        params: SwapParams,\n        pool: string,\n        staticSwapFeePercentage: bigint,\n        hookState: HookStateStableSurge,\n    ): { success: boolean; dynamicSwapFee: bigint } {\n        const stablePool = new Stable(hookState);\n\n        return {\n            success: true,\n            dynamicSwapFee: this.getSurgeFeePercentage(\n                params,\n                stablePool,\n                hookState.surgeThresholdPercentage,\n                hookState.maxSurgeFeePercentage,\n                staticSwapFeePercentage,\n            ),\n        };\n    }\n\n    private getSurgeFeePercentage(\n        params: SwapParams,\n        pool: Stable,\n        surgeThresholdPercentage: bigint,\n        maxSurgeFeePercentage: bigint,\n        staticFeePercentage: bigint,\n    ): bigint {\n        const amountCalculatedScaled18 = pool.onSwap(params);\n        const newBalances = [...params.balancesLiveScaled18];\n\n        if (params.swapKind === SwapKind.GivenIn) {\n            newBalances[params.indexIn] += params.amountGivenScaled18;\n            newBalances[params.indexOut] -= amountCalculatedScaled18;\n        } else {\n            newBalances[params.indexIn] += amountCalculatedScaled18;\n            newBalances[params.indexOut] -= params.amountGivenScaled18;\n        }\n\n        const newTotalImbalance = this.calculateImbalance([...newBalances]);\n\n        // If we are balanced, or the balance has improved, do not surge: simply return the regular fee percentage.\n        if (newTotalImbalance === 0n) {\n            return staticFeePercentage;\n        }\n\n        const oldTotalImbalance = this.calculateImbalance([\n            ...params.balancesLiveScaled18,\n        ]);\n\n        if (\n            newTotalImbalance <= oldTotalImbalance ||\n            newTotalImbalance <= surgeThresholdPercentage\n        ) {\n            return staticFeePercentage;\n        }\n\n        // surgeFee = staticFee + (maxFee - staticFee) * (pctImbalance - pctThreshold) / (1 - pctThreshold).\n        //\n        // As you can see from the formula, if it’s unbalanced exactly at the threshold, the last term is 0,\n        // and the fee is just: static + 0 = static fee.\n        // As the unbalanced proportion term approaches 1, the fee surge approaches: static + max - static ~= max fee.\n        // This formula linearly increases the fee from 0 at the threshold up to the maximum fee.\n        // At 35%, the fee would be 1% + (0.95 - 0.01) * ((0.35 - 0.3)/(0.95-0.3)) = 1% + 0.94 * 0.0769 ~ 8.2%.\n        // At 50% unbalanced, the fee would be 44%. At 99% unbalanced, the fee would be ~94%, very close to the maximum.\n        const dynamicSwapFee =\n            staticFeePercentage +\n            MathSol.mulDownFixed(\n                maxSurgeFeePercentage - staticFeePercentage,\n                MathSol.divDownFixed(\n                    newTotalImbalance - surgeThresholdPercentage,\n                    MathSol.complementFixed(surgeThresholdPercentage),\n                ),\n            );\n        return dynamicSwapFee;\n    }\n\n    private calculateImbalance(balances: bigint[]): bigint {\n        const median = this.findMedian(balances);\n\n        let totalBalance = 0n;\n        let totalDiff = 0n;\n\n        for (let i = 0; i < balances.length; i++) {\n            totalBalance += balances[i];\n            totalDiff += this.absSub(balances[i], median);\n        }\n\n        return MathSol.divDownFixed(totalDiff, totalBalance);\n    }\n\n    private findMedian(balances: bigint[]): bigint {\n        const sortedBalances = balances.sort((a, b) => {\n            if (a < b) return -1;\n            if (a > b) return 1;\n            return 0;\n        });\n        const mid = Math.floor(sortedBalances.length / 2);\n\n        if (sortedBalances.length % 2 == 0) {\n            return (sortedBalances[mid - 1] + sortedBalances[mid]) / 2n;\n        } else {\n            return sortedBalances[mid];\n        }\n    }\n\n    private absSub(a: bigint, b: bigint): bigint {\n        return a > b ? a - b : b - a;\n    }\n\n    onBeforeAddLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterAddLiquidity() {\n        return { success: false, hookAdjustedAmountsInRaw: [] };\n    }\n\n    onBeforeRemoveLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterRemoveLiquidity() {\n        return { success: false, hookAdjustedAmountsOutRaw: [] };\n    }\n\n    onBeforeSwap() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterSwap() {\n        return { success: false, hookAdjustedAmountCalculatedRaw: 0n };\n    }\n}\n\nexport default StableSurgeHook;\n","import { MathSol, WAD } from '../../utils/math';\n\n// A minimum normalized weight imposes a maximum weight ratio. We need this due to limitations in the\n// implementation of the power function, as these ratios are often exponents.\nexport const _MIN_WEIGHT = BigInt(0.01e18);\n\n// Pool limits that arise from limitations in the fixed point power function (and the imposed 1:100 maximum weight\n// ratio).\n\nexport const _computeSwapFeePercentageGivenExactIn = (\n    balanceIn: bigint,\n    exponent: bigint,\n    amountIn: bigint,\n): bigint => {\n    /**********************************************************************************************\n    // outGivenExactInWithFees                                                                   //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /      /            bI + aI        \\    (wI / wO) \\           //\n    // aI = amountIn    aO = bO * |  1 - | --------------------------  | ^            |          //\n    // wI = weightIn               \\      \\       ( bI + aI * 2 )     /              /           //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // swap fee is equal to outGivenExactIn(grossAmountIn) - outGivenExactInWithFees(grossAmountIn)\n    const powerWithFees = MathSol.powUpFixed(\n        MathSol.divUpFixed(\n            balanceIn + amountIn,\n            balanceIn + amountIn * BigInt(2),\n        ),\n        exponent,\n    );\n    const powerWithoutFees = MathSol.powUpFixed(\n        MathSol.divUpFixed(balanceIn, balanceIn + amountIn),\n        exponent,\n    );\n\n    return MathSol.mulDivUpFixed(\n        exponent,\n        MathSol.mulDivUpFixed(\n            balanceIn + amountIn,\n            powerWithFees - powerWithoutFees,\n            powerWithFees,\n        ),\n        amountIn,\n    );\n};\n\nexport const _computeSwapFeePercentageGivenExactOut = (\n    balanceOut: bigint,\n    exponent: bigint,\n    amountOut: bigint,\n): bigint => {\n    /**********************************************************************************************\n    // inGivenExactOutWithFees                                                                   //\n    // aO = amountOut                                                                            //\n    // bO = balanceOut                                                                           //\n    // bI = balanceIn              /  /        bO - aO            \\    (wO / wI)      \\          //\n    // aI = amountIn    aI = bI * |  | --------------------------  | ^            - 1  |         //\n    // wI = weightIn               \\  \\     ( bO - aO * 2)        /                   /          //\n    // wO = weightOut                                                                            //\n    **********************************************************************************************/\n\n    // swap fee is equal to inGivenExactOutWithFees(grossAmountIn) - inGivenExactOut(grossAmountIn)\n\n    const powerWithFees = MathSol.powUpFixed(\n        MathSol.divUpFixed(\n            balanceOut - amountOut,\n            balanceOut - amountOut * BigInt(2),\n        ),\n        exponent,\n    );\n    const powerWithoutFees = MathSol.powUpFixed(\n        MathSol.divUpFixed(balanceOut, balanceOut - amountOut),\n        exponent,\n    );\n\n    return MathSol.divUpFixed(\n        powerWithFees - powerWithoutFees,\n        powerWithFees - WAD,\n    );\n};\n","import { MathSol } from '../../utils/math';\nimport { HookBase, HookStateBase } from '../types';\nimport { SwapParams, SwapKind } from '../../vault/types';\nimport {\n    _computeSwapFeePercentageGivenExactIn,\n    _computeSwapFeePercentageGivenExactOut,\n} from './akronWeightedMath';\n\nexport type HookStateAkron = HookStateBase & {\n    hookType: 'Akron';\n    weights: bigint[];\n    minimumSwapFeePercentage: bigint;\n};\n\nexport class AkronHook implements HookBase {\n    public shouldCallComputeDynamicSwapFee = true;\n    public shouldCallBeforeSwap = false;\n    public shouldCallAfterSwap = false;\n    public shouldCallBeforeAddLiquidity = false;\n    public shouldCallAfterAddLiquidity = false;\n    public shouldCallBeforeRemoveLiquidity = false;\n    public shouldCallAfterRemoveLiquidity = false;\n    public enableHookAdjustedAmounts = false;\n\n    onComputeDynamicSwapFee(\n        params: SwapParams,\n        pool: string,\n        staticSwapFeePercentage: bigint,\n        hookState: HookStateAkron,\n    ): { success: boolean; dynamicSwapFee: bigint } {\n        const calculatedSwapFeePercentage =\n            params.swapKind === SwapKind.GivenIn\n                ? _computeSwapFeePercentageGivenExactIn(\n                      params.balancesLiveScaled18[params.indexIn],\n                      MathSol.divDownFixed(\n                          hookState.weights[params.indexIn],\n                          hookState.weights[params.indexOut],\n                      ),\n                      params.amountGivenScaled18,\n                  )\n                : _computeSwapFeePercentageGivenExactOut(\n                      params.balancesLiveScaled18[params.indexOut],\n                      MathSol.divUpFixed(\n                          hookState.weights[params.indexOut],\n                          hookState.weights[params.indexIn],\n                      ),\n                      params.amountGivenScaled18,\n                  );\n\n        // Charge the static or calculated fee, whichever is greater.\n        const dynamicSwapFee =\n            hookState.minimumSwapFeePercentage > calculatedSwapFeePercentage\n                ? hookState.minimumSwapFeePercentage\n                : calculatedSwapFeePercentage;\n\n        return {\n            success: true,\n            dynamicSwapFee: dynamicSwapFee,\n        };\n    }\n\n    onBeforeAddLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterAddLiquidity() {\n        return { success: false, hookAdjustedAmountsInRaw: [] };\n    }\n\n    onBeforeRemoveLiquidity() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterRemoveLiquidity() {\n        return { success: false, hookAdjustedAmountsOutRaw: [] };\n    }\n\n    onBeforeSwap() {\n        return { success: false, hookAdjustedBalancesScaled18: [] };\n    }\n\n    onAfterSwap() {\n        return { success: false, hookAdjustedAmountCalculatedRaw: 0n };\n    }\n}\n\nexport default AkronHook;\n","import { MathSol, WAD } from '../utils/math';\nimport {\n    computeAddLiquiditySingleTokenExactOut,\n    computeAddLiquidityUnbalanced,\n    computeProportionalAmountsOut,\n    computeRemoveLiquiditySingleTokenExactIn,\n    computeRemoveLiquiditySingleTokenExactOut,\n} from './basePoolMath';\nimport { Weighted } from '../weighted';\nimport { Stable } from '../stable';\nimport { GyroECLP } from '../gyro';\nimport { ReClamm } from '../reClamm';\nimport { ReClammV2 } from '../reClammV2';\nimport { QuantAmm } from '../quantAmm';\nimport { LiquidityBootstrapping } from '../liquidityBootstrapping';\n\nimport { BufferState, erc4626BufferWrapOrUnwrap } from '../buffer';\nimport {\n    isSameAddress,\n    toRawUndoRateRoundDown,\n    toRawUndoRateRoundUp,\n    toScaled18ApplyRateRoundDown,\n    toScaled18ApplyRateRoundUp,\n} from './utils';\nimport {\n    AddKind,\n    AddLiquidityInput,\n    MaxSingleTokenRemoveParams,\n    MaxSwapParams,\n    PoolBase,\n    PoolState,\n    RemoveKind,\n    RemoveLiquidityInput,\n    SwapInput,\n    SwapKind,\n    SwapParams,\n} from './types';\nimport { HookBase, HookClassConstructor, HookState } from '../hooks/types';\nimport { defaultHook } from '../hooks/constants';\nimport { ExitFeeHook } from '../hooks/exitFeeHook';\nimport { DirectionalFeeHook } from '../hooks/directionalFeeHook';\nimport { StableSurgeHook } from '../hooks/stableSurgeHook';\nimport { AkronHook } from '../hooks/akron/akronHook';\n\nconst _MINIMUM_TRADE_AMOUNT = 1e6;\n// const _MINIMUM_WRAP_AMOUNT = 1e3;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype PoolClassConstructor = new (..._args: any[]) => PoolBase;\ntype PoolClasses = Readonly<Record<string, PoolClassConstructor>>;\nexport type HookClasses = Readonly<Record<string, HookClassConstructor>>;\n\nexport class Vault {\n    private readonly poolClasses: PoolClasses = {} as const;\n    private readonly hookClasses: HookClasses = {} as const;\n\n    constructor(config?: {\n        customPoolClasses?: PoolClasses;\n        customHookClasses?: HookClasses;\n    }) {\n        const { customPoolClasses, customHookClasses: hookClasses } =\n            config || {};\n        this.poolClasses = {\n            WEIGHTED: Weighted,\n            STABLE: Stable,\n            GYROE: GyroECLP,\n            RECLAMM: ReClamm,\n            RECLAMM_V2: ReClammV2,\n            LIQUIDITY_BOOTSTRAPPING: LiquidityBootstrapping,\n            QUANT_AMM_WEIGHTED: QuantAmm,\n            // custom add liquidity types take precedence over base types\n            ...customPoolClasses,\n        };\n        this.hookClasses = {\n            ExitFee: ExitFeeHook,\n            DirectionalFee: DirectionalFeeHook,\n            StableSurge: StableSurgeHook,\n            Akron: AkronHook,\n            // custom hooks take precedence over base types\n            ...hookClasses,\n        };\n    }\n\n    public getPool(poolState: PoolState): PoolBase {\n        const poolClass = this.poolClasses[poolState.poolType];\n        if (!poolClass)\n            throw new Error(`Unsupported Pool Type: ${poolState.poolType}`);\n        return new poolClass(poolState);\n    }\n\n    public getHook(\n        hookName?: string,\n        hookState?: HookState | unknown,\n    ): HookBase {\n        if (!hookName) return defaultHook;\n        const hookClass = this.hookClasses[hookName];\n        if (!hookClass) throw new Error(`Unsupported Hook Type: ${hookName}`);\n        if (!hookState) throw new Error(`No state for Hook: ${hookName}`);\n        return new hookClass(hookState);\n    }\n\n    /**\n     * Returns the max amount that can be swapped (in relation to the amount specified by user).\n     * @param maxSwapParams\n     * @returns Returned amount/scaling is respective to the tokenOut because that’s what we’re taking out of the pool and what limits the swap size.\n     */\n    getMaxSwapAmount(swapParams: MaxSwapParams, poolState: PoolState): bigint {\n        const pool = this.getPool(poolState);\n        return pool.getMaxSwapAmount(swapParams);\n    }\n\n    /**\n     * Returns the max amount of a single token that can be added to a pool.\n     * @param poolState\n     * @returns\n     */\n    getMaxSingleTokenAddAmount(poolState: PoolState): bigint {\n        const pool = this.getPool(poolState);\n        return pool.getMaxSingleTokenAddAmount();\n    }\n\n    /**\n     * Returns the max amount of a single token that can be removed from a pool.\n     * @param maxRemoveParams\n     * @param poolState\n     * @returns\n     */\n    getMaxSingleTokenRemoveAmount(\n        maxRemoveParams: MaxSingleTokenRemoveParams,\n        poolState: PoolState,\n    ): bigint {\n        const pool = this.getPool(poolState);\n        return pool.getMaxSingleTokenRemoveAmount(maxRemoveParams);\n    }\n\n    /**\n     * Calculates the result of a swap.\n     *\n     * @param swapInput - User defined input for a swap operation, including:\n     *   - `amountRaw`: Raw amount for swap (e.g. 1USDC=1000000).\n     *   - `tokenIn`: Address of token in.\n     *   - `tokenOut`: Address of token out.\n     *   - `swapKind`: GivenIn or GivenOut.\n     * @param poolState - Pool state that will be used for calculations.\n     *   - Note: rates, fees, totalSupply use scaled 18. For detailed information, refer to the `PoolState | BufferState` types.\n     * @param hookState - Optional state for any associated hook. Required if pool has a hook enabled.\n     *   - Note: Each hook will require its own state data. See `HookState` type for officially supported hook info.\n     * @returns The raw result of the swap operation.\n     */\n    public swap(\n        swapInput: SwapInput,\n        poolState: PoolState | BufferState,\n        hookState?: HookState | unknown,\n    ): bigint {\n        if (swapInput.amountRaw === 0n) return 0n;\n\n        // buffer is handled separately than a \"normal\" pool\n        if (!('totalSupply' in poolState)) {\n            return erc4626BufferWrapOrUnwrap(swapInput, poolState);\n        }\n\n        const pool = this.getPool(poolState);\n        const hook = this.getHook(poolState.hookType, hookState);\n\n        const inputIndex = poolState.tokens.findIndex((t) =>\n            isSameAddress(swapInput.tokenIn, t),\n        );\n        if (inputIndex === -1) throw Error('Input token not found on pool');\n\n        const outputIndex = poolState.tokens.findIndex((t) =>\n            isSameAddress(swapInput.tokenOut, t),\n        );\n        if (outputIndex === -1) throw Error('Output token not found on pool');\n\n        const amountGivenScaled18 = this._computeAmountGivenScaled18(\n            swapInput.amountRaw,\n            swapInput.swapKind,\n            inputIndex,\n            outputIndex,\n            poolState.scalingFactors,\n            poolState.tokenRates,\n        );\n\n        const updatedBalancesLiveScaled18 = [...poolState.balancesLiveScaled18];\n\n        const swapParams: SwapParams = {\n            swapKind: swapInput.swapKind,\n            amountGivenScaled18,\n            balancesLiveScaled18: updatedBalancesLiveScaled18,\n            indexIn: inputIndex,\n            indexOut: outputIndex,\n        };\n\n        if (hook.shouldCallBeforeSwap) {\n            /* \n            Note - in SC balances and amounts are updated to reflect any rate change.\n            Daniel said we should not worry about this as any large rate changes will mean something has gone wrong.\n            We do take into account and balance changes due to hook using hookAdjustedBalancesScaled18.\n            */\n            const { success, hookAdjustedBalancesScaled18 } = hook.onBeforeSwap(\n                {\n                    ...swapParams,\n                    hookState,\n                },\n            );\n            if (!success) throw new Error('BeforeSwapHookFailed');\n            hookAdjustedBalancesScaled18.forEach(\n                (a, i) => (updatedBalancesLiveScaled18[i] = a),\n            );\n        }\n\n        let swapFee = poolState.swapFee;\n        if (hook.shouldCallComputeDynamicSwapFee) {\n            const { success, dynamicSwapFee } = hook.onComputeDynamicSwapFee(\n                swapParams,\n                poolState.poolAddress,\n                poolState.swapFee,\n                hookState,\n            );\n            if (success) swapFee = dynamicSwapFee;\n        }\n\n        // _swap()\n\n        let totalSwapFeeAmountScaled18 = 0n;\n        if (swapParams.swapKind === SwapKind.GivenIn) {\n            // Round up to avoid losses during precision loss.\n            totalSwapFeeAmountScaled18 = MathSol.mulUpFixed(\n                swapParams.amountGivenScaled18,\n                swapFee,\n            );\n            swapParams.amountGivenScaled18 -= totalSwapFeeAmountScaled18;\n        }\n\n        this._ensureValidSwapAmount(swapParams.amountGivenScaled18);\n\n        let amountCalculatedScaled18 = pool.onSwap(swapParams);\n\n        this._ensureValidSwapAmount(amountCalculatedScaled18);\n\n        let amountCalculatedRaw = 0n;\n        if (swapInput.swapKind === SwapKind.GivenIn) {\n            // For `ExactIn` the amount calculated is leaving the Vault, so we round down.\n            amountCalculatedRaw = toRawUndoRateRoundDown(\n                amountCalculatedScaled18,\n                poolState.scalingFactors[outputIndex],\n                // If the swap is ExactIn, the amountCalculated is the amount of tokenOut. So, we want to use the rate\n                // rounded up to calculate the amountCalculatedRaw, because scale down (undo rate) is a division, the\n                // larger the rate, the smaller the amountCalculatedRaw. So, any rounding imprecision will stay in the\n                // Vault and not be drained by the user.\n                this._computeRateRoundUp(poolState.tokenRates[outputIndex]),\n            );\n        } else {\n            // To ensure symmetry with EXACT_IN, the swap fee used by ExactOut is\n            // `amountCalculated * fee% / (100% - fee%)`. Add it to the calculated amountIn. Round up to avoid losses\n            // during precision loss.\n            totalSwapFeeAmountScaled18 = MathSol.mulDivUpFixed(\n                amountCalculatedScaled18,\n                swapFee,\n                MathSol.complementFixed(swapFee),\n            );\n\n            amountCalculatedScaled18 += totalSwapFeeAmountScaled18;\n\n            // For `ExactOut` the amount calculated is entering the Vault, so we round up.\n            amountCalculatedRaw = toRawUndoRateRoundUp(\n                amountCalculatedScaled18,\n                poolState.scalingFactors[inputIndex],\n                poolState.tokenRates[inputIndex],\n            );\n        }\n\n        const aggregateSwapFeeAmountScaled18 =\n            this._computeAndChargeAggregateSwapFees(\n                totalSwapFeeAmountScaled18,\n                poolState.aggregateSwapFee,\n                poolState.scalingFactors,\n                poolState.tokenRates,\n                inputIndex,\n            );\n\n        // For ExactIn, we increase the tokenIn balance by `amountIn`, and decrease the tokenOut balance by the\n        // (`amountOut` + fees).\n        // For ExactOut, we increase the tokenInBalance by (`amountIn` - fees), and decrease the tokenOut balance by\n        // `amountOut`.\n        const locals = {\n            balanceInIncrement: 0n,\n            balanceOutDecrement: 0n,\n        };\n\n        // Perform the conditional assignment using destructuring\n        [locals.balanceInIncrement, locals.balanceOutDecrement] =\n            swapInput.swapKind === SwapKind.GivenIn\n                ? [\n                      amountGivenScaled18 - aggregateSwapFeeAmountScaled18,\n                      amountCalculatedScaled18,\n                  ]\n                : [\n                      amountCalculatedScaled18 - aggregateSwapFeeAmountScaled18,\n                      amountGivenScaled18,\n                  ];\n\n        updatedBalancesLiveScaled18[inputIndex] += locals.balanceInIncrement;\n        updatedBalancesLiveScaled18[outputIndex] -= locals.balanceOutDecrement;\n\n        if (hook.shouldCallAfterSwap) {\n            const { success, hookAdjustedAmountCalculatedRaw } =\n                hook.onAfterSwap({\n                    kind: swapInput.swapKind,\n                    tokenIn: swapInput.tokenIn,\n                    tokenOut: swapInput.tokenOut,\n                    amountInScaled18:\n                        swapInput.swapKind === SwapKind.GivenIn\n                            ? amountGivenScaled18\n                            : amountCalculatedScaled18,\n                    amountOutScaled18:\n                        swapInput.swapKind === SwapKind.GivenIn\n                            ? amountCalculatedScaled18\n                            : amountGivenScaled18,\n                    tokenInBalanceScaled18:\n                        updatedBalancesLiveScaled18[inputIndex],\n                    tokenOutBalanceScaled18:\n                        updatedBalancesLiveScaled18[outputIndex],\n                    amountCalculatedScaled18: amountCalculatedScaled18,\n                    amountCalculatedRaw: amountCalculatedRaw,\n                    hookState: hookState,\n                });\n            if (success === false) {\n                throw new Error(\n                    `AfterAddSwapHookFailed ${poolState.poolType} ${poolState.hookType}`,\n                );\n            }\n            // If hook adjusted amounts is not enabled, ignore amount returned by the hook\n            if (hook.enableHookAdjustedAmounts)\n                amountCalculatedRaw = hookAdjustedAmountCalculatedRaw;\n        }\n\n        return amountCalculatedRaw;\n    }\n\n    /**\n     * Calculates the amount of BPT for a given add liquidity operation.\n     *\n     * @param addLiquidityInput - User defined input for an addLiquidity operation.\n     *   - For detailed information refer to the `AddLiquidityInput` type.\n     * @param poolState - Pool state that will be used for calculations.\n     *   - Note: rates, fees, totalSupply use scaled 18. For detailed information, refer to the `PoolState` type.\n     * @param hookState - Optional state for any associated hook. Required if pool has a hook enabled.\n     *   - Note: Each hook will require its own state data. See `HookState` type for officially supported hook info.\n     * @returns {Object} An object containing the raw input amounts and the calculated raw BPT output amount.\n     * @returns {bigint[]} returns.amountsInRaw - An array of raw input amounts in.\n     * @returns {bigint} returns.bptAmountOutRaw - The calculated raw BPT output amount.\n     */\n    public addLiquidity(\n        addLiquidityInput: AddLiquidityInput,\n        poolState: PoolState,\n        hookState?: HookState | unknown,\n    ): { amountsInRaw: bigint[]; bptAmountOutRaw: bigint } {\n        if (poolState.poolType === 'Buffer')\n            throw Error('Buffer pools do not support addLiquidity');\n\n        const pool = this.getPool(poolState);\n        const hook = this.getHook(poolState.hookType, hookState);\n\n        // Amounts are entering pool math, so round down.\n        // Introducing amountsInScaled18 here and passing it through to _addLiquidity is not ideal,\n        // but it avoids the even worse options of mutating amountsIn inside AddLiquidityParams,\n        // or cluttering the AddLiquidityParams interface by adding amountsInScaled18.\n        const maxAmountsInScaled18 =\n            this._copyToScaled18ApplyRateRoundDownArray(\n                addLiquidityInput.maxAmountsInRaw,\n                poolState.scalingFactors,\n                poolState.tokenRates,\n            );\n\n        const updatedBalancesLiveScaled18 = [...poolState.balancesLiveScaled18];\n\n        if (hook.shouldCallBeforeAddLiquidity) {\n            /* \n            Note - in SC balances and amounts are updated to reflect any rate change.\n            Daniel said we should not worry about this as any large rate changes will mean something has gone wrong.\n            We do take into account and balance changes due to hook using hookAdjustedBalancesScaled18.\n            */\n            const { success, hookAdjustedBalancesScaled18 } =\n                hook.onBeforeAddLiquidity(\n                    addLiquidityInput.kind,\n                    addLiquidityInput.maxAmountsInRaw,\n                    addLiquidityInput.minBptAmountOutRaw,\n                    updatedBalancesLiveScaled18,\n                    hookState,\n                );\n            if (!success) throw new Error('BeforeAddLiquidityHookFailed');\n            hookAdjustedBalancesScaled18.forEach(\n                (a, i) => (updatedBalancesLiveScaled18[i] = a),\n            );\n        }\n\n        let amountsInScaled18: bigint[];\n        let bptAmountOut: bigint;\n        let swapFeeAmountsScaled18: bigint[];\n\n        if (addLiquidityInput.kind === AddKind.UNBALANCED) {\n            this._requireUnbalancedLiquidityEnabled(poolState);\n            amountsInScaled18 = maxAmountsInScaled18;\n            const computed = computeAddLiquidityUnbalanced(\n                updatedBalancesLiveScaled18,\n                maxAmountsInScaled18,\n                poolState.totalSupply,\n                poolState.swapFee,\n                pool.getMaximumInvariantRatio(),\n                (balancesLiveScaled18, rounding) =>\n                    pool.computeInvariant(balancesLiveScaled18, rounding),\n            );\n            bptAmountOut = computed.bptAmountOut;\n            swapFeeAmountsScaled18 = computed.swapFeeAmounts;\n        } else if (addLiquidityInput.kind === AddKind.SINGLE_TOKEN_EXACT_OUT) {\n            this._requireUnbalancedLiquidityEnabled(poolState);\n            const tokenIndex = this._getSingleInputIndex(maxAmountsInScaled18);\n            amountsInScaled18 = maxAmountsInScaled18;\n            bptAmountOut = addLiquidityInput.minBptAmountOutRaw;\n            const computed = computeAddLiquiditySingleTokenExactOut(\n                updatedBalancesLiveScaled18,\n                tokenIndex,\n                bptAmountOut,\n                poolState.totalSupply,\n                poolState.swapFee,\n                pool.getMaximumInvariantRatio(),\n                (balancesLiveScaled18, tokenIndex, invariantRatio) =>\n                    pool.computeBalance(\n                        balancesLiveScaled18,\n                        tokenIndex,\n                        invariantRatio,\n                    ),\n            );\n            amountsInScaled18[tokenIndex] = computed.amountInWithFee;\n            swapFeeAmountsScaled18 = computed.swapFeeAmounts;\n        } else throw new Error('Unsupported AddLiquidity Kind');\n\n        const amountsInRaw: bigint[] = new Array(poolState.tokens.length);\n        for (let i = 0; i < poolState.tokens.length; i++) {\n            // amountsInRaw are amounts actually entering the Pool, so we round up.\n            amountsInRaw[i] = toRawUndoRateRoundUp(\n                amountsInScaled18[i],\n                poolState.scalingFactors[i],\n                poolState.tokenRates[i],\n            );\n\n            // A Pool's token balance always decreases after an exit\n            // Computes protocol and pool creator fee which is eventually taken from pool balance\n            const aggregateSwapFeeAmountScaled18 =\n                this._computeAndChargeAggregateSwapFees(\n                    swapFeeAmountsScaled18[i],\n                    poolState.aggregateSwapFee,\n                    poolState.scalingFactors,\n                    poolState.tokenRates,\n                    i,\n                );\n\n            updatedBalancesLiveScaled18[i] =\n                updatedBalancesLiveScaled18[i] +\n                amountsInScaled18[i] -\n                aggregateSwapFeeAmountScaled18;\n        }\n\n        if (hook.shouldCallAfterAddLiquidity) {\n            const { success, hookAdjustedAmountsInRaw } =\n                hook.onAfterAddLiquidity(\n                    addLiquidityInput.kind,\n                    amountsInScaled18,\n                    amountsInRaw,\n                    bptAmountOut,\n                    updatedBalancesLiveScaled18,\n                    hookState,\n                );\n\n            if (\n                success === false ||\n                hookAdjustedAmountsInRaw.length != amountsInRaw.length\n            ) {\n                throw new Error(\n                    `AfterAddLiquidityHookFailed ${poolState.poolType} ${poolState.hookType}`,\n                );\n            }\n\n            // If hook adjusted amounts is not enabled, ignore amounts returned by the hook\n            if (hook.enableHookAdjustedAmounts)\n                hookAdjustedAmountsInRaw.forEach(\n                    (a, i) => (amountsInRaw[i] = a),\n                );\n        }\n\n        return {\n            amountsInRaw: amountsInRaw,\n            bptAmountOutRaw: bptAmountOut,\n        };\n    }\n\n    /**\n     * Calculates the token amounts out for a given remove liquidity operation.\n     *\n     * @param removeLiquidityInput - User defined input for a removeLiquidity operation.\n     *   - For detailed information refer to the `RemoveLiquidityInput` type.\n     *   - Note: `minAmountsOutRaw` must always contain an amount for all tokens, e.g. for single token remove other tokens must have 0n.\n     * @param poolState - Pool state that will be used for calculations.\n     *   - Note: rates, fees, totalSupply use scaled 18. For detailed information, refer to the `PoolState` type.\n     * @param hookState - Optional state for any associated hook. Required if pool has a hook enabled.\n     *   - Note: Each hook will require its own state data. See `HookState` type for officially supported hook info.\n     * @returns {Object} An object containing the calculated raw output amounts and the BPT input amount.\n     * @returns {bigint[]} returns.amountsOutRaw - An array of calculated raw output amounts.\n     * @returns {bigint} returns.bptAmountInRaw - The raw BPT input amount.\n     */\n    public removeLiquidity(\n        removeLiquidityInput: RemoveLiquidityInput,\n        poolState: PoolState,\n        hookState?: HookState | unknown,\n    ): { amountsOutRaw: bigint[]; bptAmountInRaw: bigint } {\n        if (poolState.poolType === 'Buffer')\n            throw Error('Buffer pools do not support removeLiquidity');\n\n        const pool = this.getPool(poolState);\n        const hook = this.getHook(poolState.hookType, hookState);\n\n        // Round down when removing liquidity:\n        // If proportional, lower balances = lower proportional amountsOut, favoring the pool.\n        // If unbalanced, lower balances = lower invariant ratio without fees.\n        // bptIn = supply * (1 - ratio), so lower ratio = more bptIn, favoring the pool.\n\n        // Amounts are entering pool math; higher amounts would burn more BPT, so round up to favor the pool.\n        // Do not mutate minAmountsOut, so that we can directly compare the raw limits later, without potentially\n        // losing precision by scaling up and then down.\n        const minAmountsOutScaled18 = this._copyToScaled18ApplyRateRoundUpArray(\n            removeLiquidityInput.minAmountsOutRaw,\n            poolState.scalingFactors,\n            poolState.tokenRates,\n        );\n\n        const updatedBalancesLiveScaled18 = [...poolState.balancesLiveScaled18];\n        if (hook.shouldCallBeforeRemoveLiquidity) {\n            /* \n            Note - in SC balances and amounts are updated to reflect any rate change.\n            Daniel said we should not worry about this as any large rate changes will mean something has gone wrong.\n            We do take into account and balance changes due to hook using hookAdjustedBalancesScaled18.\n            */\n            const { success, hookAdjustedBalancesScaled18 } =\n                hook.onBeforeRemoveLiquidity(\n                    removeLiquidityInput.kind,\n                    removeLiquidityInput.maxBptAmountInRaw,\n                    removeLiquidityInput.minAmountsOutRaw,\n                    updatedBalancesLiveScaled18,\n                    hookState,\n                );\n            if (!success) throw new Error('BeforeRemoveLiquidityHookFailed');\n            hookAdjustedBalancesScaled18.forEach(\n                (a, i) => (updatedBalancesLiveScaled18[i] = a),\n            );\n        }\n\n        let tokenOutIndex: number;\n        let bptAmountIn: bigint;\n        let amountsOutScaled18: bigint[];\n        let swapFeeAmountsScaled18: bigint[];\n\n        if (removeLiquidityInput.kind === RemoveKind.PROPORTIONAL) {\n            bptAmountIn = removeLiquidityInput.maxBptAmountInRaw;\n            swapFeeAmountsScaled18 = new Array(poolState.tokens.length).fill(\n                0n,\n            );\n            amountsOutScaled18 = computeProportionalAmountsOut(\n                updatedBalancesLiveScaled18,\n                poolState.totalSupply,\n                removeLiquidityInput.maxBptAmountInRaw,\n            );\n        } else if (\n            removeLiquidityInput.kind === RemoveKind.SINGLE_TOKEN_EXACT_IN\n        ) {\n            this._requireUnbalancedLiquidityEnabled(poolState);\n            bptAmountIn = removeLiquidityInput.maxBptAmountInRaw;\n            amountsOutScaled18 = minAmountsOutScaled18;\n            tokenOutIndex = this._getSingleInputIndex(\n                removeLiquidityInput.minAmountsOutRaw,\n            );\n            const computed = computeRemoveLiquiditySingleTokenExactIn(\n                updatedBalancesLiveScaled18,\n                tokenOutIndex,\n                removeLiquidityInput.maxBptAmountInRaw,\n                poolState.totalSupply,\n                poolState.swapFee,\n                pool.getMinimumInvariantRatio(),\n                (balancesLiveScaled18, tokenIndex, invariantRatio) =>\n                    pool.computeBalance(\n                        balancesLiveScaled18,\n                        tokenIndex,\n                        invariantRatio,\n                    ),\n            );\n            amountsOutScaled18[tokenOutIndex] = computed.amountOutWithFee;\n            swapFeeAmountsScaled18 = computed.swapFeeAmounts;\n        } else if (\n            removeLiquidityInput.kind === RemoveKind.SINGLE_TOKEN_EXACT_OUT\n        ) {\n            this._requireUnbalancedLiquidityEnabled(poolState);\n            amountsOutScaled18 = minAmountsOutScaled18;\n            tokenOutIndex = this._getSingleInputIndex(\n                removeLiquidityInput.minAmountsOutRaw,\n            );\n            const computed = computeRemoveLiquiditySingleTokenExactOut(\n                updatedBalancesLiveScaled18,\n                tokenOutIndex,\n                amountsOutScaled18[tokenOutIndex],\n                poolState.totalSupply,\n                poolState.swapFee,\n                pool.getMinimumInvariantRatio(),\n                (balancesLiveScaled18, rounding) =>\n                    pool.computeInvariant(balancesLiveScaled18, rounding),\n            );\n            bptAmountIn = computed.bptAmountIn;\n            swapFeeAmountsScaled18 = computed.swapFeeAmounts;\n        } else throw new Error('Unsupported RemoveLiquidity Kind');\n\n        const amountsOutRaw = new Array(poolState.tokens.length);\n\n        for (let i = 0; i < poolState.tokens.length; ++i) {\n            // amountsOut are amounts exiting the Pool, so we round down.\n            amountsOutRaw[i] = toRawUndoRateRoundDown(\n                amountsOutScaled18[i],\n                poolState.scalingFactors[i],\n                poolState.tokenRates[i],\n            );\n\n            // A Pool's token balance always decreases after an exit\n            // Computes protocol and pool creator fee which is eventually taken from pool balance\n            const aggregateSwapFeeAmountScaled18 =\n                this._computeAndChargeAggregateSwapFees(\n                    swapFeeAmountsScaled18[i],\n                    poolState.aggregateSwapFee,\n                    poolState.scalingFactors,\n                    poolState.tokenRates,\n                    i,\n                );\n\n            updatedBalancesLiveScaled18[i] =\n                updatedBalancesLiveScaled18[i] -\n                (amountsOutScaled18[i] + aggregateSwapFeeAmountScaled18);\n        }\n\n        // AmountsOut can be changed by onAfterRemoveLiquidity if the hook charges fees or gives discounts\n        if (hook.shouldCallAfterRemoveLiquidity) {\n            const { success, hookAdjustedAmountsOutRaw } =\n                hook.onAfterRemoveLiquidity(\n                    removeLiquidityInput.kind,\n                    bptAmountIn,\n                    amountsOutScaled18,\n                    amountsOutRaw,\n                    updatedBalancesLiveScaled18,\n                    hookState,\n                );\n\n            if (\n                success === false ||\n                hookAdjustedAmountsOutRaw.length != amountsOutRaw.length\n            ) {\n                throw new Error(\n                    `AfterRemoveLiquidityHookFailed ${poolState.poolType} ${poolState.hookType}`,\n                );\n            }\n\n            // If hook adjusted amounts is not enabled, ignore amounts returned by the hook\n            if (hook.enableHookAdjustedAmounts)\n                hookAdjustedAmountsOutRaw.forEach(\n                    (a, i) => (amountsOutRaw[i] = a),\n                );\n        }\n\n        return {\n            amountsOutRaw: amountsOutRaw,\n            bptAmountInRaw: bptAmountIn,\n        };\n    }\n\n    private _computeAndChargeAggregateSwapFees(\n        swapFeeAmountScaled18: bigint,\n        aggregateSwapFeePercentage: bigint,\n        decimalScalingFactors: bigint[],\n        tokenRates: bigint[],\n        index: number,\n    ): bigint {\n        if (swapFeeAmountScaled18 > 0 && aggregateSwapFeePercentage > 0) {\n            // The total swap fee does not go into the pool; amountIn does, and the raw fee at this point does not\n            // modify it. Given that all of the fee may belong to the pool creator (i.e. outside pool balances),\n            // we round down to protect the invariant.\n            const totalSwapFeeAmountRaw = toRawUndoRateRoundDown(\n                swapFeeAmountScaled18,\n                decimalScalingFactors[index],\n                tokenRates[index],\n            );\n\n            return MathSol.mulDownFixed(\n                totalSwapFeeAmountRaw,\n                aggregateSwapFeePercentage,\n            );\n        }\n        return 0n;\n    }\n\n    private _getSingleInputIndex(maxAmountsIn: bigint[]): number {\n        const length = maxAmountsIn.length;\n        let inputIndex = length;\n\n        for (let i = 0; i < length; ++i) {\n            if (maxAmountsIn[i] !== 0n) {\n                if (inputIndex !== length) {\n                    throw new Error(\n                        'Multiple non-zero inputs for single token add',\n                    );\n                }\n                inputIndex = i;\n            }\n        }\n\n        if (inputIndex >= length) {\n            throw new Error('All zero inputs for single token add');\n        }\n\n        return inputIndex;\n    }\n\n    /**\n     * @dev Same as `toScaled18ApplyRateRoundDown`, but returns a new array, leaving the original intact.\n     */\n    private _copyToScaled18ApplyRateRoundDownArray(\n        amounts: bigint[],\n        scalingFactors: bigint[],\n        tokenRates: bigint[],\n    ): bigint[] {\n        return amounts.map((a, i) =>\n            toScaled18ApplyRateRoundDown(a, scalingFactors[i], tokenRates[i]),\n        );\n    }\n\n    /**\n     * @dev Same as `toScaled18ApplyRateRoundDown`, but returns a new array, leaving the original intact.\n     */\n    private _copyToScaled18ApplyRateRoundUpArray(\n        amounts: bigint[],\n        scalingFactors: bigint[],\n        tokenRates: bigint[],\n    ): bigint[] {\n        return amounts.map((a, i) =>\n            toScaled18ApplyRateRoundUp(a, scalingFactors[i], tokenRates[i]),\n        );\n    }\n\n    private _computeAmountGivenScaled18(\n        amountGivenRaw: bigint,\n        swapKind: SwapKind,\n        indexIn: number,\n        indexOut: number,\n        scalingFactors: bigint[],\n        tokenRates: bigint[],\n    ): bigint {\n        // If the amountGiven is entering the pool math (ExactIn), round down, since a lower apparent amountIn leads\n        // to a lower calculated amountOut, favoring the pool.\n        const amountGivenScaled18 =\n            swapKind === SwapKind.GivenIn\n                ? toScaled18ApplyRateRoundDown(\n                      amountGivenRaw,\n                      scalingFactors[indexIn],\n                      tokenRates[indexIn],\n                  )\n                : toScaled18ApplyRateRoundUp(\n                      amountGivenRaw,\n                      scalingFactors[indexOut],\n                      this._computeRateRoundUp(tokenRates[indexOut]),\n                  );\n        return amountGivenScaled18;\n    }\n\n    /**\n     * @notice Rounds up a rate informed by a rate provider.\n     * @dev Rates calculated by an external rate provider have rounding errors. Intuitively, a rate provider\n     * rounds the rate down so the pool math is executed with conservative amounts. However, when upscaling or\n     * downscaling the amount out, the rate should be rounded up to make sure the amounts scaled are conservative.\n     */\n    private _computeRateRoundUp(rate: bigint): bigint {\n        // If rate is divisible by FixedPoint.ONE, roundedRate and rate will be equal. It means that rate has 18 zeros,\n        // so there's no rounding issue and the rate should not be rounded up.\n\n        const roundedRate = (rate / WAD) * WAD;\n\n        return roundedRate == rate ? rate : rate + 1n;\n    }\n\n    // Minimum token value in or out (applied to scaled18 values), enforced as a security measure to block potential\n    // exploitation of rounding errors. This is called in the swap context, so zero is not a valid amount.\n    private _ensureValidSwapAmount(tradeAmount: bigint): boolean {\n        if (tradeAmount < _MINIMUM_TRADE_AMOUNT) {\n            throw new Error(`TradeAmountTooSmall ${tradeAmount}`);\n        }\n        return true;\n    }\n\n    private _requireUnbalancedLiquidityEnabled(poolState: PoolState): void {\n        if (!poolState.supportsUnbalancedLiquidity) {\n            throw new Error('DoesNotSupportUnbalancedLiquidity');\n        }\n    }\n}\n"]}