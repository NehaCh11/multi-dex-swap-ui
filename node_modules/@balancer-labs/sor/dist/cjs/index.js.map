{"version":3,"file":"index.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/lodash.clonedeep/index.js","../../../../src/utils/bignumber.ts","../../../../src/utils/basicOperations.ts","../../../../src/utils/index.ts","../../../../src/types.ts","../../../../src/pools/weightedPool/weightedMath.ts","../../../../src/pools/weightedPool/weightedPool.ts","../../../../src/pools/liquidity.ts","../../../../src/pools/stablePool/stableMath.ts","../../../../src/pools/stablePool/stableMathBigInt.ts","../../../../src/pools/stablePool/stablePool.ts","../../../../src/pools/metaStablePool/metaStablePool.ts","../../../../src/pools/linearPool/linearMath.ts","../../../../src/pools/linearPool/linearPool.ts","../../../../src/pools/elementPool/elementMath.ts","../../../../src/pools/elementPool/elementPool.ts","../../../../src/pools/phantomStablePool/phantomStableMath.ts","../../../../src/pools/phantomStablePool/phantomStablePool.ts","../../../../src/pools/composableStable/composableStablePool.ts","../../../../src/pools/gyroHelpers/constants.ts","../../../../src/pools/gyroHelpers/gyroSignedFixedPoint.ts","../../../../src/pools/gyro2Pool/gyro2Math.ts","../../../../src/pools/gyroHelpers/helpers.ts","../../../../src/pools/gyro2Pool/gyro2Pool.ts","../../../../src/pools/gyro3Pool/constants.ts","../../../../src/pools/gyro3Pool/gyro3Math.ts","../../../../src/pools/gyro3Pool/helpers.ts","../../../../src/pools/gyro3Pool/gyro3Pool.ts","../../../../src/pools/gyroEPool/gyroEMath/constants.ts","../../../../src/pools/gyroEPool/gyroEMath/gyroEMathHelpers.ts","../../../../src/pools/gyroEPool/gyroEMath/gyroEMathFunctions.ts","../../../../src/pools/gyroEPool/gyroEMath/gyroEMath.ts","../../../../src/pools/gyroEPool/gyroEPool.ts","../../../../src/pools/gyroEV2Pool/gyroEV2Math/gyroEV2MathHelpers.ts","../../../../src/pools/gyroEV2Pool/gyroEV2Pool.ts","../../../../src/pools/xaveFxPool/fxPoolMath.ts","../../../../src/pools/xaveFxPool/fxPool.ts","../../../../src/pools/index.ts","../../../../src/config.ts","../../../../src/router/helpersClass.ts","../../../../src/router/sorClass.ts","../../../../src/router/index.ts","../../../../src/constants.ts","../../../../src/pools/lido/index.ts","../../../../src/wrappers/unbutton.ts","../../../../src/wrapInfo.ts","../../../../src/formatSwaps.ts","../../../../src/poolCacher.ts","../../../../src/routeProposal/filtering.ts","../../../../src/routeProposal/pathLimits.ts","../../../../src/routeProposal/index.ts","../../../../src/swapCostCalculator.ts","../../../../src/index.ts","../../../../src/wrapper.ts","../../../../src/frontendHelpers/stableHelpers.ts","../../../../src/frontendHelpers/weightedHelpers.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","import { BigNumber } from 'bignumber.js';\nBigNumber.config({\n    EXPONENTIAL_AT: [-100, 100],\n    ROUNDING_MODE: 1,\n    DECIMAL_PLACES: 18,\n});\n\nexport const ZERO = bnum(0);\nexport const ONE = bnum(1);\nexport const INFINITY = bnum('Infinity');\n\nexport function scale(input: BigNumber, decimalPlaces: number): BigNumber {\n    const scalePow = new BigNumber(decimalPlaces.toString());\n    const scaleMul = new BigNumber(10).pow(scalePow);\n    return input.times(scaleMul);\n}\n\nexport function bnum(val: string | number | BigNumber): BigNumber {\n    return new BigNumber(val.toString());\n}\n\nexport { BigNumber };\n","export const BZERO = BigInt(0);\nexport const BONE = BigInt(1);\nexport const ONE = BigInt('1000000000000000000'); // 18 decimal places\n\nconst _require = (b: boolean, message: string) => {\n    if (!b) throw new Error(message);\n};\n\n/**\n * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n * it had 18 decimals.\n */\nexport function _computeScalingFactor(tokenDecimals: bigint): bigint {\n    // Tokens with more than 18 decimals are not supported.\n    const decimalsDifference = BigInt(18) - tokenDecimals;\n    return ONE * BigInt(10) ** decimalsDifference;\n}\n\n/**\n * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\n * scaling or not.\n */\nexport function _upscale(amount: bigint, scalingFactor: bigint): bigint {\n    // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of\n    // token in should be rounded up, and that of token out rounded down. This is the only place where we round in\n    // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no\n    // rounding error unless `_scalingFactor()` is overriden).\n    return MathSol.mulDownFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\n * the `amounts` array.\n */\nexport function _upscaleArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const upscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        upscaledAmounts[i] = MathSol.mulDownFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return upscaledAmounts;\n}\n\n/**\n * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n * whether it needed scaling or not. The result is rounded down.\n */\nexport function _downscaleDown(amount: bigint, scalingFactor: bigint): bigint {\n    return MathSol.divDownFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\n * *mutates* the `amounts` array.\n */\nexport function _downscaleDownArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const downscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        downscaledAmounts[i] = MathSol.divDownFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return downscaledAmounts;\n}\n\n/**\n * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n * whether it needed scaling or not. The result is rounded up.\n */\nexport function _downscaleUp(amount: bigint, scalingFactor: bigint): bigint {\n    return MathSol.divUpFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\n * *mutates* the `amounts` array.\n */\nexport function _downscaleUpArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const downscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        downscaledAmounts[i] = MathSol.divUpFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return downscaledAmounts;\n}\n\nexport class MathSol {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    // add(a: bigint, b: bigint): bigint {\n    //     const c = a + b;\n    //     // _require(c >= a, Errors.ADD_OVERFLOW);\n    //     return c;\n    // }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    static add(a: bigint, b: bigint): bigint {\n        const c = a + b;\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), 'Errors.ADD_OVERFLOW');\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    static sub(a: bigint, b: bigint): bigint {\n        _require(b <= a, 'Errors.SUB_OVERFLOW');\n        const c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    // sub(int256 a, int256 b) internal pure returns (int256) {\n    //     int256 c = a - b;\n    //     // _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\n    //     return c;\n    // }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    static max(a: bigint, b: bigint): bigint {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    static min(a: bigint, b: bigint): bigint {\n        return a < b ? a : b;\n    }\n\n    static mul(a: bigint, b: bigint): bigint {\n        const c = a * b;\n        _require(a == BZERO || c / a == b, 'Errors.MUL_OVERFLOW');\n        return c;\n    }\n\n    static div(a: bigint, b: bigint, roundUp: boolean): bigint {\n        return roundUp ? this.divUp(a, b) : this.divDown(a, b);\n    }\n\n    static divDown(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n        return a / b;\n    }\n\n    static divUp(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            return BONE + (a - BONE) / b;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static ONE = BigInt('1000000000000000000'); // 18 decimal places\n    static MAX_POW_RELATIVE_ERROR = BigInt(10000);\n\n    static mulUpFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        _require(a == BZERO || product / a == b, 'Errors.MUL_OVERFLOW');\n\n        if (product == BZERO) {\n            return BZERO;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return (product - BONE) / this.ONE + BONE;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    // Same as divDown in Smart Contract FixedPoint.sol\n    static divDownFixed(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            const aInflated = a * this.ONE;\n            // _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static divUpFixed(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            const aInflated = a * this.ONE;\n            _require(aInflated / a == this.ONE, 'Errors.DIV_INTERNAL'); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return (aInflated - BONE) / b + BONE;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static powUpFixed(x: bigint, y: bigint): bigint {\n        const raw = LogExpMath.pow(x, y);\n        const maxError = this.add(\n            this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR),\n            BONE\n        );\n\n        return this.add(raw, maxError);\n    }\n\n    static powDown(x: bigint, y: bigint): bigint {\n        const raw = LogExpMath.pow(x, y);\n        const maxError = this.add(\n            this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR),\n            BONE\n        );\n        return this.sub(raw, maxError);\n    }\n\n    // Modification: Taken from the fixed point class\n    static complementFixed(x: bigint): bigint {\n        return x < this.ONE ? this.ONE - x : BZERO;\n    }\n\n    // This is the same as mulDown in Smart Contracts FixedPoint.sol\n    static mulDownFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        _require(a == BZERO || product / a == b, 'Errors.MUL_OVERFLOW');\n\n        return product / this.ONE;\n    }\n}\n\nclass LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static ONE_18 = BigInt('1000000000000000000');\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    static ONE_20 = BigInt('100000000000000000000');\n    static ONE_36 = BigInt('1000000000000000000000000000000000000');\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    static MAX_NATURAL_EXPONENT = BigInt('130000000000000000000');\n    static MIN_NATURAL_EXPONENT = BigInt('-41000000000000000000');\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    static LN_36_LOWER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) - BigInt('100000000000000000');\n    static LN_36_UPPER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) + BigInt('100000000000000000');\n\n    static MILD_EXPONENT_BOUND: bigint =\n        BigInt(2) ** BigInt(254) / LogExpMath.ONE_20;\n\n    // 18 decimal constants\n    static x0 = BigInt('128000000000000000000'); // 27\n    static a0 = BigInt(\n        '38877084059945950922200000000000000000000000000000000000'\n    ); // e(x0) (no decimals)\n    static x1 = BigInt('64000000000000000000'); // 26\n    static a1 = BigInt('6235149080811616882910000000'); // e(x1) (no decimals)\n\n    // 20 decimal constants\n    static x2 = BigInt('3200000000000000000000'); // 25\n    static a2 = BigInt('7896296018268069516100000000000000'); // e(x2)\n    static x3 = BigInt('1600000000000000000000'); // 24\n    static a3 = BigInt('888611052050787263676000000'); // e(x3)\n    static x4 = BigInt('800000000000000000000'); // 23\n    static a4 = BigInt('298095798704172827474000'); // e(x4)\n    static x5 = BigInt('400000000000000000000'); // 22\n    static a5 = BigInt('5459815003314423907810'); // e(x5)\n    static x6 = BigInt('200000000000000000000'); // 21\n    static a6 = BigInt('738905609893065022723'); // e(x6)\n    static x7 = BigInt('100000000000000000000'); // 20\n    static a7 = BigInt('271828182845904523536'); // e(x7)\n    static x8 = BigInt('50000000000000000000'); // 2-1\n    static a8 = BigInt('164872127070012814685'); // e(x8)\n    static x9 = BigInt('25000000000000000000'); // 2-2\n    static a9 = BigInt('128402541668774148407'); // e(x9)\n    static x10 = BigInt('12500000000000000000'); // 2-3\n    static a10 = BigInt('113314845306682631683'); // e(x10)\n    static x11 = BigInt('6250000000000000000'); // 2-4\n    static a11 = BigInt('106449445891785942956'); // e(x11)\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static pow(x: bigint, y: bigint): bigint {\n        if (y === BZERO) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return this.ONE_18;\n        }\n\n        if (x == BZERO) {\n            return BZERO;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(\n            x <\n                BigInt(\n                    '57896044618658097711785492504343953926634992332820282019728792003956564819968'\n                ),\n            'Errors.X_OUT_OF_BOUNDS'\n        );\n        const x_int256 = x;\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < this.MILD_EXPONENT_BOUND, 'Errors.Y_OUT_OF_BOUNDS');\n        const y_int256 = y;\n\n        let logx_times_y;\n        if (\n            this.LN_36_LOWER_BOUND < x_int256 &&\n            x_int256 < this.LN_36_UPPER_BOUND\n        ) {\n            const ln_36_x = this._ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y =\n                (ln_36_x / this.ONE_18) * y_int256 +\n                ((ln_36_x % this.ONE_18) * y_int256) / this.ONE_18;\n        } else {\n            logx_times_y = this._ln(x_int256) * y_int256;\n        }\n        logx_times_y /= this.ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            this.MIN_NATURAL_EXPONENT <= logx_times_y &&\n                logx_times_y <= this.MAX_NATURAL_EXPONENT,\n            'Errors.PRODUCT_OUT_OF_BOUNDS'\n        );\n\n        // return uint256(exp(logx_times_y));\n        return this.exp(logx_times_y);\n    }\n\n    static exp(x: bigint): bigint {\n        _require(\n            x >= this.MIN_NATURAL_EXPONENT && x <= this.MAX_NATURAL_EXPONENT,\n            'Errors.INVALID_EXPONENT'\n        );\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return (this.ONE_18 * this.ONE_18) / this.exp(BigInt(-1) * x);\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        let firstAN;\n        if (x >= this.x0) {\n            x -= this.x0;\n            firstAN = this.a0;\n        } else if (x >= this.x1) {\n            x -= this.x1;\n            firstAN = this.a1;\n        } else {\n            firstAN = BigInt(1); // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= BigInt(100);\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        let product = this.ONE_20;\n\n        if (x >= this.x2) {\n            x -= this.x2;\n            product = (product * this.a2) / this.ONE_20;\n        }\n        if (x >= this.x3) {\n            x -= this.x3;\n            product = (product * this.a3) / this.ONE_20;\n        }\n        if (x >= this.x4) {\n            x -= this.x4;\n            product = (product * this.a4) / this.ONE_20;\n        }\n        if (x >= this.x5) {\n            x -= this.x5;\n            product = (product * this.a5) / this.ONE_20;\n        }\n        if (x >= this.x6) {\n            x -= this.x6;\n            product = (product * this.a6) / this.ONE_20;\n        }\n        if (x >= this.x7) {\n            x -= this.x7;\n            product = (product * this.a7) / this.ONE_20;\n        }\n        if (x >= this.x8) {\n            x -= this.x8;\n            product = (product * this.a8) / this.ONE_20;\n        }\n        if (x >= this.x9) {\n            x -= this.x9;\n            product = (product * this.a9) / this.ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        let seriesSum = this.ONE_20; // The initial one in the sum, with 20 decimal places.\n        let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by this.ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = (term * x) / this.ONE_20 / BigInt(2);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(3);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(4);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(5);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(6);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(7);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(8);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(9);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(10);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(11);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(12);\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by this.ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / this.ONE_20) * firstAN) / BigInt(100);\n    }\n\n    static _ln_36(x: bigint): bigint {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= this.ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        const z = ((x - this.ONE_36) * this.ONE_36) / (x + this.ONE_36);\n        const z_squared = (z * z) / this.ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(11);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(13);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(15);\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * BigInt(2);\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    static _ln(a: bigint): bigint {\n        if (a < this.ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by this.ONE_18.\n            return BigInt(-1) * this._ln((this.ONE_18 * this.ONE_18) / a);\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // this.ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        let sum = BZERO;\n        if (a >= this.a0 * this.ONE_18) {\n            a /= this.a0; // Integer, not fixed point division\n            sum += this.x0;\n        }\n\n        if (a >= this.a1 * this.ONE_18) {\n            a /= this.a1; // Integer, not fixed point division\n            sum += this.x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= BigInt(100);\n        a *= BigInt(100);\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= this.a2) {\n            a = (a * this.ONE_20) / this.a2;\n            sum += this.x2;\n        }\n\n        if (a >= this.a3) {\n            a = (a * this.ONE_20) / this.a3;\n            sum += this.x3;\n        }\n\n        if (a >= this.a4) {\n            a = (a * this.ONE_20) / this.a4;\n            sum += this.x4;\n        }\n\n        if (a >= this.a5) {\n            a = (a * this.ONE_20) / this.a5;\n            sum += this.x5;\n        }\n\n        if (a >= this.a6) {\n            a = (a * this.ONE_20) / this.a6;\n            sum += this.x6;\n        }\n\n        if (a >= this.a7) {\n            a = (a * this.ONE_20) / this.a7;\n            sum += this.x7;\n        }\n\n        if (a >= this.a8) {\n            a = (a * this.ONE_20) / this.a8;\n            sum += this.x8;\n        }\n\n        if (a >= this.a9) {\n            a = (a * this.ONE_20) / this.a9;\n            sum += this.x9;\n        }\n\n        if (a >= this.a10) {\n            a = (a * this.ONE_20) / this.a10;\n            sum += this.x10;\n        }\n\n        if (a >= this.a11) {\n            a = (a * this.ONE_20) / this.a11;\n            sum += this.x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        const z = ((a - this.ONE_20) * this.ONE_20) / (a + this.ONE_20);\n        const z_squared = (z * z) / this.ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(11);\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= BigInt(2);\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / BigInt(100);\n    }\n}\n","import { getAddress } from '@ethersproject/address';\nimport { parseFixed, BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    _computeScalingFactor,\n    _downscaleDown,\n    ONE as ONE_BigInt,\n    _upscale,\n} from './basicOperations';\nimport { SubgraphToken } from '../types';\n\nexport const isSameAddress = (address1: string, address2: string): boolean =>\n    getAddress(address1) === getAddress(address2);\n\n/// Parses a fixed-point decimal string into a BigNumber\n/// If we do not have enough decimals to express the number, we truncate it\nexport function safeParseFixed(value: string, decimals = 0): BigNumber {\n    const [integer, fraction] = value.split('.');\n    if (!fraction) {\n        return parseFixed(value, decimals);\n    }\n    const safeValue = integer + '.' + fraction.slice(0, decimals);\n    return parseFixed(safeValue, decimals);\n}\n\n// normalizes its balance as if it had 18 decimals taking price rate into consideration.\nexport const normaliseBalance = (\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'balance'>\n): bigint => {\n    return parseFixed(token.balance, 18)\n        .mul(parseFixed(token.priceRate ?? '1', 18))\n        .div(ONE)\n        .toBigInt();\n};\n\n// normalizes amount as if it had 18 decimals taking price rate into consideration.\nexport const normaliseAmount = (\n    amount: bigint,\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'decimals'>\n): bigint => {\n    const scalingFactor = _computeScalingFactor(BigInt(token.decimals));\n    return BigNumber.from(_upscale(amount, scalingFactor).toString())\n        .mul(parseFixed(token.priceRate ?? '1', 18))\n        .div(ONE)\n        .toBigInt();\n};\n\n// denormalises amount from 18 decimals to token decimals taking price rate into consideration.\nexport const denormaliseAmount = (\n    amount: bigint,\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'decimals'>\n): bigint => {\n    const amountAfterRate =\n        (amount * ONE_BigInt) /\n        BigInt(parseFixed(token.priceRate ?? '1', 18).toString());\n    const scalingFactor = _computeScalingFactor(BigInt(token.decimals));\n    return _downscaleDown(amountAfterRate, scalingFactor);\n};\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber } from './utils/bignumber';\n\nexport interface SorConfig {\n    chainId: number;\n    vault: string;\n    weth: string;\n    connectingTokens?: { symbol: string; address: string }[];\n    staBal3Pool?: { id: string; address: string };\n    usdcConnectingPool?: { id: string; usdc: string };\n    wETHwstETH?: { id: string; address: string };\n    lbpRaisingTokens?: string[];\n}\n\nexport type NoNullableField<T> = {\n    [P in keyof T]: NonNullable<T[P]>;\n};\n\nexport enum SwapTypes {\n    SwapExactIn,\n    SwapExactOut,\n}\n\nexport enum PoolTypes {\n    Weighted,\n    Stable,\n    Element,\n    MetaStable,\n    Linear,\n    Gyro2,\n    Gyro3,\n    GyroE,\n    Fx,\n}\n\nexport interface SwapOptions {\n    gasPrice: BigNumber;\n    swapGas: BigNumber;\n    timestamp: number;\n    maxPools: number;\n    poolTypeFilter: PoolFilter;\n    forceRefresh: boolean;\n}\n\nexport type PoolPairBase = {\n    id: string;\n    address: string;\n    poolType: PoolTypes;\n    swapFee: BigNumber;\n    tokenIn: string;\n    tokenOut: string;\n    decimalsIn: number;\n    decimalsOut: number;\n    balanceIn: BigNumber;\n    balanceOut: BigNumber;\n};\n\nexport interface Swap {\n    pool: string;\n    tokenIn: string;\n    tokenOut: string;\n    swapAmount?: string;\n    limitReturnAmount?: string;\n    maxPrice?: string;\n    tokenInDecimals: number;\n    tokenOutDecimals: number;\n    returnAmount?: string;\n}\n\nexport interface SubgraphPoolBase {\n    id: string;\n    address: string;\n    poolType: string;\n    poolTypeVersion?: number;\n    swapFee: string;\n    swapEnabled: boolean;\n    totalShares: string;\n    tokens: SubgraphToken[];\n    tokensList: string[];\n\n    // Weighted & Element field\n    totalWeight?: string;\n\n    // Stable specific fields\n    amp?: string;\n\n    // Element specific fields\n    expiryTime?: number;\n    unitSeconds?: number;\n    principalToken?: string;\n    baseToken?: string;\n\n    // Linear specific fields\n    mainIndex?: number;\n    wrappedIndex?: number;\n    lowerTarget?: string;\n    upperTarget?: string;\n\n    // Gyro2 specific fields\n    sqrtAlpha?: string;\n    sqrtBeta?: string;\n\n    // Gyro3 specific field\n    root3Alpha?: string;\n\n    // GyroE and GyroEV2 specific fields\n    alpha?: string;\n    beta?: string;\n    c?: string;\n    s?: string;\n    lambda?: string;\n    tauAlphaX?: string;\n    tauAlphaY?: string;\n    tauBetaX?: string;\n    tauBetaY?: string;\n    u?: string;\n    v?: string;\n    w?: string;\n    z?: string;\n    dSq?: string;\n\n    // GyroEV2 specific fields\n    tokenRates?: string[];\n\n    // FxPool\n    delta?: string;\n    epsilon?: string;\n}\n\nexport type SubgraphToken = {\n    address: string;\n    balance: string;\n    decimals: number;\n    priceRate: string;\n    // WeightedPool field\n    weight: string | null;\n    token?: SubgraphTokenData;\n};\n\nexport type SubgraphTokenData = {\n    latestFXPrice?: string;\n};\n\nexport interface SwapV2 {\n    poolId: string;\n    assetInIndex: number;\n    assetOutIndex: number;\n    amount: string;\n    userData: string;\n    returnAmount?: string;\n}\n\nexport interface SwapInfo {\n    tokenAddresses: string[];\n    swaps: SwapV2[];\n    swapAmount: BigNumber;\n    swapAmountForSwaps: BigNumber; // Used with stETH/wstETH\n    returnAmount: BigNumber;\n    returnAmountFromSwaps: BigNumber; // Used with stETH/wstETH\n    returnAmountConsideringFees: BigNumber;\n    tokenIn: string;\n    tokenInForSwaps?: string; // Used with stETH/wstETH\n    tokenOut: string;\n    tokenOutFromSwaps?: string; // Used with stETH/wstETH\n    marketSp: string;\n}\n\nexport interface PoolDictionary {\n    [poolId: string]: PoolBase;\n}\n\nexport interface PoolPairDictionary {\n    [tokenInOut: string]: PoolPairBase;\n}\n\nexport interface hopDictionary {\n    [hopToken: string]: Set<string>; // the set of pool ids\n}\n\nexport interface NewPath {\n    id: string; // pool address if direct path, contactenation of pool addresses if multihop\n    swaps: Swap[];\n    poolPairData: PoolPairBase[];\n    limitAmount: BigNumber;\n    pools: PoolBase[];\n    filterEffectivePrice?: OldBigNumber; // TODO: This is just used for filtering, maybe there is a better way to filter?\n}\n\nexport enum PoolFilter {\n    All = 'All',\n    Weighted = 'Weighted',\n    Stable = 'Stable',\n    MetaStable = 'MetaStable',\n    LiquidityBootstrapping = 'LiquidityBootstrapping',\n    Investment = 'Investment',\n    Element = 'Element',\n    StablePhantom = 'StablePhantom',\n    ComposableStable = 'ComposableStable',\n    Gyro2 = 'Gyro2',\n    Gyro3 = 'Gyro3',\n    GyroE = 'GyroE',\n    // Linear Pools defined below all operate the same mathematically but have different factories and names in Subgraph\n    AaveLinear = 'AaveLinear',\n    Linear = 'Linear',\n    EulerLinear = 'EulerLinear',\n    ERC4626Linear = 'ERC4626Linear',\n    BeefyLinear = 'BeefyLinear',\n    GearboxLinear = 'GearboxLinear',\n    MidasLinear = 'MidasLinear',\n    ReaperLinear = 'ReaperLinear',\n    SiloLinear = 'SiloLinear',\n    TetuLinear = 'TetuLinear',\n    YearnLinear = 'YearnLinear',\n    // FX = 'FX',\n}\n\nexport interface PoolBase<D extends PoolPairBase = PoolPairBase> {\n    poolType: PoolTypes;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: { address: string; balance: string; decimals: number }[];\n    totalShares: BigNumber;\n    mainIndex?: number;\n    isLBP?: boolean;\n    parsePoolPairData: (tokenIn: string, tokenOut: string) => D;\n    getNormalizedLiquidity: (poolPairData: D) => OldBigNumber;\n    getLimitAmountSwap: (poolPairData: D, swapType: SwapTypes) => OldBigNumber;\n    /**\n     * @param {string} token - Address of token.\n     * @param {BigNumber} newBalance - New balance of token. EVM scaled.\n     */\n    updateTokenBalanceForPool: (token: string, newBalance: BigNumber) => void;\n    updateTotalShares: (newTotalShares: BigNumber) => void;\n    _exactTokenInForTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n    _tokenInForExactTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[];\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber;\n    _spotPriceAfterSwapExactTokenInForTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n    _spotPriceAfterSwapTokenInForExactTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut: (\n        poolPairData: D,\n        amount: OldBigNumber\n    ) => OldBigNumber;\n}\n\nexport interface WeightedPool<D extends PoolPairBase> extends PoolBase<D> {\n    totalWeight: string;\n}\n\nexport interface TokenPriceService {\n    /**\n     * This should return the price of the native asset (ETH) in the token defined by tokenAddress.\n     * Example: BAL = $20 USD, ETH = $4,000 USD, then 1 ETH = 200 BAL. This function would return 200.\n     * @param tokenAddress\n     */\n    getNativeAssetPriceInToken(tokenAddress: string): Promise<string>;\n}\n\nexport interface PoolDataService {\n    getPools(query?: GraphQLArgs): Promise<SubgraphPoolBase[]>;\n}\n\nexport type FundManagement = {\n    sender: string;\n    recipient: string;\n    fromInternalBalance: boolean;\n    toInternalBalance: boolean;\n};\n\ntype GraphQLFilterOperator = 'gt' | 'lt' | 'eq' | 'in' | 'not_in' | 'contains';\n\ntype GraphQLFilter = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [operator in GraphQLFilterOperator]?: any;\n};\n\nexport interface GraphQLArgs {\n    chainId?: number;\n    first?: number;\n    skip?: number;\n    nextToken?: string;\n    orderBy?: string;\n    orderDirection?: string;\n    block?: {\n        number?: number;\n    };\n    where?: Record<string, GraphQLFilter>;\n}\n","import { formatFixed } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum } from '../../utils/bignumber';\nimport { WeightedPoolPairData } from './weightedPool';\nimport { MathSol, BZERO } from '../../utils/basicOperations';\n\nconst MAX_INVARIANT_RATIO = BigInt('3000000000000000000'); // 3e18\n\n// The following function are BigInt versions implemented by Sergio.\n// BigInt was requested from integrators as it is more efficient.\n// Swap outcomes formulas should match exactly those from smart contracts.\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    // is it necessary to check ranges of variables? same for the other functions\n    amountIn = subtractFee(amountIn, fee);\n    const exponent = MathSol.divDownFixed(weightIn, weightOut);\n    const denominator = MathSol.add(balanceIn, amountIn);\n    const base = MathSol.divUpFixed(balanceIn, denominator);\n    const power = MathSol.powUpFixed(base, exponent);\n    return MathSol.mulDownFixed(balanceOut, MathSol.complementFixed(power));\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _calcInGivenOut(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const base = MathSol.divUpFixed(balanceOut, balanceOut - amountOut);\n    const exponent = MathSol.divUpFixed(weightOut, weightIn);\n    const power = MathSol.powUpFixed(base, exponent);\n    const ratio = MathSol.sub(power, MathSol.ONE);\n    const amountIn = MathSol.mulUpFixed(balanceIn, ratio);\n    return addFee(amountIn, fee);\n}\n\nfunction subtractFee(amount: bigint, fee: bigint): bigint {\n    const feeAmount = MathSol.mulUpFixed(amount, fee);\n    return amount - feeAmount;\n}\n\nfunction addFee(amount: bigint, fee: bigint): bigint {\n    return MathSol.divUpFixed(amount, MathSol.complementFixed(fee));\n}\n\n// TO DO - Swap old versions of these in Pool for the BigInt version\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOutBigInt(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    const numerator = MathSol.mulUpFixed(balanceIn, weightOut);\n    let denominator = MathSol.mulUpFixed(balanceOut, weightIn);\n    const feeComplement = MathSol.complementFixed(fee);\n    denominator = MathSol.mulUpFixed(denominator, feeComplement);\n    const base = MathSol.divUpFixed(\n        balanceIn,\n        MathSol.add(MathSol.mulUpFixed(amountIn, feeComplement), balanceIn)\n    );\n    const exponent = MathSol.divUpFixed(weightIn + weightOut, weightOut);\n    denominator = MathSol.mulUpFixed(\n        denominator,\n        MathSol.powUpFixed(base, exponent)\n    );\n    return MathSol.divUpFixed(numerator, denominator);\n    //        -(\n    //            (Bi * wo) /\n    //            (Bo * (-1 + f) * (Bi / (Ai + Bi - Ai * f)) ** ((wi + wo) / wo) * wi)\n    //        )\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOutBigInt(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    let numerator = MathSol.mulUpFixed(balanceIn, weightOut);\n    const feeComplement = MathSol.complementFixed(fee);\n    const base = MathSol.divUpFixed(\n        balanceOut,\n        MathSol.sub(balanceOut, amountOut)\n    );\n    const exponent = MathSol.divUpFixed(weightIn + weightOut, weightIn);\n    numerator = MathSol.mulUpFixed(\n        numerator,\n        MathSol.powUpFixed(base, exponent)\n    );\n    const denominator = MathSol.mulUpFixed(\n        MathSol.mulUpFixed(balanceOut, weightIn),\n        feeComplement\n    );\n    return MathSol.divUpFixed(numerator, denominator);\n    //        -(\n    //            (Bi * (Bo / (-Ao + Bo)) ** ((wi + wo) / wi) * wo) /\n    //            (Bo * (-1 + f) * wi)\n    //        )\n}\n\n/**\n * Calculates BPT for given tokens in. Note all numbers use upscaled amounts. e.g. 1USDC = 1e18.\n * @param balances Pool balances.\n * @param normalizedWeights Token weights.\n * @param amountsIn Amount of each token.\n * @param bptTotalSupply Total BPT of pool.\n * @param swapFeePercentage Swap fee percentage.\n * @returns BPT out.\n */\nexport function _calcBptOutGivenExactTokensIn(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsIn: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    const balanceRatiosWithFee = new Array<bigint>(amountsIn.length);\n\n    let invariantRatioWithFees = BZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithFee[i] = MathSol.divDownFixed(\n            MathSol.add(balances[i], amountsIn[i]),\n            balances[i]\n        );\n        invariantRatioWithFees = MathSol.add(\n            invariantRatioWithFees,\n            MathSol.mulDownFixed(balanceRatiosWithFee[i], normalizedWeights[i])\n        );\n    }\n\n    let invariantRatio = MathSol.ONE;\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee: bigint;\n\n        if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.sub(invariantRatioWithFees, MathSol.ONE)\n            );\n            const taxableAmount = MathSol.sub(amountsIn[i], nonTaxableAmount);\n            const swapFee = MathSol.mulUpFixed(\n                taxableAmount,\n                swapFeePercentage\n            );\n            amountInWithoutFee = MathSol.add(\n                nonTaxableAmount,\n                MathSol.sub(taxableAmount, swapFee)\n            );\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        const balanceRatio = MathSol.divDownFixed(\n            MathSol.add(balances[i], amountInWithoutFee),\n            balances[i]\n        );\n\n        invariantRatio = MathSol.mulDownFixed(\n            invariantRatio,\n            MathSol.powDown(balanceRatio, normalizedWeights[i])\n        );\n    }\n\n    if (invariantRatio > MathSol.ONE) {\n        return MathSol.mulDownFixed(\n            bptTotalSupply,\n            MathSol.sub(invariantRatio, MathSol.ONE)\n        );\n    } else {\n        return BZERO;\n    }\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    totalBPT: bigint\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = amountOut                  /        bptIn         \\                                  //\n    // b = balance           a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\       totalBPT       /                                  //\n    // bpt = totalBPT                                                                            //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, totalBPT);\n\n    const amountsOut = new Array<bigint>(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n    }\n\n    return amountsOut;\n}\n\nexport function _calcTokenOutGivenExactBptIn(\n    balance: bigint,\n    normalizedWeight: bigint,\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    /*****************************************************************************************\n        // exactBPTInForTokenOut                                                                //\n        // a = amountOut                                                                        //\n        // b = balance                     /      /    totalBPT - bptIn       \\    (1 / w)  \\   //\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n        // bpt = totalBPT                  \\      \\       totalBPT            /             /   //\n        // w = weight                                                                           //\n        *****************************************************************************************/\n\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n    // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n    const invariantRatio = MathSol.divUpFixed(\n        MathSol.sub(bptTotalSupply, bptAmountIn),\n        bptTotalSupply\n    );\n    // Calculate by how much the token balance has to decrease to match invariantRatio\n    const balanceRatio = MathSol.powUpFixed(\n        invariantRatio,\n        MathSol.divDownFixed(MathSol.ONE, normalizedWeight)\n    );\n\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n    const amountOutWithoutFee = MathSol.mulDownFixed(\n        balance,\n        MathSol.complementFixed(balanceRatio)\n    );\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = MathSol.mulUpFixed(\n        amountOutWithoutFee,\n        MathSol.complementFixed(normalizedWeight)\n    );\n    const nonTaxableAmount = MathSol.sub(amountOutWithoutFee, taxableAmount);\n    const swapFee = MathSol.mulUpFixed(taxableAmount, swapFeePercentage);\n    const amountOut = MathSol.add(\n        nonTaxableAmount,\n        MathSol.sub(taxableAmount, swapFee)\n    );\n    return amountOut;\n}\n\nexport function _calcBptInGivenExactTokensOut(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsOut: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT in, so we round up overall.\n    const balanceRatiosWithoutFee = new Array<bigint>(amountsOut.length);\n\n    let invariantRatioWithoutFees = BZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithoutFee[i] = MathSol.divUpFixed(\n            MathSol.sub(balances[i], amountsOut[i]),\n            balances[i]\n        );\n        invariantRatioWithoutFees = MathSol.add(\n            invariantRatioWithoutFees,\n            MathSol.mulUpFixed(balanceRatiosWithoutFee[i], normalizedWeights[i])\n        );\n    }\n\n    const invariantRatio = _computeExitExactTokensOutInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsOut,\n        balanceRatiosWithoutFee,\n        invariantRatioWithoutFees,\n        swapFeePercentage\n    );\n\n    return MathSol.mulUpFixed(\n        bptTotalSupply,\n        MathSol.complementFixed(invariantRatio)\n    );\n}\n\nexport const _calcTokenInGivenExactBptOut = (\n    balance: bigint,\n    normalizedWeight: bigint,\n    bptAmountOut: bigint,\n    bptTotalSupply: bigint,\n    swapFee: bigint\n): bigint => {\n    /*****************************************************************************************\n    // tokenInForExactBptOut                                                                //\n    // a = amountIn                                                                         //\n    // b = balance                      /  /     bpt + bptOut     \\    (1 / w)      \\       //\n    // bptOut = bptAmountOut   a = b * |  | ---------------------- | ^          - 1  |      //\n    // bpt = bptTotalSupply             \\  \\         bpt          /                 /       //\n    // w = normalizedWeight                                                                 //\n    *****************************************************************************************/\n\n    // Token in, so we round up overall\n\n    // Calculate the factor by which the invariant will increase after minting `bptAmountOut`\n    const invariantRatio = MathSol.divUpFixed(\n        MathSol.add(bptTotalSupply, bptAmountOut),\n        bptTotalSupply\n    );\n    if (invariantRatio > MAX_INVARIANT_RATIO) {\n        throw new Error('MAX_OUT_BPT_FOR_TOKEN_IN');\n    }\n\n    // Calculate by how much the token balance has to increase to cause `invariantRatio`\n    const balanceRatio = MathSol.powUpFixed(\n        invariantRatio,\n        MathSol.divUpFixed(MathSol.ONE, normalizedWeight)\n    );\n    const amountInWithoutFee = MathSol.mulUpFixed(\n        balance,\n        MathSol.sub(balanceRatio, MathSol.ONE)\n    );\n    // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees accordingly\n    const taxablePercentage = MathSol.complementFixed(normalizedWeight);\n    const taxableAmount = MathSol.mulUpFixed(\n        amountInWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = MathSol.sub(amountInWithoutFee, taxableAmount);\n\n    return MathSol.add(\n        nonTaxableAmount,\n        MathSol.divUpFixed(taxableAmount, MathSol.complementFixed(swapFee))\n    );\n};\n\n/**\n * @dev Intermediate function to avoid stack-too-deep errors.\n */\nfunction _computeExitExactTokensOutInvariantRatio(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsOut: bigint[],\n    balanceRatiosWithoutFee: bigint[],\n    invariantRatioWithoutFees: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    let invariantRatio = MathSol.ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee;\n        if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.complementFixed(invariantRatioWithoutFees)\n            );\n            const taxableAmount = MathSol.sub(amountsOut[i], nonTaxableAmount);\n            const taxableAmountPlusFees = MathSol.divUpFixed(\n                taxableAmount,\n                MathSol.complementFixed(swapFeePercentage)\n            );\n\n            amountOutWithFee = MathSol.add(\n                nonTaxableAmount,\n                taxableAmountPlusFees\n            );\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        const balanceRatio = MathSol.divDownFixed(\n            MathSol.sub(balances[i], amountOutWithFee),\n            balances[i]\n        );\n\n        invariantRatio = MathSol.mulDownFixed(\n            invariantRatio,\n            MathSol.powDown(balanceRatio, normalizedWeights[i])\n        );\n    }\n    return invariantRatio;\n}\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\nexport function _calculateInvariant(\n    normalizedWeights: bigint[],\n    balances: bigint[]\n): bigint {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let invariant = MathSol.ONE;\n    for (let i = 0; i < normalizedWeights.length; i++) {\n        invariant = MathSol.mulDownFixed(\n            invariant,\n            MathSol.powDown(balances[i], normalizedWeights[i])\n        );\n    }\n\n    if (invariant < 0) throw Error('Weighted Invariant < 0');\n\n    return invariant;\n}\n\nexport function _calcDueProtocolSwapFeeBptAmount(\n    totalSupply: bigint,\n    previousInvariant: bigint,\n    currentInvariant: bigint,\n    protocolSwapFeePercentage: bigint\n): bigint {\n    // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n    // fees to the Vault.\n    const growth = MathSol.divDownFixed(currentInvariant, previousInvariant);\n\n    // Shortcut in case there was no growth when comparing the current against the previous invariant.\n    // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n    // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n    if (growth <= MathSol.ONE) {\n        return BZERO;\n    }\n\n    // Assuming the Pool is balanced and token weights have not changed, a growth of the invariant translates into\n    // proportional growth of all token balances. The protocol is due a percentage of that growth: more precisely,\n    // it is due `k = protocol fee * (growth - 1) * balance / growth` for each token.\n    // We compute the amount of BPT to mint for the protocol that would allow it to proportionally exit the Pool and\n    // receive these balances. Note that the total BPT supply will increase when minting, so we need to account for\n    // this in order to compute the percentage of Pool ownership the protocol will have.\n\n    // The formula is:\n    //\n    // toMint = supply * k / (1 - k)\n\n    // We compute protocol fee * (growth - 1) / growth, as we'll use that value twice.\n    // There is no need to use SafeMath since we already checked growth is strictly greater than one.\n    const k = MathSol.divDownFixed(\n        MathSol.mulDownFixed(protocolSwapFeePercentage, growth - MathSol.ONE),\n        growth\n    );\n    const numerator = MathSol.mulDownFixed(totalSupply, k);\n    const denominator = MathSol.complementFixed(k);\n\n    return denominator == BZERO\n        ? BZERO\n        : MathSol.divDownFixed(numerator, denominator);\n}\n\n// spotPriceAfterSwap\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * wo) /\n            (Bo * (-1 + f) * (Bi / (Ai + Bi - Ai * f)) ** ((wi + wo) / wo) * wi)\n        )\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * (Bo / (-Ao + Bo)) ** ((wi + wo) / wi) * wo) /\n            (Bo * (-1 + f) * wi)\n        )\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (Bi * ((Ai + Bi + Ai * f * (-1 + wi)) / Bi) ** (1 - wi)) /\n            (Bbpt * (1 + f * (-1 + wi)) * wi)\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutGivenExactTokenInBigInt(\n    balanceIn: bigint,\n    balanceOut: bigint,\n    weightIn: bigint,\n    amountIn: bigint,\n    swapFeeRatio: bigint\n): bigint {\n    const feeFactor =\n        MathSol.ONE -\n        MathSol.mulDownFixed(MathSol.complementFixed(weightIn), swapFeeRatio);\n    const denominatorFactor = MathSol.powDown(\n        MathSol.ONE + (amountIn * feeFactor) / balanceIn,\n        MathSol.complementFixed(weightIn)\n    );\n    return MathSol.divDownFixed(\n        MathSol.ONE,\n        (balanceOut * weightIn * feeFactor) / (balanceIn * denominatorFactor)\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Aibpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee));\n    return bnum(\n        ((1 - Aibpt / Bbpt) ** ((-1 + wo) / wo) *\n            Bbpt *\n            (1 + f * (-1 + wo)) *\n            wo) /\n            Bo\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (Bbpt *\n            (1 + f * (-1 + wo)) *\n            wo *\n            (1 + (Ao * (-1 + f - f * wo)) / Bo) ** (-1 + wo)) /\n            Bo\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceOut, 18));\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Aobpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (((Aobpt + Bbpt) / Bbpt) ** (1 / wi) * Bi) /\n            ((Aobpt + Bbpt) * (1 + f * (-1 + wi)) * wi)\n    );\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum((wi + wo) / (Bo * (Bi / (Ai + Bi - Ai * f)) ** (wi / wo) * wi));\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * (Bo / (-Ao + Bo)) ** (wo / wi) * wo * (wi + wo)) /\n            ((Ao - Bo) ** 2 * (-1 + f) * wi ** 2)\n        )\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceOut, 18));\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -((-1 + wi) / (Bbpt * ((Ai + Bi + Ai * f * (-1 + wi)) / Bi) ** wi * wi))\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceOut.toNumber(), 18)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Aobpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (((Aobpt + Bbpt) / Bbpt) ** (1 / wi) * Bi * (-1 + wi)) /\n            ((Aobpt + Bbpt) ** 2 * (1 + f * (-1 + wi)) * wi ** 2)\n        )\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Aibpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            ((1 + f * (-1 + wo)) * (-1 + wo)) /\n            ((1 - Aibpt / Bbpt) ** (1 / wo) * Bo)\n        )\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee));\n    return bnum(\n        -(\n            (Bbpt *\n                (1 + f * (-1 + wo)) ** 2 *\n                (-1 + wo) *\n                wo *\n                (1 + (Ao * (-1 + f - f * wo)) / Bo) ** (-2 + wo)) /\n            Bo ** 2\n        )\n    );\n}\n","import { getAddress } from '@ethersproject/address';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    scale,\n    ZERO,\n} from '../../utils/bignumber';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n    NoNullableField,\n} from '../../types';\nimport {\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _spotPriceAfterSwapExactTokenInForBPTOut,\n    _spotPriceAfterSwapExactBPTInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactBPTOut,\n    _spotPriceAfterSwapBPTInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactBPTInForTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForBPTOut,\n    _calcTokensOutGivenExactBptIn,\n} from './weightedMath';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { MathSol } from '../../utils/basicOperations';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nenum PairTypes {\n    BptToToken,\n    TokenToBpt,\n    TokenToToken,\n}\n\nexport type WeightedPoolToken = Pick<\n    NoNullableField<SubgraphToken>,\n    'address' | 'balance' | 'decimals' | 'weight'\n>;\n\nexport type WeightedPoolPairData = PoolPairBase & {\n    pairType: PairTypes;\n    weightIn: BigNumber;\n    weightOut: BigNumber;\n};\n\nexport class WeightedPool implements PoolBase<WeightedPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Weighted;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: WeightedPoolToken[];\n    totalWeight: BigNumber;\n    tokensList: string[];\n    MAX_IN_RATIO = parseFixed('0.3', 18);\n    MAX_OUT_RATIO = parseFixed('0.3', 18);\n    isLBP = false;\n\n    static fromPool(pool: SubgraphPoolBase, isLBP?: boolean): WeightedPool {\n        if (!pool.totalWeight)\n            throw new Error('WeightedPool missing totalWeight');\n        const weightedPool = new WeightedPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalWeight,\n            pool.totalShares,\n            pool.tokens as WeightedPoolToken[],\n            pool.tokensList\n        );\n        if (isLBP) weightedPool.isLBP = true;\n        return weightedPool;\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalWeight: string,\n        totalShares: string,\n        tokens: WeightedPoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.totalWeight = parseFixed(totalWeight, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): WeightedPoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n        const weightIn = parseFixed(tI.weight, 18)\n            .mul(ONE)\n            .div(this.totalWeight);\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n        const weightOut = parseFixed(tO.weight, 18)\n            .mul(ONE)\n            .div(this.totalWeight);\n\n        let pairType: PairTypes;\n        if (tokenIn == this.address) {\n            pairType = PairTypes.BptToToken;\n        } else if (tokenOut == this.address) {\n            pairType = PairTypes.TokenToBpt;\n        } else {\n            pairType = PairTypes.TokenToToken;\n        }\n\n        const poolPairData: WeightedPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            pairType: pairType,\n            weightIn: weightIn,\n            weightOut: weightOut,\n            swapFee: this.swapFee,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedWeights(): bigint[] {\n        return this.tokens.map((t) =>\n            parseFixed(t.weight, 18).mul(ONE).div(this.totalWeight).toBigInt()\n        );\n    }\n\n    getNormalizedLiquidity(poolPairData: WeightedPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PoolPairBase,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceIn.mul(this.MAX_IN_RATIO).div(ONE),\n                    poolPairData.decimalsIn\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut.mul(this.MAX_OUT_RATIO).div(ONE),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        }\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n    // i.e. when using token with 2decimals 0.002 should be returned as 0\n    // Uses ROUND_DOWN mode (1)\n    // calcOutGivenIn\n    _exactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (amount.isNaN()) return amount;\n        const amountIn = parseFixed(amount.dp(18, 1).toString(), 18).toBigInt();\n        const decimalsIn = poolPairData.decimalsIn;\n        const decimalsOut = poolPairData.decimalsOut;\n        const balanceIn = parseFixed(\n            poolPairData.balanceIn.toString(),\n            18 - decimalsIn\n        ).toBigInt();\n        const balanceOut = parseFixed(\n            poolPairData.balanceOut.toString(),\n            18 - decimalsOut\n        ).toBigInt();\n        const normalizedWeightIn = poolPairData.weightIn.toBigInt();\n        const normalizedWeightOut = poolPairData.weightOut.toBigInt();\n        const swapFee = poolPairData.swapFee.toBigInt();\n        let returnAmt: bigint;\n        try {\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnAmt = _calcBptOutGivenExactTokensIn(\n                    [balanceIn, BigInt(1)],\n                    [normalizedWeightIn, MathSol.ONE - normalizedWeightIn],\n                    [amountIn, BigInt(0)],\n                    balanceOut,\n                    swapFee\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnAmt = _calcTokenOutGivenExactBptIn(\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountIn,\n                    balanceIn,\n                    swapFee\n                );\n            } else {\n                returnAmt = _calcOutGivenIn(\n                    balanceIn,\n                    normalizedWeightIn,\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountIn,\n                    swapFee\n                );\n            }\n            // return human scaled\n            return scale(bnum(returnAmt.toString()), -18);\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n    // i.e. when using token with 2decimals 0.002 should be returned as 0\n    // Uses ROUND_UP mode (0)\n    // calcInGivenOut\n    _tokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (amount.isNaN()) return amount;\n        const amountOut = parseFixed(\n            amount.dp(18, 1).toString(),\n            18\n        ).toBigInt();\n        const decimalsIn = poolPairData.decimalsIn;\n        const decimalsOut = poolPairData.decimalsOut;\n        const balanceIn = parseFixed(\n            poolPairData.balanceIn.toString(),\n            18 - decimalsIn\n        ).toBigInt();\n        const balanceOut = parseFixed(\n            poolPairData.balanceOut.toString(),\n            18 - decimalsOut\n        ).toBigInt();\n        const normalizedWeightIn = poolPairData.weightIn.toBigInt();\n        const normalizedWeightOut = poolPairData.weightOut.toBigInt();\n        const swapFee = poolPairData.swapFee.toBigInt();\n        let returnAmt: bigint;\n        try {\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnAmt = _calcTokenInGivenExactBptOut(\n                    balanceIn,\n                    normalizedWeightIn,\n                    amountOut,\n                    balanceOut,\n                    swapFee\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnAmt = _calcBptInGivenExactTokensOut(\n                    [balanceOut, BigInt(1)],\n                    [normalizedWeightOut, MathSol.ONE - normalizedWeightOut],\n                    [amountOut, BigInt(0)],\n                    balanceIn,\n                    swapFee\n                );\n            } else {\n                returnAmt = _calcInGivenOut(\n                    balanceIn,\n                    normalizedWeightIn,\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountOut,\n                    swapFee\n                );\n            }\n            // return human scaled\n            return scale(bnum(returnAmt.toString()), -18);\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        const balancesNormalised = this.tokens\n            .filter((t) => !isSameAddress(t.address, this.address))\n            .map((t) => normaliseBalance(t));\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, this.tokens[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                balancesNormalised,\n                this.getNormalizedWeights(),\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            return Zero;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _spotPriceAfterSwapExactTokenInForBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _spotPriceAfterSwapExactBPTInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _spotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _spotPriceAfterSwapTokenInForExactBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _spotPriceAfterSwapBPTInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _spotPriceAfterSwapTokenInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n}\n","import { BigNumber as OldBigNumber, ZERO, bnum } from '../utils/bignumber';\n\n/*\nIt is possible to compute the normalized liquidity using another function already existing at every pool type, which is the derivative of spot price after swap.\nhttps://quark-ceres-740.notion.site/SOR-Normalized-liquidity-and-highest-liquidity-pool-d81bd3db48e5482ab2275a8eecac33b4\n*/\nexport function universalNormalizedLiquidity(\n    derivativeSpotPriceAtZero: OldBigNumber\n): OldBigNumber {\n    const ans = bnum(1).div(derivativeSpotPriceAtZero);\n    if (ans.isNaN() || ans.lt(ZERO) || !ans.isFinite()) return ZERO;\n    return ans;\n}\n","import { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as EONE } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n} from '../../utils/bignumber';\nimport { StablePoolPairData } from './stablePool';\n// All functions are adapted from the solidity ones to be found on:\n// https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/pools/stable/StableMath.sol\n\n// TODO: implement all up and down rounding variations\n\n/**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant to compute                                                                  //\n    // A = amplifier                n * D^2 + A * n^n * S * (n^n * P / D^(n1))                  //\n    // S = sum of balances         ____________________________________________                  //\n    // P = product of balances    (n+1) * D + ( A * n^n  1)* (n^n * P / D^(n1))                //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\nexport function _invariant(\n    A: BigNumber,\n    balances: OldBigNumber[] // balances\n): OldBigNumber {\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    for (let i = 0; i < totalCoins; i++) {\n        sum = sum.plus(balances[i]);\n    }\n    if (sum.isZero()) {\n        return ZERO;\n    }\n    let prevInv = ZERO;\n    let inv = sum;\n\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const ATimesNpowN = AAdjusted.times(totalCoins ** totalCoins); // A*n^n\n\n    for (let i = 0; i < 255; i++) {\n        let P_D = bnum(totalCoins).times(balances[0]);\n        for (let j = 1; j < totalCoins; j++) {\n            //P_D is rounded up\n            P_D = P_D.times(balances[j]).times(totalCoins).div(inv);\n        }\n        prevInv = inv;\n        //inv is rounded up\n        inv = bnum(totalCoins)\n            .times(inv)\n            .times(inv)\n            .plus(ATimesNpowN.times(sum).times(P_D))\n            .div(\n                bnum(totalCoins + 1)\n                    .times(inv)\n                    .plus(ATimesNpowN.minus(1).times(P_D))\n            );\n        // Equality with the precision of 1\n        if (inv.gt(prevInv)) {\n            if (inv.minus(prevInv).lt(bnum(10 ** -18))) {\n                break;\n            }\n        } else if (prevInv.minus(inv).lt(bnum(10 ** -18))) {\n            break;\n        }\n    }\n    //Result is rounded up\n    return inv;\n}\n\n// Adapted from StableMath.sol, _outGivenIn()\n// * Added swap fee at very first line\n/**********************************************************************************************\n    // outGivenIn token x for y - polynomial equation to solve                                   //\n    // ay = amount out to calculate                                                              //\n    // by = balance token out                                                                    //\n    // y = by - ay                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               y^2 + ( S - ----------  - 1) * y -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but y                                                           //\n    // P = product of final balances but y                                                       //\n    **********************************************************************************************/\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    let tokenAmountIn = amount;\n    tokenAmountIn = tokenAmountIn\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexIn) {\n            x = balances[i].plus(tokenAmountIn);\n        } else if (i != tokenIndexOut) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate out balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded down\n    // return balances[tokenIndexOut] > y ? balances[tokenIndexOut].minus(y) : 0;\n    return balances[tokenIndexOut].minus(y);\n}\n\n// Adapted from StableMath.sol, _inGivenOut()\n// * Added swap fee at very last line\n/**********************************************************************************************\n    // inGivenOut token x for y - polynomial equation to solve                                   //\n    // ax = amount in to calculate                                                               //\n    // bx = balance token in                                                                     //\n    // x = bx + ax                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               x^2 + ( S - ----------  - 1) * x -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but x                                                           //\n    // P = product of final balances but x                                                       //\n    **********************************************************************************************/\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexOut) {\n            x = balances[i].minus(tokenAmountOut);\n        } else if (i != tokenIndexIn) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate in balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded up\n    return y\n        .minus(balances[tokenIndexIn])\n        .multipliedBy(EONE.toString())\n        .div(EONE.sub(swapFee).toString());\n}\n\n//This function calcuates the analytical solution to find the balance required\nexport function _solveAnalyticalBalance(\n    sum: OldBigNumber,\n    inv: OldBigNumber,\n    A: BigNumber,\n    n_pow_n: OldBigNumber,\n    p: OldBigNumber\n): OldBigNumber {\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const oldBN_A = bnum(formatFixed(A, 3));\n    //Round up p\n    p = p.times(inv).div(oldBN_A.times(n_pow_n).times(n_pow_n));\n    //Round down b\n    const b = sum.plus(inv.div(oldBN_A.times(n_pow_n)));\n    const c = inv\n        .minus(b)\n        .plus(inv.minus(b).times(inv.minus(b)).plus(p.times(4)).sqrt());\n    //Round up y\n    return c.div(2);\n}\n\n//////////////////////\n////  These functions have been added exclusively for the SORv2\n//////////////////////\n\nfunction _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S = S.plus(balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const a = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const b = S.minus(D).times(a).plus(D);\n    const twoaxy = bnum(2).times(a).times(x).times(y);\n    const partial_x = twoaxy.plus(a.times(y).times(y)).plus(b.times(y));\n    const partial_y = twoaxy.plus(a.times(x).times(x)).plus(b.times(x));\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(partial_y);\n    } else {\n        const partial_xx = bnum(2).times(a).times(y);\n        const partial_yy = bnum(2).times(a).times(x);\n        const partial_xy = partial_xx.plus(partial_yy).plus(b);\n        const numerator = bnum(2)\n            .times(partial_x)\n            .times(partial_y)\n            .times(partial_xy)\n            .minus(partial_xx.times(partial_y.pow(2)))\n            .minus(partial_yy.times(partial_x.pow(2)));\n        const denominator = partial_x.pow(2).times(partial_y);\n        ans = numerator.div(denominator);\n        if (wrt_out) {\n            ans = ans.times(partial_y).div(partial_x);\n        }\n    }\n    return ans;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        false\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    const feeFactor = EONE.div(swapFee).toString();\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        true\n    ).div(feeFactor);\n}\n\n// The following are used in front-end helper functions\n\nfunction _feeFactor(\n    balances: OldBigNumber[],\n    tokenIndex: number,\n    swapFee: BigNumber\n): OldBigNumber {\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n    const currentWeight = balances[tokenIndex].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n    return ONE.minus(\n        tokenBalancePercentageExcess\n            .times(swapFee.toString())\n            .div(EONE.toString())\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, tokenIndexIn, decimalsOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnum(formatFixed(balanceOut, decimalsOut)).plus(amount),\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n/*\nFlow of calculations:\namountBPTOut -> newInvariant -> (amountInProportional, amountInAfterFee) ->\namountInPercentageExcess -> amountIn\n*/\nfunction _tokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountOut = amount;\n\n    /**********************************************************************************************\n    // TODO description                            //\n    **********************************************************************************************/\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const newInvariant = allBalances[tokenIndexOut]\n        .plus(bptAmountOut)\n        .div(allBalances[tokenIndexOut])\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // get amountInAfterFee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInAfterFee = newBalanceTokenIndex.minus(balances[tokenIndexIn]);\n\n    // Get tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n\n    // return amountIn\n    return amountInAfterFee.div(\n        ONE.minus(\n            tokenBalancePercentageExcess\n                .times(swapFee.toString())\n                .div(EONE.toString())\n        )\n    );\n}\n\n//This function calculates the balance of a given token (tokenIndex)\n// given all the other balances and the invariant\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    inv: OldBigNumber,\n    tokenIndex: number\n): OldBigNumber {\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    let nPowN = ONE;\n    let x = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        nPowN = nPowN.times(totalCoins);\n        if (i != tokenIndex) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    // Calculate token balance\n    return _solveAnalyticalBalance(sum, inv, A, nPowN, p);\n}\n\nfunction _poolDerivativesBPT(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    bptSupply: OldBigNumber,\n    tokenIndexIn: number,\n    is_first_derivative: boolean,\n    is_BPT_out: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    let D_P = D.div(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S.plus(balances[i]);\n            D_P = D_P.times(D).div(balances[i].times(totalCoins));\n        }\n    }\n    const x = balances[tokenIndexIn];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const alpha = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const beta = alpha.times(S);\n    const gamma = ONE.minus(alpha);\n    const partial_x = bnum(2)\n        .times(alpha)\n        .times(x)\n        .plus(beta)\n        .plus(gamma.times(D));\n    const minus_partial_D = D_P.times(totalCoins + 1).minus(gamma.times(x));\n    const partial_D = ZERO.minus(minus_partial_D);\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(minus_partial_D).times(bptSupply).div(D);\n    } else {\n        const partial_xx = bnum(2).times(alpha);\n        const partial_xD = gamma;\n        const n_times_nplusone = totalCoins * (totalCoins + 1);\n        const partial_DD = ZERO.minus(D_P.times(n_times_nplusone).div(D));\n        if (is_BPT_out) {\n            const term1 = partial_xx.times(partial_D).div(partial_x.pow(2));\n            const term2 = bnum(2).times(partial_xD).div(partial_x);\n            const term3 = partial_DD.div(partial_D);\n            ans = term1.minus(term2).plus(term3).times(D).div(bptSupply);\n            if (wrt_out) {\n                const D_prime = ZERO.minus(partial_x.div(partial_D));\n                ans = ans.div(D_prime).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2)\n                .times(partial_xD)\n                .div(partial_D)\n                .minus(partial_DD.times(partial_x).div(partial_D.pow(2)))\n                .minus(partial_xx.div(partial_x));\n            if (wrt_out) {\n                ans = ans\n                    .times(partial_x)\n                    .div(minus_partial_D)\n                    .times(bptSupply)\n                    .div(D);\n            }\n        }\n    }\n    return ans;\n}\n","/*\nSwap outcome and \"spot price after swap\" formulas for weighted, stable and linear pools.\nAmounts are represented using bigint type. Swap outcomes formulas should\nmatch exactly those from smart contracts.\n\nTest cases are found in poolsMathWeighted.spec.ts, poolsMathStable.spec.ts poolsMathLinear.spec.ts.\n\nIt is necessary to review whether to use MathSol operations or native +,-,\\*,/ case by case. MathSol operations are able to reproduce overflows while native operations produce a much more readable code. For instance, for \"spot price after swap\" native operations\nare preferred since in this case there are not smart contract analogs, amount limits are assumed to have been checked elsewhere, and some formulas get complicated, specially for stable pools.\n*/\nimport { MathSol, BZERO } from '../../utils/basicOperations';\n\nconst AMP_PRECISION = BigInt(1e3);\n\nfunction _calculateInvariant(amp: bigint, balances: bigint[]): bigint {\n    /**********************************************************************************************\n      // invariant                                                                                 //\n      // D = invariant                                                  D^(n+1)                    //\n      // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n      // S = sum of balances                                             n^n P                     //\n      // P = product of balances                                                                   //\n      // n = number of tokens                                                                      //\n      *********x************************************************************************************/\n\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n\n    let sum = BZERO;\n    const numTokens = balances.length;\n    for (let i = 0; i < numTokens; i++) {\n        sum = sum + balances[i];\n    }\n    if (sum == BZERO) {\n        return BZERO;\n    }\n\n    let prevInvariant = BZERO;\n    let invariant = sum;\n    const ampTimesTotal = amp * BigInt(numTokens);\n\n    for (let i = 0; i < 255; i++) {\n        let D_P = invariant;\n        for (let j = 0; j < numTokens; j++) {\n            // (D_P * invariant) / (balances[j] * numTokens)\n            D_P = MathSol.divDown(\n                MathSol.mul(D_P, invariant),\n                MathSol.mul(balances[j], BigInt(numTokens))\n            );\n        }\n\n        prevInvariant = invariant;\n        invariant = MathSol.divDown(\n            MathSol.mul(\n                // (ampTimesTotal * sum) / AMP_PRECISION + D_P * numTokens\n                MathSol.divDown(\n                    MathSol.mul(ampTimesTotal, sum),\n                    AMP_PRECISION\n                ) + MathSol.mul(D_P, BigInt(numTokens)),\n                invariant\n            ),\n            // ((ampTimesTotal - _AMP_PRECISION) * invariant) / _AMP_PRECISION + (numTokens + 1) * D_P\n            MathSol.divDown(\n                MathSol.mul(ampTimesTotal - AMP_PRECISION, invariant),\n                AMP_PRECISION\n            ) + MathSol.mul(BigInt(numTokens + 1), D_P)\n        );\n\n        if (invariant > prevInvariant) {\n            if (invariant - prevInvariant <= 1) {\n                return invariant;\n            }\n        } else if (prevInvariant - invariant <= 1) {\n            return invariant;\n        }\n    }\n    throw new Error('Errors.STABLE_INVARIANT_DIDNT_CONVERGE');\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    amountIn = subtractFee(amountIn, fee);\n    const invariant = _calculateInvariant(amp, balances);\n\n    const initBalance = balances[tokenIndexIn];\n    balances[tokenIndexIn] = initBalance + amountIn;\n    const finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amp,\n        balances,\n        invariant,\n        tokenIndexOut\n    );\n    return balances[tokenIndexOut] - finalBalanceOut - BigInt(1);\n}\n\nexport function _calcInGivenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const invariant = _calculateInvariant(amp, balances);\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n\n    const finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amp,\n        balances,\n        invariant,\n        tokenIndexIn\n    );\n\n    let amountIn = MathSol.add(\n        MathSol.sub(finalBalanceIn, balances[tokenIndexIn]),\n        BigInt(1)\n    );\n    amountIn = addFee(amountIn, fee);\n    return amountIn;\n}\n\n/**\n * _calcBptOutGivenExactTokensIn\n * @param amp Amplification parameter in EVM Scale\n * @param balances Token balances in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param amountsIn Token amounts in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param bptTotalSupply BPT total supply in EVM Scale\n * @param swapFeePercentage Swap fee percentage in EVM Scale\n * @returns BPT out in EVM Scale\n */\nexport function _calcBptOutGivenExactTokensIn(\n    amp: bigint,\n    balances: bigint[],\n    amountsIn: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT out, so we round down overall.\n\n    // First loop calculates the sum of all token balances, which will be used to calculate\n    // the current weights of each token, relative to this sum\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const balanceRatiosWithFee: bigint[] = new Array(amountsIn.length);\n    // The weighted sum of token balance ratios with fee\n    let invariantRatioWithFees = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divDownFixed(balances[i], sumBalances);\n        balanceRatiosWithFee[i] = MathSol.divDownFixed(\n            balances[i] + amountsIn[i],\n            balances[i]\n        );\n        invariantRatioWithFees =\n            invariantRatioWithFees +\n            MathSol.mulDownFixed(balanceRatiosWithFee[i], currentWeight);\n    }\n\n    // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n    const newBalances: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee: bigint;\n\n        // Check if the balance ratio is greater than the ideal ratio to charge fees or not\n        if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                invariantRatioWithFees - MathSol.ONE\n            );\n            const taxableAmount = amountsIn[i] - nonTaxableAmount;\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            amountInWithoutFee =\n                nonTaxableAmount +\n                MathSol.mulDownFixed(\n                    taxableAmount,\n                    MathSol.ONE - swapFeePercentage\n                );\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n        newBalances[i] = balances[i] + amountInWithoutFee;\n    }\n\n    // Get current and new invariants, taking swap fees into account\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = _calculateInvariant(amp, newBalances);\n\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    // If the invariant didn't increase for any reason, we simply don't mint BPT\n    if (invariantRatio > MathSol.ONE) {\n        return MathSol.mulDownFixed(\n            bptTotalSupply,\n            invariantRatio - MathSol.ONE\n        );\n    } else {\n        return BigInt(0);\n    }\n}\n\n/**\n * _calcTokenInGivenExactBptOut\n * @param amp Amplification parameter in EVM Scale\n * @param balances Token balances in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param tokenIndexIn Index of token in (from tokens array without BPT)\n * @param bptAmountOut BPT amount out in EVM scale\n * @param bptTotalSupply BPT total supply in EVM Scale\n * @param fee Swap fee percentage in EVM Scale\n * @returns token in EVM Scale normalised to 18 decimals\n */\nexport function _calcTokenInGivenExactBptOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptAmountOut: bigint,\n    bptTotalSupply: bigint,\n    fee: bigint\n): bigint {\n    // Token in, so we round up overall.\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(\n            MathSol.add(bptTotalSupply, bptAmountOut),\n            bptTotalSupply\n        ),\n        currentInvariant\n    );\n\n    // Calculate amount in without fee.\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInWithoutFee = MathSol.sub(\n        newBalanceTokenIndex,\n        balances[tokenIndexIn]\n    );\n\n    // First calculate the sum of all token balances, which will be used to calculate\n    // the current weight of each token\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = MathSol.add(sumBalances, balances[i]);\n    }\n\n    // We can now compute how much extra balance is being deposited\n    // and used in virtual swaps, and charge swap fees accordingly.\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndexIn],\n        sumBalances\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n    const taxableAmount = MathSol.mulUpFixed(\n        amountInWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = MathSol.sub(amountInWithoutFee, taxableAmount);\n\n    return MathSol.add(\n        nonTaxableAmount,\n        MathSol.divUpFixed(taxableAmount, MathSol.sub(MathSol.ONE, fee))\n    );\n}\n\n/*\nFlow of calculations:\namountsTokenOut -> amountsOutProportional ->\namountOutPercentageExcess -> amountOutBeforeFee -> newInvariant -> amountBPTIn\n*/\nexport function _calcBptInGivenExactTokensOut(\n    amp: bigint,\n    balances: bigint[],\n    amountsOut: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT in, so we round up overall.\n\n    // First loop calculates the sum of all token balances, which will be used to calculate\n    // the current weights of each token relative to this sum\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const balanceRatiosWithoutFee: bigint[] = new Array(amountsOut.length);\n    let invariantRatioWithoutFees = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divUpFixed(balances[i], sumBalances);\n        balanceRatiosWithoutFee[i] = MathSol.divUpFixed(\n            balances[i] - amountsOut[i],\n            balances[i]\n        );\n        invariantRatioWithoutFees =\n            invariantRatioWithoutFees +\n            MathSol.mulUpFixed(balanceRatiosWithoutFee[i], currentWeight);\n    }\n\n    // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n    const newBalances: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee: bigint;\n        if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.complementFixed(invariantRatioWithoutFees)\n            );\n            const taxableAmount = amountsOut[i] - nonTaxableAmount;\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            amountOutWithFee =\n                nonTaxableAmount +\n                MathSol.divUpFixed(\n                    taxableAmount,\n                    MathSol.ONE - swapFeePercentage\n                );\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n        newBalances[i] = balances[i] - amountOutWithFee;\n    }\n\n    // Get current and new invariants, taking into account swap fees\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = _calculateInvariant(amp, newBalances);\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    // return amountBPTIn\n    return MathSol.mulUpFixed(\n        bptTotalSupply,\n        MathSol.complementFixed(invariantRatio)\n    );\n}\n\nexport function _calcTokenOutGivenExactBptIn(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndex: number,\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // Token out, so we round down overall.\n\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(bptTotalSupply - bptAmountIn, bptTotalSupply),\n        currentInvariant\n    );\n\n    // Calculate amount out without fee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n    const amountOutWithoutFee = balances[tokenIndex] - newBalanceTokenIndex;\n\n    // First calculate the sum of all token balances, which will be used to calculate\n    // the current weight of each token\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndex],\n        sumBalances\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = MathSol.mulUpFixed(\n        amountOutWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = amountOutWithoutFee - taxableAmount;\n\n    // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n    return (\n        nonTaxableAmount +\n        MathSol.mulDownFixed(taxableAmount, MathSol.ONE - swapFeePercentage)\n    );\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = tokenAmountOut             /        bptIn         \\                                  //\n    // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n    // bpt = bptTotalSupply                                                                      //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, bptTotalSupply);\n\n    const amountsOut: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n    }\n\n    return amountsOut;\n}\n\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    amp: bigint,\n    balances: bigint[],\n    invariant: bigint,\n    tokenIndex: number\n): bigint {\n    // Rounds result up overall\n\n    const ampTimesTotal = amp * BigInt(balances.length);\n    let sum = balances[0];\n    let P_D = balances[0] * BigInt(balances.length);\n    for (let j = 1; j < balances.length; j++) {\n        P_D = MathSol.divDown(\n            MathSol.mul(MathSol.mul(P_D, balances[j]), BigInt(balances.length)),\n            invariant\n        );\n        sum = sum + balances[j];\n    }\n    // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n    sum = sum - balances[tokenIndex];\n\n    const inv2 = MathSol.mul(invariant, invariant);\n    // We remove the balance fromm c by multiplying it\n    const c = MathSol.mul(\n        MathSol.mul(\n            MathSol.divUp(inv2, MathSol.mul(ampTimesTotal, P_D)),\n            AMP_PRECISION\n        ),\n        balances[tokenIndex]\n    );\n    const b =\n        sum +\n        MathSol.mul(MathSol.divDown(invariant, ampTimesTotal), AMP_PRECISION);\n\n    // We iterate to find the balance\n    let prevTokenBalance = BZERO;\n    // We multiply the first iteration outside the loop with the invariant to set the value of the\n    // initial approximation.\n    let tokenBalance = MathSol.divUp(inv2 + c, invariant + b);\n\n    for (let i = 0; i < 255; i++) {\n        prevTokenBalance = tokenBalance;\n\n        tokenBalance = MathSol.divUp(\n            MathSol.mul(tokenBalance, tokenBalance) + c,\n            MathSol.mul(tokenBalance, BigInt(2)) + b - invariant\n        );\n\n        if (tokenBalance > prevTokenBalance) {\n            if (tokenBalance - prevTokenBalance <= 1) {\n                return tokenBalance;\n            }\n        } else if (prevTokenBalance - tokenBalance <= 1) {\n            return tokenBalance;\n        }\n    }\n    throw new Error('Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE');\n}\n\nfunction subtractFee(amount: bigint, fee: bigint): bigint {\n    const feeAmount = MathSol.mulUpFixed(amount, fee);\n    return amount - feeAmount;\n}\n\nfunction addFee(amount: bigint, fee: bigint): bigint {\n    return MathSol.divUpFixed(amount, MathSol.complementFixed(fee));\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    const feeComplement = MathSol.complementFixed(fee);\n    const balancesCopy = [...balances];\n    balances[tokenIndexIn] = MathSol.add(\n        balances[tokenIndexIn],\n        MathSol.mulUpFixed(amountIn, feeComplement)\n    );\n    balances[tokenIndexOut] = MathSol.sub(\n        balances[tokenIndexOut],\n        _calcOutGivenIn(\n            amp,\n            balancesCopy,\n            tokenIndexIn,\n            tokenIndexOut,\n            amountIn,\n            fee\n        )\n    );\n    let ans = _poolDerivatives(\n        amp,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = MathSol.divDownFixed(\n        MathSol.ONE,\n        MathSol.mulDownFixed(ans, feeComplement)\n    );\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const balancesCopy = [...balances];\n    const _in = _calcInGivenOut(\n        amp,\n        balancesCopy,\n        tokenIndexIn,\n        tokenIndexOut,\n        amountOut,\n        fee\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn] + _in;\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n    let ans = _poolDerivatives(\n        amp,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    const feeComplement = MathSol.complementFixed(fee);\n    ans = MathSol.divUpFixed(\n        MathSol.ONE,\n        MathSol.mulUpFixed(ans, feeComplement)\n    );\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptTotalSupply: bigint,\n    amountIn: bigint\n    // assuming zero fee\n): bigint {\n    balances[tokenIndexIn] = balances[tokenIndexIn] + amountIn;\n    // working\n    const amountsIn = balances.map((_value, index) =>\n        index == tokenIndexIn ? amountIn : BigInt(0)\n    );\n    const finalBPTSupply =\n        bptTotalSupply +\n        _calcBptOutGivenExactTokensIn(\n            amp,\n            balances,\n            amountsIn,\n            bptTotalSupply,\n            BigInt(0)\n        );\n    let ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        finalBPTSupply,\n        tokenIndexIn,\n        true,\n        true,\n        false\n    );\n    ans = MathSol.divUpFixed(MathSol.ONE, ans);\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptTotalSupply: bigint,\n    amountOut: bigint\n    // assuming zero fee\n): bigint {\n    const balancesCopy = [...balances];\n    const _in = _calcTokenInGivenExactBptOut(\n        amp,\n        balancesCopy,\n        tokenIndexIn,\n        amountOut,\n        bptTotalSupply,\n        BigInt(0)\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn] + _in;\n    let ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupply + amountOut,\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = MathSol.divUpFixed(MathSol.ONE, ans); // ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexOut: number,\n    bptTotalSupply: bigint,\n    amountIn: bigint\n    // assuming zero fee\n): bigint {\n    // balances copy not necessary?\n    const _out = _calcTokenOutGivenExactBptIn(\n        amp,\n        balances,\n        tokenIndexOut,\n        amountIn,\n        bptTotalSupply,\n        BigInt(0)\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut] - _out;\n    const bptTotalSupplyAfter = MathSol.sub(bptTotalSupply, amountIn);\n    const ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupplyAfter,\n        tokenIndexOut,\n        true,\n        false,\n        false\n    );\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexOut: number,\n    bptTotalSupply: bigint,\n    amountOut: bigint\n): bigint {\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n    const amountsOut = balances.map((_value, index) =>\n        index == tokenIndexOut ? amountOut : BigInt(0)\n    );\n    const bptTotalSupplyAfter =\n        bptTotalSupply -\n        _calcBptInGivenExactTokensOut(\n            amp,\n            balances,\n            amountsOut,\n            bptTotalSupply,\n            BigInt(0)\n        );\n    const ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupplyAfter,\n        tokenIndexOut,\n        true,\n        false,\n        true\n    );\n    return ans;\n}\n\nexport function _poolDerivatives(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): bigint {\n    const totalCoins = balances.length;\n    const D = _calculateInvariant(amp, balances);\n    let S = BigInt(0);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S += balances[i];\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    const a = amp * BigInt(totalCoins);\n    const b = a * (S - D) + D * AMP_PRECISION;\n    const twoaxy = BigInt(2) * a * x * y;\n    const partial_x = twoaxy + a * y * y + b * y;\n    const partial_y = twoaxy + a * x * x + b * x;\n    let ans: bigint;\n    if (is_first_derivative) {\n        ans = MathSol.divUpFixed(partial_x, partial_y);\n    } else {\n        // Untested case:\n        const partial_xx = BigInt(2) * a * y;\n        const partial_yy = BigInt(2) * a * x;\n        const partial_xy = partial_xx + partial_yy + b; // AMP_PRECISION missing\n        const numerator =\n            BigInt(2) * partial_x * partial_y * partial_xy -\n            partial_xx * partial_y * partial_y +\n            partial_yy * partial_x * partial_x;\n        const denominator = partial_x * partial_x * partial_y;\n        ans = MathSol.divUpFixed(numerator, denominator); // change the order to directly use integer operations\n        if (wrt_out) {\n            ans = MathSol.mulUpFixed(\n                MathSol.mulUpFixed(ans, partial_y),\n                partial_x\n            );\n        }\n    }\n    return ans;\n}\n\nexport function _poolDerivativesBPT(\n    amp: bigint,\n    balances: bigint[],\n    bptSupply: bigint,\n    tokenIndexIn: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    is_first_derivative: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    is_BPT_out: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    wrt_out: boolean\n): bigint {\n    const totalCoins = balances.length;\n    const D = _calculateInvariant(amp, balances);\n    let S = BigInt(0);\n    let D_P = D / BigInt(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S + balances[i];\n            D_P = (D_P * D) / (BigInt(totalCoins) * balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const alpha = amp * BigInt(totalCoins);\n    const beta = alpha * S; // units = 10 ** 21\n    const gamma = BigInt(AMP_PRECISION) - alpha;\n    const partial_x = BigInt(2) * alpha * x + beta + gamma * D;\n    const minus_partial_D =\n        D_P * BigInt(totalCoins + 1) * AMP_PRECISION - gamma * x;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const partial_D = -minus_partial_D;\n    const ans = MathSol.divUpFixed(\n        (partial_x * bptSupply) / minus_partial_D,\n        D\n    );\n    /*\n    if (is_first_derivative) {\n        ans = MathSol.divUpFixed((partial_x * bptSupply) / minus_partial_D, D);\n    } else {\n        let partial_xx = bnum(2).times(alpha);\n        let partial_xD = gamma;\n        let n_times_nplusone = totalCoins * (totalCoins + 1);\n        let partial_DD = bnum(0).minus( D_P.times(n_times_nplusone).div(D) );\n        if (is_BPT_out) {\n            let term1 = partial_xx.times(partial_D).div( partial_x.pow(2) );\n            let term2 = bnum(2).times(partial_xD).div(partial_x);\n            let term3 = partial_DD.div(partial_D);\n            ans = (term1.minus(term2).plus(term3)).times(D).div(bptSupply)\n            if (wrt_out) {\n                let D_prime = bnum(0).minus( partial_x.div(partial_D) );\n                ans = ans.div( D_prime ).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2).times(partial_xD).div(partial_D).minus(\n                partial_DD.times(partial_x).div(partial_D.pow(2)) ).minus(\n                partial_xx.div(partial_x) );\n            if (wrt_out) {\n                ans = ans.times(partial_x).div(minus_partial_D).times(bptSupply).div(D);\n            }\n        }\n    }\n*/\n    return ans;\n}\n","import { getAddress } from '@ethersproject/address';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    scale,\n    ZERO,\n} from '../../utils/bignumber';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport {\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n} from './stableMath';\nimport {\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcTokensOutGivenExactBptIn,\n} from './stableMathBigInt';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\ntype StablePoolToken = Pick<SubgraphToken, 'address' | 'balance' | 'decimals'>;\n\nexport type StablePoolPairData = PoolPairBase & {\n    allBalances: OldBigNumber[];\n    allBalancesScaled: BigNumber[]; // EVM Maths uses everything in 1e18 upscaled format and this avoids repeated scaling\n    amp: BigNumber;\n    tokenIndexIn: number;\n    tokenIndexOut: number;\n};\n\nexport class StablePool implements PoolBase<StablePoolPairData> {\n    poolType: PoolTypes = PoolTypes.Stable;\n    id: string;\n    address: string;\n    amp: BigNumber;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: StablePoolToken[];\n    tokensList: string[];\n    MAX_IN_RATIO = parseFixed('0.3', 18);\n    MAX_OUT_RATIO = parseFixed('0.3', 18);\n\n    static AMP_DECIMALS = 3;\n\n    static fromPool(pool: SubgraphPoolBase): StablePool {\n        if (!pool.amp) throw new Error('StablePool missing amp factor');\n        return new StablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: StablePoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.amp = parseFixed(amp, StablePool.AMP_DECIMALS);\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): StablePoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        // Get all token balances\n        const allBalances = this.tokens.map(({ balance }) => bnum(balance));\n        const allBalancesScaled = this.tokens.map(({ balance }) =>\n            parseFixed(balance, 18)\n        );\n\n        const poolPairData: StablePoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            allBalances,\n            allBalancesScaled, // TO DO - Change to BigInt??\n            amp: this.amp,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: StablePoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PoolPairBase,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // We multiply ratios by 10**-18 because we are in normalized space\n        // so 0.5 should be 0.5 and not 500000000000000000\n        // TODO: update bmath to use everything normalized\n        if (swapType === SwapTypes.SwapExactIn) {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceIn.mul(this.MAX_IN_RATIO).div(ONE),\n                    poolPairData.decimalsIn\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut.mul(this.MAX_OUT_RATIO).div(ONE),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n\n            const amtWithFeeEvm = this.subtractSwapFeeAmount(\n                parseFixed(\n                    amount.dp(poolPairData.decimalsIn).toString(),\n                    poolPairData.decimalsIn\n                ),\n                poolPairData.swapFee\n            );\n\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = amtWithFeeEvm.mul(\n                10 ** (18 - poolPairData.decimalsIn)\n            );\n\n            const amt = _calcOutGivenIn(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amtScaled.toBigInt(),\n                BigInt(0)\n            );\n\n            // return normalised amount\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            // console.error(`_evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.dp(18).toString(), 18);\n\n            let amt = _calcInGivenOut(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amtScaled.toBigInt(),\n                BigInt(0)\n            );\n\n            // this is downscaleUp\n            const scaleFactor = BigInt(10 ** (18 - poolPairData.decimalsIn));\n            amt = (amt + scaleFactor - BigInt(1)) / scaleFactor;\n\n            const amtWithFee = this.addSwapFeeAmount(\n                BigNumber.from(amt),\n                poolPairData.swapFee\n            );\n            return bnum(amtWithFee.toString()).div(\n                10 ** poolPairData.decimalsIn\n            );\n        } catch (err) {\n            console.error(`_evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        // takes price rate into account\n        const balancesNormalised = this.tokens\n            .filter((t) => !isSameAddress(t.address, this.address))\n            .map((t) => normaliseBalance(t));\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, this.tokens[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                this.amp.toBigInt(),\n                balancesNormalised,\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            return Zero;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _spotPriceAfterSwapExactTokenInForTokenOut(amount, poolPairData);\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _spotPriceAfterSwapTokenInForExactTokenOut(amount, poolPairData);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n\n    subtractSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L466\n        const feeAmount = amount.mul(swapFee).add(ONE.sub(1)).div(ONE);\n        return amount.sub(feeAmount);\n    }\n\n    addSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L458\n        const feeAmount = ONE.sub(swapFee);\n        return amount.mul(ONE).add(feeAmount.sub(1)).div(feeAmount);\n    }\n}\n","import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport {\n    PoolBase,\n    PoolTypes,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport { getAddress } from '@ethersproject/address';\nimport {\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n} from '../stablePool/stableMath';\nimport {\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcTokensOutGivenExactBptIn,\n} from '../stablePool/stableMathBigInt';\nimport { StablePoolPairData } from '../stablePool/stablePool';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\ntype MetaStablePoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'priceRate'\n>;\n\nexport type MetaStablePoolPairData = StablePoolPairData & {\n    tokenInPriceRate: BigNumber;\n    tokenOutPriceRate: BigNumber;\n};\n\nexport class MetaStablePool implements PoolBase<MetaStablePoolPairData> {\n    poolType: PoolTypes = PoolTypes.MetaStable;\n    id: string;\n    address: string;\n    amp: BigNumber;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: MetaStablePoolToken[];\n    tokensList: string[];\n    MAX_IN_RATIO = parseFixed('0.3', 18);\n    MAX_OUT_RATIO = parseFixed('0.3', 18);\n\n    static AMP_DECIMALS = 3;\n\n    static fromPool(pool: SubgraphPoolBase): MetaStablePool {\n        if (!pool.amp) throw new Error('MetaStablePool missing amp factor');\n        return new MetaStablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: MetaStablePoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.amp = parseFixed(amp, MetaStablePool.AMP_DECIMALS);\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n    }\n\n    parsePoolPairData(\n        tokenIn: string,\n        tokenOut: string\n    ): MetaStablePoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n\n        const decimalsIn = tI.decimals;\n        const tokenInPriceRate = parseFixed(tI.priceRate, 18);\n        const balanceIn = formatFixed(\n            parseFixed(tI.balance, decimalsIn).mul(tokenInPriceRate).div(ONE),\n            decimalsIn\n        );\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n\n        const decimalsOut = tO.decimals;\n        const tokenOutPriceRate = parseFixed(tO.priceRate, 18);\n        const balanceOut = formatFixed(\n            parseFixed(tO.balance, decimalsOut).mul(tokenOutPriceRate).div(ONE),\n            decimalsOut\n        );\n\n        // Get all token balances\n        const allBalances = this.tokens.map(({ balance, priceRate }) =>\n            bnum(balance).times(bnum(priceRate))\n        );\n        const allBalancesScaled = this.tokens.map(({ balance, priceRate }) =>\n            parseFixed(balance, 18).mul(parseFixed(priceRate, 18)).div(ONE)\n        );\n\n        const poolPairData: MetaStablePoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            allBalances,\n            allBalancesScaled,\n            amp: this.amp,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            tokenInPriceRate,\n            tokenOutPriceRate,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: MetaStablePoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: MetaStablePoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // We multiply ratios by 10**-18 because we are in normalized space\n        // so 0.5 should be 0.5 and not 500000000000000000\n        // TODO: update bmath to use everything normalized\n        // PoolPairData is using balances that have already been exchanged so need to convert back\n        if (swapType === SwapTypes.SwapExactIn) {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceIn\n                        .mul(this.MAX_IN_RATIO)\n                        .div(poolPairData.tokenInPriceRate),\n                    poolPairData.decimalsIn\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut\n                        .mul(this.MAX_OUT_RATIO)\n                        .div(poolPairData.tokenOutPriceRate),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n\n            const amtWithFee = this.subtractSwapFeeAmount(\n                parseFixed(\n                    amount.dp(poolPairData.decimalsIn).toString(),\n                    poolPairData.decimalsIn\n                ),\n                poolPairData.swapFee\n            );\n\n            const amountConverted = amtWithFee\n                .mul(poolPairData.tokenInPriceRate)\n                .div(ONE);\n\n            const returnAmt = _calcOutGivenIn(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amountConverted.toBigInt(),\n                BigInt(0)\n            );\n\n            const returnEvmWithRate = BigNumber.from(returnAmt)\n                .mul(ONE)\n                .div(poolPairData.tokenOutPriceRate);\n\n            return bnum(formatFixed(returnEvmWithRate, 18));\n        } catch (err) {\n            // console.error(`_evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            const decimalsIn = poolPairData.decimalsIn;\n            const decimalsOut = poolPairData.decimalsOut;\n\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const scalingFactorIn =\n                poolPairData.tokenInPriceRate.toBigInt() *\n                BigInt(10 ** (18 - decimalsIn));\n\n            const scalingFactorOut =\n                poolPairData.tokenOutPriceRate.toBigInt() *\n                BigInt(10 ** (18 - decimalsOut));\n\n            // eslint-disable-next-line prettier/prettier\n            const amountBigInt = BigInt(\n                amount\n                    .times(10 ** decimalsOut)\n                    .dp(0)\n                    .toString()\n            );\n            const amountConverted =\n                (amountBigInt * scalingFactorOut) / BigInt(10 ** 18);\n\n            const returnAmount = _calcInGivenOut(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amountConverted,\n                BigInt(0)\n            );\n\n            const returnAmountConverted =\n                (returnAmount * BigInt(10 ** 18)) / scalingFactorIn;\n\n            const returnAmtWithFee = this.addSwapFeeAmount(\n                BigNumber.from(returnAmountConverted),\n                poolPairData.swapFee\n            );\n            return bnum(returnAmtWithFee.toString()).div(\n                10 ** poolPairData.decimalsIn\n            );\n        } catch (err) {\n            console.error(`_evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized as if it had 18 decimals for maths\n        // takes price rate into account\n        const balancesNormalised = this.tokens\n            .filter((t) => !isSameAddress(t.address, this.address))\n            .map((t) => normaliseBalance(t));\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                BigNumber.from(denormaliseAmount(a, this.tokens[i]).toString())\n            );\n            return amountsOut;\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized as if it had 18 decimals for maths\n            // takes price rate into account\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                this.amp.toBigInt(),\n                balancesNormalised,\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            return Zero;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const result = _spotPriceAfterSwapExactTokenInForTokenOut(\n            amountConverted,\n            poolPairData\n        );\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const result = _spotPriceAfterSwapTokenInForExactTokenOut(\n            amountConverted,\n            poolPairData\n        );\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            amount,\n            poolPairData\n        ).times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: MetaStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        )\n            .div(priceRateIn)\n            .times(priceRateOut)\n            .times(priceRateOut);\n    }\n\n    subtractSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L466\n        const feeAmount = amount.mul(swapFee).add(ONE.sub(1)).div(ONE);\n        return amount.sub(feeAmount);\n    }\n\n    addSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L458\n        const feeAmount = ONE.sub(swapFee);\n        return amount.mul(ONE).add(feeAmount.sub(1)).div(feeAmount);\n    }\n}\n","import { MathSol, BZERO } from '../../utils/basicOperations';\n\ntype Params = {\n    fee: bigint;\n    rate: bigint;\n    lowerTarget: bigint;\n    upperTarget: bigint;\n};\n\nexport function _calcBptOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n\n    if (bptSupply == BigInt(0)) {\n        return _toNominal(mainIn, params);\n    }\n\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n    const deltaNominalMain = afterNominalMain - previousNominalMain;\n    const invariant = _calcInvariantUp(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divDown(MathSol.mul(bptSupply, deltaNominalMain), invariant);\n}\n\nexport function _calcBptInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n    const deltaNominalMain = previousNominalMain - afterNominalMain;\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUp(MathSol.mul(bptSupply, deltaNominalMain), invariant);\n}\n\nexport function _calcBptInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newWrappedBalance = wrappedBalance - wrappedOut;\n    const newInvariant = _calcInvariantDown(\n        nominalMain,\n        newWrappedBalance,\n        params\n    );\n    const newBptBalance = MathSol.divDown(\n        MathSol.mul(bptSupply, newInvariant),\n        previousInvariant\n    );\n    return bptSupply - newBptBalance;\n}\n\nexport function _calcWrappedOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n    const deltaNominalMain = afterNominalMain - previousNominalMain;\n    return MathSol.divDownFixed(deltaNominalMain, params.rate);\n}\n\nexport function _calcWrappedInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n    const deltaNominalMain = previousNominalMain - afterNominalMain;\n    return MathSol.divUpFixed(deltaNominalMain, params.rate);\n}\n\nexport function _calcMainInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    if (bptSupply == BigInt(0)) {\n        return _fromNominal(bptOut, params);\n    }\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantUp(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const deltaNominalMain = MathSol.divUp(\n        MathSol.mul(invariant, bptOut),\n        bptSupply\n    );\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcMainOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const deltaNominalMain = MathSol.divDown(\n        MathSol.mul(invariant, bptIn),\n        bptSupply\n    );\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcMainOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulDownFixed(wrappedIn, params.rate);\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcMainInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulUpFixed(wrappedOut, params.rate);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcBptOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    if (bptSupply == BigInt(0)) {\n        // Return nominal DAI\n        return MathSol.mulDownFixed(wrappedIn, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newWrappedBalance = wrappedBalance + wrappedIn;\n    const newInvariant = _calcInvariantDown(\n        nominalMain,\n        newWrappedBalance,\n        params\n    );\n    const newBptBalance = MathSol.divDown(\n        MathSol.mul(bptSupply, newInvariant),\n        previousInvariant\n    );\n    return newBptBalance - bptSupply;\n}\n\nexport function _calcWrappedInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    if (bptSupply == BigInt(0)) {\n        // Return nominal DAI\n        return MathSol.divUpFixed(bptOut, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newBptBalance = bptSupply + bptOut;\n    const newWrappedBalance = MathSol.divUpFixed(\n        MathSol.divUp(\n            MathSol.mul(newBptBalance, previousInvariant),\n            bptSupply\n        ) - nominalMain,\n        params.rate\n    );\n\n    return newWrappedBalance - wrappedBalance;\n}\n\nexport function _calcWrappedOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newBptBalance = bptSupply - bptIn;\n    const newWrappedBalance = MathSol.divUpFixed(\n        MathSol.divUp(\n            MathSol.mul(newBptBalance, previousInvariant),\n            bptSupply\n        ) - nominalMain,\n        params.rate\n    );\n\n    return wrappedBalance - newWrappedBalance;\n}\n\nfunction _calcInvariantUp(\n    nominalMainBalance: bigint,\n    wrappedBalance: bigint,\n    params: Params\n): bigint {\n    return nominalMainBalance + MathSol.mulUpFixed(wrappedBalance, params.rate);\n}\n\nfunction _calcInvariantDown(\n    nominalMainBalance: bigint,\n    wrappedBalance: bigint,\n    params: Params\n): bigint {\n    return (\n        nominalMainBalance + MathSol.mulDownFixed(wrappedBalance, params.rate)\n    );\n}\n\nfunction _toNominal(real: bigint, params: Params): bigint {\n    // Fees are always rounded down: either direction would work but we need to be consistent, and rounding down\n    // uses less gas.\n    if (real < params.lowerTarget) {\n        const fees = MathSol.mulDownFixed(\n            params.lowerTarget - real,\n            params.fee\n        );\n        return MathSol.sub(real, fees);\n    } else if (real <= params.upperTarget) {\n        return real;\n    } else {\n        const fees = MathSol.mulDownFixed(\n            real - params.upperTarget,\n            params.fee\n        );\n        return MathSol.sub(real, fees);\n    }\n}\n\nfunction _fromNominal(nominal: bigint, params: Params): bigint {\n    // Since real = nominal + fees, rounding down fees is equivalent to rounding down real.\n    if (nominal < params.lowerTarget) {\n        return MathSol.divDownFixed(\n            nominal + MathSol.mulDownFixed(params.fee, params.lowerTarget),\n            MathSol.ONE + params.fee\n        );\n    } else if (nominal <= params.upperTarget) {\n        return nominal;\n    } else {\n        return MathSol.divDownFixed(\n            nominal - MathSol.mulDownFixed(params.fee, params.upperTarget),\n            MathSol.ONE - params.fee\n        );\n    }\n}\n\nfunction leftDerivativeToNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount <= params.lowerTarget) {\n        return onePlusFee;\n    } else if (amount <= params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return oneMinusFee;\n    }\n}\n\nfunction rightDerivativeToNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount < params.lowerTarget) {\n        return onePlusFee;\n    } else if (amount < params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return oneMinusFee;\n    }\n}\n\nfunction leftDerivativeFromNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount <= params.lowerTarget) {\n        return MathSol.divUpFixed(MathSol.ONE, onePlusFee);\n    } else if (amount <= params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return MathSol.divUpFixed(MathSol.ONE, oneMinusFee);\n    }\n}\n\nfunction rightDerivativeFromNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount < params.lowerTarget) {\n        return MathSol.divUpFixed(MathSol.ONE, onePlusFee);\n    } else if (amount < params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return MathSol.divUpFixed(MathSol.ONE, oneMinusFee);\n    }\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    bptIndex: number\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = tokenAmountOut             /        bptIn         \\                                  //\n    // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n    // bpt = bptTotalSupply                                                                      //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, bptTotalSupply);\n    const amountsOut: bigint[] = new Array(balances.length).fill(BZERO);\n    for (let i = 0; i < balances.length; i++) {\n        // BPT is skipped as those tokens are not the LPs, but rather the preminted and undistributed amount.\n        if (i != bptIndex) {\n            amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n        }\n    }\n    return amountsOut;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'main->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const finalMainBalance = mainIn + mainBalance;\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    let poolFactor = MathSol.ONE;\n    if (bptSupply != BigInt(0)) {\n        poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    }\n    return MathSol.divUpFixed(\n        poolFactor,\n        rightDerivativeToNominal(finalMainBalance, params)\n    );\n}\n\n// PairType = 'main->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapMainInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    let poolFactor = MathSol.ONE;\n    if (bptSupply != BigInt(0)) {\n        poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    }\n    const deltaNominalMain = MathSol.mulUpFixed(bptOut, poolFactor);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    return MathSol.mulUpFixed(\n        poolFactor,\n        rightDerivativeFromNominal(afterNominalMain, params)\n    );\n}\n\n// PairType = 'BPT->main'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapMainOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const poolFactor = MathSol.divDownFixed(invariant, bptSupply);\n    const deltaNominalMain = MathSol.mulDownFixed(bptIn, poolFactor);\n    const afterNominalMain = MathSol.sub(previousNominalMain, deltaNominalMain);\n    return MathSol.divUpFixed(\n        MathSol.ONE,\n        MathSol.mulUpFixed(\n            poolFactor,\n            leftDerivativeFromNominal(afterNominalMain, params)\n        )\n    );\n}\n\n// PairType = 'BPT->main'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBptInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const finalMainBalance = MathSol.sub(mainBalance, mainOut);\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    return MathSol.divUpFixed(\n        leftDerivativeToNominal(finalMainBalance, params),\n        poolFactor\n    );\n}\n\n// PairType = 'main->wrapped'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapMainInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulUpFixed(wrappedOut, params.rate);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    return MathSol.mulUpFixed(\n        rightDerivativeFromNominal(afterNominalMain, params),\n        params.rate\n    );\n}\n\n// PairType = 'wrapped->main'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapWrappedInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const afterMain = mainBalance - mainOut;\n    return MathSol.divUpFixed(\n        leftDerivativeToNominal(afterMain, params),\n        params.rate\n    );\n}\n\n// PairType = 'main->wrapped'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapWrappedOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    return MathSol.divDownFixed(\n        params.rate,\n        rightDerivativeToNominal(mainBalance + mainIn, params)\n    );\n}\n\n// PairType = 'wrapped->main'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapMainOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulDownFixed(wrappedIn, params.rate);\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const inversePrice = MathSol.mulUpFixed(\n        leftDerivativeFromNominal(afterNominalMain, params),\n        params.rate\n    );\n    return MathSol.divUpFixed(MathSol.ONE, inversePrice);\n}\n\n// PairType = 'wrapped->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    if (bptSupply == BigInt(0)) {\n        return params.rate;\n    }\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUpFixed(\n        previousInvariant,\n        MathSol.mulUpFixed(bptSupply, params.rate)\n    );\n}\n\n// PairType = 'BPT->wrapped'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapWrappedOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUp(\n        MathSol.mul(bptSupply, params.rate),\n        previousInvariant\n    );\n}\n\n// PairType = 'wrapped->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapWrappedInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    if (bptSupply == BigInt(0)) {\n        return MathSol.divUpFixed(MathSol.ONE, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUpFixed(\n        previousInvariant,\n        MathSol.mulUpFixed(bptSupply, params.rate)\n    );\n}\n\n// PairType = 'BPT->wrapped'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBptInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divDown(\n        MathSol.mul(bptSupply, params.rate),\n        previousInvariant\n    );\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// Derivative of spot price is always zero, except at the target break points,\n// where it is infinity in some sense. But we ignore this pathology, return zero\n// and expect good behaviour at the optimization algorithm.\n","import { BigNumber, parseFixed, formatFixed } from '@ethersproject/bignumber';\nimport { bnum, INFINITY, scale, ZERO } from '../../utils/bignumber';\nimport { BigNumber as OldBigNumber } from '../../utils/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { isSameAddress } from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport {\n    _calcBptOutPerMainIn,\n    _calcBptInPerWrappedOut,\n    _calcBptInPerMainOut,\n    _calcWrappedOutPerMainIn,\n    _calcWrappedInPerMainOut,\n    _calcMainInPerBptOut,\n    _calcMainOutPerBptIn,\n    _calcMainOutPerWrappedIn,\n    _calcMainInPerWrappedOut,\n    _calcBptOutPerWrappedIn,\n    _calcWrappedInPerBptOut,\n    _calcWrappedOutPerBptIn,\n    _spotPriceAfterSwapBptOutPerMainIn,\n    _spotPriceAfterSwapMainOutPerBptIn,\n    _spotPriceAfterSwapBptOutPerWrappedIn,\n    _spotPriceAfterSwapWrappedOutPerBptIn,\n    _spotPriceAfterSwapWrappedOutPerMainIn,\n    _spotPriceAfterSwapMainOutPerWrappedIn,\n    _spotPriceAfterSwapMainInPerBptOut,\n    _spotPriceAfterSwapBptInPerMainOut,\n    _spotPriceAfterSwapWrappedInPerBptOut,\n    _spotPriceAfterSwapBptInPerWrappedOut,\n    _spotPriceAfterSwapMainInPerWrappedOut,\n    _spotPriceAfterSwapWrappedInPerMainOut,\n} from './linearMath';\n\nexport enum PairTypes {\n    BptToMainToken,\n    MainTokenToBpt,\n    MainTokenToWrappedToken,\n    WrappedTokenToMainToken,\n    BptToWrappedToken,\n    WrappedTokenToBpt,\n}\n\ntype LinearPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'priceRate'\n>;\n\nexport type LinearPoolPairData = PoolPairBase & {\n    pairType: PairTypes;\n    wrappedBalance: OldBigNumber; // If main token is USDC then wrapped token is aUSDC (or a wrapped version of it)\n    wrappedBalanceScaled: BigNumber; // If main token is USDC then wrapped token is aUSDC (or a wrapped version of it)\n    wrappedDecimals: number;\n    rate: BigNumber; // PriceRate of wrapped token\n    lowerTarget: BigNumber; // Target determine the range where there are positive, zero or negative fees\n    upperTarget: BigNumber; // when the \"main token\" has a balance below lowerTarget, there are negative fees when adding main token\n    mainBalanceScaled: BigNumber; // Scaled are used for EVM/SDK maths\n    bptBalanceScaled: BigNumber;\n    virtualBptSupply: BigNumber;\n};\n\nexport class LinearPool implements PoolBase<LinearPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Linear;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: LinearPoolToken[];\n    tokensList: string[];\n\n    wrappedIndex: number;\n    wrappedDecimals: number;\n    mainIndex: number;\n    bptIndex: number;\n    lowerTarget: BigNumber;\n    upperTarget: BigNumber;\n    MAX_RATIO = parseFixed('10', 18); // Specific for Linear pool types\n    ALMOST_ONE = parseFixed('0.99', 18);\n    // Used for VirutalBpt and can be removed if SG is updated with VirtualBpt value\n    MAX_TOKEN_BALANCE = BigNumber.from('2').pow('112').sub('1');\n\n    static fromPool(pool: SubgraphPoolBase): LinearPool {\n        if (pool.mainIndex === undefined)\n            throw new Error('LinearPool missing mainIndex');\n        if (pool.wrappedIndex === undefined)\n            throw new Error('LinearPool missing wrappedIndex');\n        if (!pool.lowerTarget)\n            throw new Error('LinearPool missing lowerTarget');\n        if (!pool.upperTarget)\n            throw new Error('LinearPool missing upperTarget');\n        return new LinearPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList,\n            pool.mainIndex,\n            pool.wrappedIndex,\n            pool.lowerTarget,\n            pool.upperTarget\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: LinearPoolToken[],\n        tokensList: string[],\n        mainIndex: number,\n        wrappedIndex: number,\n        lowerTarget: string,\n        upperTarget: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.mainIndex = mainIndex;\n        this.bptIndex = this.tokensList.indexOf(this.address);\n        this.wrappedIndex = wrappedIndex;\n        this.wrappedDecimals = this.tokens[this.wrappedIndex].decimals;\n        this.lowerTarget = parseFixed(lowerTarget, 18); // Wrapped token will have same decimals as underlying\n        this.upperTarget = parseFixed(upperTarget, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): LinearPoolPairData {\n        let pairType: PairTypes;\n\n        const tI = this.tokens.find((t) => isSameAddress(t.address, tokenIn));\n        if (!tI) throw Error(`Pool does not contain token in ${tokenIn}`);\n        const decimalsIn = tI.decimals;\n        const balanceIn = parseFixed(tI.balance, decimalsIn);\n\n        const tO = this.tokens.find((t) => isSameAddress(t.address, tokenOut));\n        if (!tO) throw Error(`Pool does not contain token out ${tokenOut}`);\n        const decimalsOut = tO.decimals;\n        const balanceOut = parseFixed(tO.balance, decimalsOut);\n\n        // Linear pools allow trading between token and pool BPT (phantom BPT)\n        if (isSameAddress(tokenIn, this.address)) {\n            if (isSameAddress(tokenOut, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.BptToWrappedToken;\n            else pairType = PairTypes.BptToMainToken;\n        } else if (isSameAddress(tokenOut, this.address)) {\n            if (isSameAddress(tokenIn, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.WrappedTokenToBpt;\n            else pairType = PairTypes.MainTokenToBpt;\n        } else {\n            if (isSameAddress(tokenIn, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.WrappedTokenToMainToken;\n            else pairType = PairTypes.MainTokenToWrappedToken;\n        }\n\n        // Get all token balances scaled to 18\n        const allBalancesScaled = this.tokens.map(({ balance }) =>\n            parseFixed(balance, 18)\n        );\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/88a14eb623f6a22ef3f1afc5a8c49ebfa7eeceed/pkg/pool-linear/contracts/LinearPool.sol#L247\n        // VirtualBPTSupply must be used for the maths\n        // TO DO - SG should be updated to so that totalShares should return VirtualSupply\n        const bptBalanceScaled = allBalancesScaled[this.bptIndex];\n        const virtualBptSupply = this.MAX_TOKEN_BALANCE.sub(bptBalanceScaled);\n\n        const poolPairData: LinearPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            pairType: pairType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: balanceIn,\n            balanceOut: balanceOut,\n            swapFee: this.swapFee,\n            wrappedBalance: scale(\n                bnum(this.tokens[this.wrappedIndex].balance),\n                this.wrappedDecimals\n            ),\n            wrappedBalanceScaled: allBalancesScaled[this.wrappedIndex], // Note this is not multiplied by rate\n            wrappedDecimals: this.wrappedDecimals,\n            rate: parseFixed(this.tokens[this.wrappedIndex].priceRate, 18),\n            lowerTarget: this.lowerTarget,\n            upperTarget: this.upperTarget,\n            mainBalanceScaled: allBalancesScaled[this.mainIndex],\n            bptBalanceScaled,\n            virtualBptSupply,\n        };\n\n        return poolPairData;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getNormalizedLiquidity(poolPairData: LinearPoolPairData): OldBigNumber {\n        return INFINITY; // It is the inverse of zero\n        // This is correct since linear pools have no price impact,\n        // except for the swap fee that is expected to be small.\n    }\n\n    getLimitAmountSwap(\n        poolPairData: LinearPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // Needs to return human scaled numbers\n        const linearPoolPairData = poolPairData as LinearPoolPairData;\n        const balanceOutHuman = scale(\n            bnum(poolPairData.balanceOut.toString()),\n            -poolPairData.decimalsOut\n        );\n\n        if (swapType === SwapTypes.SwapExactIn) {\n            if (linearPoolPairData.pairType === PairTypes.MainTokenToBpt) {\n                return this._mainTokenInForExactBPTOut(\n                    poolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n            } else if (\n                linearPoolPairData.pairType === PairTypes.WrappedTokenToBpt\n            ) {\n                // Swapping to BPT allows for a very large amount so using pre-minted amount as estimation\n                return scale(bnum(this.MAX_TOKEN_BALANCE.toString()), -18);\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToMainToken\n            ) {\n                // Limit is amount of BPT in for pool balance of tokenOut\n                // Amount must be in human scale\n                return this._BPTInForExactMainTokenOut(\n                    linearPoolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToWrappedToken\n            ) {\n                const limit = this._BPTInForExactWrappedTokenOut(\n                    poolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n                // Returning Human scale\n                return limit;\n            } else if (\n                linearPoolPairData.pairType ===\n                    PairTypes.MainTokenToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.WrappedTokenToMainToken\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else return bnum(0);\n        } else {\n            if (\n                linearPoolPairData.pairType === PairTypes.MainTokenToBpt ||\n                linearPoolPairData.pairType === PairTypes.WrappedTokenToBpt\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.MAX_RATIO)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToMainToken ||\n                linearPoolPairData.pairType === PairTypes.BptToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.MainTokenToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.WrappedTokenToMainToken\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else return bnum(0);\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n\n        // update total shares with BPT balance diff\n        if (isSameAddress(this.address, token)) {\n            const parsedTokenBalance = parseFixed(T.balance, T.decimals);\n            const diff = parsedTokenBalance.sub(newBalance);\n            const newTotalShares = this.totalShares.add(diff);\n            this.updateTotalShares(newTotalShares);\n        }\n        // update token balance with new balance\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n            return this._exactMainTokenInForBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n            return this._exactBPTInForMainTokenOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n            return this._exactWrappedTokenInForBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n            return this._exactBPTInForWrappedTokenOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n        ) {\n            return this._exactMainTokenInForWrappedOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n        ) {\n            return this._exactWrappedTokenInForMainOut(poolPairData, amount);\n        } else return bnum(0);\n    }\n\n    _exactWrappedTokenInForMainOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainOutPerWrappedIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactMainTokenInForWrappedOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedOutPerMainIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactMainTokenInForBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcBptOutPerMainIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactBPTInForMainTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainOutPerBptIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactWrappedTokenInForBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amt = _calcBptOutPerWrappedIn(\n                parseFixed(amount.toString(), 18).toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactBPTInForWrappedTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedOutPerBptIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n            return this._mainTokenInForExactBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n            return this._BPTInForExactMainTokenOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n            return this._wrappedTokenInForExactBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n            return this._BPTInForExactWrappedTokenOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n        ) {\n            return this._mainTokenInForExactWrappedOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n        ) {\n            return this._wrappedTokenInForExactMainOut(poolPairData, amount);\n        } else return bnum(0); // LinearPool does not support TokenToToken\n    }\n\n    _wrappedTokenInForExactMainOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedInPerMainOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _mainTokenInForExactWrappedOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainInPerWrappedOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _mainTokenInForExactBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n            // in = main\n            // out = BPT\n            const amt = _calcMainInPerBptOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _BPTInForExactMainTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcBptInPerMainOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _wrappedTokenInForExactBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedInPerBptOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _BPTInForExactWrappedTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amt = _calcBptInPerWrappedOut(\n                // amtNoRate.toBigInt(),\n                parseFixed(amount.toString(), 18).toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Linear Pool doesn't have Exit Pool implementation\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Linear Pool doesn't have Join Pool implementation\n        return Zero;\n    }\n\n    // SPOT PRICES AFTER SWAP\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const bigintAmount = parseFixed(\n                amount.dp(18).toString(),\n                18\n            ).toBigInt();\n            const mainBalance = poolPairData.mainBalanceScaled.toBigInt();\n            const wrappedBalance = poolPairData.wrappedBalanceScaled.toBigInt();\n            const bptSupply = poolPairData.virtualBptSupply.toBigInt();\n            const params = {\n                fee: poolPairData.swapFee.toBigInt(),\n                lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                upperTarget: poolPairData.upperTarget.toBigInt(),\n                rate: poolPairData.rate.toBigInt(),\n            };\n            let result: bigint;\n            if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n                result = _spotPriceAfterSwapBptOutPerMainIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n                result = _spotPriceAfterSwapMainOutPerBptIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n                result = _spotPriceAfterSwapBptOutPerWrappedIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n                result = _spotPriceAfterSwapWrappedOutPerBptIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n            ) {\n                result = _spotPriceAfterSwapWrappedOutPerMainIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n            ) {\n                result = _spotPriceAfterSwapMainOutPerWrappedIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else return bnum(0);\n            return scale(bnum(result.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                0\n            );\n        } catch (err) {\n            return bnum(0);\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const bigintAmount = parseFixed(\n                amount.dp(18).toString(),\n                18\n            ).toBigInt();\n            const mainBalance = poolPairData.mainBalanceScaled.toBigInt();\n            const wrappedBalance = poolPairData.wrappedBalanceScaled.toBigInt();\n            const bptSupply = poolPairData.virtualBptSupply.toBigInt();\n            const params = {\n                fee: poolPairData.swapFee.toBigInt(),\n                lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                upperTarget: poolPairData.upperTarget.toBigInt(),\n                rate: poolPairData.rate.toBigInt(),\n            };\n            let result: bigint;\n            if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n                result = _spotPriceAfterSwapMainInPerBptOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n                result = _spotPriceAfterSwapBptInPerMainOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n                result = _spotPriceAfterSwapWrappedInPerBptOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n                result = _spotPriceAfterSwapBptInPerWrappedOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n            ) {\n                result = _spotPriceAfterSwapMainInPerWrappedOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n            ) {\n                result = _spotPriceAfterSwapWrappedInPerMainOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else return bnum(0);\n            return scale(bnum(result.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                0\n            );\n        } catch (err) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        poolPairData: LinearPoolPairData,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return bnum(0);\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        poolPairData: LinearPoolPairData,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return bnum(0);\n    }\n}\n","import { formatFixed } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum } from '../../utils/bignumber';\nimport { ElementPoolPairData } from './elementPool';\n\n// calc_out_given_in (swap)\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ai = amount.toNumber();\n    return bnum(\n        Bo -\n            (Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                (1 / (1 - t)) -\n            Math.abs(\n                Ai -\n                    Bo +\n                    (Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                        (1 / (1 - t))\n            ) *\n                f\n    );\n}\n\n// calc_in_given_out (swap)\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ao = amount.toNumber();\n    return bnum(\n        -Bi +\n            (Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n                (1 / (1 - t)) +\n            Math.abs(\n                -Ao -\n                    Bi +\n                    (Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n                        (1 / (1 - t))\n            ) *\n                f\n    );\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ai = amount.toNumber();\n    return bnum(\n        1 /\n            ((Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                (-1 + 1 / (1 - t)) /\n                (Ai + Bi) ** t -\n                Math.abs(\n                    1 -\n                        (Bi ** (1 - t) -\n                            (Ai + Bi) ** (1 - t) +\n                            Bo ** (1 - t)) **\n                            (-1 + 1 / (1 - t)) /\n                            (Ai + Bi) ** t\n                ) *\n                    f)\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ao = amount.toNumber();\n    return bnum(\n        (Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n            (-1 + 1 / (1 - t)) /\n            (-Ao + Bo) ** t +\n            Math.abs(\n                -1 +\n                    (Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n                        (-1 + 1 / (1 - t)) /\n                        (-Ao + Bo) ** t\n            ) *\n                f\n    );\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ai = amount.toNumber();\n    return bnum(\n        -(\n            (-(\n                ((Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                    (-2 + 1 / (1 - t)) *\n                    (-1 + 1 / (1 - t)) *\n                    (1 - t)) /\n                (Ai + Bi) ** (2 * t)\n            ) -\n                (Ai + Bi) ** (-1 - t) *\n                    (Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                        (-1 + 1 / (1 - t)) *\n                    t -\n                f *\n                    Math.abs(\n                        ((Bi ** (1 - t) -\n                            (Ai + Bi) ** (1 - t) +\n                            Bo ** (1 - t)) **\n                            (-2 + 1 / (1 - t)) *\n                            (-1 + 1 / (1 - t)) *\n                            (1 - t)) /\n                            (Ai + Bi) ** (2 * t) +\n                            (Ai + Bi) ** (-1 - t) *\n                                (Bi ** (1 - t) -\n                                    (Ai + Bi) ** (1 - t) +\n                                    Bo ** (1 - t)) **\n                                    (-1 + 1 / (1 - t)) *\n                                t\n                    )) /\n            ((Bi ** (1 - t) - (Ai + Bi) ** (1 - t) + Bo ** (1 - t)) **\n                (-1 + 1 / (1 - t)) /\n                (Ai + Bi) ** t -\n                Math.abs(\n                    1 -\n                        (Bi ** (1 - t) -\n                            (Ai + Bi) ** (1 - t) +\n                            Bo ** (1 - t)) **\n                            (-1 + 1 / (1 - t)) /\n                            (Ai + Bi) ** t\n                ) *\n                    f) **\n                2\n        )\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: ElementPoolPairData\n): OldBigNumber {\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const t = getTimeTillExpiry(\n        poolPairData.expiryTime,\n        poolPairData.currentBlockTimestamp,\n        poolPairData.unitSeconds\n    );\n    const Ao = amount.toNumber();\n    return bnum(\n        ((Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n            (-2 + 1 / (1 - t)) *\n            (-1 + 1 / (1 - t)) *\n            (1 - t)) /\n            (-Ao + Bo) ** (2 * t) +\n            (-Ao + Bo) ** (-1 - t) *\n                (Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n                    (-1 + 1 / (1 - t)) *\n                t +\n            f *\n                Math.abs(\n                    ((Bi ** (1 - t) + Bo ** (1 - t) - (-Ao + Bo) ** (1 - t)) **\n                        (-2 + 1 / (1 - t)) *\n                        (-1 + 1 / (1 - t)) *\n                        (1 - t)) /\n                        (-Ao + Bo) ** (2 * t) +\n                        (-Ao + Bo) ** (-1 - t) *\n                            (Bi ** (1 - t) +\n                                Bo ** (1 - t) -\n                                (-Ao + Bo) ** (1 - t)) **\n                                (-1 + 1 / (1 - t)) *\n                            t\n                )\n    );\n}\n\nexport function getTimeTillExpiry(\n    expiryTime: number,\n    currentBlockTimestamp: number,\n    unitSeconds: number\n): number {\n    let t =\n        currentBlockTimestamp < expiryTime\n            ? expiryTime - currentBlockTimestamp\n            : 0;\n    t = t / unitSeconds;\n    return t;\n}\n","import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { isSameAddress } from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport { getAddress } from '@ethersproject/address';\nimport {\n    _exactTokenInForTokenOut,\n    _tokenInForExactTokenOut,\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n    getTimeTillExpiry,\n} from './elementMath';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\ntype ElementPoolToken = Pick<SubgraphToken, 'address' | 'balance' | 'decimals'>;\n\nexport type ElementPoolPairData = PoolPairBase & {\n    totalShares: BigNumber;\n    expiryTime: number;\n    unitSeconds: number;\n    principalToken: string;\n    baseToken: string;\n    currentBlockTimestamp: number;\n};\n\nexport class ElementPool implements PoolBase<ElementPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Element;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: ElementPoolToken[];\n    tokensList: string[];\n    // Element specific\n    expiryTime: number;\n    unitSeconds: number;\n    principalToken: string;\n    baseToken: string;\n    currentBlockTimestamp: number;\n\n    static fromPool(pool: SubgraphPoolBase): ElementPool {\n        if (!pool.expiryTime) throw new Error('ElementPool missing expiryTime');\n        if (!pool.unitSeconds)\n            throw new Error('ElementPool missing unitSeconds');\n        if (!pool.principalToken)\n            throw new Error('ElementPool missing principalToken');\n\n        if (!pool.baseToken) throw new Error('ElementPool missing baseToken');\n\n        return new ElementPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList,\n            pool.expiryTime,\n            pool.unitSeconds,\n            pool.principalToken,\n            pool.baseToken\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: ElementPoolToken[],\n        tokensList: string[],\n        expiryTime: number,\n        unitSeconds: number,\n        principalToken: string,\n        baseToken: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.expiryTime = expiryTime;\n        this.unitSeconds = unitSeconds;\n        this.principalToken = principalToken;\n        this.baseToken = baseToken;\n        this.currentBlockTimestamp = 0;\n    }\n\n    setCurrentBlockTimestamp(timestamp: number): void {\n        this.currentBlockTimestamp = timestamp;\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): ElementPoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const decimalsIn = tI.decimals;\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const decimalsOut = tO.decimals;\n\n        // We already add the virtual LP shares to the right balance\n        const realBalanceIn = parseFixed(tI.balance, decimalsIn);\n        const realBalanceOut = parseFixed(tO.balance, decimalsOut);\n        let balanceIn = realBalanceIn;\n        let balanceOut = realBalanceOut;\n        if (tokenIn == this.principalToken) {\n            balanceIn = realBalanceIn.add(this.totalShares);\n        } else if (tokenOut == this.principalToken) {\n            balanceOut = realBalanceOut.add(this.totalShares);\n        }\n\n        const poolPairData: ElementPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            principalToken: this.principalToken,\n            baseToken: this.baseToken,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn,\n            balanceOut,\n            swapFee: this.swapFee,\n            totalShares: this.totalShares,\n            expiryTime: this.expiryTime,\n            unitSeconds: this.unitSeconds,\n            currentBlockTimestamp: this.currentBlockTimestamp,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: ElementPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: ElementPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        const MAX_OUT_RATIO = parseFixed('0.3', 18);\n        if (swapType === SwapTypes.SwapExactIn) {\n            // \"Ai < (Bi**(1-t)+Bo**(1-t))**(1/(1-t))-Bi\" must hold in order for\n            // base of root to be non-negative\n            const Bi = parseFloat(\n                formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n            );\n            const Bo = parseFloat(\n                formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n            );\n            const t = getTimeTillExpiry(\n                this.expiryTime,\n                this.currentBlockTimestamp,\n                this.unitSeconds\n            );\n            return bnum((Bi ** (1 - t) + Bo ** (1 - t)) ** (1 / (1 - t)) - Bi);\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut.mul(MAX_OUT_RATIO).div(ONE),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _exactTokenInForTokenOut(amount, poolPairData);\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _tokenInForExactTokenOut(amount, poolPairData);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _spotPriceAfterSwapExactTokenInForTokenOut(amount, poolPairData);\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _spotPriceAfterSwapTokenInForExactTokenOut(amount, poolPairData);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: ElementPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        poolPairData.currentBlockTimestamp = this.currentBlockTimestamp;\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n}\n","import { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as EONE } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n} from '../../utils/bignumber';\nimport { PhantomStablePoolPairData } from './phantomStablePool';\n\n// All functions are adapted from the solidity ones to be found on:\n// https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/pools/stable/StableMath.sol\n\n// TODO: implement all up and down rounding variations\n\n/**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant to compute                                                                  //\n    // A = amplifier                n * D^2 + A * n^n * S * (n^n * P / D^(n1))                  //\n    // S = sum of balances         ____________________________________________                  //\n    // P = product of balances    (n+1) * D + ( A * n^n  1)* (n^n * P / D^(n1))                //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\n\nconst AMP_PRECISION_BNUM = bnum(1000);\n\nexport function _invariant(\n    A: BigNumber,\n    balances: OldBigNumber[] // balances\n): OldBigNumber {\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    for (let i = 0; i < totalCoins; i++) {\n        sum = sum.plus(balances[i]);\n    }\n    if (sum.isZero()) {\n        return ZERO;\n    }\n    let prevInv = ZERO;\n    let inv = sum;\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const ATimesNpowN = AAdjusted.times(totalCoins ** totalCoins); // A*n^n\n\n    for (let i = 0; i < 255; i++) {\n        let P_D = bnum(totalCoins).times(balances[0]);\n        for (let j = 1; j < totalCoins; j++) {\n            //P_D is rounded up\n            P_D = P_D.times(balances[j]).times(totalCoins).div(inv);\n        }\n        prevInv = inv;\n        //inv is rounded up\n        inv = bnum(totalCoins)\n            .times(inv)\n            .times(inv)\n            .plus(ATimesNpowN.times(sum).times(P_D))\n            .div(\n                bnum(totalCoins + 1)\n                    .times(inv)\n                    .plus(ATimesNpowN.minus(1).times(P_D))\n            );\n        // Equality with the precision of 1\n        if (inv.gt(prevInv)) {\n            if (inv.minus(prevInv).lt(bnum(10 ** -18))) {\n                break;\n            }\n        } else if (prevInv.minus(inv).lt(bnum(10 ** -18))) {\n            break;\n        }\n    }\n    //Result is rounded up\n    return inv;\n}\n\n// Adapted from StableMath.sol, _outGivenIn()\n// * Added swap fee at very first line\n/**********************************************************************************************\n    // outGivenIn token x for y - polynomial equation to solve                                   //\n    // ay = amount out to calculate                                                              //\n    // by = balance token out                                                                    //\n    // y = by - ay                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               y^2 + ( S - ----------  - 1) * y -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but y                                                           //\n    // P = product of final balances but y                                                       //\n    **********************************************************************************************/\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    let tokenAmountIn = amount;\n    tokenAmountIn = tokenAmountIn\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexIn) {\n            x = balances[i].plus(tokenAmountIn);\n        } else if (i != tokenIndexOut) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate out balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded down\n    // return balances[tokenIndexOut] > y ? balances[tokenIndexOut].minus(y) : 0;\n    return balances[tokenIndexOut].minus(y);\n}\n\n// Adapted from StableMath.sol, _inGivenOut()\n// * Added swap fee at very last line\n/**********************************************************************************************\n    // inGivenOut token x for y - polynomial equation to solve                                   //\n    // ax = amount in to calculate                                                               //\n    // bx = balance token in                                                                     //\n    // x = bx + ax                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               x^2 + ( S - ----------  - 1) * x -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but x                                                           //\n    // P = product of final balances but x                                                       //\n    **********************************************************************************************/\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexOut) {\n            x = balances[i].minus(tokenAmountOut);\n        } else if (i != tokenIndexIn) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate in balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded up\n    return y\n        .minus(balances[tokenIndexIn])\n        .multipliedBy(EONE.toString())\n        .div(EONE.sub(swapFee).toString());\n}\n\n/*\nFlow of calculations:\namountBPTOut -> newInvariant -> (amountInProportional, amountInAfterFee) ->\namountInPercentageExcess -> amountIn\n*/\nexport function _tokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsOut,\n        tokenIndexIn,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountOut = amount;\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    const newInvariant = bnumBalanceOut\n        .plus(bptAmountOut)\n        .div(bnumBalanceOut)\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // get amountInAfterFee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInAfterFee = newBalanceTokenIndex.minus(balances[tokenIndexIn]);\n\n    // Get tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalancePercentageExcess = bnum(1).minus(currentWeight);\n\n    // return amountIn\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    return amountInAfterFee.div(\n        bnum(1).minus(tokenBalancePercentageExcess.times(bnumSwapFee))\n    );\n}\n\nexport function _BPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsIn,\n        tokenIndexOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weights of each token relative to the sum of all balances\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const currentWeight = balances[tokenIndexOut].div(sumBalances);\n    const tokenBalanceRatioWithoutFee = balances[tokenIndexOut]\n        .minus(tokenAmountOut)\n        .div(balances[tokenIndexOut]);\n    const weightedBalanceRatio = bnum(1).minus(\n        bnum(1).minus(tokenBalanceRatioWithoutFee).times(currentWeight)\n    );\n\n    // calculate new amounts in taking into account the fee on the % excess\n    const tokenBalancePercentageExcess = weightedBalanceRatio\n        .minus(tokenBalanceRatioWithoutFee)\n        .div(bnum(1).minus(tokenBalanceRatioWithoutFee));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const amountOutBeforeFee = tokenAmountOut.div(\n        bnum(1).minus(bnumSwapFee.times(tokenBalancePercentageExcess))\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amountOutBeforeFee);\n\n    // get new invariant taking into account swap fees\n    const newInvariant = _invariant(A, balances);\n\n    // return amountBPTIn\n    const bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n    return bnumBalanceIn.times(\n        bnum(1).minus(newInvariant.div(currentInvariant))\n    );\n}\n\n//This function calculates the balance of a given token (tokenIndex)\n// given all the other balances and the invariant\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    inv: OldBigNumber,\n    tokenIndex: number\n): OldBigNumber {\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    let nPowN = ONE;\n    let x = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        nPowN = nPowN.times(totalCoins);\n        if (i != tokenIndex) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    // Calculate token balance\n    return _solveAnalyticalBalance(sum, inv, A, nPowN, p);\n}\n\n//This function calcuates the analytical solution to find the balance required\nexport function _solveAnalyticalBalance(\n    sum: OldBigNumber,\n    inv: OldBigNumber,\n    A: BigNumber,\n    n_pow_n: OldBigNumber,\n    p: OldBigNumber\n): OldBigNumber {\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const oldBN_A = bnum(formatFixed(A, 3));\n    //Round up p\n    p = p.times(inv).div(oldBN_A.times(n_pow_n).times(n_pow_n));\n    //Round down b\n    const b = sum.plus(inv.div(oldBN_A.times(n_pow_n)));\n    //Round up c\n    // let c = inv >= b\n    //     ? inv.minus(b).plus(Math.sqrtUp(inv.minus(b).times(inv.minus(b)).plus(p.times(4))))\n    //     : Math.sqrtUp(b.minus(inv).times(b.minus(inv)).plus(p.times(4))).minus(b.minus(inv));\n    let c;\n    if (inv.gte(b)) {\n        c = inv\n            .minus(b)\n            .plus(inv.minus(b).times(inv.minus(b)).plus(p.times(4)).sqrt());\n    } else {\n        c = b\n            .minus(inv)\n            .times(b.minus(inv))\n            .plus(p.times(4))\n            .sqrt()\n            .minus(b.minus(inv));\n    }\n    //Round up y\n    return c.div(2);\n}\n\n//////////////////////\n////  These functions have been added exclusively for the SORv2\n//////////////////////\n\nexport function _exactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexIn,\n        swapFee,\n        decimalsOut,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const tokenAmountIn = amount;\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weights of each token relative to the sum of all balances\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalanceRatioWithoutFee = balances[tokenIndexIn]\n        .plus(tokenAmountIn)\n        .div(balances[tokenIndexIn]);\n    const weightedBalanceRatio = bnum(1).plus(\n        tokenBalanceRatioWithoutFee.minus(bnum(1)).times(currentWeight)\n    );\n\n    // calculate new amountIn taking into account the fee on the % excess\n    // Percentage of the amount supplied that will be implicitly swapped for other tokens in the pool\n    const tokenBalancePercentageExcess = tokenBalanceRatioWithoutFee\n        .minus(weightedBalanceRatio)\n        .div(tokenBalanceRatioWithoutFee.minus(bnum(1)));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const amountInAfterFee = tokenAmountIn.times(\n        bnum(1).minus(bnumSwapFee.times(tokenBalancePercentageExcess))\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(amountInAfterFee);\n\n    // get new invariant taking into account swap fees\n    const newInvariant = _invariant(A, balances);\n\n    const bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n\n    return bnumBalanceOut.times(\n        newInvariant.div(currentInvariant).minus(bnum(1))\n    );\n}\n\n/* \nFlow of calculations:\namountBPTin -> newInvariant -> (amountOutProportional, amountOutBeforeFee) ->\namountOutPercentageExcess -> amountOut\n*/\nexport function _exactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n\n    const { amp, allBalances, tokenIndexOut, swapFee } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountIn = amount;\n\n    /**********************************************************************************************\n    // TODO description                            //\n    **********************************************************************************************/\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const bnumBalanceIn = bnum(formatFixed(poolPairData.virtualBptSupply, 18));\n    const newInvariant = bnumBalanceIn\n        .minus(bptAmountIn)\n        .div(bnumBalanceIn)\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexOut\n        );\n    const amountOutBeforeFee =\n        balances[tokenIndexOut].minus(newBalanceTokenIndex);\n\n    // Calculate tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexOut].div(sumBalances);\n    const tokenBalancePercentageExcess = bnum(1).minus(currentWeight);\n    const ans = amountOutBeforeFee.times(\n        ONE.minus(\n            tokenBalancePercentageExcess\n                .times(swapFee.toString())\n                .div(EONE.toString())\n        )\n    );\n    return ans;\n}\n\nexport function _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S = S.plus(balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const a = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const b = S.minus(D).times(a).plus(D);\n    const twoaxy = bnum(2).times(a).times(x).times(y);\n    const partial_x = twoaxy.plus(a.times(y).times(y)).plus(b.times(y));\n    const partial_y = twoaxy.plus(a.times(x).times(x)).plus(b.times(x));\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(partial_y);\n    } else {\n        const partial_xx = bnum(2).times(a).times(y);\n        const partial_yy = bnum(2).times(a).times(x);\n        const partial_xy = partial_xx.plus(partial_yy).plus(b);\n        const numerator = bnum(2)\n            .times(partial_x)\n            .times(partial_y)\n            .times(partial_xy)\n            .minus(partial_xx.times(partial_y.pow(2)))\n            .minus(partial_yy.times(partial_x.pow(2)));\n        const denominator = partial_x.pow(2).times(partial_y);\n        ans = numerator.div(denominator);\n        if (wrt_out) {\n            ans = ans.times(partial_y).div(partial_x);\n        }\n    }\n    return ans;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\nexport function _poolDerivativesBPT(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    bptSupply: OldBigNumber,\n    tokenIndexIn: number,\n    is_first_derivative: boolean,\n    is_BPT_out: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    let D_P = D.div(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S.plus(balances[i]);\n            D_P = D_P.times(D).div(balances[i].times(totalCoins));\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const alpha = bnum(A.toString()).times(totalCoins ** totalCoins); // = ATimesNpowN\n    const beta = alpha.times(S);\n    const gamma = AMP_PRECISION_BNUM.minus(alpha);\n    const partial_x = bnum(2)\n        .times(alpha)\n        .times(x)\n        .plus(beta)\n        .plus(gamma.times(D));\n    const minus_partial_D = D_P.times(totalCoins + 1)\n        .times(AMP_PRECISION_BNUM)\n        .minus(gamma.times(x));\n    const partial_D = ZERO.minus(minus_partial_D);\n    let ans: OldBigNumber;\n    if (is_first_derivative) {\n        ans = partial_x.div(minus_partial_D).times(bptSupply).div(D);\n    } else {\n        const partial_xx = bnum(2).times(alpha);\n        const partial_xD = gamma;\n        const n_times_nplusone = totalCoins * (totalCoins + 1);\n        const partial_DD = ZERO.minus(D_P.times(n_times_nplusone).div(D));\n        if (is_BPT_out) {\n            const term1 = partial_xx.times(partial_D).div(partial_x.pow(2));\n            const term2 = bnum(2).times(partial_xD).div(partial_x);\n            const term3 = partial_DD.div(partial_D);\n            ans = term1.minus(term2).plus(term3).times(D).div(bptSupply);\n            if (wrt_out) {\n                const D_prime = ZERO.minus(partial_x.div(partial_D));\n                ans = ans.div(D_prime).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2)\n                .times(partial_xD)\n                .div(partial_D)\n                .minus(partial_DD.times(partial_x).div(partial_D.pow(2)))\n                .minus(partial_xx.div(partial_x));\n            if (wrt_out) {\n                ans = ans\n                    .times(partial_x)\n                    .div(minus_partial_D)\n                    .times(bptSupply)\n                    .div(D);\n            }\n        }\n    }\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\nfunction _feeFactor(\n    balances: OldBigNumber[],\n    tokenIndex: number,\n    swapFee: BigNumber\n): OldBigNumber {\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n    const currentWeight = balances[tokenIndex].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n    return ONE.minus(\n        tokenBalancePercentageExcess\n            .times(swapFee.toString())\n            .div(EONE.toString())\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsOut,\n        tokenIndexIn,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    let bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(feeFactor)\n    );\n    bnumBalanceOut = bnumBalanceOut.plus(\n        _exactTokenInForBPTOut(amount, poolPairData)\n    );\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        true,\n        true,\n        false\n    );\n    ans = bnum(1).div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexIn,\n        decimalsOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(amount);\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexOut,\n        swapFee,\n        decimalsIn,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _out = _exactBPTInForTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    let bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _out.div(feeFactor)\n    );\n    bnumBalanceIn = bnumBalanceIn.minus(amount);\n\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        true,\n        false,\n        false\n    ).div(feeFactor);\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsIn,\n        tokenIndexOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        amount.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(\n        _BPTInForExactTokenOut(amount, poolPairData)\n    );\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        true,\n        false,\n        true\n    ).div(feeFactor);\n    return ans;\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        false\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData).times(\n        bnum(1).minus(bnumSwapFee)\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    const feeFactor = bnum(1).minus(bnumSwapFee);\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        true\n    ).div(feeFactor);\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, decimalsOut, tokenIndexIn, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(feeFactor)\n    );\n    let bnumBalanceOut = bnum(formatFixed(balanceOut, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(\n        _exactTokenInForBPTOut(amount, poolPairData)\n    );\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        false,\n        true,\n        false\n    );\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, decimalsOut, tokenIndexIn, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let bnumBalanceOut = bnum(formatFixed(balanceOut, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(amount);\n    return _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        false,\n        true,\n        true\n    ).div(feeFactor);\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceIn, decimalsIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _in = _BPTInForExactTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        amount.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(balanceIn, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(_in);\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        false,\n        false,\n        true\n    );\n    return ans.div(feeFactor.pow(2));\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceIn, decimalsIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _out = _exactBPTInForTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _out.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(balanceIn, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(amount);\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        false,\n        false,\n        false\n    );\n    return ans.div(feeFactor);\n}\n","import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { isSameAddress } from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport {\n    PoolBase,\n    PoolTypes,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport { getAddress } from '@ethersproject/address';\nimport {\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcOutGivenIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _calcInGivenOut,\n} from '../stablePool/stableMathBigInt';\nimport * as phantomStableMath from '../phantomStablePool/phantomStableMath';\nimport { MetaStablePoolPairData } from '../metaStablePool/metaStablePool';\nimport cloneDeep from 'lodash.clonedeep';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nexport enum PairTypes {\n    BptToToken,\n    TokenToBpt,\n    TokenToToken,\n}\n\nexport type PhantomStablePoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'priceRate'\n>;\n\nexport type PhantomStablePoolPairData = MetaStablePoolPairData & {\n    pairType: PairTypes;\n    bptIndex: number;\n    virtualBptSupply: BigNumber;\n};\n\nexport class PhantomStablePool implements PoolBase<PhantomStablePoolPairData> {\n    poolType: PoolTypes = PoolTypes.MetaStable;\n    id: string;\n    address: string;\n    amp: BigNumber;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: PhantomStablePoolToken[];\n    tokensList: string[];\n    ALMOST_ONE = parseFixed('0.99', 18);\n\n    static AMP_DECIMALS = 3;\n\n    static fromPool(pool: SubgraphPoolBase): PhantomStablePool {\n        if (!pool.amp) throw new Error('PhantomStablePool missing amp factor');\n        return new PhantomStablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    // Remove BPT from Balances and update indices\n    static removeBPT(\n        poolPairData: PhantomStablePoolPairData\n    ): PhantomStablePoolPairData {\n        const poolPairDataNoBpt = cloneDeep(poolPairData);\n        const bptIndex = poolPairData.bptIndex;\n        if (bptIndex != -1) {\n            poolPairDataNoBpt.allBalances.splice(bptIndex, 1);\n            poolPairDataNoBpt.allBalancesScaled.splice(bptIndex, 1);\n            if (bptIndex < poolPairData.tokenIndexIn)\n                poolPairDataNoBpt.tokenIndexIn -= 1;\n            if (bptIndex < poolPairData.tokenIndexOut)\n                poolPairDataNoBpt.tokenIndexOut -= 1;\n        }\n        return poolPairDataNoBpt;\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: PhantomStablePoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.amp = parseFixed(amp, PhantomStablePool.AMP_DECIMALS);\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n    }\n\n    parsePoolPairData(\n        tokenIn: string,\n        tokenOut: string\n    ): PhantomStablePoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = bnum(tI.balance)\n            .times(bnum(tI.priceRate))\n            .dp(tI.decimals)\n            .toString();\n        const decimalsIn = tI.decimals;\n        const tokenInPriceRate = parseFixed(tI.priceRate, 18);\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = bnum(tO.balance)\n            .times(bnum(tO.priceRate))\n            .dp(tO.decimals)\n            .toString();\n        const decimalsOut = tO.decimals;\n        const tokenOutPriceRate = parseFixed(tO.priceRate, 18);\n\n        // Get all token balances\n        const allBalances = this.tokens.map(({ balance, priceRate }) =>\n            bnum(balance).times(bnum(priceRate))\n        );\n        const allBalancesScaled = this.tokens.map(({ balance, priceRate }) =>\n            parseFixed(balance, 18).mul(parseFixed(priceRate, 18)).div(ONE)\n        );\n\n        // Phantom pools allow trading between token and pool BPT\n        let pairType: PairTypes;\n        if (isSameAddress(tokenIn, this.address)) {\n            pairType = PairTypes.BptToToken;\n        } else if (isSameAddress(tokenOut, this.address)) {\n            pairType = PairTypes.TokenToBpt;\n        } else {\n            pairType = PairTypes.TokenToToken;\n        }\n\n        const bptIndex = this.tokensList.indexOf(this.address);\n\n        // VirtualBPTSupply must be used for the maths\n        const virtualBptSupply = this.totalShares;\n\n        const poolPairData: PhantomStablePoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            pairType: pairType,\n            bptIndex: bptIndex,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            allBalances,\n            allBalancesScaled,\n            amp: this.amp,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            tokenInPriceRate,\n            tokenOutPriceRate,\n            virtualBptSupply,\n        };\n\n        return PhantomStablePool.removeBPT(poolPairData);\n    }\n\n    getNormalizedLiquidity(\n        poolPairData: PhantomStablePoolPairData\n    ): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PhantomStablePoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // PoolPairData is using balances that have already been exchanged so need to convert back\n        if (swapType === SwapTypes.SwapExactIn) {\n            // Return max valid amount of tokenIn\n            // As an approx - use almost the total balance of token out as we can add any amount of tokenIn and expect some back\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(poolPairData.tokenOutPriceRate),\n                    poolPairData.decimalsOut\n                )\n            );\n        } else {\n            // Return max amount of tokenOut - approx is almost all balance\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(poolPairData.tokenOutPriceRate),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n\n        // update total shares with BPT balance diff\n        if (isSameAddress(this.address, token)) {\n            const parsedTokenBalance = parseFixed(T.balance, T.decimals);\n            const diff = parsedTokenBalance.sub(newBalance);\n            const newTotalShares = this.totalShares.add(diff);\n            this.updateTotalShares(newTotalShares);\n        }\n        // update token balance with new balance\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // This code assumes that decimalsIn and decimalsOut is 18\n\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const amtWithFeeEvm = this.subtractSwapFeeAmount(\n                parseFixed(amount.dp(18).toString(), 18),\n                poolPairData.swapFee\n            );\n            const amountConvertedEvm = amtWithFeeEvm\n                .mul(poolPairData.tokenInPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                const amountsInBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsInBigInt[poolPairData.tokenIndexIn] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptOutGivenExactTokensIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsInBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnEvm = _calcTokenOutGivenExactBptIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else {\n                returnEvm = _calcOutGivenIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    BigInt(0)\n                );\n            }\n\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenOutPriceRate);\n\n            // Return human scaled\n            return bnum(formatFixed(returnEvmWithRate, 18));\n        } catch (err) {\n            // console.error(`PhantomStable _evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // This code assumes that decimalsIn and decimalsOut is 18\n\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenOutPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnEvm = _calcTokenInGivenExactBptOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                const amountsOutBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsOutBigInt[poolPairData.tokenIndexOut] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptInGivenExactTokensOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsOutBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0) // Fee is handled below\n                );\n            } else {\n                returnEvm = _calcInGivenOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    BigInt(0) // Fee is handled below\n                );\n            }\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenInPriceRate);\n\n            const returnEvmWithFee = this.addSwapFeeAmount(\n                returnEvmWithRate,\n                poolPairData.swapFee\n            );\n\n            // return human number\n            return bnum(formatFixed(returnEvmWithFee, 18));\n        } catch (err) {\n            console.error(`PhantomStable _evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // PhantomStables can only be exited by using BPT > token swaps\n        throw new Error(\n            'PhantomPool does not have exit pool (_calcTokensOutGivenExactBptIn).'\n        );\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // PhantomStables can only be joined by using token > BPT swaps\n        throw new Error(\n            'PhantomPool does not have join pool (_calcBptOutGivenExactTokensIn).'\n        );\n    }\n\n    // this is the multiplicative inverse of the derivative of _exactTokenInForTokenOut\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            bnum(formatFixed(poolPairData.tokenInPriceRate, 18))\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result = phantomStableMath._spotPriceAfterSwapExactTokenInForBPTOut(\n                amountConverted,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result = phantomStableMath._spotPriceAfterSwapExactBPTInForTokenOut(\n                amountConverted,\n                poolPairData\n            );\n        } else {\n            result =\n                phantomStableMath._spotPriceAfterSwapExactTokenInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    // this is the derivative of _tokenInForExactTokenOut\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result = phantomStableMath._spotPriceAfterSwapTokenInForExactBPTOut(\n                amountConverted,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result = phantomStableMath._spotPriceAfterSwapBPTInForExactTokenOut(\n                amountConverted,\n                poolPairData\n            );\n        } else {\n            result =\n                phantomStableMath._spotPriceAfterSwapTokenInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut).times(priceRateOut);\n    }\n\n    subtractSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L466\n        const feeAmount = amount.mul(swapFee).add(ONE.sub(1)).div(ONE);\n        return amount.sub(feeAmount);\n    }\n\n    addSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L458\n        const feeAmount = ONE.sub(swapFee);\n        return amount.mul(ONE).add(feeAmount.sub(1)).div(feeAmount);\n    }\n}\n","import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport { SubgraphPoolBase } from '../../types';\nimport {\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcOutGivenIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _calcInGivenOut,\n    _calcTokensOutGivenExactBptIn,\n} from '../stablePool/stableMathBigInt';\nimport {\n    PhantomStablePool,\n    PhantomStablePoolPairData,\n    PhantomStablePoolToken,\n    PairTypes,\n} from '../phantomStablePool/phantomStablePool';\nexport class ComposableStablePool extends PhantomStablePool {\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: PhantomStablePoolToken[],\n        tokensList: string[]\n    ) {\n        super(id, address, amp, swapFee, totalShares, tokens, tokensList);\n    }\n\n    static fromPool(pool: SubgraphPoolBase): ComposableStablePool {\n        if (!pool.amp)\n            throw new Error('ComposableStablePool missing amp factor');\n        return new ComposableStablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n\n            if (amount.isZero()) return ZERO;\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenInPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                const amountsInBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsInBigInt[poolPairData.tokenIndexIn] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptOutGivenExactTokensIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsInBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnEvm = _calcTokenOutGivenExactBptIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else {\n                returnEvm = _calcOutGivenIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            }\n\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenOutPriceRate);\n\n            // Return human scaled\n            return bnum(formatFixed(returnEvmWithRate, 18)).dp(\n                poolPairData.decimalsOut\n            );\n        } catch (err) {\n            // console.error(`PhantomStable _evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenOutPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnEvm = _calcTokenInGivenExactBptOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                const amountsOutBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsOutBigInt[poolPairData.tokenIndexOut] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptInGivenExactTokensOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsOutBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else {\n                returnEvm = _calcInGivenOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            }\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenInPriceRate);\n\n            // return human number\n            return bnum(formatFixed(returnEvmWithRate, 18)).dp(\n                poolPairData.decimalsOut\n            );\n        } catch (err) {\n            console.error(`PhantomStable _evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        // takes price rate into account\n        const tokensWithoutBpt = this.tokens.filter(\n            (t) => !isSameAddress(t.address, this.address)\n        );\n        const balancesNormalised = tokensWithoutBpt.map((t) =>\n            normaliseBalance(t)\n        );\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, tokensWithoutBpt[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale (Should not have value for BPT token)\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                this.amp.toBigInt(),\n                balancesNormalised,\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            console.error(err);\n            return Zero;\n        }\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\n\n// SQRT constants\n\nexport const SQRT_1E_NEG_1 = BigNumber.from('316227766016837933');\nexport const SQRT_1E_NEG_3 = BigNumber.from('31622776601683793');\nexport const SQRT_1E_NEG_5 = BigNumber.from('3162277660168379');\nexport const SQRT_1E_NEG_7 = BigNumber.from('316227766016837');\nexport const SQRT_1E_NEG_9 = BigNumber.from('31622776601683');\nexport const SQRT_1E_NEG_11 = BigNumber.from('3162277660168');\nexport const SQRT_1E_NEG_13 = BigNumber.from('316227766016');\nexport const SQRT_1E_NEG_15 = BigNumber.from('31622776601');\nexport const SQRT_1E_NEG_17 = BigNumber.from('3162277660');\n\n// High precision\nexport const ONE_XP = BigNumber.from(10).pow(38); // 38 decimal places\n\n// Small number to prevent rounding errors\nexport const SMALL = BigNumber.from(10).pow(8); // 1e-10 in normal precision\n\n// Swap Limit factor\nexport const SWAP_LIMIT_FACTOR = BigNumber.from('999999000000000000');\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    SQRT_1E_NEG_1,\n    SQRT_1E_NEG_3,\n    SQRT_1E_NEG_5,\n    SQRT_1E_NEG_7,\n    SQRT_1E_NEG_9,\n    SQRT_1E_NEG_11,\n    SQRT_1E_NEG_13,\n    SQRT_1E_NEG_15,\n    SQRT_1E_NEG_17,\n    ONE_XP,\n} from './constants';\n\n/////////\n/// ARITHMETIC HELPERS\n/////////\n\nexport function mulUp(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n    return product.sub(1).div(ONE).add(1);\n}\n\nexport function divUp(a: BigNumber, b: BigNumber): BigNumber {\n    const aInflated = a.mul(ONE);\n    return aInflated.sub(1).div(b).add(1);\n}\n\nexport function mulDown(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n    return product.div(ONE);\n}\n\nexport function divDown(a: BigNumber, b: BigNumber): BigNumber {\n    const aInflated = a.mul(ONE);\n    return aInflated.div(b);\n}\n\nexport function mulXpU(a: BigNumber, b: BigNumber): BigNumber {\n    return a.mul(b).div(ONE_XP);\n}\n\nexport function divXpU(a: BigNumber, b: BigNumber): BigNumber {\n    if (b.isZero()) throw new Error('ZERO DIVISION');\n    return a.mul(ONE_XP).div(b);\n}\n\nexport function mulDownMagU(a: BigNumber, b: BigNumber): BigNumber {\n    return a.mul(b).div(ONE);\n}\n\nexport function divDownMagU(a: BigNumber, b: BigNumber): BigNumber {\n    if (b.isZero()) throw new Error('ZERO DIVISION');\n    return a.mul(ONE).div(b);\n}\n\nexport function mulUpMagU(a: BigNumber, b: BigNumber): BigNumber {\n    const product = a.mul(b);\n    if (product.gt(0)) return product.sub(1).div(ONE).add(1);\n    else if (product.lt(0)) return product.add(1).div(ONE).sub(1);\n    else return BigNumber.from(0);\n}\n\nexport function divUpMagU(a: BigNumber, b: BigNumber): BigNumber {\n    if (b.isZero()) throw new Error('ZERO DIVISION');\n    if (b.lt(0)) {\n        b = b.mul(-1);\n        a = a.mul(-1);\n    }\n    if (a.isZero()) {\n        return BigNumber.from(0);\n    } else {\n        if (a.gt(0)) return a.mul(ONE).sub(1).div(b).add(1);\n        else return a.mul(ONE).add(1).div(b.sub(1));\n    }\n}\n\nexport function mulUpXpToNpU(a: BigNumber, b: BigNumber): BigNumber {\n    const TenPower19 = BigNumber.from(10).pow(19);\n    const b1 = b.div(TenPower19);\n    const b2 = b.isNegative()\n        ? b.mul(-1).mod(TenPower19).mul(-1)\n        : b.mod(TenPower19);\n    const prod1 = a.mul(b1);\n    const prod2 = a.mul(b2);\n    return prod1.lte(0) && prod2.lte(0)\n        ? prod1.add(prod2.div(TenPower19)).div(TenPower19)\n        : prod1.add(prod2.div(TenPower19)).sub(1).div(TenPower19).add(1);\n}\n\nexport function mulDownXpToNpU(a: BigNumber, b: BigNumber): BigNumber {\n    const TenPower19 = BigNumber.from(10).pow(19);\n    const b1 = b.div(TenPower19);\n    const b2 = b.isNegative()\n        ? b.mul(-1).mod(TenPower19).mul(-1)\n        : b.mod(TenPower19);\n    const prod1 = a.mul(b1);\n    const prod2 = a.mul(b2);\n    return prod1.gte(0) && prod2.gte(0)\n        ? prod1.add(prod2.div(TenPower19)).div(TenPower19)\n        : prod1.add(prod2.div(TenPower19)).add(1).div(TenPower19).sub(1);\n}\n\n/////////\n/// SQUARE ROOT\n/////////\n\nexport function sqrt(input: BigNumber, tolerance: BigNumber): BigNumber {\n    if (input.isZero()) {\n        return BigNumber.from(0);\n    }\n    let guess = makeInitialGuess(input);\n\n    // 7 iterations\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const i of new Array(7).fill(0)) {\n        guess = guess.add(input.mul(ONE).div(guess)).div(2);\n    }\n\n    // Check square is more or less correct (in some epsilon range)\n    const guessSquared = guess.mul(guess).div(ONE);\n    if (\n        !(\n            guessSquared.lte(input.add(mulUp(guess, tolerance))) &&\n            guessSquared.gte(input.sub(mulUp(guess, tolerance)))\n        )\n    )\n        throw new Error('GyroEPool: sqrt failed');\n\n    return guess;\n}\n\nfunction makeInitialGuess(input: BigNumber) {\n    if (input.gte(ONE)) {\n        return BigNumber.from(2)\n            .pow(intLog2Halved(input.div(ONE)))\n            .mul(ONE);\n    } else {\n        if (input.lte('10')) {\n            return SQRT_1E_NEG_17;\n        }\n        if (input.lte('100')) {\n            return BigNumber.from('10000000000');\n        }\n        if (input.lte('1000')) {\n            return SQRT_1E_NEG_15;\n        }\n        if (input.lte('10000')) {\n            return BigNumber.from('100000000000');\n        }\n        if (input.lte('100000')) {\n            return SQRT_1E_NEG_13;\n        }\n        if (input.lte('1000000')) {\n            return BigNumber.from('1000000000000');\n        }\n        if (input.lte('10000000')) {\n            return SQRT_1E_NEG_11;\n        }\n        if (input.lte('100000000')) {\n            return BigNumber.from('10000000000000');\n        }\n        if (input.lte('1000000000')) {\n            return SQRT_1E_NEG_9;\n        }\n        if (input.lte('10000000000')) {\n            return BigNumber.from('100000000000000');\n        }\n        if (input.lte('100000000000')) {\n            return SQRT_1E_NEG_7;\n        }\n        if (input.lte('1000000000000')) {\n            return BigNumber.from('1000000000000000');\n        }\n        if (input.lte('10000000000000')) {\n            return SQRT_1E_NEG_5;\n        }\n        if (input.lte('100000000000000')) {\n            return BigNumber.from('10000000000000000');\n        }\n        if (input.lte('1000000000000000')) {\n            return SQRT_1E_NEG_3;\n        }\n        if (input.lte('10000000000000000')) {\n            return BigNumber.from('100000000000000000');\n        }\n        if (input.lte('100000000000000000')) {\n            return SQRT_1E_NEG_1;\n        }\n        return input;\n    }\n}\n\nfunction intLog2Halved(x: BigNumber) {\n    let n = 0;\n\n    for (let i = 128; i >= 2; i = i / 2) {\n        const factor = BigNumber.from(2).pow(i);\n        if (x.gte(factor)) {\n            x = x.div(factor);\n            n += i / 2;\n        }\n    }\n\n    return n;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    sqrt,\n    mulUp,\n    divUp,\n    mulDown,\n    divDown,\n} from '../gyroHelpers/gyroSignedFixedPoint';\n\n/////////\n/// Virtual Parameter calculations\n/////////\n\nexport function _findVirtualParams(\n    invariant: BigNumber,\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): [BigNumber, BigNumber] {\n    return [divDown(invariant, sqrtBeta), mulDown(invariant, sqrtAlpha)];\n}\n\n/////////\n/// Invariant Calculation\n/////////\n\nexport function _calculateInvariant(\n    balances: BigNumber[], // balances\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Calculate with quadratic formula\n        // 0 = (1-sqrt(alpha/beta)*L^2 - (y/sqrt(beta)+x*sqrt(alpha))*L - x*y)\n        // 0 = a*L^2 + b*L + c\n        // here a > 0, b < 0, and c < 0, which is a special case that works well w/o negative numbers\n        // taking mb = -b and mc = -c:                            (1/2)\n        //                                  mb + (mb^2 + 4 * a * mc)^                   //\n        //                   L =    ------------------------------------------          //\n        //                                          2 * a                               //\n        //                                                                              //\n        **********************************************************************************************/\n    const [a, mb, bSquare, mc] = _calculateQuadraticTerms(\n        balances,\n        sqrtAlpha,\n        sqrtBeta\n    );\n\n    const invariant = _calculateQuadratic(a, mb, bSquare, mc);\n\n    return invariant;\n}\n\nexport function _calculateQuadraticTerms(\n    balances: BigNumber[],\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): [BigNumber, BigNumber, BigNumber, BigNumber] {\n    const a = ONE.sub(divDown(sqrtAlpha, sqrtBeta));\n    const bterm0 = divDown(balances[1], sqrtBeta);\n    const bterm1 = mulDown(balances[0], sqrtAlpha);\n    const mb = bterm0.add(bterm1);\n    const mc = mulDown(balances[0], balances[1]);\n\n    // For better fixed point precision, calculate in expanded form w/ re-ordering of multiplications\n    // b^2 = x^2 * alpha + x*y*2*sqrt(alpha/beta) + y^2 / beta\n    let bSquare = mulDown(\n        mulDown(mulDown(balances[0], balances[0]), sqrtAlpha),\n        sqrtAlpha\n    );\n    const bSq2 = divDown(\n        mulDown(\n            mulDown(mulDown(balances[0], balances[1]), ONE.mul(2)),\n            sqrtAlpha\n        ),\n        sqrtBeta\n    );\n\n    const bSq3 = divDown(\n        mulDown(balances[1], balances[1]),\n        mulUp(sqrtBeta, sqrtBeta)\n    );\n\n    bSquare = bSquare.add(bSq2).add(bSq3);\n\n    return [a, mb, bSquare, mc];\n}\n\nexport function _calculateQuadratic(\n    a: BigNumber,\n    mb: BigNumber,\n    bSquare: BigNumber,\n    mc: BigNumber\n): BigNumber {\n    const denominator = mulUp(a, ONE.mul(2));\n    // order multiplications for fixed point precision\n    const addTerm = mulDown(mulDown(mc, ONE.mul(4)), a);\n    // The minus sign in the radicand cancels out in this special case, so we add\n    const radicand = bSquare.add(addTerm);\n    const sqrResult = sqrt(radicand, BigNumber.from(5));\n    // The minus sign in the numerator cancels out in this special case\n    const numerator = mb.add(sqrResult);\n    const invariant = divDown(numerator, denominator);\n\n    return invariant;\n}\n\n/////////\n/// Swap functions\n/////////\n\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountIn: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Y = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // L  = inv.Liq                   /              L^2            \\                            //\n        //                   - dy = y' - |   --------------------------  |                           //\n        //  x' = virtIn                   \\          ( x' + dX)         /                            //\n        //  y' = virtOut                                                                             //\n        // Note that -dy > 0 is what the trader receives.                                            //\n        // We exploit the fact that this formula is symmetric up to virtualParam{X,Y}.               //\n        **********************************************************************************************/\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18.\n    const virtInOver = balanceIn.add(mulUp(virtualParamIn, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualParamOut, ONE.sub(1)));\n\n    const amountOut = divDown(\n        mulDown(virtOutUnder, amountIn),\n        virtInOver.add(amountIn)\n    );\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    return amountOut;\n}\n// SwapType = 'swapExactOut'\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountOut: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n      // dX = incrX  = amountIn  > 0                                                               //\n      // dY = incrY  = amountOut < 0                                                               //\n      // x = balanceIn             x' = x +  virtualParamX                                         //\n      // y = balanceOut            y' = y +  virtualParamY                                         //\n      // x = balanceIn                                                                             //\n      // L  = inv.Liq                /              L^2             \\                              //\n      //                     dx =   |   --------------------------  |  -  x'                       //\n      // x' = virtIn                \\         ( y' + dy)           /                               //\n      // y' = virtOut                                                                              //\n      // Note that dy < 0 < dx.                                                                    //\n      **********************************************************************************************/\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18.\n    const virtInOver = balanceIn.add(mulUp(virtualParamIn, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualParamOut, ONE.sub(1)));\n\n    const amountIn = divUp(\n        mulUp(virtInOver, amountOut),\n        virtOutUnder.sub(amountOut)\n    );\n\n    return amountIn;\n}\n\n// /////////\n// ///  Spot price function\n// /////////\n\nexport function _calculateNewSpotPrice(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1   /     x' + (1 - s) * dx        \\                          //\n        //                     p_y =  --- |   --------------------------  |                          //\n        // x' = virtIn                1-s  \\         y' + dy              /                          //\n        // y' = virtOut                                                                              //\n        // Note that dy < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualParamIn); // x + virtualParamX = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualParamOut); // y + virtualParamY = y'\n    const denominator = mulDown(afterFeeMultiplier, virtOut.sub(outAmount)); // (1 - s) * (y' + dy)\n    const newSpotPrice = divDown(numerator, denominator);\n\n    return newSpotPrice;\n}\n\n// /////////\n// ///  Derivatives of spotPriceAfterSwap\n// /////////\n\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    balances: BigNumber[],\n    outAmount: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************                                                        \n        // dy = incrY  = amountOut < 0                                                               //\n                                                                                                     //\n        // y = balanceOut            y' = y +  virtualParamY = virtOut                               //\n        //                                                                                           //\n        //                                 /              1               \\                          //\n        //                  (p_y)' =   2  |   --------------------------  |                          //\n        //                                 \\           y' + dy            /                          //\n        //                                                                                           //\n        // Note that dy < 0                                                                          //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const virtOut = balances[1].add(virtualParamOut); // y' = y + virtualParamY\n    const denominator = virtOut.sub(outAmount); // y' + dy\n\n    const derivative = divDown(TWO, denominator);\n\n    return derivative;\n}\n\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1       /     x' + (1 - s) * dx        \\                      //\n        //                     p_y =  --- (2) |   --------------------------  |                      //\n        // x' = virtIn                1-s      \\         (y' + dy)^2          /                      //\n        // y' = virtOut                                                                              //\n        // Note that dy < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualParamIn); // x + virtualParamX = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualParamOut); // y + virtualParamY = y'\n    const denominator = mulDown(virtOut.sub(outAmount), virtOut.sub(outAmount)); // (y' + dy)^2\n    const factor = divDown(TWO, afterFeeMultiplier); // 2 / (1 - s)\n\n    const derivative = mulDown(factor, divDown(numerator, denominator));\n\n    return derivative;\n}\n\n// /////////\n// ///  Normalized Liquidity measured with respect to the in-asset.\n// /////////\nexport function _getNormalizedLiquidity(\n    balances: BigNumber[],\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // x = balanceOut             x' = x +  virtualParamOut                                      //\n    // s = swapFee                                                                               //\n    //                                                                                           //\n    //                             normalizedLiquidity =  0.5 * x'                               //\n    //                                                                                           //\n    // x' = virtOut                                                                              //\n    // Note that balances = [balanceIn, balanceOut].                                             //\n    **********************************************************************************************/\n\n    const virtOut = balances[1].add(virtualParamOut);\n    return virtOut.div(2);\n}\n","import { BigNumber, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\n\n////////\n/// Normalize balances\n////////\nexport function _normalizeBalances(\n    balances: BigNumber[],\n    decimals: number[]\n): BigNumber[] {\n    const scalingFactors = decimals.map((d) => parseFixed('1', d));\n\n    return balances.map((bal, index) =>\n        bal.mul(ONE).div(scalingFactors[index])\n    );\n}\n\n/////////\n/// Fee calculations\n/////////\n\nexport function _reduceFee(amountIn: BigNumber, swapFee: BigNumber): BigNumber {\n    const feeAmount = amountIn.mul(swapFee).div(ONE);\n    return amountIn.sub(feeAmount);\n}\n\nexport function _addFee(amountIn: BigNumber, swapFee: BigNumber): BigNumber {\n    return amountIn.mul(ONE).div(ONE.sub(swapFee));\n}\n","import { getAddress } from '@ethersproject/address';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { formatFixed, BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\n\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphToken,\n    SwapTypes,\n    SubgraphPoolBase,\n} from '../../types';\nimport { isSameAddress, safeParseFixed } from '../../utils';\nimport {\n    _calculateInvariant,\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _findVirtualParams,\n    _calculateNewSpotPrice,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n} from './gyro2Math';\nimport {\n    _normalizeBalances,\n    _reduceFee,\n    _addFee,\n} from '../gyroHelpers/helpers';\nimport { mulDown, divDown } from '../gyroHelpers/gyroSignedFixedPoint';\nimport { SWAP_LIMIT_FACTOR } from '../gyroHelpers/constants';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nexport type Gyro2PoolPairData = PoolPairBase & {\n    sqrtAlpha: BigNumber;\n    sqrtBeta: BigNumber;\n};\n\nexport type Gyro2PoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals'\n>;\n\nexport class Gyro2Pool implements PoolBase<Gyro2PoolPairData> {\n    poolType: PoolTypes = PoolTypes.Gyro2;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: Gyro2PoolToken[];\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    sqrtAlpha: BigNumber;\n    sqrtBeta: BigNumber;\n\n    static fromPool(pool: SubgraphPoolBase): Gyro2Pool {\n        if (!pool.sqrtAlpha || !pool.sqrtBeta)\n            throw new Error(\n                'Pool missing Gyro2 sqrtAlpha and/or sqrtBeta params'\n            );\n\n        return new Gyro2Pool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens as Gyro2PoolToken[],\n            pool.tokensList,\n            pool.sqrtAlpha,\n            pool.sqrtBeta\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: Gyro2PoolToken[],\n        tokensList: string[],\n        sqrtAlpha: string,\n        sqrtBeta: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = safeParseFixed(swapFee, 18);\n        this.totalShares = safeParseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.sqrtAlpha = safeParseFixed(sqrtAlpha, 18);\n        this.sqrtBeta = safeParseFixed(sqrtBeta, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): Gyro2PoolPairData {\n        const tokenInIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenInIndex < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenInIndex];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenOutIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenOutIndex < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenOutIndex];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        const tokenInIsToken0 = tokenInIndex === 0;\n\n        const poolPairData: Gyro2PoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: safeParseFixed(balanceIn, decimalsIn),\n            balanceOut: safeParseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            sqrtAlpha: tokenInIsToken0\n                ? this.sqrtAlpha\n                : divDown(ONE, this.sqrtBeta),\n            sqrtBeta: tokenInIsToken0\n                ? this.sqrtBeta\n                : divDown(ONE, this.sqrtAlpha),\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: Gyro2PoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: Gyro2PoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const maxAmountInAssetInPool = mulDown(\n                invariant,\n                divDown(ONE, poolPairData.sqrtAlpha).sub(\n                    divDown(ONE, poolPairData.sqrtBeta)\n                )\n            ); // x+ = L * (1/sqrtAlpha - 1/sqrtBeta)\n            const limitAmountIn = maxAmountInAssetInPool.sub(\n                normalizedBalances[0]\n            );\n            const limitAmountInPlusSwapFee = divDown(\n                limitAmountIn,\n                ONE.sub(poolPairData.swapFee)\n            );\n            return bnum(\n                formatFixed(\n                    mulDown(limitAmountInPlusSwapFee, SWAP_LIMIT_FACTOR),\n                    18\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    mulDown(poolPairData.balanceOut, SWAP_LIMIT_FACTOR),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualParamIn,\n                virtualParamOut\n            );\n\n            return bnum(formatFixed(outAmount, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualParamIn,\n                virtualParamOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n\n            return bnum(formatFixed(inAmount, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualParamIn,\n                virtualParamOut\n            );\n            const newSpotPrice = _calculateNewSpotPrice(\n                normalizedBalances,\n                inAmount,\n                outAmount,\n                virtualParamIn,\n                virtualParamOut,\n                poolPairData.swapFee\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualParamIn,\n                virtualParamOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n            const newSpotPrice = _calculateNewSpotPrice(\n                normalizedBalances,\n                inAmount,\n                outAmount,\n                virtualParamIn,\n                virtualParamOut,\n                poolPairData.swapFee\n            );\n\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualParamIn,\n                virtualParamOut\n            );\n            const derivative =\n                _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                    normalizedBalances,\n                    outAmount,\n                    virtualParamOut\n                );\n\n            return bnum(formatFixed(derivative, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: Gyro2PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [poolPairData.balanceIn, poolPairData.balanceOut];\n            const normalizedBalances = _normalizeBalances(balances, [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n            ]);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const [virtualParamIn, virtualParamOut] = _findVirtualParams(\n                invariant,\n                poolPairData.sqrtAlpha,\n                poolPairData.sqrtBeta\n            );\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualParamIn,\n                virtualParamOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n\n            const derivative =\n                _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                    normalizedBalances,\n                    inAmount,\n                    outAmount,\n                    virtualParamIn,\n                    virtualParamOut,\n                    poolPairData.swapFee\n                );\n\n            return bnum(formatFixed(derivative, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\n\n// POW3 constant\n// Threshold of x where the normal method of computing x^3 would overflow and we need a workaround.\n// Equal to 4.87e13 scaled; 4.87e13 is the point x where x**3 * 10**36 = (x**2 native) * (x native) ~ 2**256\nexport const _SAFE_LARGE_POW3_THRESHOLD = BigNumber.from(10).pow(29).mul(487);\nexport const MIDDECIMAL = BigNumber.from(10).pow(9); // splits the fixed point decimals into two equal parts.\n\n// Stopping criterion for the Newton iteration that computes the invariant:\n// - Stop if the step width doesn't shrink anymore by at least a factor _INVARIANT_SHRINKING_FACTOR_PER_STEP.\n// - ... but in any case, make at least _INVARIANT_MIN_ITERATIONS iterations. This is useful to compensate for a\n// less-than-ideal starting point, which is important when alpha is small.\nexport const _INVARIANT_SHRINKING_FACTOR_PER_STEP = 8;\nexport const _INVARIANT_MIN_ITERATIONS = 5;\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    _INVARIANT_MIN_ITERATIONS,\n    _INVARIANT_SHRINKING_FACTOR_PER_STEP,\n} from './constants';\nimport { _safeLargePow3ADown } from './helpers';\nimport {\n    mulUp,\n    divUp,\n    mulDown,\n    divDown,\n    sqrt,\n} from '../gyroHelpers/gyroSignedFixedPoint';\n\n/////////\n/// Invariant Calculation\n/////////\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\n// Argument root3Alpha = cube root of the lower price bound (symmetric across assets)\n// Note: all price bounds for the pool are alpha and 1/alpha\n\nexport function _calculateInvariant(\n    balances: BigNumber[],\n    root3Alpha: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n// Calculate root of cubic:\n// (1-alpha)L^3 - (x+y+z) * alpha^(2/3) * L^2 - (x*y + y*z + x*z) * alpha^(1/3) * L - x*y*z = 0\n// These coefficients are a,b,c,d respectively\n// here, a > 0, b < 0, c < 0, and d < 0\n// taking mb = -b and mc = -c\n/**********************************************************************************************/\n    const [a, mb, mc, md] = _calculateCubicTerms(balances, root3Alpha);\n    return _calculateCubic(a, mb, mc, md, root3Alpha);\n}\n\n/** @dev Prepares quadratic terms for input to _calculateCubic\n *  assumes a > 0, b < 0, c <= 0, and d <= 0 and returns a, -b, -c, -d\n *  terms come from cubic in Section 3.1.1\n *  argument root3Alpha = cube root of alpha\n */\nexport function _calculateCubicTerms(\n    balances: BigNumber[],\n    root3Alpha: BigNumber\n): [BigNumber, BigNumber, BigNumber, BigNumber] {\n    const alpha23: BigNumber = mulDown(root3Alpha, root3Alpha); // alpha to the power of (2/3)\n    const alpha = mulDown(alpha23, root3Alpha);\n    const a = ONE.sub(alpha);\n    const bterm = balances[0].add(balances[1]).add(balances[2]);\n    const mb = mulDown(mulDown(bterm, root3Alpha), root3Alpha);\n    const cterm = mulDown(balances[0], balances[1])\n        .add(mulDown(balances[1], balances[2]))\n        .add(mulDown(balances[2], balances[0]));\n    const mc = mulDown(cterm, root3Alpha);\n    const md = mulDown(mulDown(balances[0], balances[1]), balances[2]);\n\n    return [a, mb, mc, md];\n}\n\n/** @dev Calculate the maximal root of the polynomial a L^3 - mb L^2 - mc L - md.\n *   This root is always non-negative, and it is the unique positive root unless mb == mc == md == 0. */\nexport function _calculateCubic(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber\n): BigNumber {\n    let rootEst = _calculateCubicStartingPoint(a, mb, mc);\n    rootEst = _runNewtonIteration(a, mb, mc, md, root3Alpha, rootEst);\n    return rootEst;\n}\n\n/** @dev Starting point for Newton iteration. Safe with all cubic polynomials where the coefficients have the appropriate\n *   signs, but calibrated to the particular polynomial for computing the invariant. */\nexport function _calculateCubicStartingPoint(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber\n): BigNumber {\n    const radic = mulUp(mb, mb).add(mulUp(mulUp(a, mc), ONE.mul(3)));\n    const lmin = divUp(mb, a.mul(3)).add(\n        divUp(sqrt(radic, BigNumber.from(5)), a.mul(3))\n    );\n    // This formula has been found experimentally. It is exact for alpha -> 1, where the factor is 1.5. All\n    // factors > 1 are safe. For small alpha values, it is more efficient to fallback to a larger factor.\n    const alpha = ONE.sub(a); // We know that a is in [0, 1].\n    const factor = alpha.gte(ONE.div(2)) ? ONE.mul(3).div(2) : ONE.mul(2);\n    const l0 = mulUp(lmin, factor);\n    return l0;\n}\n\n/** @dev Find a root of the given polynomial with the given starting point l.\n *   Safe iff l > the local minimum.\n *   Note that f(l) may be negative for the first iteration and will then be positive (up to rounding errors).\n *   f'(l) is always positive for the range of values we consider.\n *   See write-up, Appendix A. */\nexport function _runNewtonIteration(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber,\n    rootEst: BigNumber\n): BigNumber {\n    let deltaAbsPrev = BigNumber.from(0);\n    for (let iteration = 0; iteration < 255; ++iteration) {\n        // The delta to the next step can be positive or negative, so we represent a positive and a negative part\n        // separately. The signed delta is delta_plus - delta_minus, but we only ever consider its absolute value.\n        const [deltaAbs, deltaIsPos] = _calcNewtonDelta(\n            a,\n            mb,\n            mc,\n            md,\n            root3Alpha,\n            rootEst\n        );\n\n        // ^ Note: If we ever set _INVARIANT_MIN_ITERATIONS=0, the following should include `iteration >= 1`.\n        if (\n            deltaAbs.lte(1) ||\n            (iteration >= _INVARIANT_MIN_ITERATIONS && deltaIsPos)\n        )\n            // This should mathematically never happen. Thus, the numerical error dominates at this point.\n            return rootEst;\n        if (\n            iteration >= _INVARIANT_MIN_ITERATIONS &&\n            deltaAbs.gte(\n                deltaAbsPrev.div(\n                    BigNumber.from(_INVARIANT_SHRINKING_FACTOR_PER_STEP)\n                )\n            )\n        ) {\n            // The iteration has stalled and isn't making significant progress anymore.\n            return rootEst;\n        }\n        deltaAbsPrev = deltaAbs;\n        if (deltaIsPos) rootEst = rootEst.add(deltaAbs);\n        else rootEst = rootEst.sub(deltaAbs);\n    }\n\n    throw new Error(\n        'Gyro3Pool: Newton Method did not converge on required invariant'\n    );\n}\n\n// -f(l)/f'(l), represented as an absolute value and a sign. Require that l is sufficiently large so that f is strictly increasing.\nexport function _calcNewtonDelta(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber,\n    rootEst: BigNumber\n): [BigNumber, boolean] {\n    // The following is equal to dfRootEst^3 * a but with an order of operations optimized for precision.\n    // Subtraction does not underflow since rootEst is chosen so that it's always above the (only) local minimum.\n    let dfRootEst = BigNumber.from(0);\n\n    const rootEst2 = mulDown(rootEst, rootEst);\n    dfRootEst = rootEst2.mul(3);\n    dfRootEst = dfRootEst.sub(\n        mulDown(mulDown(mulDown(dfRootEst, root3Alpha), root3Alpha), root3Alpha)\n    );\n    dfRootEst = dfRootEst.sub(mulDown(rootEst, mb).mul(2)).sub(mc);\n\n    const deltaMinus = _safeLargePow3ADown(rootEst, root3Alpha, dfRootEst);\n\n    // NB: We could order the operations here in much the same way we did above to reduce errors. But tests show\n    // that this has no significant effect, and it would lead to more complex code.\n    let deltaPlus = mulDown(mulDown(rootEst, rootEst), mb);\n    deltaPlus = divDown(deltaPlus.add(mulDown(rootEst, mc)), dfRootEst);\n    deltaPlus = deltaPlus.add(divDown(md, dfRootEst));\n\n    const deltaIsPos = deltaPlus.gte(deltaMinus);\n    const deltaAbs = deltaIsPos\n        ? deltaPlus.sub(deltaMinus)\n        : deltaMinus.sub(deltaPlus);\n\n    return [deltaAbs, deltaIsPos];\n}\n\n/////////\n/// Swap Amount Calculations\n/////////\n\n/** @dev Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n * current balances and weights.\n * Changed signs compared to original algorithm to account for amountOut < 0.\n * See Proposition 12 in 3.1.4.*/\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountIn: BigNumber,\n    virtualOffset: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Z = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualOffset                                         //\n        // z = balanceOut            z' = z +  virtualOffset                                         //\n        // L  = inv.Liq                   /            x' * z'          \\                            //\n        //                   - dZ = z' - |   --------------------------  |                           //\n        //  x' = virtIn                   \\          ( x' + dX)         /                            //\n        //  z' = virtOut                                                                             //\n        // Note that -dz > 0 is what the trader receives.                                            //\n        // We exploit the fact that this formula is symmetric up to virtualParam{X,Y,Z}.             //\n        **********************************************************************************************/\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18, compensating for the maximum multiplicative error in the invariant\n    // computation.\n\n    const virtInOver = balanceIn.add(mulUp(virtualOffset, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualOffset, ONE.sub(1)));\n    const amountOut = virtOutUnder.mul(amountIn).div(virtInOver.add(amountIn));\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    return amountOut;\n}\n\n/** @dev Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n * currhent balances and weights.\n * Similar to the one before but adapting bc negative values (amountOut would be negative).*/\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountOut: BigNumber,\n    virtualOffset: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Z = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualOffset                                         //\n        // z = balanceOut            z' = z +  virtualOffset                                         //\n        // L  = inv.Liq            /            x' * z'          \\             x' * dZ               //\n        //                   dX = |   --------------------------  | - x' = ---------------           //\n        //  x' = virtIn            \\          ( z' + dZ)         /             z' - dZ               //\n        //  z' = virtOut                                                                             //\n        // Note that dz < 0 < dx.                                                                    //\n        // We exploit the fact that this formula is symmetric and does not depend on which asset is  //\n        // which.\n        // We assume that the virtualOffset carries a relative +/- 3e-18 error due to the invariant  //\n        // calculation add an appropriate safety margin.                                             //\n        **********************************************************************************************/\n\n    // Note that this in particular reverts if amountOut > balanceOut, i.e., if the trader tries to take more out of\n    // the pool than is in it.\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18, compensating for the maximum multiplicative error in the invariant\n    // computation.\n    const virtInOver = balanceIn.add(mulUp(virtualOffset, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualOffset, ONE.sub(1)));\n\n    const amountIn = divUp(\n        mulUp(virtInOver, amountOut),\n        virtOutUnder.sub(amountOut)\n    );\n\n    return amountIn;\n}\n\n// /////////\n// ///  Spot price function\n// /////////\n\nexport function _calculateNewSpotPrice(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualOffsetInOut                                     //\n        // z = balanceOut            z' = z +  virtualOffsetInOut                                     //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1   /     x' + (1 - s) * dx        \\                          //\n        //                     p_z =  --- |   --------------------------  |                          //\n        // x' = virtIn                1-s  \\         z' + dz              /                          //\n        // z' = virtOut                                                                              //\n        // Note that dz < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualOffsetInOut); // x + virtualOffsetInOut = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n\n    const virtOut = balances[1].add(virtualOffsetInOut); // z + virtualOffsetInOut = y'\n    const denominator = mulDown(afterFeeMultiplier, virtOut.sub(outAmount)); // (1 - s) * (z' + dz)\n\n    const newSpotPrice = divDown(numerator, denominator);\n\n    return newSpotPrice;\n}\n\n// /////////\n// ///  Derivatives of spotPriceAfterSwap\n// /////////\n\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    balances: BigNumber[],\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************                                                        \n        // dz = incrZ  = amountOut < 0                                                               //\n                                                                                                     //\n        // z = balanceOut            z' = z +  virtualOffsetInOut = virtOut                          //\n        //                                                                                           //\n        //                                 /              1               \\                          //\n        //                  (p_z)' =   2  |   --------------------------  |                          //\n        //                                 \\           z' + dz            /                          //\n        //                                                                                           //\n        // Note that dz < 0                                                                          //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const virtOut = balances[1].add(virtualOffsetInOut); // z' = z + virtualOffsetInOut\n    const denominator = virtOut.sub(outAmount); // z' + dz\n\n    const derivative = divDown(TWO, denominator);\n\n    return derivative;\n}\n\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualOffsetInOut                                    //\n        // z = balanceOut            z' = z +  virtualOffsetInOut                                    //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1       /     x' + (1 - s) * dx        \\                      //\n        //                     p_z =  --- (2) |   --------------------------  |                      //\n        // x' = virtIn                1-s      \\         (z' + dz)^2          /                      //\n        // z' = virtOut                                                                              //\n        // Note that dz < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualOffsetInOut); // x + virtualOffsetInOut = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualOffsetInOut); // z + virtualOffsetInOut = z'\n    const denominator = mulDown(virtOut.sub(outAmount), virtOut.sub(outAmount));\n    // (z' + dz)^2\n    const factor = divDown(TWO, afterFeeMultiplier); // 2 / (1 - s)\n\n    const derivative = mulDown(factor, divDown(numerator, denominator));\n\n    return derivative;\n}\n\n// /////////\n// ///  Normalized Liquidity measured with respect to the out-asset.\n// ///  NB This is the same function as for the 2-CLP because the marginal trading curve of the 3-CLP\n// ///  is a 2-CLP curve. We use different virtual offsets, of course.\n// /////////\nexport function _getNormalizedLiquidity(\n    balances: BigNumber[],\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // x = balanceOut             x' = x +  virtualParamOut                                      //\n    // s = swapFee                                                                               //\n    //                                                                                           //\n    //                             normalizedLiquidity = 0.5 * x'                                //\n    //                                                                                           //\n    // x' = virtOut                                                                              //\n    // Note that balances = [balanceIn, balanceOut, balanceTertiary].                            //\n    **********************************************************************************************/\n\n    const virtOut = balances[1].add(virtualParamOut);\n    return virtOut.div(2);\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { _SAFE_LARGE_POW3_THRESHOLD, MIDDECIMAL } from './constants';\n\n// Helpers\nexport function _safeLargePow3ADown(\n    l: BigNumber,\n    root3Alpha: BigNumber,\n    d: BigNumber\n): BigNumber {\n    let ret = BigNumber.from(0);\n    if (l.lte(_SAFE_LARGE_POW3_THRESHOLD)) {\n        // Simple case where there is no overflow\n        ret = l.mul(l).div(ONE).mul(l).div(ONE);\n        ret = ret.sub(\n            ret\n                .mul(root3Alpha)\n                .div(ONE)\n                .mul(root3Alpha)\n                .div(ONE)\n                .mul(root3Alpha)\n                .div(ONE)\n        );\n        ret = ret.mul(ONE).div(d);\n    } else {\n        ret = l.mul(l).div(ONE);\n\n        // Compute l^2 * l * (1 - root3Alpha^3)\n        // The following products split up the factors into different groups of decimal places to reduce temorary\n        // blowup and prevent overflow.\n        // No precision is lost.\n        ret = ret.mul(l.div(ONE)).add(ret.mul(l.mod(ONE)).div(ONE));\n\n        let x = ret;\n\n        for (let i = 0; i < 3; i++) {\n            x = x\n                .mul(root3Alpha.div(MIDDECIMAL))\n                .div(MIDDECIMAL)\n                .add(x.mul(root3Alpha.mod(MIDDECIMAL)));\n        }\n        ret = ret.sub(x);\n\n        // We perform half-precision division to reduce blowup.\n        // In contrast to the above multiplications, this loses precision if d is small. However, tests show that,\n        // for the l and d values considered here, the precision lost would be below the precision of the fixed\n        // point type itself, so nothing is actually lost.\n        ret = ret.mul(MIDDECIMAL).div(d.div(MIDDECIMAL));\n    }\n    return ret;\n}\n","import { getAddress } from '@ethersproject/address';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { formatFixed, BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\n\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphToken,\n    SwapTypes,\n    SubgraphPoolBase,\n} from '../../types';\nimport { isSameAddress, safeParseFixed } from '../../utils';\nimport {\n    _calculateInvariant,\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _calculateNewSpotPrice,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n} from './gyro3Math';\n\nimport {\n    _normalizeBalances,\n    _reduceFee,\n    _addFee,\n} from '../gyroHelpers/helpers';\nimport { mulDown, divDown } from '../gyroHelpers/gyroSignedFixedPoint';\nimport { SWAP_LIMIT_FACTOR } from '../gyroHelpers/constants';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nexport type Gyro3PoolPairData = PoolPairBase & {\n    balanceTertiary: BigNumber; // Balance of the unchanged asset\n    decimalsTertiary: number; // Decimals of the unchanged asset\n};\n\nexport type Gyro3PoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals'\n>;\n\nexport class Gyro3Pool implements PoolBase<Gyro3PoolPairData> {\n    poolType: PoolTypes = PoolTypes.Gyro3;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: Gyro3PoolToken[];\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    root3Alpha: BigNumber;\n\n    private static findToken(list, tokenAddress, error) {\n        const token = list.find(\n            (t) => getAddress(t.address) === getAddress(tokenAddress)\n        );\n        if (!token) throw new Error(error);\n        return token;\n    }\n\n    static fromPool(pool: SubgraphPoolBase): Gyro3Pool {\n        if (!pool.root3Alpha) throw new Error('Pool missing root3Alpha');\n\n        if (\n            safeParseFixed(pool.root3Alpha, 18).lte(0) ||\n            safeParseFixed(pool.root3Alpha, 18).gte(ONE)\n        )\n            throw new Error('Invalid root3Alpha parameter');\n\n        if (pool.tokens.length !== 3)\n            throw new Error('Gyro3Pool must contain three tokens only');\n\n        return new Gyro3Pool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens as Gyro3PoolToken[],\n            pool.tokensList,\n            pool.root3Alpha\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: Gyro3PoolToken[],\n        tokensList: string[],\n        root3Alpha: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = safeParseFixed(swapFee, 18);\n        this.totalShares = safeParseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.root3Alpha = safeParseFixed(root3Alpha, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): Gyro3PoolPairData {\n        const tI = Gyro3Pool.findToken(\n            this.tokens,\n            tokenIn,\n            'Pool does not contain tokenIn'\n        );\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tO = Gyro3Pool.findToken(\n            this.tokens,\n            tokenOut,\n            'Pool does not contain tokenOut'\n        );\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        const tokenTertiary = this.tokens.find(\n            (t) =>\n                getAddress(t.address) !== getAddress(tokenOut) &&\n                getAddress(t.address) !== getAddress(tokenIn)\n        );\n\n        if (!tokenTertiary)\n            throw new Error('Pool does not contain a valid third token');\n\n        const balanceTertiary = tokenTertiary.balance;\n        const decimalsTertiary = tokenTertiary.decimals;\n\n        const poolPairData: Gyro3PoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            decimalsTertiary: Number(decimalsTertiary),\n            balanceIn: safeParseFixed(balanceIn, decimalsIn),\n            balanceOut: safeParseFixed(balanceOut, decimalsOut),\n            balanceTertiary: safeParseFixed(balanceTertiary, decimalsTertiary),\n            swapFee: this.swapFee,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: Gyro3PoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: Gyro3PoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n            const a = mulDown(invariant, this.root3Alpha);\n            const maxAmountInAssetInPool = divDown(\n                mulDown(\n                    normalizedBalances[0].add(a),\n                    normalizedBalances[1].add(a)\n                ),\n                a\n            ).sub(a); // (x + a)(y + a) / a - a\n            const limitAmountIn = maxAmountInAssetInPool.sub(\n                normalizedBalances[0]\n            );\n            const limitAmountInPlusSwapFee = divDown(\n                limitAmountIn,\n                ONE.sub(poolPairData.swapFee)\n            );\n            return bnum(\n                formatFixed(\n                    mulDown(limitAmountInPlusSwapFee, SWAP_LIMIT_FACTOR),\n                    18\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    mulDown(poolPairData.balanceOut, SWAP_LIMIT_FACTOR),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualOffsetInOut\n            );\n            return bnum(formatFixed(outAmount, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualOffsetInOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n\n            return bnum(formatFixed(inAmount, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualOffsetInOut\n            );\n\n            const newSpotPrice = _calculateNewSpotPrice(\n                normalizedBalances,\n                inAmount,\n                outAmount,\n                virtualOffsetInOut,\n                poolPairData.swapFee\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualOffsetInOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n\n            const newSpotPrice = _calculateNewSpotPrice(\n                normalizedBalances,\n                inAmount,\n                outAmount,\n                virtualOffsetInOut,\n                poolPairData.swapFee\n            );\n\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = _reduceFee(inAmount, poolPairData.swapFee);\n\n            const outAmount = _calcOutGivenIn(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                inAmountLessFee,\n                virtualOffsetInOut\n            );\n            const derivative =\n                _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                    normalizedBalances,\n                    outAmount,\n                    virtualOffsetInOut\n                );\n\n            return bnum(formatFixed(derivative, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: Gyro3PoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const balances = [\n                poolPairData.balanceIn,\n                poolPairData.balanceOut,\n                poolPairData.balanceTertiary,\n            ];\n            const decimals = [\n                poolPairData.decimalsIn,\n                poolPairData.decimalsOut,\n                poolPairData.decimalsTertiary,\n            ];\n            const normalizedBalances = _normalizeBalances(balances, decimals);\n\n            const invariant = _calculateInvariant(\n                normalizedBalances,\n                this.root3Alpha\n            );\n\n            const virtualOffsetInOut = mulDown(invariant, this.root3Alpha);\n\n            const inAmountLessFee = _calcInGivenOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                outAmount,\n                virtualOffsetInOut\n            );\n            const inAmount = _addFee(inAmountLessFee, poolPairData.swapFee);\n\n            const derivative =\n                _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                    normalizedBalances,\n                    inAmount,\n                    outAmount,\n                    virtualOffsetInOut,\n                    poolPairData.swapFee\n                );\n\n            return bnum(formatFixed(derivative, 18));\n        } catch (error) {\n            return bnum(0);\n        }\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\n\nexport const MAX_BALANCES = BigNumber.from(10).pow(34); // 1e16 in normal precision\n\n// Invariant calculation\nexport const MAX_INVARIANT = BigNumber.from(10).pow(37).mul(3); // 3e19 in normal precision\n","import { BigNumber, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { ONE_XP } from '../../gyroHelpers/constants';\nimport {\n    mulDown,\n    divDown,\n    mulDownMagU,\n    divDownMagU,\n    mulUpMagU,\n    divUpMagU,\n    mulUpXpToNpU,\n    mulDownXpToNpU,\n    mulXpU,\n    divXpU,\n    sqrt,\n} from '../../gyroHelpers/gyroSignedFixedPoint';\nimport { MAX_BALANCES } from './constants';\n\n/////////\n/// TYPES\n/////////\n\nexport type GyroEParams = {\n    alpha: BigNumber;\n    beta: BigNumber;\n    c: BigNumber;\n    s: BigNumber;\n    lambda: BigNumber;\n};\n\n// terms in this struct are stored in extra precision (38 decimals) with final decimal rounded down\nexport type DerivedGyroEParams = {\n    tauAlpha: Vector2;\n    tauBeta: Vector2;\n    u: BigNumber;\n    v: BigNumber;\n    w: BigNumber;\n    z: BigNumber;\n    dSq: BigNumber;\n};\n\nexport type Vector2 = {\n    x: BigNumber;\n    y: BigNumber;\n};\n\nexport type QParams = {\n    a: BigNumber;\n    b: BigNumber;\n    c: BigNumber;\n};\n\n/////////\n/// FEE CALCULATION\n/////////\n\nexport function reduceFee(amountIn: BigNumber, swapFee: BigNumber): BigNumber {\n    const feeAmount = mulDown(amountIn, swapFee);\n    return amountIn.sub(feeAmount);\n}\n\nexport function addFee(amountIn: BigNumber, swapFee: BigNumber): BigNumber {\n    return divDown(amountIn, ONE.sub(swapFee));\n}\n\n////////\n/// BALANCE CALCULATION\n////////\nexport function normalizeBalances(\n    balances: BigNumber[],\n    decimals: number[]\n): BigNumber[] {\n    const scalingFactors = decimals.map((d) => parseFixed('1', d));\n\n    return balances.map((bal, index) =>\n        bal.mul(ONE).div(scalingFactors[index])\n    );\n}\n\nexport function balancesFromTokenInOut(\n    balanceTokenIn: BigNumber,\n    balanceTokenOut: BigNumber,\n    tokenInIsToken0: boolean\n): [BigNumber, BigNumber] {\n    return tokenInIsToken0\n        ? [balanceTokenIn, balanceTokenOut]\n        : [balanceTokenOut, balanceTokenIn];\n}\n\n/////////\n/// INVARIANT CALC\n/////////\n\nexport function calcAtAChi(\n    x: BigNumber,\n    y: BigNumber,\n    p: GyroEParams,\n    d: DerivedGyroEParams\n): BigNumber {\n    const dSq2 = mulXpU(d.dSq, d.dSq);\n\n    // (cx - sy) * (w/lambda + z) / lambda\n    //      account for 2 factors of dSq (4 s,c factors)\n    const termXp = divXpU(\n        divDownMagU(divDownMagU(d.w, p.lambda).add(d.z), p.lambda),\n        dSq2\n    );\n\n    let val = mulDownXpToNpU(\n        mulDownMagU(x, p.c).sub(mulDownMagU(y, p.s)),\n        termXp\n    );\n\n    // (x lambda s + y lambda c) * u, note u > 0\n    let termNp = mulDownMagU(mulDownMagU(x, p.lambda), p.s).add(\n        mulDownMagU(mulDownMagU(y, p.lambda), p.c)\n    );\n    val = val.add(mulDownXpToNpU(termNp, divXpU(d.u, dSq2)));\n\n    // (sx+cy) * v, note v > 0\n    termNp = mulDownMagU(x, p.s).add(mulDownMagU(y, p.c));\n    val = val.add(mulDownXpToNpU(termNp, divXpU(d.v, dSq2)));\n\n    return val;\n}\n\nexport function calcInvariantSqrt(\n    x: BigNumber,\n    y: BigNumber,\n    p: GyroEParams,\n    d: DerivedGyroEParams\n): [BigNumber, BigNumber] {\n    let val = calcMinAtxAChiySqPlusAtxSq(x, y, p, d).add(\n        calc2AtxAtyAChixAChiy(x, y, p, d)\n    );\n    val = val.add(calcMinAtyAChixSqPlusAtySq(x, y, p, d));\n    const err = mulUpMagU(x, x).add(mulUpMagU(y, y)).div(ONE_XP);\n    val = val.gt(0) ? sqrt(val, BigNumber.from(5)) : BigNumber.from(0);\n    return [val, err];\n}\n\nfunction calcMinAtxAChiySqPlusAtxSq(\n    x: BigNumber,\n    y: BigNumber,\n    p: GyroEParams,\n    d: DerivedGyroEParams\n) {\n    let termNp = mulUpMagU(mulUpMagU(mulUpMagU(x, x), p.c), p.c).add(\n        mulUpMagU(mulUpMagU(mulUpMagU(y, y), p.s), p.s)\n    );\n    termNp = termNp.sub(\n        mulDownMagU(mulDownMagU(mulDownMagU(x, y), p.c.mul(2)), p.s)\n    );\n    const termXp = mulXpU(d.u, d.u)\n        .add(divDownMagU(mulXpU(d.u.mul(2), d.v), p.lambda))\n        .add(divDownMagU(divDownMagU(mulXpU(d.v, d.v), p.lambda), p.lambda));\n\n    let val = mulDownXpToNpU(termNp.mul(-1), termXp);\n    val = val.add(\n        mulDownXpToNpU(\n            divDownMagU(divDownMagU(termNp.sub(9), p.lambda), p.lambda),\n            divXpU(ONE_XP, d.dSq)\n        )\n    );\n    return val;\n}\n\nfunction calc2AtxAtyAChixAChiy(\n    x: BigNumber,\n    y: BigNumber,\n    p: GyroEParams,\n    d: DerivedGyroEParams\n) {\n    let termNp = mulDownMagU(\n        mulDownMagU(mulDownMagU(x, x).sub(mulUpMagU(y, y)), p.c.mul(2)),\n        p.s\n    );\n\n    const xy = mulDownMagU(y, x.mul(2));\n    termNp = termNp\n        .add(mulDownMagU(mulDownMagU(xy, p.c), p.c))\n        .sub(mulDownMagU(mulDownMagU(xy, p.s), p.s));\n    let termXp = mulXpU(d.z, d.u).add(\n        divDownMagU(divDownMagU(mulXpU(d.w, d.v), p.lambda), p.lambda)\n    );\n    termXp = termXp.add(\n        divDownMagU(mulXpU(d.w, d.u).add(mulXpU(d.z, d.v)), p.lambda)\n    );\n    termXp = divXpU(termXp, mulXpU(mulXpU(mulXpU(d.dSq, d.dSq), d.dSq), d.dSq));\n    const val = mulDownXpToNpU(termNp, termXp);\n    return val;\n}\n\nfunction calcMinAtyAChixSqPlusAtySq(\n    x: BigNumber,\n    y: BigNumber,\n    p: GyroEParams,\n    d: DerivedGyroEParams\n) {\n    let termNp = mulUpMagU(mulUpMagU(mulUpMagU(x, x), p.s), p.s).add(\n        mulUpMagU(mulUpMagU(mulUpMagU(y, y), p.c), p.c)\n    );\n    termNp = termNp.add(mulUpMagU(mulUpMagU(mulUpMagU(x, y), p.s.mul(2)), p.c));\n    let termXp = mulXpU(d.z, d.z).add(\n        divDownMagU(divDownMagU(mulXpU(d.w, d.w), p.lambda), p.lambda)\n    );\n    termXp = termXp.add(divDownMagU(mulXpU(d.z.mul(2), d.w), p.lambda));\n    termXp = divXpU(termXp, mulXpU(mulXpU(mulXpU(d.dSq, d.dSq), d.dSq), d.dSq));\n    let val = mulDownXpToNpU(termNp.mul(-1), termXp);\n    val = val.add(mulDownXpToNpU(termNp.sub(9), divXpU(ONE_XP, d.dSq)));\n    return val;\n}\n\nexport function calcAChiAChiInXp(\n    p: GyroEParams,\n    d: DerivedGyroEParams\n): BigNumber {\n    const dSq3 = mulXpU(mulXpU(d.dSq, d.dSq), d.dSq);\n    let val = mulUpMagU(p.lambda, divXpU(mulXpU(d.u.mul(2), d.v), dSq3));\n    val = val.add(\n        mulUpMagU(\n            mulUpMagU(divXpU(mulXpU(d.u.add(1), d.u.add(1)), dSq3), p.lambda),\n            p.lambda\n        )\n    );\n    val = val.add(divXpU(mulXpU(d.v, d.v), dSq3));\n    const termXp = divUpMagU(d.w, p.lambda).add(d.z);\n    val = val.add(divXpU(mulXpU(termXp, termXp), dSq3));\n    return val;\n}\n\n/////////\n/// SWAP AMOUNT CALC\n/////////\n\nexport function checkAssetBounds(\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2,\n    newBal: BigNumber,\n    assetIndex: number\n): void {\n    if (assetIndex === 0) {\n        const xPlus = maxBalances0(params, derived, invariant);\n        if (newBal.gt(MAX_BALANCES) || newBal.gt(xPlus))\n            throw new Error('ASSET BOUNDS EXCEEDED');\n    } else {\n        const yPlus = maxBalances1(params, derived, invariant);\n        if (newBal.gt(MAX_BALANCES) || newBal.gt(yPlus))\n            throw new Error('ASSET BOUNDS EXCEEDED');\n    }\n}\n\nfunction maxBalances0(p: GyroEParams, d: DerivedGyroEParams, r: Vector2) {\n    const termXp1 = divXpU(d.tauBeta.x.sub(d.tauAlpha.x), d.dSq);\n    const termXp2 = divXpU(d.tauBeta.y.sub(d.tauAlpha.y), d.dSq);\n    let xp = mulDownXpToNpU(\n        mulDownMagU(mulDownMagU(r.y, p.lambda), p.c),\n        termXp1\n    );\n    xp = xp.add(\n        termXp2.gt(BigNumber.from(0))\n            ? mulDownMagU(r.y, p.s)\n            : mulDownXpToNpU(mulUpMagU(r.x, p.s), termXp2)\n    );\n    return xp;\n}\n\nfunction maxBalances1(p: GyroEParams, d: DerivedGyroEParams, r: Vector2) {\n    const termXp1 = divXpU(d.tauBeta.x.sub(d.tauAlpha.x), d.dSq);\n    const termXp2 = divXpU(d.tauBeta.y.sub(d.tauAlpha.y), d.dSq);\n    let yp = mulDownXpToNpU(\n        mulDownMagU(mulDownMagU(r.y, p.lambda), p.s),\n        termXp1\n    );\n    yp = yp.add(\n        termXp2.gt(BigNumber.from(0))\n            ? mulDownMagU(r.y, p.c)\n            : mulDownXpToNpU(mulUpMagU(r.x, p.c), termXp2)\n    );\n    return yp;\n}\n\nexport function calcYGivenX(\n    x: BigNumber,\n    params: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2\n): BigNumber {\n    const ab: Vector2 = {\n        x: virtualOffset0(params, d, r),\n        y: virtualOffset1(params, d, r),\n    };\n\n    const y = solveQuadraticSwap(\n        params.lambda,\n        x,\n        params.s,\n        params.c,\n        r,\n        ab,\n        d.tauBeta,\n        d.dSq\n    );\n    return y;\n}\n\nexport function calcXGivenY(\n    y: BigNumber,\n    params: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2\n): BigNumber {\n    const ba: Vector2 = {\n        x: virtualOffset1(params, d, r),\n        y: virtualOffset0(params, d, r),\n    };\n    const x = solveQuadraticSwap(\n        params.lambda,\n        y,\n        params.c,\n        params.s,\n        r,\n        ba,\n        {\n            x: d.tauAlpha.x.mul(-1),\n            y: d.tauAlpha.y,\n        },\n        d.dSq\n    );\n    return x;\n}\n\nexport function virtualOffset0(\n    p: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2,\n    switchTau?: boolean\n): BigNumber {\n    const tauValue = switchTau ? d.tauAlpha : d.tauBeta;\n    const termXp = divXpU(tauValue.x, d.dSq);\n\n    let a = tauValue.x.gt(BigNumber.from(0))\n        ? mulUpXpToNpU(mulUpMagU(mulUpMagU(r.x, p.lambda), p.c), termXp)\n        : mulUpXpToNpU(mulDownMagU(mulDownMagU(r.y, p.lambda), p.c), termXp);\n\n    a = a.add(mulUpXpToNpU(mulUpMagU(r.x, p.s), divXpU(tauValue.y, d.dSq)));\n\n    return a;\n}\n\nexport function virtualOffset1(\n    p: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2,\n    switchTau?: boolean\n): BigNumber {\n    const tauValue = switchTau ? d.tauBeta : d.tauAlpha;\n    const termXp = divXpU(tauValue.x, d.dSq);\n\n    let b = tauValue.x.lt(BigNumber.from(0))\n        ? mulUpXpToNpU(mulUpMagU(mulUpMagU(r.x, p.lambda), p.s), termXp.mul(-1))\n        : mulUpXpToNpU(\n              mulDownMagU(mulDownMagU(r.y.mul(-1), p.lambda), p.s),\n              termXp\n          );\n\n    b = b.add(mulUpXpToNpU(mulUpMagU(r.x, p.c), divXpU(tauValue.y, d.dSq)));\n    return b;\n}\n\nfunction solveQuadraticSwap(\n    lambda: BigNumber,\n    x: BigNumber,\n    s: BigNumber,\n    c: BigNumber,\n    r: Vector2,\n    ab: Vector2,\n    tauBeta: Vector2,\n    dSq: BigNumber\n): BigNumber {\n    const lamBar: Vector2 = {\n        x: ONE_XP.sub(divDownMagU(divDownMagU(ONE_XP, lambda), lambda)),\n        y: ONE_XP.sub(divUpMagU(divUpMagU(ONE_XP, lambda), lambda)),\n    };\n    const q: QParams = {\n        a: BigNumber.from(0),\n        b: BigNumber.from(0),\n        c: BigNumber.from(0),\n    };\n    const xp = x.sub(ab.x);\n    if (xp.gt(BigNumber.from(0))) {\n        q.b = mulUpXpToNpU(\n            mulDownMagU(mulDownMagU(xp.mul(-1), s), c),\n            divXpU(lamBar.y, dSq)\n        );\n    } else {\n        q.b = mulUpXpToNpU(\n            mulUpMagU(mulUpMagU(xp.mul(-1), s), c),\n            divXpU(lamBar.x, dSq).add(1)\n        );\n    }\n    const sTerm: Vector2 = {\n        x: divXpU(mulDownMagU(mulDownMagU(lamBar.y, s), s), dSq),\n        y: divXpU(mulUpMagU(mulUpMagU(lamBar.x, s), s), dSq.add(1)).add(1),\n    };\n    sTerm.x = ONE_XP.sub(sTerm.x);\n    sTerm.y = ONE_XP.sub(sTerm.y);\n\n    q.c = calcXpXpDivLambdaLambda(x, r, lambda, s, c, tauBeta, dSq).mul(-1);\n    q.c = q.c.add(mulDownXpToNpU(mulDownMagU(r.y, r.y), sTerm.y)); // r.y ===  currentInv + err\n    q.c = q.c.gt(BigNumber.from(0))\n        ? sqrt(q.c, BigNumber.from(5))\n        : BigNumber.from(0);\n    if (q.b.sub(q.c).gt(BigNumber.from(0))) {\n        q.a = mulUpXpToNpU(q.b.sub(q.c), divXpU(ONE_XP, sTerm.y).add(1));\n    } else {\n        q.a = mulUpXpToNpU(q.b.sub(q.c), divXpU(ONE_XP, sTerm.x));\n    }\n    return q.a.add(ab.y);\n}\n\nexport function calcXpXpDivLambdaLambda(\n    x: BigNumber,\n    r: Vector2,\n    lambda: BigNumber,\n    s: BigNumber,\n    c: BigNumber,\n    tauBeta: Vector2,\n    dSq: BigNumber\n): BigNumber {\n    const sqVars = {\n        x: mulXpU(dSq, dSq),\n        y: mulUpMagU(r.x, r.x),\n    };\n    const q: QParams = {\n        a: BigNumber.from(0),\n        b: BigNumber.from(0),\n        c: BigNumber.from(0),\n    };\n    let termXp = divXpU(mulXpU(tauBeta.x, tauBeta.y), sqVars.x);\n    if (termXp.gt(BigNumber.from(0))) {\n        q.a = mulUpMagU(sqVars.y, s.mul(2));\n        q.a = mulUpXpToNpU(mulUpMagU(q.a, c), termXp.add(7));\n    } else {\n        q.a = mulDownMagU(mulDownMagU(r.y, r.y), s.mul(2)); // r.y ===  currentInv + err\n        q.a = mulUpXpToNpU(mulDownMagU(q.a, c), termXp);\n    }\n\n    if (tauBeta.x.lt(BigNumber.from(0))) {\n        q.b = mulUpXpToNpU(\n            mulUpMagU(mulUpMagU(r.x, x), c.mul(2)),\n            divXpU(tauBeta.x, dSq).mul(-1).add(3)\n        );\n    } else {\n        q.b = mulUpXpToNpU(\n            mulDownMagU(mulDownMagU(r.y.mul(-1), x), c.mul(2)),\n            divXpU(tauBeta.x, dSq)\n        );\n    }\n    q.a = q.a.add(q.b);\n    termXp = divXpU(mulXpU(tauBeta.y, tauBeta.y), sqVars.x).add(7);\n    q.b = mulUpMagU(sqVars.y, s);\n    q.b = mulUpXpToNpU(mulUpMagU(q.b, s), termXp);\n\n    q.c = mulUpXpToNpU(\n        mulDownMagU(mulDownMagU(r.y.mul(-1), x), s.mul(2)),\n        divXpU(tauBeta.y, dSq)\n    );\n    q.b = q.b.add(q.c).add(mulUpMagU(x, x));\n    q.b = q.b.gt(BigNumber.from(0))\n        ? divUpMagU(q.b, lambda)\n        : divDownMagU(q.b, lambda);\n\n    q.a = q.a.add(q.b);\n    q.a = q.a.gt(BigNumber.from(0))\n        ? divUpMagU(q.a, lambda)\n        : divDownMagU(q.a, lambda);\n\n    termXp = divXpU(mulXpU(tauBeta.x, tauBeta.x), sqVars.x).add(7);\n    const val = mulUpMagU(mulUpMagU(sqVars.y, c), c);\n    return mulUpXpToNpU(val, termXp).add(q.a);\n}\n\n/////////\n/// LINEAR ALGEBRA OPERATIONS\n/////////\n\nexport function mulA(params: GyroEParams, tp: Vector2): Vector2 {\n    return {\n        x: divDownMagU(mulDownMagU(params.c, tp.x), params.lambda).sub(\n            divDownMagU(mulDownMagU(params.s, tp.y), params.lambda)\n        ),\n        y: mulDownMagU(params.s, tp.x).add(mulDownMagU(params.c, tp.y)),\n    };\n}\n\nexport function scalarProd(t1: Vector2, t2: Vector2): BigNumber {\n    const ret = mulDownMagU(t1.x, t2.x).add(mulDownMagU(t1.y, t2.y));\n    return ret;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n    QParams,\n    virtualOffset0,\n    virtualOffset1,\n} from './gyroEMathHelpers';\nimport { ONE_XP } from '../../gyroHelpers/constants';\nimport {\n    mulDown,\n    divDown,\n    mulDownMagU,\n    divDownMagU,\n    mulUpMagU,\n    divUpMagU,\n    mulUpXpToNpU,\n    mulDownXpToNpU,\n    divXpU,\n    sqrt,\n} from '../../gyroHelpers/gyroSignedFixedPoint';\nimport { calcXpXpDivLambdaLambda } from './gyroEMathHelpers';\n\n/////////\n/// SPOT PRICE AFTER SWAP CALCULATIONS\n/////////\n\nexport function calcSpotPriceYGivenX(\n    x: BigNumber,\n    params: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2\n): BigNumber {\n    const ab: Vector2 = {\n        x: virtualOffset0(params, d, r),\n        y: virtualOffset1(params, d, r),\n    };\n    const newSpotPriceFactor = solveDerivativeQuadraticSwap(\n        params.lambda,\n        x,\n        params.s,\n        params.c,\n        r,\n        ab,\n        d.tauBeta,\n        d.dSq\n    );\n    return newSpotPriceFactor;\n}\n\nexport function calcSpotPriceXGivenY(\n    y: BigNumber,\n    params: GyroEParams,\n    d: DerivedGyroEParams,\n    r: Vector2\n): BigNumber {\n    const ba: Vector2 = {\n        x: virtualOffset1(params, d, r),\n        y: virtualOffset0(params, d, r),\n    };\n    const newSpotPriceFactor = solveDerivativeQuadraticSwap(\n        params.lambda,\n        y,\n        params.c,\n        params.s,\n        r,\n        ba,\n        {\n            x: d.tauAlpha.x.mul(-1),\n            y: d.tauAlpha.y,\n        },\n        d.dSq\n    );\n    return newSpotPriceFactor;\n}\n\nfunction solveDerivativeQuadraticSwap(\n    lambda: BigNumber,\n    x: BigNumber,\n    s: BigNumber,\n    c: BigNumber,\n    r: Vector2,\n    ab: Vector2,\n    tauBeta: Vector2,\n    dSq: BigNumber\n): BigNumber {\n    const lamBar: Vector2 = {\n        x: ONE_XP.sub(divDownMagU(divDownMagU(ONE_XP, lambda), lambda)),\n        y: ONE_XP.sub(divUpMagU(divUpMagU(ONE_XP, lambda), lambda)),\n    };\n    const q: QParams = {\n        a: BigNumber.from(0),\n        b: BigNumber.from(0),\n        c: BigNumber.from(0),\n    };\n    const xp = x.sub(ab.x);\n    q.b = mulUpXpToNpU(mulDownMagU(s, c), divXpU(lamBar.y, dSq));\n\n    const sTerm: Vector2 = {\n        x: divXpU(mulDownMagU(mulDownMagU(lamBar.y, s), s), dSq),\n        y: divXpU(mulUpMagU(mulUpMagU(lamBar.x, s), s), dSq.add(1)).add(1),\n    };\n    sTerm.x = ONE_XP.sub(sTerm.x);\n    sTerm.y = ONE_XP.sub(sTerm.y);\n\n    q.c = calcXpXpDivLambdaLambda(x, r, lambda, s, c, tauBeta, dSq).mul(-1);\n    q.c = q.c.add(mulDownXpToNpU(mulDownMagU(r.y, r.y), sTerm.y)); // r.y ===  currentInv + err\n    q.c = q.c.gt(BigNumber.from(0))\n        ? sqrt(q.c, BigNumber.from(5))\n        : BigNumber.from(0);\n\n    q.c = mulDown(mulDown(q.c, lambda), lambda);\n    q.c = divDown(xp, q.c);\n\n    if (q.b.sub(q.c).gt(BigNumber.from(0))) {\n        q.a = mulUpXpToNpU(q.b.sub(q.c), divXpU(ONE_XP, sTerm.y).add(1));\n    } else {\n        q.a = mulUpXpToNpU(q.b.sub(q.c), divXpU(ONE_XP, sTerm.x));\n    }\n    return q.a;\n}\n\n/////////\n/// SPOT PRICE DERIVATIVE CALCULATIONS\n/////////\n\nfunction setup(\n    balances,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2,\n    ixVar: number\n) {\n    const r = rVec.y;\n    const { c, s, lambda } = params;\n    const [x0, y0] = balances;\n    const a = virtualOffset0(params, derived, rVec);\n    const b = virtualOffset1(params, derived, rVec);\n    const ls = ONE.sub(divDown(ONE, mulDown(lambda, lambda)));\n    const f = ONE.sub(fee);\n\n    let R: BigNumber;\n    if (ixVar === 0) {\n        R = sqrt(\n            mulDown(mulDown(r, r), ONE.sub(mulDown(ls, mulDown(s, s)))).sub(\n                divDown(mulDown(x0.sub(a), x0.sub(a)), mulDown(lambda, lambda))\n            ),\n            BigNumber.from(5)\n        );\n    } else {\n        R = sqrt(\n            mulDown(mulDown(r, r), ONE.sub(mulDown(ls, mulDown(c, c)))).sub(\n                divDown(mulDown(y0.sub(b), y0.sub(b)), mulDown(lambda, lambda))\n            ),\n            BigNumber.from(5)\n        );\n    }\n\n    return { x0, y0, c, s, lambda, a, b, ls, f, r, R };\n}\n\nexport function normalizedLiquidityYIn(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { y0, c, s, lambda, b, ls, R } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        1\n    );\n\n    const returnValue = divDown(\n        mulDown(\n            divDown(ONE, ONE.sub(mulDown(ls, mulDown(c, c)))),\n            mulDown(\n                R,\n                mulDown(\n                    mulDown(\n                        mulDown(\n                            mulDown(mulDown(ls, s), c),\n                            mulDown(lambda, lambda)\n                        ),\n                        R\n                    ).sub(y0.sub(b)),\n                    mulDown(\n                        mulDown(\n                            mulDown(mulDown(ls, s), c),\n                            mulDown(lambda, lambda)\n                        ),\n                        R\n                    ).sub(y0.sub(b))\n                )\n            )\n        ),\n        mulDown(mulDown(lambda, lambda), mulDown(R, R)).add(\n            mulDown(y0.sub(b), y0.sub(b))\n        )\n    );\n\n    return returnValue;\n}\n\nexport function normalizedLiquidityXIn(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { x0, c, s, lambda, a, ls, R } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        0\n    );\n\n    const returnValue = divDown(\n        mulDown(\n            divDown(ONE, ONE.sub(mulDown(ls, mulDown(s, s)))),\n            mulDown(\n                R,\n                mulDown(\n                    mulDown(\n                        mulDown(\n                            mulDown(mulDown(ls, s), c),\n                            mulDown(lambda, lambda)\n                        ),\n                        R\n                    ).sub(x0.sub(a)),\n                    mulDown(\n                        mulDown(\n                            mulDown(mulDown(ls, s), c),\n                            mulDown(lambda, lambda)\n                        ),\n                        R\n                    ).sub(x0.sub(a))\n                )\n            )\n        ),\n        mulDown(mulDown(lambda, lambda), mulDown(R, R)).add(\n            mulDown(x0.sub(a), x0.sub(a))\n        )\n    );\n\n    return returnValue;\n}\n\nexport function dPyDXIn(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { x0, c, s, lambda, a, ls, R } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        0\n    );\n\n    const returnValue = divDown(\n        mulDown(\n            ONE.sub(mulDown(ls, mulDown(s, s))),\n            divDown(ONE, mulDown(mulDown(lambda, lambda), R)).add(\n                divDown(\n                    mulDown(x0.sub(a), x0.sub(a)),\n                    mulDown(\n                        mulDown(\n                            mulDown(lambda, lambda),\n                            mulDown(lambda, lambda)\n                        ),\n                        mulDown(R, mulDown(R, R))\n                    )\n                )\n            )\n        ),\n        mulDown(\n            mulDown(mulDown(ls, s), c).sub(\n                divDown(x0.sub(a), mulDown(mulDown(lambda, lambda), R))\n            ),\n            mulDown(mulDown(ls, s), c).sub(\n                divDown(x0.sub(a), mulDown(mulDown(lambda, lambda), R))\n            )\n        )\n    );\n\n    return returnValue;\n}\n\nexport function dPxDYIn(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { y0, c, s, lambda, b, ls, R } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        1\n    );\n\n    const returnValue = divDown(\n        mulDown(\n            ONE.sub(mulDown(ls, mulDown(c, c))),\n            divDown(ONE, mulDown(mulDown(lambda, lambda), R)).add(\n                divDown(\n                    mulDown(y0.sub(b), y0.sub(b)),\n                    mulDown(\n                        mulDown(\n                            mulDown(lambda, lambda),\n                            mulDown(lambda, lambda)\n                        ),\n                        mulDown(R, mulDown(R, R))\n                    )\n                )\n            )\n        ),\n        mulDown(\n            mulDown(mulDown(ls, s), c).sub(\n                divDown(y0.sub(b), mulDown(mulDown(lambda, lambda), R))\n            ),\n            mulDown(mulDown(ls, s), c).sub(\n                divDown(y0.sub(b), mulDown(mulDown(lambda, lambda), R))\n            )\n        )\n    );\n\n    return returnValue;\n}\n\nexport function dPxDXOut(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { x0, s, lambda, a, ls, R, f } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        0\n    );\n\n    const returnValue = mulDown(\n        divDown(ONE, mulDown(f, ONE.sub(mulDown(ls, mulDown(s, s))))),\n        divDown(ONE, mulDown(mulDown(lambda, lambda), R)).add(\n            divDown(\n                mulDown(x0.sub(a), x0.sub(a)),\n                mulDown(\n                    mulDown(mulDown(lambda, lambda), mulDown(lambda, lambda)),\n                    mulDown(mulDown(R, R), R)\n                )\n            )\n        )\n    );\n\n    return returnValue;\n}\n\nexport function dPyDYOut(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    fee: BigNumber,\n    rVec: Vector2\n): BigNumber {\n    const { y0, c, lambda, b, ls, R, f } = setup(\n        balances,\n        params,\n        derived,\n        fee,\n        rVec,\n        1\n    );\n\n    const returnValue = mulDown(\n        divDown(ONE, mulDown(f, ONE.sub(mulDown(ls, mulDown(c, c))))),\n        divDown(ONE, mulDown(mulDown(lambda, lambda), R)).add(\n            divDown(\n                mulDown(y0.sub(b), y0.sub(b)),\n                mulDown(\n                    mulDown(mulDown(lambda, lambda), mulDown(lambda, lambda)),\n                    mulDown(mulDown(R, R), R)\n                )\n            )\n        )\n    );\n\n    return returnValue;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { MAX_BALANCES, MAX_INVARIANT } from './constants';\nimport { ONE_XP, SMALL } from '../../gyroHelpers/constants';\nimport {\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n    calcAtAChi,\n    calcInvariantSqrt,\n    calcAChiAChiInXp,\n    calcXGivenY,\n    calcYGivenX,\n    checkAssetBounds,\n} from './gyroEMathHelpers';\nimport {\n    mulDown,\n    divDown,\n    mulUpMagU,\n    divUpMagU,\n    mulUpXpToNpU,\n    mulDownXpToNpU,\n    divXpU,\n    sqrt,\n} from '../../gyroHelpers/gyroSignedFixedPoint';\nimport {\n    normalizedLiquidityXIn,\n    normalizedLiquidityYIn,\n    calcSpotPriceXGivenY,\n    calcSpotPriceYGivenX,\n    dPxDXOut,\n    dPxDYIn,\n    dPyDXIn,\n    dPyDYOut,\n} from './gyroEMathFunctions';\n\nexport function calculateNormalizedLiquidity(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    r: Vector2,\n    fee: BigNumber,\n    tokenInIsToken0: boolean\n): BigNumber {\n    if (tokenInIsToken0) {\n        return normalizedLiquidityXIn(balances, params, derived, fee, r);\n    } else {\n        return normalizedLiquidityYIn(balances, params, derived, fee, r);\n    }\n}\n\nexport function calculateInvariantWithError(\n    balances: BigNumber[],\n    params: GyroEParams,\n    derived: DerivedGyroEParams\n): [BigNumber, BigNumber] {\n    const [x, y] = balances;\n\n    if (x.add(y).gt(MAX_BALANCES)) throw new Error('MAX ASSETS EXCEEDED');\n    const AtAChi = calcAtAChi(x, y, params, derived);\n\n    const invariantResult = calcInvariantSqrt(x, y, params, derived);\n    const square_root = invariantResult[0];\n    let err = invariantResult[1];\n\n    if (square_root.gt(0)) {\n        err = divUpMagU(err.add(1), square_root.mul(2));\n    } else {\n        err = err.gt(0)\n            ? sqrt(err, BigNumber.from(5))\n            : BigNumber.from(10).pow(9);\n    }\n\n    err = mulUpMagU(params.lambda, x.add(y))\n        .div(ONE_XP)\n        .add(err)\n        .add(1)\n        .mul(20);\n\n    const mulDenominator = divXpU(\n        ONE_XP,\n        calcAChiAChiInXp(params, derived).sub(ONE_XP)\n    );\n    const invariant = mulDownXpToNpU(\n        AtAChi.add(square_root).sub(err),\n        mulDenominator\n    );\n    err = mulUpXpToNpU(err, mulDenominator);\n\n    err = err\n        .add(\n            mulUpXpToNpU(invariant, mulDenominator)\n                .mul(\n                    params.lambda\n                        .mul(params.lambda)\n                        .div(BigNumber.from(10).pow(36))\n                )\n                .mul(40)\n                .div(ONE_XP)\n        )\n        .add(1);\n\n    if (invariant.add(err).gt(MAX_INVARIANT))\n        throw new Error('MAX INVARIANT EXCEEDED');\n\n    return [invariant, err];\n}\n\nexport function calcOutGivenIn(\n    balances: BigNumber[],\n    amountIn: BigNumber,\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2\n): BigNumber {\n    if (amountIn.lt(SMALL)) return BigNumber.from(0);\n\n    const ixIn = Number(!tokenInIsToken0);\n    const ixOut = Number(tokenInIsToken0);\n\n    const calcGiven = tokenInIsToken0 ? calcYGivenX : calcXGivenY;\n\n    const balInNew = balances[ixIn].add(amountIn);\n\n    checkAssetBounds(params, derived, invariant, balInNew, ixIn);\n    const balOutNew = calcGiven(balInNew, params, derived, invariant);\n    const amountOut = balances[ixOut].sub(balOutNew);\n    if (amountOut.lt(0)) {\n        // Should never happen; check anyways to catch a numerical bug.\n        throw new Error('ASSET BOUNDS EXCEEDED 1');\n    }\n\n    return amountOut;\n}\n\nexport function calcInGivenOut(\n    balances: BigNumber[],\n    amountOut: BigNumber,\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2\n): BigNumber {\n    if (amountOut.lt(SMALL)) return BigNumber.from(0);\n\n    const ixIn = Number(!tokenInIsToken0);\n    const ixOut = Number(tokenInIsToken0);\n\n    const calcGiven = tokenInIsToken0 ? calcXGivenY : calcYGivenX;\n\n    if (amountOut.gt(balances[ixOut]))\n        throw new Error('ASSET BOUNDS EXCEEDED 2');\n    const balOutNew = balances[ixOut].sub(amountOut);\n\n    const balInNew = calcGiven(balOutNew, params, derived, invariant);\n    checkAssetBounds(params, derived, invariant, balInNew, ixIn);\n    const amountIn = balInNew.sub(balances[ixIn]);\n\n    if (amountIn.lt(0))\n        // Should never happen; check anyways to catch a numerical bug.\n        throw new Error('ASSET BOUNDS EXCEEDED 3');\n    return amountIn;\n}\n\nexport function calcSpotPriceAfterSwapOutGivenIn(\n    balances: BigNumber[],\n    amountIn: BigNumber,\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2,\n    swapFee: BigNumber\n): BigNumber {\n    const ixIn = Number(!tokenInIsToken0);\n    const f = ONE.sub(swapFee);\n\n    const calcSpotPriceGiven = tokenInIsToken0\n        ? calcSpotPriceYGivenX\n        : calcSpotPriceXGivenY;\n\n    const balInNew = balances[ixIn].add(amountIn);\n    const newSpotPriceFactor = calcSpotPriceGiven(\n        balInNew,\n        params,\n        derived,\n        invariant\n    );\n    return divDown(ONE, mulDown(newSpotPriceFactor, f));\n}\n\nexport function calcSpotPriceAfterSwapInGivenOut(\n    balances: BigNumber[],\n    amountOut: BigNumber,\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2,\n    swapFee: BigNumber\n): BigNumber {\n    const ixOut = Number(tokenInIsToken0);\n    const f = ONE.sub(swapFee);\n\n    const calcSpotPriceGiven = tokenInIsToken0\n        ? calcSpotPriceXGivenY\n        : calcSpotPriceYGivenX;\n\n    const balOutNew = balances[ixOut].sub(amountOut);\n    const newSpotPriceFactor = calcSpotPriceGiven(\n        balOutNew,\n        params,\n        derived,\n        invariant\n    );\n    return divDown(newSpotPriceFactor, f);\n}\n\nexport function calcDerivativePriceAfterSwapOutGivenIn(\n    balances: BigNumber[],\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2,\n    swapFee: BigNumber\n): BigNumber {\n    const ixIn = Number(!tokenInIsToken0);\n\n    const newDerivativeSpotPriceFactor = ixIn\n        ? dPxDYIn(balances, params, derived, swapFee, invariant)\n        : dPyDXIn(balances, params, derived, swapFee, invariant);\n\n    return newDerivativeSpotPriceFactor;\n}\n\nexport function calcDerivativeSpotPriceAfterSwapInGivenOut(\n    balances: BigNumber[],\n    tokenInIsToken0: boolean,\n    params: GyroEParams,\n    derived: DerivedGyroEParams,\n    invariant: Vector2,\n    swapFee: BigNumber\n): BigNumber {\n    const ixIn = Number(!tokenInIsToken0);\n\n    const newDerivativeSpotPriceFactor = ixIn\n        ? dPxDXOut(balances, params, derived, swapFee, invariant)\n        : dPyDYOut(balances, params, derived, swapFee, invariant);\n\n    return newDerivativeSpotPriceFactor;\n}\n","import { getAddress } from '@ethersproject/address';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { formatFixed, BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\n\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphToken,\n    SwapTypes,\n    SubgraphPoolBase,\n} from '../../types';\nimport {\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n    normalizeBalances,\n    balancesFromTokenInOut,\n    reduceFee,\n    addFee,\n    virtualOffset0,\n    virtualOffset1,\n} from './gyroEMath/gyroEMathHelpers';\nimport { isSameAddress, safeParseFixed } from '../../utils';\nimport { mulDown, divDown } from '../gyroHelpers/gyroSignedFixedPoint';\nimport {\n    calculateInvariantWithError,\n    calcOutGivenIn,\n    calcInGivenOut,\n    calcSpotPriceAfterSwapOutGivenIn,\n    calcSpotPriceAfterSwapInGivenOut,\n    calcDerivativePriceAfterSwapOutGivenIn,\n    calcDerivativeSpotPriceAfterSwapInGivenOut,\n} from './gyroEMath/gyroEMath';\nimport { SWAP_LIMIT_FACTOR } from '../gyroHelpers/constants';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nexport type GyroEPoolPairData = PoolPairBase & {\n    tokenInIsToken0: boolean;\n};\n\nexport type GyroEPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals'\n>;\n\ntype GyroEParamsFromSubgraph = {\n    alpha: string;\n    beta: string;\n    c: string;\n    s: string;\n    lambda: string;\n};\ntype DerivedGyroEParamsFromSubgraph = {\n    tauAlphaX: string;\n    tauAlphaY: string;\n    tauBetaX: string;\n    tauBetaY: string;\n    u: string;\n    v: string;\n    w: string;\n    z: string;\n    dSq: string;\n};\n\nexport class GyroEPool implements PoolBase<GyroEPoolPairData> {\n    poolType: PoolTypes = PoolTypes.GyroE;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: GyroEPoolToken[];\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    gyroEParams: GyroEParams;\n    derivedGyroEParams: DerivedGyroEParams;\n\n    static fromPool(pool: SubgraphPoolBase): GyroEPool {\n        const {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n        } = pool;\n\n        const gyroEParams = {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n        };\n\n        const derivedGyroEParams = {\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n        };\n\n        if (\n            !Object.values(gyroEParams).every((el) => el) ||\n            !Object.values(derivedGyroEParams).every((el) => el)\n        )\n            throw new Error(\n                'Pool missing GyroE params and/or GyroE derived params'\n            );\n\n        return new GyroEPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens as GyroEPoolToken[],\n            pool.tokensList,\n            gyroEParams as GyroEParamsFromSubgraph,\n            derivedGyroEParams as DerivedGyroEParamsFromSubgraph\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: GyroEPoolToken[],\n        tokensList: string[],\n        gyroEParams: GyroEParamsFromSubgraph,\n        derivedGyroEParams: DerivedGyroEParamsFromSubgraph\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = safeParseFixed(swapFee, 18);\n        this.totalShares = safeParseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n\n        this.gyroEParams = {\n            alpha: safeParseFixed(gyroEParams.alpha, 18),\n            beta: safeParseFixed(gyroEParams.beta, 18),\n            c: safeParseFixed(gyroEParams.c, 18),\n            s: safeParseFixed(gyroEParams.s, 18),\n            lambda: safeParseFixed(gyroEParams.lambda, 18),\n        };\n\n        this.derivedGyroEParams = {\n            tauAlpha: {\n                x: safeParseFixed(derivedGyroEParams.tauAlphaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauAlphaY, 38),\n            },\n            tauBeta: {\n                x: safeParseFixed(derivedGyroEParams.tauBetaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauBetaY, 38),\n            },\n            u: safeParseFixed(derivedGyroEParams.u, 38),\n            v: safeParseFixed(derivedGyroEParams.v, 38),\n            w: safeParseFixed(derivedGyroEParams.w, 38),\n            z: safeParseFixed(derivedGyroEParams.z, 38),\n            dSq: safeParseFixed(derivedGyroEParams.dSq, 38),\n        };\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): GyroEPoolPairData {\n        const tokenInIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenInIndex < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenInIndex];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenOutIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenOutIndex < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenOutIndex];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        const tokenInIsToken0 = tokenInIndex === 0;\n\n        const poolPairData: GyroEPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: safeParseFixed(balanceIn, decimalsIn),\n            balanceOut: safeParseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            tokenInIsToken0,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: GyroEPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: GyroEPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut]\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const virtualOffsetFunc = poolPairData.tokenInIsToken0\n                ? virtualOffset0\n                : virtualOffset1;\n            const maxAmountInAssetInPool = virtualOffsetFunc(\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            ).sub(\n                virtualOffsetFunc(\n                    this.gyroEParams,\n                    this.derivedGyroEParams,\n                    invariant,\n                    true\n                )\n            );\n            const limitAmountIn = maxAmountInAssetInPool.sub(\n                normalizedBalances[0]\n            );\n            const limitAmountInPlusSwapFee = divDown(\n                limitAmountIn,\n                ONE.sub(poolPairData.swapFee)\n            );\n            return bnum(\n                formatFixed(\n                    mulDown(limitAmountInPlusSwapFee, SWAP_LIMIT_FACTOR),\n                    18\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    mulDown(poolPairData.balanceOut, SWAP_LIMIT_FACTOR),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n        const inAmount = safeParseFixed(amount.toString(), 18);\n        const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n        const outAmount = calcOutGivenIn(\n            orderedNormalizedBalances,\n            inAmountLessFee,\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant\n        );\n        return bnum(formatFixed(outAmount, 18));\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n        const outAmount = safeParseFixed(amount.toString(), 18);\n\n        const inAmountLessFee = calcInGivenOut(\n            orderedNormalizedBalances,\n            outAmount,\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant\n        );\n        const inAmount = addFee(inAmountLessFee, poolPairData.swapFee);\n        return bnum(formatFixed(inAmount, 18));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n        const inAmount = safeParseFixed(amount.toString(), 18);\n        const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n        const newSpotPrice = calcSpotPriceAfterSwapOutGivenIn(\n            orderedNormalizedBalances,\n            inAmountLessFee,\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant,\n            poolPairData.swapFee\n        );\n        return bnum(formatFixed(newSpotPrice, 18));\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n        const outAmount = safeParseFixed(amount.toString(), 18);\n        const newSpotPrice = calcSpotPriceAfterSwapInGivenOut(\n            orderedNormalizedBalances,\n            outAmount,\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant,\n            poolPairData.swapFee\n        );\n        return bnum(formatFixed(newSpotPrice, 18));\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const inAmount = safeParseFixed(amount.toString(), 18);\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n\n        const derivative = calcDerivativePriceAfterSwapOutGivenIn(\n            [\n                orderedNormalizedBalances[0].add(\n                    reduceFee(inAmount, poolPairData.swapFee)\n                ),\n                orderedNormalizedBalances[1],\n            ],\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant,\n            poolPairData.swapFee\n        );\n        return bnum(formatFixed(derivative, 18));\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const normalizedBalances = normalizeBalances(\n            [poolPairData.balanceIn, poolPairData.balanceOut],\n            [poolPairData.decimalsIn, poolPairData.decimalsOut]\n        );\n        const orderedNormalizedBalances = balancesFromTokenInOut(\n            normalizedBalances[0],\n            normalizedBalances[1],\n            poolPairData.tokenInIsToken0\n        );\n        const [currentInvariant, invErr] = calculateInvariantWithError(\n            orderedNormalizedBalances,\n            this.gyroEParams,\n            this.derivedGyroEParams\n        );\n        const invariant: Vector2 = {\n            x: currentInvariant.add(invErr.mul(2)),\n            y: currentInvariant,\n        };\n        const outAmount = safeParseFixed(amount.toString(), 18);\n        const derivative = calcDerivativeSpotPriceAfterSwapInGivenOut(\n            [\n                orderedNormalizedBalances[0],\n                orderedNormalizedBalances[1].sub(outAmount),\n            ],\n            poolPairData.tokenInIsToken0,\n            this.gyroEParams,\n            this.derivedGyroEParams,\n            invariant,\n            poolPairData.swapFee\n        );\n        return bnum(formatFixed(derivative, 18));\n    }\n}\n","import { BigNumber, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { mulDown } from '../../gyroHelpers/gyroSignedFixedPoint';\n\nexport function normalizeBalances(\n    balances: BigNumber[],\n    decimals: number[],\n    tokenRates: BigNumber[]\n): BigNumber[] {\n    const scalingFactors = decimals.map((d) => parseFixed('1', d));\n\n    return balances.map((bal, index) =>\n        mulDown(bal.mul(ONE).div(scalingFactors[index]), tokenRates[index])\n    );\n}\n","import { getAddress } from '@ethersproject/address';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { formatFixed, BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\n\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphToken,\n    SwapTypes,\n    SubgraphPoolBase,\n} from '../../types';\nimport {\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n    balancesFromTokenInOut,\n    reduceFee,\n    addFee,\n    virtualOffset0,\n    virtualOffset1,\n} from '../gyroEPool/gyroEMath/gyroEMathHelpers';\nimport { isSameAddress, safeParseFixed } from '../../utils';\nimport { mulDown, divDown } from '../gyroHelpers/gyroSignedFixedPoint';\nimport {\n    calculateInvariantWithError,\n    calcOutGivenIn,\n    calcInGivenOut,\n    calcSpotPriceAfterSwapOutGivenIn,\n    calcSpotPriceAfterSwapInGivenOut,\n    calcDerivativePriceAfterSwapOutGivenIn,\n    calcDerivativeSpotPriceAfterSwapInGivenOut,\n} from '../gyroEPool/gyroEMath/gyroEMath';\nimport { SWAP_LIMIT_FACTOR } from '../gyroHelpers/constants';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nimport { normalizeBalances } from './gyroEV2Math/gyroEV2MathHelpers';\n\n// Alias for code readability. Observe that `balancesFromTokenInOut()` is its own inverse.\nconst valuesInOutFrom01 = balancesFromTokenInOut;\n\nexport type GyroEPoolPairData = PoolPairBase & {\n    tokenInIsToken0: boolean;\n};\n\nexport type GyroEPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals'\n>;\n\ntype GyroEParamsFromSubgraph = {\n    alpha: string;\n    beta: string;\n    c: string;\n    s: string;\n    lambda: string;\n};\ntype DerivedGyroEParamsFromSubgraph = {\n    tauAlphaX: string;\n    tauAlphaY: string;\n    tauBetaX: string;\n    tauBetaY: string;\n    u: string;\n    v: string;\n    w: string;\n    z: string;\n    dSq: string;\n};\n\nexport class GyroEV2Pool implements PoolBase<GyroEPoolPairData> {\n    poolType: PoolTypes = PoolTypes.GyroE;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: GyroEPoolToken[];\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    gyroEParams: GyroEParams;\n    derivedGyroEParams: DerivedGyroEParams;\n    tokenRates: BigNumber[];\n\n    static fromPool(pool: SubgraphPoolBase): GyroEV2Pool {\n        const {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n            tokenRates,\n        } = pool;\n\n        const gyroEParams = {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n        };\n\n        const derivedGyroEParams = {\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n        };\n\n        if (\n            !Object.values(gyroEParams).every((el) => el) ||\n            !Object.values(derivedGyroEParams).every((el) => el)\n        )\n            throw new Error(\n                'Pool missing GyroE params and/or GyroE derived params'\n            );\n\n        if (!tokenRates) throw new Error('GyroEV2 Pool missing tokenRates');\n\n        return new GyroEV2Pool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens as GyroEPoolToken[],\n            pool.tokensList,\n            gyroEParams as GyroEParamsFromSubgraph,\n            derivedGyroEParams as DerivedGyroEParamsFromSubgraph,\n            tokenRates\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: GyroEPoolToken[],\n        tokensList: string[],\n        gyroEParams: GyroEParamsFromSubgraph,\n        derivedGyroEParams: DerivedGyroEParamsFromSubgraph,\n        tokenRates: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = safeParseFixed(swapFee, 18);\n        this.totalShares = safeParseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.tokenRates = [\n            safeParseFixed(tokenRates[0], 18),\n            safeParseFixed(tokenRates[1], 18),\n        ];\n\n        this.gyroEParams = {\n            alpha: safeParseFixed(gyroEParams.alpha, 18),\n            beta: safeParseFixed(gyroEParams.beta, 18),\n            c: safeParseFixed(gyroEParams.c, 18),\n            s: safeParseFixed(gyroEParams.s, 18),\n            lambda: safeParseFixed(gyroEParams.lambda, 18),\n        };\n\n        this.derivedGyroEParams = {\n            tauAlpha: {\n                x: safeParseFixed(derivedGyroEParams.tauAlphaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauAlphaY, 38),\n            },\n            tauBeta: {\n                x: safeParseFixed(derivedGyroEParams.tauBetaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauBetaY, 38),\n            },\n            u: safeParseFixed(derivedGyroEParams.u, 38),\n            v: safeParseFixed(derivedGyroEParams.v, 38),\n            w: safeParseFixed(derivedGyroEParams.w, 38),\n            z: safeParseFixed(derivedGyroEParams.z, 38),\n            dSq: safeParseFixed(derivedGyroEParams.dSq, 38),\n        };\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): GyroEPoolPairData {\n        const tokenInIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenInIndex < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenInIndex];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenOutIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenOutIndex < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenOutIndex];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        const tokenInIsToken0 = tokenInIndex === 0;\n\n        const poolPairData: GyroEPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: safeParseFixed(balanceIn, decimalsIn),\n            balanceOut: safeParseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            tokenInIsToken0,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: GyroEPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: GyroEPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const virtualOffsetFunc = poolPairData.tokenInIsToken0\n                ? virtualOffset0\n                : virtualOffset1;\n            const maxAmountInAssetInPool = virtualOffsetFunc(\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            ).sub(\n                virtualOffsetFunc(\n                    this.gyroEParams,\n                    this.derivedGyroEParams,\n                    invariant,\n                    true\n                )\n            );\n            const limitAmountIn = divDown(\n                maxAmountInAssetInPool.sub(normalizedBalances[0]),\n                tokenRateInOut[0]\n            );\n            const limitAmountInPlusSwapFee = divDown(\n                limitAmountIn,\n                ONE.sub(poolPairData.swapFee)\n            );\n            return bnum(\n                formatFixed(\n                    mulDown(limitAmountInPlusSwapFee, SWAP_LIMIT_FACTOR),\n                    18\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    mulDown(poolPairData.balanceOut, SWAP_LIMIT_FACTOR),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n            const inAmountLessFeeScaled = mulDown(\n                inAmountLessFee,\n                tokenRateInOut[0]\n            );\n            const outAmountScaled = calcOutGivenIn(\n                orderedNormalizedBalances,\n                inAmountLessFeeScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            );\n            const outAmount = divDown(outAmountScaled, tokenRateInOut[1]);\n            return bnum(formatFixed(outAmount, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const outAmountScaled = mulDown(outAmount, tokenRateInOut[1]);\n\n            const inAmountScaledLessFee = calcInGivenOut(\n                orderedNormalizedBalances,\n                outAmountScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            );\n            const inAmountLessFee = divDown(\n                inAmountScaledLessFee,\n                tokenRateInOut[0]\n            );\n            const inAmount = addFee(inAmountLessFee, poolPairData.swapFee);\n            return bnum(formatFixed(inAmount, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n            const inAmountLessFeeScaled = mulDown(\n                inAmountLessFee,\n                tokenRateInOut[0]\n            );\n            const newSpotPriceScaled = calcSpotPriceAfterSwapOutGivenIn(\n                orderedNormalizedBalances,\n                inAmountLessFeeScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const newSpotPrice = divDown(\n                mulDown(newSpotPriceScaled, tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const outAmountScaled = mulDown(outAmount, tokenRateInOut[1]);\n            const newSpotPriceScaled = calcSpotPriceAfterSwapInGivenOut(\n                orderedNormalizedBalances,\n                outAmountScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const newSpotPrice = divDown(\n                mulDown(newSpotPriceScaled, tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n\n            const derivativeScaled = calcDerivativePriceAfterSwapOutGivenIn(\n                [\n                    orderedNormalizedBalances[0].add(\n                        reduceFee(\n                            mulDown(inAmount, tokenRateInOut[0]),\n                            poolPairData.swapFee\n                        )\n                    ),\n                    orderedNormalizedBalances[1],\n                ],\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const derivative = mulDown(derivativeScaled, tokenRateInOut[1]);\n            return bnum(formatFixed(derivative, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const derivativeScaled = calcDerivativeSpotPriceAfterSwapInGivenOut(\n                [\n                    orderedNormalizedBalances[0],\n                    orderedNormalizedBalances[1].sub(\n                        mulDown(outAmount, tokenRateInOut[1])\n                    ),\n                ],\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const rateAdjFactor = divDown(\n                mulDown(tokenRateInOut[1], tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            const derivative = mulDown(derivativeScaled, rateAdjFactor);\n            return bnum(formatFixed(derivative, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n}\n","import { BigNumber as OldBigNumber, bnum, scale } from '../../utils/bignumber';\nimport { FxPoolPairData } from './fxPool';\nimport { formatFixed } from '@ethersproject/bignumber';\n\n// Constants\nexport const CURVEMATH_MAX_DIFF = -0.000001000000000000024;\nexport const NEGATIVE_ONE = bnum('-1');\nexport const ONE = bnum('1');\nexport const ONE_TO_THE_SECOND_NUM = 100;\nexport const ONE_TO_THE_SECOND = BigInt(`${ONE_TO_THE_SECOND_NUM}`);\nexport const ONE_TO_THE_EIGHT_NUM = 100000000;\nexport const ONE_TO_THE_EIGHT = BigInt(`${ONE_TO_THE_EIGHT_NUM}`);\nexport const ONE_TO_THE_SIX_NUM = 1000000;\nexport const ONE_TO_THE_SIX = BigInt(`${ONE_TO_THE_SIX_NUM}`);\nexport const ONE_TO_THE_THIRTEEN_NUM = 10000000000000;\nexport const ONE_TO_THE_THIRTEEN = BigInt(`${ONE_TO_THE_THIRTEEN_NUM}`);\nexport const ONE_ETHER = scale(bnum('1'), 18);\nexport const ALMOST_ZERO = 0.0000000000000000001; // swapping within beta region has no slippage\nconst CURVEMATH_MAX = 0.25; //CURVEMATH MAX from contract\n\nexport enum CurveMathRevert {\n    LowerHalt = 'CurveMath/lower-halt',\n    UpperHalt = 'CurveMath/upper-halt',\n    SwapInvariantViolation = 'CurveMath/swap-invariant-violation',\n    SwapConvergenceFailed = 'CurveMath/swap-convergence-failed',\n    CannotSwap = 'CannotSwap',\n}\n\ninterface ParsedFxPoolData {\n    alpha: number;\n    beta: number;\n    delta: number;\n    epsilon: number;\n    lambda: number;\n    baseTokenRate: number;\n    _oGLiq: number;\n    _nGLiq: number;\n    _oBals: number[];\n    _nBals: number[];\n    givenAmountInNumeraire: number;\n}\n\ninterface ReservesInNumeraire {\n    tokenInReservesInNumeraire: number;\n    tokenOutReservesInNumeraire: number;\n    _oGLiq: number;\n}\n\nconst isUSDC = (address: string) => {\n    if (\n        address == '0x2791bca1f2de4661ed88a30c99a7a9449aa84174' ||\n        address == '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nconst calculateGivenAmountInNumeraire = (\n    isOriginSwap: boolean,\n    poolPairData: FxPoolPairData,\n    amount: number\n) => {\n    let calculatedNumeraireAmount;\n\n    if (isOriginSwap) {\n        // tokenIn is given\n        calculatedNumeraireAmount = viewNumeraireAmount(\n            amount,\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        );\n    } else {\n        // tokenOut is given\n        calculatedNumeraireAmount = viewNumeraireAmount(\n            amount,\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        );\n    }\n\n    return calculatedNumeraireAmount;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const convertToNumber = (\n    amount: number,\n    baseDecimal: number | string\n) => {\n    if (typeof baseDecimal === 'string') {\n        return Number(bnum(amount).div(bnum(ONE_ETHER)));\n    } else {\n        return amount / baseDecimal;\n    }\n};\n\nexport const poolBalancesToNumeraire = (\n    poolPairData: FxPoolPairData\n): ReservesInNumeraire => {\n    let tokenInNumeraire, tokenOutNumeraire;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        tokenInNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceIn),\n                poolPairData.tokenInLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsIn)\n        );\n        tokenOutNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceOut),\n                poolPairData.tokenOutLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsOut)\n        );\n    } else {\n        tokenInNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceOut),\n                poolPairData.tokenOutLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsOut)\n        );\n\n        tokenOutNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceIn),\n                poolPairData.tokenInLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsIn)\n        );\n    }\n\n    return {\n        tokenInReservesInNumeraire: tokenInNumeraire,\n        tokenOutReservesInNumeraire: tokenOutNumeraire,\n        _oGLiq: tokenInNumeraire + tokenOutNumeraire,\n    };\n};\n// everything is in order of USDC, base token\nconst getParsedFxPoolData = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData,\n    isOriginSwap: boolean\n): ParsedFxPoolData => {\n    // reserves are in raw amount, they converted to numeraire\n    const baseReserves = isUSDC(poolPairData.tokenIn)\n        ? convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceOut),\n                  poolPairData.tokenOutLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsOut)\n          )\n        : convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceIn),\n                  poolPairData.tokenInLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsIn)\n          );\n\n    // reserves are not in wei\n    const usdcReserves = isUSDC(poolPairData.tokenIn)\n        ? convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceIn),\n                  poolPairData.tokenInLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsIn)\n          )\n        : convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceOut),\n                  poolPairData.tokenOutLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsOut)\n          );\n\n    // rate is converted from chainlink to the actual rate in decimals\n    const baseTokenRate = isUSDC(poolPairData.tokenIn)\n        ? poolPairData.tokenOutLatestFXPrice.toNumber()\n        : poolPairData.tokenInLatestFXPrice.toNumber();\n\n    // given amount in or out converted to numeraire\n    const givenAmountInNumeraire = calculateGivenAmountInNumeraire(\n        isOriginSwap,\n        poolPairData,\n        Number(amount.toString())\n    );\n\n    return {\n        alpha: Number(formatFixed(poolPairData.alpha, 18)),\n        beta: Number(formatFixed(poolPairData.beta, 18)),\n        delta: Number(formatFixed(poolPairData.delta, 18)),\n        epsilon: Number(formatFixed(poolPairData.epsilon, 18)),\n        lambda: Number(formatFixed(poolPairData.lambda, 18)),\n        baseTokenRate: baseTokenRate,\n        _oGLiq: baseReserves + usdcReserves,\n        _nGLiq: baseReserves + usdcReserves,\n        _oBals: [usdcReserves, baseReserves],\n        _nBals: isUSDC(poolPairData.tokenIn)\n            ? [\n                  usdcReserves + givenAmountInNumeraire,\n                  baseReserves - givenAmountInNumeraire,\n              ]\n            : [\n                  usdcReserves - givenAmountInNumeraire,\n                  baseReserves + givenAmountInNumeraire,\n              ],\n\n        givenAmountInNumeraire: givenAmountInNumeraire,\n    };\n};\n\n// get base decimals for\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const getBaseDecimals = (decimals: number) => {\n    switch (decimals) {\n        case 6: {\n            return ONE_TO_THE_SIX_NUM;\n        }\n\n        case 2: {\n            return ONE_TO_THE_SECOND_NUM;\n        }\n\n        case 18: {\n            return ONE_ETHER.toString();\n        }\n\n        default: {\n            return ONE_ETHER.toString();\n        }\n    }\n};\n\n// Base Assimilator Functions\n// calculations are from the BaseToUsdAssimilator\nexport const viewRawAmount = (_amount: number, rate: number): OldBigNumber => {\n    return bnum(_amount / rate);\n};\n\nconst viewNumeraireAmount = (_amount: number, rate: number): number => {\n    return _amount * rate;\n};\n\n// Curve Math\n// calculations are from CurveMath.sol\nconst calculateMicroFee = (\n    _bal: number,\n    _ideal: number,\n    _beta: number,\n    _delta: number\n): number => {\n    let _threshold, _feeMargin;\n    let fee_ = 0;\n\n    if (_bal < _ideal) {\n        _threshold = _ideal * (1 - _beta); // CURVEMATH ONE\n\n        if (_bal < _threshold) {\n            _feeMargin = _threshold - _bal;\n            fee_ = _feeMargin / _ideal;\n            fee_ = fee_ * _delta;\n\n            if (fee_ > CURVEMATH_MAX) {\n                fee_ = CURVEMATH_MAX;\n            }\n\n            fee_ = fee_ * _feeMargin;\n        } else {\n            fee_ = 0;\n        }\n    } else {\n        _threshold = _ideal * (1 + _beta); // CURVEMATH_ONE\n\n        if (_bal > _threshold) {\n            _feeMargin = _bal - _threshold;\n\n            fee_ = _feeMargin / _ideal;\n            fee_ = fee_ * _delta;\n\n            if (fee_ > CURVEMATH_MAX) fee_ = CURVEMATH_MAX;\n\n            fee_ = fee_ * _feeMargin;\n        } else {\n            fee_ = 0;\n        }\n    }\n\n    return fee_;\n};\n\nconst calculateFee = (\n    _gLiq: number,\n    _bals: number[],\n    _beta: number,\n    _delta: number,\n    _weights: number[]\n): number => {\n    const _length = _bals.length;\n    let psi_ = 0;\n\n    for (let i = 0; i < _length; i++) {\n        const _ideal = _gLiq * _weights[i];\n\n        // keep away from wei values like how the contract do it\n        psi_ = psi_ + calculateMicroFee(_bals[i], _ideal, _beta, _delta);\n    }\n\n    return psi_;\n};\n\n// return outputAmount and ngliq\nconst calculateTrade = (\n    _oGLiq: number,\n    _nGLiq: number,\n    _oBals: number[],\n    _nBals: number[],\n    _inputAmt: number,\n    _outputIndex: number,\n    poolPairData: ParsedFxPoolData\n): [number, number] => {\n    let outputAmt_;\n    const _weights: number[] = [0.5, 0.5]; // const for now since all weights are 0.5\n\n    const alpha = poolPairData.alpha;\n    const beta = poolPairData.beta;\n    const delta = poolPairData.delta;\n    const lambda = poolPairData.lambda;\n\n    outputAmt_ = -_inputAmt;\n\n    const _omega = calculateFee(_oGLiq, _oBals, beta, delta, _weights);\n\n    let _psi: number;\n\n    for (let i = 0; i < 32; i++) {\n        _psi = calculateFee(_nGLiq, _nBals, beta, delta, _weights);\n\n        const prevAmount = outputAmt_;\n\n        outputAmt_ =\n            _omega < _psi\n                ? -(_inputAmt + (_omega - _psi))\n                : -(_inputAmt + lambda * (_omega - _psi));\n\n        if (\n            outputAmt_ / ONE_TO_THE_THIRTEEN_NUM ==\n            prevAmount / ONE_TO_THE_THIRTEEN_NUM\n        ) {\n            _nGLiq = _oGLiq + _inputAmt + outputAmt_;\n\n            _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\n\n            // throws error already, removed if statement\n            enforceSwapInvariant(_oGLiq, _omega, _nGLiq, _psi);\n            enforceHalts(_oGLiq, _nGLiq, _oBals, _nBals, _weights, alpha);\n\n            return [outputAmt_, _nGLiq];\n        } else {\n            _nGLiq = _oGLiq + _inputAmt + outputAmt_;\n\n            _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\n        }\n    }\n\n    throw new Error(CurveMathRevert.SwapConvergenceFailed);\n};\n\n// invariant enforcement\nconst enforceHalts = (\n    _oGLiq: number,\n    _nGLiq: number,\n    _oBals: number[],\n    _nBals: number[],\n    _weights: number[],\n    alpha: number\n): boolean => {\n    const _length = _nBals.length;\n    const _alpha = alpha;\n\n    for (let i = 0; i < _length; i++) {\n        const _nIdeal = _nGLiq * _weights[i];\n\n        if (_nBals[i] > _nIdeal) {\n            const _upperAlpha = 1 + _alpha;\n\n            const _nHalt = _nIdeal * _upperAlpha;\n\n            if (_nBals[i] > _nHalt) {\n                const _oHalt = _oGLiq * _weights[i] * _upperAlpha;\n\n                if (_oBals[i] < _oHalt) {\n                    throw new Error(CurveMathRevert.UpperHalt);\n                }\n                if (_nBals[i] - _nHalt > _oBals[i] - _oHalt) {\n                    throw new Error(CurveMathRevert.UpperHalt);\n                }\n            }\n        } else {\n            const _lowerAlpha = 1 - _alpha;\n\n            const _nHalt = _nIdeal * _lowerAlpha;\n\n            if (_nBals[i] < _nHalt) {\n                let _oHalt = _oGLiq * _weights[i];\n                _oHalt = _oHalt * _lowerAlpha;\n\n                if (_oBals[i] > _oHalt) {\n                    throw new Error(CurveMathRevert.LowerHalt);\n                }\n                if (_nHalt - _nBals[i] > _oHalt - _oBals[i]) {\n                    throw new Error(CurveMathRevert.LowerHalt);\n                }\n            }\n        }\n    }\n    return true;\n};\n\nconst enforceSwapInvariant = (\n    _oGLiq: number,\n    _omega: number,\n    _nGLiq: number,\n    _psi: number\n): boolean => {\n    const _nextUtil = _nGLiq - _psi;\n\n    const _prevUtil = _oGLiq - _omega;\n\n    const _diff = _nextUtil - _prevUtil;\n\n    // from int128 private constant MAX_DIFF = -0x10C6F7A0B5EE converted to plain decimals\n    if (0 < _diff || _diff >= CURVEMATH_MAX_DIFF) {\n        return true;\n    } else {\n        throw new Error(CurveMathRevert.SwapInvariantViolation);\n    }\n};\n\n// Exported functions\n\n// origin swap\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const targetAmountInNumeraire = parsedFxPoolData.givenAmountInNumeraire;\n\n    if (poolPairData.tokenIn === poolPairData.tokenOut) {\n        return viewRawAmount(\n            targetAmountInNumeraire,\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const _amt = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 1 : 0, // if USDC return base token (index 1), else return 0 for USDC out\n        parsedFxPoolData\n    );\n\n    if (_amt === undefined) {\n        throw new Error(CurveMathRevert.CannotSwap);\n    } else {\n        const epsilon = parsedFxPoolData.epsilon;\n        const _amtWithFee = _amt[0] * (1 - epsilon); // fee retained by the pool\n\n        return viewRawAmount(\n            Math.abs(_amtWithFee),\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        );\n    }\n}\n\n// target swap\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber {\n    // const amountIn = scale(amount, poolPairData.decimalsOut);\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, false);\n    const targetAmountInNumeraire = -parsedFxPoolData.givenAmountInNumeraire;\n\n    if (poolPairData.tokenIn === poolPairData.tokenOut) {\n        viewRawAmount(\n            // poolPairData.tokenOut as TokenSymbol,\n            targetAmountInNumeraire,\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const _amt = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire,\n        isUSDC(poolPairData.tokenIn) ? 0 : 1, // if USDC return 0 else return 1 for base token\n        parsedFxPoolData\n    );\n\n    if (_amt === undefined) {\n        throw new Error(CurveMathRevert.CannotSwap);\n    } else {\n        const epsilon = Number(formatFixed(poolPairData.epsilon, 18));\n\n        const _amtWithFee = _amt[0] * (1 + epsilon); // fee retained by the pool\n\n        return viewRawAmount(\n            Math.abs(_amtWithFee),\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n}\n\nexport const spotPriceBeforeSwap = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    // input amount 1 XSGD to get the output in USDC\n    const inputAmountInNumeraire = 1;\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const outputAmountInNumeraire = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        1, // input amount\n        0, // always output in USDC\n        parsedFxPoolData\n    );\n\n    return bnum(\n        ((Math.abs(outputAmountInNumeraire[0]) *\n            (1 - parsedFxPoolData.epsilon)) /\n            Math.abs(inputAmountInNumeraire)) *\n            parsedFxPoolData.baseTokenRate\n    );\n};\n\n// spot price after origin swap\nexport const _spotPriceAfterSwapExactTokenInForTokenOut = (\n    poolPairData: FxPoolPairData,\n    amount: OldBigNumber\n): OldBigNumber => {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const targetAmountInNumeraire = parsedFxPoolData.givenAmountInNumeraire;\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nBals = parsedFxPoolData._nBals;\n    const currentRate = parsedFxPoolData.baseTokenRate;\n    const beta = parsedFxPoolData.beta;\n    const epsilon = parsedFxPoolData.epsilon;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n\n    const outputAfterTrade = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 1 : 0, // if USDC return base token (index 1), else return 0 for USDC out\n        parsedFxPoolData\n    );\n\n    const outputAmount = outputAfterTrade[0];\n\n    const maxBetaLimit: number = (1 + beta) * 0.5 * _oGLiq;\n\n    const minBetaLimit: number = (1 - beta) * 0.5 * _oGLiq;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        // token[0] to token [1] in originswap\n        const oBals0after = _nBals[0];\n\n        const oBals1after = _nBals[1];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            // returns 0 because  Math.abs(targetAmountInNumeraire)) * currentRate\n            // used that function with a 0 amount to get a market spot price for the pool\n            // which is used in front end display.\n\n            return amount.isZero()\n                ? spotPriceBeforeSwap(amount, poolPairData)\n                : bnum(\n                      (Math.abs(outputAmount * (1 - epsilon)) /\n                          Math.abs(targetAmountInNumeraire)) *\n                          currentRate\n                  );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    } else {\n        // if usdc is tokenOut\n        //  token[1] to token [0] in originswap\n        const oBals0after = _nBals[1];\n\n        const oBals1after = _nBals[0];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            if (amount.isZero())\n                return spotPriceBeforeSwap(amount, poolPairData);\n\n            const ratioOfOutputAndInput =\n                Math.abs(outputAmount * (1 - epsilon)) /\n                Math.abs(targetAmountInNumeraire);\n\n            return bnum(ratioOfOutputAndInput * currentRate);\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    }\n};\n\n// spot price after target swap\n// the less the normalized liquidity\n// we must have a absolute of the derivative price\nexport const _spotPriceAfterSwapTokenInForExactTokenOut = (\n    poolPairData: FxPoolPairData,\n    amount: OldBigNumber\n): OldBigNumber => {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, false);\n\n    const targetAmountInNumeraire = -parsedFxPoolData.givenAmountInNumeraire;\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nBals = parsedFxPoolData._nBals;\n    const currentRate = parsedFxPoolData.baseTokenRate;\n\n    const beta = parsedFxPoolData.beta;\n    const epsilon = parsedFxPoolData.epsilon;\n\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n\n    const outputAfterTrade = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 0 : 1, // if USDC return 0 else return 1 for base token\n        parsedFxPoolData\n    );\n\n    const outputAmount = outputAfterTrade[0];\n\n    const maxBetaLimit: number = (1 + beta) * 0.5 * _oGLiq;\n\n    const minBetaLimit: number = (1 - beta) * 0.5 * _oGLiq;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        // token[0] to token [1] in originswap\n        const oBals0after = _nBals[0];\n        const oBals1after = _nBals[1];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            return bnum(\n                (Math.abs(targetAmountInNumeraire) /\n                    Math.abs(outputAmount * (1 + epsilon))) *\n                    currentRate\n            );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    } else {\n        //  token[1] to token [0] in originswap\n        const oBals0after = _nBals[0];\n        const oBals1after = _nBals[1];\n\n        const isBeyondMinBeta = oBals0after < minBetaLimit;\n        const isBeyondMaxBeta = oBals1after > maxBetaLimit;\n\n        if (isBeyondMinBeta && isBeyondMaxBeta) {\n            return bnum(\n                (Math.abs(targetAmountInNumeraire) /\n                    Math.abs(outputAmount * (1 + epsilon))) *\n                    currentRate\n            );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    }\n};\n\n// origin swap\nexport const _derivativeSpotPriceAfterSwapExactTokenInForTokenOut = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    const x = spotPriceBeforeSwap(bnum('1'), poolPairData);\n    const y = _spotPriceAfterSwapExactTokenInForTokenOut(poolPairData, amount);\n    const yMinusX = y.minus(x);\n    const ans = yMinusX.div(x);\n    return ans.isZero() ? bnum(ALMOST_ZERO) : ans.abs();\n};\n\n// target swap\nexport const _derivativeSpotPriceAfterSwapTokenInForExactTokenOut = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    const x = spotPriceBeforeSwap(bnum('1'), poolPairData);\n    const y = _spotPriceAfterSwapTokenInForExactTokenOut(poolPairData, amount);\n    const yMinusX = y.minus(x);\n    const ans = yMinusX.div(x);\n    return ans.abs();\n};\n","import { getAddress } from '@ethersproject/address';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { BigNumber as OldBigNumber, ZERO, bnum } from '../../utils/bignumber';\nimport { isSameAddress } from '../../utils';\nimport { universalNormalizedLiquidity } from '../liquidity';\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n    SwapTypes,\n} from '../../types';\nimport {\n    poolBalancesToNumeraire,\n    viewRawAmount,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n    _exactTokenInForTokenOut,\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _tokenInForExactTokenOut,\n} from './fxPoolMath';\n\ntype FxPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'token'\n>;\n\nexport type FxPoolPairData = PoolPairBase & {\n    alpha: BigNumber;\n    beta: BigNumber;\n    lambda: BigNumber;\n    delta: BigNumber;\n    epsilon: BigNumber;\n    tokenInLatestFXPrice: OldBigNumber;\n    tokenOutLatestFXPrice: OldBigNumber;\n};\n\nexport class FxPool implements PoolBase<FxPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Fx;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: FxPoolToken[];\n    tokensList: string[];\n    alpha: BigNumber;\n    beta: BigNumber;\n    lambda: BigNumber;\n    delta: BigNumber;\n    epsilon: BigNumber;\n\n    static fromPool(pool: SubgraphPoolBase): FxPool {\n        if (\n            !pool.alpha ||\n            !pool.beta ||\n            !pool.lambda ||\n            !pool.delta ||\n            !pool.epsilon\n        )\n            throw new Error('FX Pool Missing Subgraph Field');\n        return new FxPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList,\n            pool.alpha,\n            pool.beta,\n            pool.lambda,\n            pool.delta,\n            pool.epsilon\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: FxPoolToken[],\n        tokensList: string[],\n        alpha: string,\n        beta: string,\n        lambda: string,\n        delta: string,\n        epsilon: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.alpha = parseFixed(alpha, 18);\n        this.beta = parseFixed(beta, 18);\n        this.lambda = parseFixed(lambda, 18);\n        this.delta = parseFixed(delta, 18);\n        this.epsilon = parseFixed(epsilon, 18);\n    }\n    updateTotalShares: (newTotalShares: BigNumber) => void;\n    mainIndex?: number | undefined;\n    isLBP?: boolean | undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Will copy over other implementations, not supporting BPT tokens atm\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Will copy over other implementations, not supporting BPT tokens atm\n        return Zero;\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): FxPoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        if (!tO.token?.latestFXPrice || !tI.token?.latestFXPrice)\n            throw 'FX Pool Missing LatestFxPrice';\n\n        const poolPairData: FxPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            alpha: this.alpha,\n            beta: this.beta,\n            lambda: this.lambda,\n            delta: this.delta,\n            epsilon: this.epsilon,\n            tokenInLatestFXPrice: bnum(tI.token.latestFXPrice), // decimals is formatted from subgraph in rate we get from the chainlink oracle\n            tokenOutLatestFXPrice: bnum(tO.token.latestFXPrice), // decimals is formatted from subgraph in rate we get from the chainlink oracle\n        };\n\n        return poolPairData;\n    }\n\n    // Normalized liquidity is an abstract term that can be thought of the\n    // inverse of the slippage. It is proportional to the token balances in the\n    // pool but also depends on the shape of the invariant curve.\n    // As a standard, we define normalized liquidity in tokenOut\n    getNormalizedLiquidity(poolPairData: FxPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    /*\n    Fx pool logic has an alpha region where it halts swaps.\n    maxLimit  = [(1 + alpha) * oGLiq * 0.5] - token value in numeraire\n    */\n    getLimitAmountSwap(\n        poolPairData: FxPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        try {\n            const parsedReserves = poolBalancesToNumeraire(poolPairData);\n\n            const alphaValue = Number(formatFixed(poolPairData.alpha, 18));\n\n            const maxLimit = (1 + alphaValue) * parsedReserves._oGLiq * 0.5;\n\n            if (swapType === SwapTypes.SwapExactIn) {\n                const maxLimitAmount =\n                    maxLimit - parsedReserves.tokenInReservesInNumeraire;\n\n                return bnum(\n                    viewRawAmount(\n                        maxLimitAmount,\n                        poolPairData.tokenInLatestFXPrice.toNumber()\n                    ).toString()\n                );\n            } else {\n                const maxLimitAmount =\n                    maxLimit - parsedReserves.tokenOutReservesInNumeraire;\n\n                return bnum(\n                    viewRawAmount(\n                        maxLimitAmount,\n                        poolPairData.tokenOutLatestFXPrice.toNumber()\n                    ).toString()\n                );\n            }\n        } catch {\n            return ZERO;\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (this.address == token) {\n            this.totalShares = newBalance;\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _exactTokenInForTokenOut(amount, poolPairData);\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _tokenInForExactTokenOut(amount, poolPairData);\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _spotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                amount\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _spotPriceAfterSwapTokenInForExactTokenOut(\n                poolPairData,\n                amount\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n}\n","import { WeightedPool } from './weightedPool/weightedPool';\nimport { StablePool } from './stablePool/stablePool';\nimport { MetaStablePool } from './metaStablePool/metaStablePool';\nimport { LinearPool } from './linearPool/linearPool';\nimport { ElementPool } from './elementPool/elementPool';\nimport { PhantomStablePool } from './phantomStablePool/phantomStablePool';\nimport { ComposableStablePool } from './composableStable/composableStablePool';\nimport { Gyro2Pool } from './gyro2Pool/gyro2Pool';\nimport { Gyro3Pool } from './gyro3Pool/gyro3Pool';\nimport { GyroEPool } from './gyroEPool/gyroEPool';\nimport { GyroEV2Pool } from './gyroEV2Pool/gyroEV2Pool';\nimport { FxPool } from './xaveFxPool/fxPool';\nimport {\n    BigNumber as OldBigNumber,\n    INFINITY,\n    scale,\n    ZERO,\n} from '../utils/bignumber';\nimport {\n    SubgraphPoolBase,\n    PoolBase,\n    SwapTypes,\n    PoolPairBase,\n    PoolTypes,\n    PoolFilter,\n} from '../types';\n\nexport function parseNewPool(\n    pool: SubgraphPoolBase,\n    currentBlockTimestamp = 0\n):\n    | WeightedPool\n    | StablePool\n    | ElementPool\n    | LinearPool\n    | MetaStablePool\n    | PhantomStablePool\n    | ComposableStablePool\n    | Gyro2Pool\n    | Gyro3Pool\n    | GyroEPool\n    | GyroEV2Pool\n    | FxPool\n    | undefined {\n    // We're not interested in any pools which don't allow swapping\n    if (!pool.swapEnabled) return undefined;\n\n    let newPool:\n        | WeightedPool\n        | StablePool\n        | ElementPool\n        | LinearPool\n        | MetaStablePool\n        | PhantomStablePool\n        | ComposableStablePool\n        | Gyro2Pool\n        | Gyro3Pool\n        | GyroEPool\n        | GyroEV2Pool\n        | FxPool;\n\n    try {\n        const isLinear = pool.poolType.toString().includes('Linear');\n        if (!isLinear && !(pool.poolType in PoolFilter)) {\n            console.error(`Unsupported pool type: ${pool.poolType} ${pool.id}`);\n            return undefined;\n        }\n        if (pool.poolType === 'Weighted' || pool.poolType === 'Investment') {\n            newPool = WeightedPool.fromPool(pool, false);\n        } else if (pool.poolType === 'LiquidityBootstrapping') {\n            newPool = WeightedPool.fromPool(pool, true);\n        } else if (pool.poolType === 'Stable') {\n            newPool = StablePool.fromPool(pool);\n        } else if (pool.poolType === 'MetaStable') {\n            newPool = MetaStablePool.fromPool(pool);\n        } else if (pool.poolType === 'Element') {\n            newPool = ElementPool.fromPool(pool);\n            newPool.setCurrentBlockTimestamp(currentBlockTimestamp);\n        } else if (isLinear) newPool = LinearPool.fromPool(pool);\n        else if (pool.poolType === 'StablePhantom')\n            newPool = PhantomStablePool.fromPool(pool);\n        else if (pool.poolType === 'ComposableStable')\n            newPool = ComposableStablePool.fromPool(pool);\n        else if (pool.poolType === 'Gyro2') newPool = Gyro2Pool.fromPool(pool);\n        else if (pool.poolType === 'Gyro3') newPool = Gyro3Pool.fromPool(pool);\n        else if (pool.poolType === 'GyroE') {\n            if (pool.poolTypeVersion === 2) {\n                newPool = GyroEV2Pool.fromPool(pool);\n            } else {\n                newPool = GyroEPool.fromPool(pool);\n            }\n        } else if (pool.poolType === 'FX') newPool = FxPool.fromPool(pool);\n        else {\n            console.error(\n                `Unknown pool type or type field missing: ${pool.poolType} ${pool.id}`\n            );\n            return undefined;\n        }\n    } catch (err) {\n        console.error(`parseNewPool: ${err.message}`);\n        return undefined;\n    }\n    return newPool;\n}\n\n// TODO: Add cases for pairType = [BTP->token, token->BTP] and poolType = [weighted, stable]\nexport function getOutputAmountSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    // TODO: check if necessary to check if amount > limitAmount\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (\n            poolPairData.poolType !== PoolTypes.Linear &&\n            poolPairData.balanceIn.isZero()\n        ) {\n            return ZERO;\n        } else {\n            return pool._exactTokenInForTokenOut(poolPairData, amount);\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        } else if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        ) {\n            return INFINITY;\n        } else {\n            return pool._tokenInForExactTokenOut(poolPairData, amount);\n        }\n    }\n    throw Error('Unsupported swap');\n}\n","import { BigNumber as OldBigNumber } from './utils/bignumber';\n\n// priceErrorTolerance is how close we expect prices after swap to be in SOR\n// suggested paths\nlet priceErrorTolerance = '0.00001';\ntry {\n    priceErrorTolerance = process.env.PRICE_ERROR_TOLERANCE || '0.00001';\n} catch (err) {\n    if (console) {\n        console.log(err);\n    }\n}\n\nexport const PRICE_ERROR_TOLERANCE: OldBigNumber = new OldBigNumber(\n    priceErrorTolerance\n);\n// infinitesimal is an amount that's used to initialize swap amounts so they are\n// not zero or the path's limit.\n// It's also used in the calculation of derivatives in pool maths\n// const infinitesimal: string = process.env.INFINITESIMAL || '0.000001';\nconst infinitesimal = '0.01'; // Increasing INFINITESIMAL to '0.01' to test derivative sensitivity\nexport const INFINITESIMAL = new OldBigNumber(infinitesimal);\n","import {\n    BigNumber as OldBigNumber,\n    ZERO,\n    INFINITY,\n    scale,\n    bnum,\n} from '../utils/bignumber';\nimport { getOutputAmountSwap } from '../pools';\nimport { INFINITESIMAL } from '../config';\nimport {\n    NewPath,\n    SwapTypes,\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n} from '../types';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\n\nconst MINIMUM_VALUE = bnum('0.000000000000000001');\n\nexport function getHighestLimitAmountsForPaths(\n    paths: NewPath[],\n    maxPools: number\n): BigNumber[] {\n    if (paths.length === 0) return [];\n    const limitAmounts: BigNumber[] = [];\n    for (let i = 0; i < maxPools; i++) {\n        if (i < paths.length) {\n            const limitAmount = paths[i].limitAmount;\n            limitAmounts.push(limitAmount);\n        }\n    }\n    return limitAmounts;\n}\n\nexport function getEffectivePriceSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber,\n    inputDecimals: number,\n    outputDecimals: number,\n    costReturnToken: BigNumber\n): OldBigNumber {\n    if (amount.lt(INFINITESIMAL)) {\n        // Return spot price as code below would be 0/0 = undefined\n        // or small_amount/0 or 0/small_amount which would cause bugs\n        return getSpotPriceAfterSwapForPath(path, swapType, amount);\n    }\n\n    let outputAmountSwap = getOutputAmountSwapForPath(\n        path,\n        swapType,\n        amount,\n        inputDecimals\n    );\n    const gasCost = bnum(formatFixed(costReturnToken, outputDecimals)).times(\n        path.pools.length\n    );\n    if (swapType === SwapTypes.SwapExactIn) {\n        outputAmountSwap = outputAmountSwap.minus(gasCost);\n        return amount.div(outputAmountSwap); // amountIn/AmountOut\n    } else {\n        amount = amount.plus(gasCost);\n        return outputAmountSwap.div(amount); // amountIn/AmountOut\n    }\n}\n\nexport function getOutputAmountSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber,\n    inputDecimals: number\n): OldBigNumber {\n    // First of all check if the amount is above limit, if so, return 0 for\n    // 'swapExactIn' or Inf for swapExactOut\n    if (amount.gt(bnum(formatFixed(path.limitAmount, inputDecimals)))) {\n        if (swapType === SwapTypes.SwapExactIn) {\n            return ZERO;\n        } else {\n            return INFINITY;\n        }\n    }\n\n    const amounts = getAmounts(path, swapType, amount);\n    if (swapType === SwapTypes.SwapExactIn) {\n        return amounts[amounts.length - 1];\n    } else {\n        return amounts[0];\n    }\n}\n\nfunction getAmounts(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber[] {\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [amount];\n\n    if (swapType === SwapTypes.SwapExactIn) {\n        for (let i = 0; i < pools.length; i++) {\n            ans.push(\n                getOutputAmountSwap(\n                    pools[i],\n                    poolPairData[i],\n                    swapType,\n                    ans[ans.length - 1]\n                )\n            );\n        }\n    } else {\n        const n = pools.length;\n        for (let i = 0; i < pools.length; i++) {\n            ans.unshift(\n                getOutputAmountSwap(\n                    pools[n - 1 - i],\n                    poolPairData[n - 1 - i],\n                    swapType,\n                    ans[0]\n                )\n            );\n        }\n    }\n    return ans;\n}\n\nfunction getProdsSpotPrices(\n    path: NewPath,\n    swapType: SwapTypes,\n    amounts: OldBigNumber[]\n): OldBigNumber[] {\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [bnum(1)];\n    const n = pools.length;\n    let oneIfExactOut = 0;\n    if (swapType === SwapTypes.SwapExactOut) oneIfExactOut = 1;\n    for (let i = 0; i < pools.length; i++) {\n        ans.unshift(\n            getSpotPriceAfterSwap(\n                pools[n - 1 - i],\n                poolPairData[n - 1 - i],\n                swapType,\n                amounts[n - 1 - i + oneIfExactOut]\n            ).times(ans[0])\n        );\n    }\n    return ans;\n}\n\nfunction getProdsFirstSpotPrices(\n    path: NewPath,\n    swapType: SwapTypes,\n    amounts: OldBigNumber[]\n): OldBigNumber[] {\n    if (swapType !== SwapTypes.SwapExactOut)\n        // Throw error?\n        return [bnum(0)];\n\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [bnum(1)];\n    for (let i = 0; i < pools.length; i++) {\n        ans.push(\n            getSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i + 1]\n            ).times(ans[ans.length - 1])\n        );\n    }\n    return ans;\n}\n\nexport function getSpotPriceAfterSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    const amounts = getAmounts(path, swapType, amount);\n    const prodsSpotPrices = getProdsSpotPrices(path, swapType, amounts);\n    return prodsSpotPrices[0];\n}\n\n// TODO: Add cases for pairType = [BTP->token, token->BTP] and poolType = [weighted, stable]\nexport function getSpotPriceAfterSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    // TODO: check if necessary to check if amount > limitAmount\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (poolPairData.balanceIn.isZero()) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        return pool._spotPriceAfterSwapExactTokenInForTokenOut(\n            poolPairData,\n            amount\n        );\n    } else {\n        return pool._spotPriceAfterSwapTokenInForExactTokenOut(\n            poolPairData,\n            amount\n        );\n    }\n    throw Error('Unsupported swap');\n}\n\nexport function getDerivativeSpotPriceAfterSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    const poolPairData = path.poolPairData;\n    const pools = path.pools;\n    const n = pools.length;\n\n    const amounts = getAmounts(path, swapType, amount);\n    const prodsSpotPrices = getProdsSpotPrices(path, swapType, amounts);\n    let ans = bnum(0);\n    if (swapType === SwapTypes.SwapExactIn) {\n        for (let i = 0; i < n; i++) {\n            const newTerm = getDerivativeSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i]\n            ).times(prodsSpotPrices[i + 1]);\n            ans = ans.plus(newTerm);\n        }\n    } else {\n        const prodsFirstSpotPrices = getProdsFirstSpotPrices(\n            path,\n            swapType,\n            amounts\n        );\n        for (let i = 0; i < n; i++) {\n            let newTerm = getDerivativeSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i + 1]\n            ).times(prodsSpotPrices[i + 1]);\n            newTerm = newTerm\n                .times(prodsSpotPrices[i + 1])\n                .times(prodsFirstSpotPrices[i]);\n            // The following option is more efficient but returns less precision due to the division\n            /*          let thisSpotPrice = getSpotPriceAfterSwap(pools[i], poolPairData[i], swapType, amounts[i + 1]);\n            newTerm = newTerm.div(thisSpotPrice).times(prodsSpotPrices[0]);*/\n            ans = ans.plus(newTerm);\n        }\n    }\n    if (ans.eq(bnum(0))) ans = MINIMUM_VALUE;\n    return ans;\n}\n\n// TODO: Add cases for pairType = [BPT->token, token->BPT] and poolType = [weighted, stable]\nexport function getDerivativeSpotPriceAfterSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    // TODO: check if necessary to check if amount > limitAmount\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (poolPairData.balanceIn.isZero()) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        return pool._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            poolPairData,\n            amount\n        );\n    } else {\n        return pool._derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            poolPairData,\n            amount\n        );\n    }\n    throw Error('Unsupported swap');\n}\n\n// We need do pass 'pools' here because this function has to update the pools state\n// in case a pool is used twice in two different paths\nexport function EVMgetOutputAmountSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    //we recalculate the pool pair data since balance updates are not reflected immediately in cached poolPairData\n    poolPairData = pool.parsePoolPairData(\n        poolPairData.tokenIn,\n        poolPairData.tokenOut\n    );\n\n    const { balanceIn, balanceOut, tokenIn, tokenOut } = poolPairData;\n\n    let returnAmount: OldBigNumber;\n\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (\n            poolPairData.poolType !== PoolTypes.Linear &&\n            poolPairData.balanceIn.isZero()\n        ) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (pool.poolType === PoolTypes.Element) {\n            // TODO this will just be part of below once maths available\n            returnAmount = getOutputAmountSwap(\n                pool,\n                poolPairData,\n                swapType,\n                amount\n            );\n        } else if (pool.poolType in PoolTypes) {\n            // Will accept/return normalised values\n            returnAmount = pool._exactTokenInForTokenOut(poolPairData, amount);\n        } else {\n            throw Error('Unsupported swap');\n        }\n    } else {\n        if (pool.poolType === PoolTypes.Element) {\n            // TODO this will just be part of below once maths available\n            returnAmount = getOutputAmountSwap(\n                pool,\n                poolPairData,\n                swapType,\n                amount\n            );\n        } else if (pool.poolType in PoolTypes) {\n            // Will accept/return normalised values\n            returnAmount = pool._tokenInForExactTokenOut(poolPairData, amount);\n        } else {\n            throw Error('Unsupported swap');\n        }\n    }\n\n    const amountIn = swapType === SwapTypes.SwapExactIn ? amount : returnAmount;\n    const amountOut =\n        swapType === SwapTypes.SwapExactIn ? returnAmount : amount;\n\n    // Update balances of tokenIn and tokenOut\n    pool.updateTokenBalanceForPool(\n        tokenIn,\n        balanceIn.add(\n            parseFixed(\n                amountIn.dp(poolPairData.decimalsIn).toString(),\n                poolPairData.decimalsIn\n            )\n        )\n    );\n    pool.updateTokenBalanceForPool(\n        tokenOut,\n        balanceOut.sub(\n            parseFixed(\n                amountOut.dp(poolPairData.decimalsOut).toString(),\n                poolPairData.decimalsOut\n            )\n        )\n    );\n\n    return returnAmount;\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport { PRICE_ERROR_TOLERANCE } from '../config';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n    INFINITY,\n} from '../utils/bignumber';\nimport { SwapTypes, NewPath, Swap } from '../types';\nimport {\n    getEffectivePriceSwapForPath,\n    getSpotPriceAfterSwapForPath,\n    getDerivativeSpotPriceAfterSwapForPath,\n    getOutputAmountSwapForPath,\n    EVMgetOutputAmountSwap,\n} from './helpersClass';\nimport { BigNumber, formatFixed } from '@ethersproject/bignumber';\n\nexport const optimizeSwapAmounts = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    initialSwapAmounts: BigNumber[],\n    highestLimitAmounts: BigNumber[],\n    inputDecimals: number,\n    outputDecimals: number,\n    initialNumPaths: number,\n    maxPools: number,\n    costReturnToken: BigNumber\n): [NewPath[], OldBigNumber[], OldBigNumber] => {\n    // First get the optimal totalReturn to trade 'totalSwapAmount' with\n    // one path only (b=1). Then increase the number of pools as long as\n    // improvementCondition is true (see more information below)\n    let bestTotalReturnConsideringFees =\n        swapType === SwapTypes.SwapExactIn ? INFINITY.times(-1) : INFINITY;\n    let bestSwapAmounts: OldBigNumber[] = [];\n    let bestPaths: NewPath[] = [];\n    let swapAmounts = initialSwapAmounts.map((amount) =>\n        bnum(formatFixed(amount, inputDecimals))\n    );\n    for (let b = initialNumPaths; b <= paths.length; b++) {\n        if (b != initialNumPaths) {\n            // We already had a previous iteration and are adding another pool this new iteration\n            // swapAmounts.push(ONE); // Initialize new swapAmount with 1 wei to\n            // make sure that it won't be considered as a non viable amount (which would\n            // be the case if it started at 0)\n\n            // Start new path at 1/b of totalSwapAmount (i.e. if this is the 5th pool, we start with\n            // 20% of the totalSwapAmount for this new swapAmount added). However, we need to make sure\n            // that this value is not higher then the bth limit of the paths available otherwise there\n            // won't be any possible path to process this swapAmount:\n            const humanTotalSwapAmount = formatFixed(\n                totalSwapAmount,\n                inputDecimals\n            );\n            const newSwapAmount = OldBigNumber.min.apply(null, [\n                bnum(humanTotalSwapAmount).times(bnum(1 / b)),\n                formatFixed(highestLimitAmounts[b - 1], inputDecimals),\n            ]);\n            // We need then to multiply all current\n            // swapAmounts by 1-newSwapAmount/totalSwapAmount.\n            swapAmounts.forEach((swapAmount, i) => {\n                swapAmounts[i] = swapAmount.times(\n                    ONE.minus(newSwapAmount.div(humanTotalSwapAmount))\n                );\n            });\n\n            if (!newSwapAmount.isZero()) swapAmounts.push(newSwapAmount);\n        }\n\n        const { paths: selectedPaths, swapAmounts: bestAmounts } =\n            optimizePathDistribution(\n                paths,\n                swapType,\n                totalSwapAmount,\n                swapAmounts,\n                inputDecimals,\n                outputDecimals,\n                costReturnToken\n            );\n        swapAmounts = bestAmounts;\n\n        const totalReturn = calcTotalReturn(\n            selectedPaths,\n            swapType,\n            swapAmounts,\n            inputDecimals\n        );\n\n        // Calculates the number of pools in all the paths to include the gas costs\n        const totalNumberOfPools = selectedPaths.reduce(\n            (acc, path) => acc + path.swaps.length,\n            0\n        );\n\n        // improvementCondition is true if we are improving the totalReturn\n        // Notice that totalReturn has to be maximized for 'swapExactIn'\n        // and MINIMIZED for 'swapExactOut'\n        // This is because for the case of 'swapExactOut', totalReturn means the\n        // amount of tokenIn needed to buy totalSwapAmount of tokenOut\n        const costReturnTokenHuman = formatFixed(\n            costReturnToken,\n            outputDecimals\n        );\n        let improvementCondition = false;\n        let totalReturnConsideringFees = ZERO;\n        const gasFees = bnum(totalNumberOfPools).times(costReturnTokenHuman);\n        if (swapType === SwapTypes.SwapExactIn) {\n            totalReturnConsideringFees = totalReturn.minus(gasFees);\n            improvementCondition = totalReturnConsideringFees.isGreaterThan(\n                bestTotalReturnConsideringFees\n            );\n        } else {\n            totalReturnConsideringFees = totalReturn.plus(gasFees);\n            improvementCondition = totalReturnConsideringFees.isLessThan(\n                bestTotalReturnConsideringFees\n            );\n        }\n\n        // Stop if improvement has stopped\n        if (!improvementCondition) break;\n\n        bestSwapAmounts = [...swapAmounts]; // Copy to avoid linking variables\n        bestPaths = [...selectedPaths];\n        bestTotalReturnConsideringFees = totalReturnConsideringFees;\n\n        // Stop if max number of pools has been reached\n        if (totalNumberOfPools >= maxPools) break;\n    }\n\n    // 0 swap amounts can occur due to rounding errors but we don't want to pass those on so filter out\n    bestPaths = bestPaths.filter((_, i) => !bestSwapAmounts[i].isZero());\n    bestSwapAmounts = bestSwapAmounts.filter(\n        (swapAmount) => !swapAmount.isZero()\n    );\n\n    return [bestPaths, bestSwapAmounts, bestTotalReturnConsideringFees];\n};\n\n/**\n * For a fixed number of possible paths, finds the optimal distribution of swap amounts to maximise output\n */\nconst optimizePathDistribution = (\n    allPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    initialSwapAmounts: OldBigNumber[],\n    inputDecimals: number,\n    outputDecimals,\n    costReturnToken: BigNumber\n): { paths: NewPath[]; swapAmounts: OldBigNumber[] } => {\n    let [selectedPaths, exceedingAmounts] = getBestPathIds(\n        allPaths,\n        swapType,\n        initialSwapAmounts,\n        inputDecimals,\n        outputDecimals,\n        costReturnToken\n    );\n\n    let swapAmounts = initialSwapAmounts;\n\n    // Trivial case of only allowing a single path\n    if (initialSwapAmounts.length === 1) {\n        return {\n            swapAmounts,\n            paths: selectedPaths,\n        };\n    }\n\n    const humanTotalSwapAmount = bnum(\n        formatFixed(totalSwapAmount, inputDecimals)\n    );\n\n    // We store the next set of paths to consider separately so that can always retrieve the previous paths\n    let newSelectedPaths = selectedPaths;\n\n    // We now loop to iterateSwapAmounts until we converge.\n    const historyOfSortedPathIds: string[] = [];\n    let sortedPathIdsJSON = JSON.stringify(\n        newSelectedPaths.map(({ id }) => id).sort()\n    );\n\n    while (!historyOfSortedPathIds.includes(sortedPathIdsJSON)) {\n        // Local minima can result in infinite loops\n        // We then maintain a log of the sorted paths ids which we have already considered to prevent getting stuck\n        historyOfSortedPathIds.push(sortedPathIdsJSON);\n        selectedPaths = newSelectedPaths;\n\n        [swapAmounts, exceedingAmounts] = iterateSwapAmounts(\n            selectedPaths,\n            swapType,\n            humanTotalSwapAmount,\n            swapAmounts,\n            exceedingAmounts\n        );\n        [newSelectedPaths, exceedingAmounts] = getBestPathIds(\n            allPaths,\n            swapType,\n            swapAmounts,\n            inputDecimals,\n            outputDecimals,\n            costReturnToken\n        );\n\n        if (newSelectedPaths.length === 0) break;\n\n        const pathIds = newSelectedPaths.map(({ id }) => id).sort();\n        sortedPathIdsJSON = JSON.stringify(pathIds);\n    }\n\n    return {\n        swapAmounts,\n        paths: selectedPaths,\n    };\n};\n\nexport const formatSwaps = (\n    bestPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    bestSwapAmounts: OldBigNumber[]\n): [Swap[][], OldBigNumber, OldBigNumber] => {\n    //// Prepare swap data from paths\n    const swaps: Swap[][] = [];\n    let highestSwapAmt = bestSwapAmounts[0];\n    let largestSwapPath: NewPath = bestPaths[0];\n    let bestTotalReturn = ZERO; // Reset totalReturn as this time it will be\n    // calculated with the EVM maths so the return is exactly what the user will get\n    // after executing the transaction (given there are no front-runners)\n\n    bestPaths.forEach((path, i) => {\n        const swapAmount = bestSwapAmounts[i];\n\n        if (swapAmount.gt(highestSwapAmt)) {\n            highestSwapAmt = swapAmount;\n            largestSwapPath = path;\n        }\n        // // TODO: remove. To debug only!\n        /*\n        console.log(\n            'Prices should be all very close (unless one of the paths is on the limit!'\n        );\n        console.log(\n            getSpotPriceAfterSwapForPath(path, swapType, swapAmount).toNumber()\n        );\n        */\n        const poolPairData = path.poolPairData;\n        const pathSwaps: Swap[] = [];\n        const amounts: OldBigNumber[] = [];\n        let returnAmount: OldBigNumber;\n        const n = poolPairData.length;\n        amounts.push(swapAmount);\n        if (swapType === SwapTypes.SwapExactIn) {\n            for (let i = 0; i < n; i++) {\n                amounts.push(\n                    EVMgetOutputAmountSwap(\n                        path.pools[i],\n                        poolPairData[i],\n                        SwapTypes.SwapExactIn,\n                        amounts[amounts.length - 1]\n                    )\n                );\n                const swap: Swap = {\n                    pool: path.swaps[i].pool,\n                    tokenIn: path.swaps[i].tokenIn,\n                    tokenOut: path.swaps[i].tokenOut,\n                    swapAmount: amounts[i].toString(),\n                    tokenInDecimals: path.poolPairData[i].decimalsIn,\n                    tokenOutDecimals: path.poolPairData[i].decimalsOut,\n                    returnAmount: amounts[amounts.length - 1].toString(),\n                };\n                pathSwaps.push(swap);\n            }\n            returnAmount = amounts[n];\n        } else {\n            for (let i = 0; i < n; i++) {\n                amounts.unshift(\n                    EVMgetOutputAmountSwap(\n                        path.pools[n - 1 - i],\n                        poolPairData[n - 1 - i],\n                        SwapTypes.SwapExactOut,\n                        amounts[0]\n                    )\n                );\n                const swap: Swap = {\n                    pool: path.swaps[n - 1 - i].pool,\n                    tokenIn: path.swaps[n - 1 - i].tokenIn,\n                    tokenOut: path.swaps[n - 1 - i].tokenOut,\n                    swapAmount: amounts[1].toString(),\n                    tokenInDecimals: path.poolPairData[n - 1 - i].decimalsIn,\n                    tokenOutDecimals: path.poolPairData[n - 1 - i].decimalsOut,\n                    returnAmount: amounts[0].toString(),\n                };\n                pathSwaps.unshift(swap);\n            }\n            returnAmount = amounts[0];\n        }\n        swaps.push(pathSwaps);\n        bestTotalReturn = bestTotalReturn.plus(returnAmount);\n    });\n\n    // Since the individual swapAmounts for each path are integers, the sum of all swapAmounts\n    // might not be exactly equal to the totalSwapAmount the user requested. We need to correct that rounding error\n    // and we do that by adding the rounding error to the first path.\n    if (swaps.length > 0) {\n        const totalSwapAmountWithRoundingErrors = bestSwapAmounts.reduce(\n            (a, b) => a.plus(b),\n            ZERO\n        );\n        const dust = totalSwapAmount.minus(totalSwapAmountWithRoundingErrors);\n        if (swapType === SwapTypes.SwapExactIn) {\n            // As swap is ExactIn, add dust to input pool\n            swaps[0][0].swapAmount = bnum(swaps[0][0].swapAmount as string)\n                .plus(dust)\n                .toString();\n        } else {\n            // As swap is ExactOut, add dust to output pool\n            const firstPathLastPoolIndex = bestPaths[0].swaps.length - 1;\n            swaps[0][firstPathLastPoolIndex].swapAmount = bnum(\n                swaps[0][firstPathLastPoolIndex].swapAmount as string\n            )\n                .plus(dust)\n                .toString();\n        }\n    }\n\n    if (bestTotalReturn.eq(0)) return [[], ZERO, ZERO];\n\n    const marketSp = getSpotPriceAfterSwapForPath(\n        largestSwapPath,\n        swapType,\n        ZERO\n    );\n\n    return [swaps, bestTotalReturn, marketSp];\n};\n\n//  For a given list of swapAmounts, gets list of pools with best effective price for these amounts\n//  Always choose best pool for highest swapAmount first, then 2nd swapAmount and so on. This is\n//  because it's best to use the best effective price for the highest amount to be traded\nfunction getBestPathIds(\n    originalPaths: NewPath[],\n    swapType: SwapTypes,\n    swapAmounts: OldBigNumber[],\n    inputDecimals: number,\n    outputDecimals: number,\n    costReturnToken: BigNumber\n): [NewPath[], OldBigNumber[]] {\n    const selectedPaths: NewPath[] = [];\n    const selectedPathExceedingAmounts: OldBigNumber[] = [];\n    const paths = cloneDeep(originalPaths); // Deep copy to avoid changing the original path data\n\n    // Sort swapAmounts in descending order without changing original: https://stackoverflow.com/a/42442909\n    const sortedSwapAmounts = [...swapAmounts].sort((a, b) => {\n        return b.minus(a).toNumber();\n    });\n\n    sortedSwapAmounts.forEach((swapAmount) => {\n        // Find path that has best effective price\n        let bestPathIndex = -1;\n        let bestEffectivePrice = INFINITY; // Start with worst price possible\n        paths.forEach((path, i) => {\n            // Do not consider this path if its limit is below swapAmount\n            if (\n                bnum(formatFixed(path.limitAmount, inputDecimals)).gte(\n                    swapAmount\n                )\n            ) {\n                // Calculate effective price of this path for this swapAmount\n                // If path.limitAmount = swapAmount we set effectivePrice as\n                // Infinity because we know this path is maxed out and we want\n                // to select other paths that can still be improved on\n                let effectivePrice: OldBigNumber;\n                if (\n                    bnum(formatFixed(path.limitAmount, inputDecimals)).eq(\n                        swapAmount\n                    )\n                ) {\n                    effectivePrice = INFINITY;\n                } else {\n                    // TODO for optimization: pass already calculated limitAmount as input\n                    // to getEffectivePriceSwapForPath()\n                    effectivePrice = getEffectivePriceSwapForPath(\n                        path,\n                        swapType,\n                        swapAmount,\n                        inputDecimals,\n                        outputDecimals,\n                        costReturnToken\n                    );\n                }\n                if (effectivePrice.lte(bestEffectivePrice)) {\n                    bestEffectivePrice = effectivePrice;\n                    bestPathIndex = i;\n                }\n            }\n        });\n\n        if (bestPathIndex === -1) {\n            selectedPaths.push({\n                id: '',\n                swaps: [],\n                poolPairData: [],\n                limitAmount: BigNumber.from('0'),\n                pools: [],\n            });\n            selectedPathExceedingAmounts.push(ZERO);\n            return;\n        } else {\n            selectedPaths.push(paths[bestPathIndex]);\n            selectedPathExceedingAmounts.push(\n                swapAmount.minus(\n                    bnum(\n                        formatFixed(\n                            paths[bestPathIndex].limitAmount,\n                            inputDecimals\n                        )\n                    )\n                )\n            );\n            paths.splice(bestPathIndex, 1); // Remove path from list\n        }\n    });\n\n    return [selectedPaths, selectedPathExceedingAmounts];\n}\n\n// This functions finds the swapAmounts such that all the paths that have viable swapAmounts (i.e.\n// that are not negative or equal to limitAmount) bring their respective prices after swap to the\n// same price (which means that this is the optimal solution for the paths analyzed)\nfunction iterateSwapAmounts(\n    selectedPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[]\n): [OldBigNumber[], OldBigNumber[]] {\n    let priceError = ONE; // Initialize priceError just so that while starts\n    let prices: OldBigNumber[] = [];\n    // // Since this is the beginning of an iteration with a new set of paths, we\n    // // set any swapAmounts that were 0 previously to 1 wei or at the limit\n    // // to limit minus 1 wei just so that they\n    // // are considered as viable for iterateSwapAmountsApproximation(). If they were\n    // // left at 0 iterateSwapAmountsApproximation() would consider them already outside\n    // // the viable range and would not iterate on them. This is useful when\n    // // iterateSwapAmountsApproximation() is being repeatedly called within the while loop\n    // // below, but not when a new execution of iterateSwapAmounts() happens with new\n    // // paths.\n    // for (let i = 0; i < swapAmounts.length; ++i) {\n    //     if (swapAmounts[i].isZero()) {\n    //         // Very small amount: TODO put in config file\n    //         const epsilon = totalSwapAmount.times(INFINITESIMAL);\n    //         swapAmounts[i] = epsilon;\n    //         exceedingAmounts[i] = exceedingAmounts[i].plus(epsilon);\n    //     }\n    //     if (exceedingAmounts[i].isZero()) {\n    //         // Very small amount: TODO put in config file\n    //         const epsilon = totalSwapAmount.times(INFINITESIMAL);\n    //         swapAmounts[i] = swapAmounts[i].minus(epsilon); // Very small amount\n    //         exceedingAmounts[i] = exceedingAmounts[i].minus(epsilon);\n    //     }\n    // }\n    let iterationCount = 0;\n    while (priceError.isGreaterThan(PRICE_ERROR_TOLERANCE)) {\n        [prices, swapAmounts, exceedingAmounts] =\n            iterateSwapAmountsApproximation(\n                selectedPaths,\n                swapType,\n                totalSwapAmount,\n                swapAmounts,\n                exceedingAmounts,\n                iterationCount\n            );\n        const maxPrice = OldBigNumber.max.apply(null, prices);\n        const minPrice = OldBigNumber.min.apply(null, prices);\n        priceError = maxPrice.minus(minPrice).div(minPrice);\n        iterationCount++;\n        if (iterationCount > 100) break;\n    }\n    return [swapAmounts, exceedingAmounts];\n}\n\nfunction iterateSwapAmountsApproximation(\n    selectedPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[], // This is the amount by which swapAmount exceeds the pool limit_amount\n    iterationCount: number\n): [OldBigNumber[], OldBigNumber[], OldBigNumber[]] {\n    let sumInverseDerivativeSPaSs = ZERO;\n    let sumSPaSDividedByDerivativeSPaSs = ZERO;\n    const SPaSs: OldBigNumber[] = [];\n    const derivativeSPaSs: OldBigNumber[] = [];\n\n    // We only iterate on the swapAmounts that are viable (i.e. no negative or > than path limit)\n    // OR if this is the first time \"iterateSwapAmountsApproximation\" is called\n    // within \"iterateSwapAmounts()\". In this case swapAmounts should be considered viable\n    // also if they are on the limit.\n    swapAmounts.forEach((swapAmount, i) => {\n        // if (swapAmount.gt(ZERO) && exceedingAmounts[i].lt(ZERO)) {\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        ) {\n            const path = selectedPaths[i];\n            const SPaS = getSpotPriceAfterSwapForPath(\n                path,\n                swapType,\n                swapAmount\n            );\n            SPaSs.push(SPaS);\n            const derivative_SPaS = getDerivativeSpotPriceAfterSwapForPath(\n                path,\n                swapType,\n                swapAmount\n            );\n            derivativeSPaSs.push(derivative_SPaS);\n            sumInverseDerivativeSPaSs = sumInverseDerivativeSPaSs.plus(\n                ONE.div(derivative_SPaS)\n            );\n            sumSPaSDividedByDerivativeSPaSs =\n                sumSPaSDividedByDerivativeSPaSs.plus(SPaS.div(derivative_SPaS));\n        } else {\n            // This swapAmount is not viable but we push to keep list length consistent\n            derivativeSPaSs.push(bnum('NaN'));\n            SPaSs.push(bnum('NaN'));\n        }\n    });\n    // // This division using BigNumber below lost precision. Its result was for example\n    // 1.042818e-12 while using normal js math operations it was\n    // 1.0428184989387553e-12. This loss of precision caused an important bug\n\n    // let weighted_average_SPaS = sumSPaSDividedByDerivativeSPaSs.div(\n    //     sumInverseDerivativeSPaSs\n    // );\n    const weighted_average_SPaS = bnum(\n        sumSPaSDividedByDerivativeSPaSs.toNumber() /\n            sumInverseDerivativeSPaSs.toNumber()\n    );\n\n    swapAmounts.forEach((swapAmount, i) => {\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        ) {\n            const deltaSwapAmount = weighted_average_SPaS\n                .minus(SPaSs[i])\n                .div(derivativeSPaSs[i]);\n            swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n            exceedingAmounts[i] = exceedingAmounts[i].plus(deltaSwapAmount);\n        }\n    });\n\n    // Make sure no input amount is negative or above the path limit\n    while (\n        OldBigNumber.min.apply(null, swapAmounts).lt(ZERO) ||\n        OldBigNumber.max.apply(null, exceedingAmounts).gt(ZERO)\n    ) {\n        [swapAmounts, exceedingAmounts] = redistributeInputAmounts(\n            swapAmounts,\n            exceedingAmounts,\n            derivativeSPaSs\n        );\n    }\n\n    const pricesForViableAmounts: OldBigNumber[] = []; // Get prices for all non-negative AND below-limit input amounts\n    let swapAmountsSumWithRoundingErrors = ZERO;\n    swapAmounts.forEach((swapAmount, i) => {\n        swapAmountsSumWithRoundingErrors =\n            swapAmountsSumWithRoundingErrors.plus(swapAmount);\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        )\n            pricesForViableAmounts.push(\n                getSpotPriceAfterSwapForPath(\n                    selectedPaths[i],\n                    swapType,\n                    swapAmount\n                )\n            );\n    });\n\n    const roundingError = totalSwapAmount.minus(\n        swapAmountsSumWithRoundingErrors\n    );\n    // console.log(\"Rounding error\")\n    // console.log(roundingError.div(totalSwapAmount).toNumber())\n    // // let errorLimit = totalSwapAmount.times(bnum(0.001))\n    // // if(roundingError>errorLimit)\n    // //     throw \"Rounding error in iterateSwapAmountsApproximation() too large\";\n\n    // Add rounding error to make sum be exactly equal to totalSwapAmount to avoid error compounding\n    // Add to the first swapAmount that is already not zero or at the limit\n    // AND only if swapAmount would not leave the viable range (i.e. swapAmoung\n    // would still be >0 and <limit) after adding the error\n    // I.d. we need: (swapAmount+error)>0 AND (exceedingAmount+error)<0\n    for (let i = 0; i < swapAmounts.length; ++i) {\n        if (swapAmounts[i].gt(ZERO) && exceedingAmounts[i].lt(ZERO)) {\n            if (\n                swapAmounts[i].plus(roundingError).gt(ZERO) &&\n                exceedingAmounts[i].plus(roundingError).lt(ZERO)\n            ) {\n                swapAmounts[i] = swapAmounts[i].plus(roundingError);\n                exceedingAmounts[i] = exceedingAmounts[i].plus(roundingError);\n                break;\n            }\n        }\n    }\n\n    return [pricesForViableAmounts, swapAmounts, exceedingAmounts];\n}\n\nfunction redistributeInputAmounts(\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[],\n    derivativeSPaSs: OldBigNumber[]\n): [OldBigNumber[], OldBigNumber[]] {\n    let sumInverseDerivativeSPaSsForViableAmounts = ZERO;\n    let sumInverseDerivativeSPaSsForNegativeAmounts = ZERO;\n    let sumInverseDerivativeSPaSsForExceedingAmounts = ZERO;\n    let sumNegativeOrExceedingSwapAmounts = ZERO;\n    swapAmounts.forEach((swapAmount, i) => {\n        // Amount is negative\n        if (swapAmount.lte(ZERO)) {\n            sumNegativeOrExceedingSwapAmounts =\n                sumNegativeOrExceedingSwapAmounts.plus(swapAmount);\n            sumInverseDerivativeSPaSsForNegativeAmounts =\n                sumInverseDerivativeSPaSsForNegativeAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n        }\n        // Amount is above limit (exceeding > 0)\n        else if (exceedingAmounts[i].gte(ZERO)) {\n            sumNegativeOrExceedingSwapAmounts =\n                sumNegativeOrExceedingSwapAmounts.plus(exceedingAmounts[i]);\n            sumInverseDerivativeSPaSsForExceedingAmounts =\n                sumInverseDerivativeSPaSsForExceedingAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n        }\n        // Sum the inverse of the derivative if the swapAmount is viable,\n        // i.e. if swapAmount > 0 or swapAmount < limit\n        else\n            sumInverseDerivativeSPaSsForViableAmounts =\n                sumInverseDerivativeSPaSsForViableAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n    });\n\n    // Now redestribute sumNegativeOrExceedingSwapAmounts\n    // to non-exceeding pools if sumNegativeOrExceedingSwapAmounts > 0\n    // or to non zero swapAmount pools if sumNegativeOrExceedingSwapAmounts < 0\n    swapAmounts.forEach((swapAmount, i) => {\n        if (swapAmount.lte(ZERO)) {\n            swapAmounts[i] = ZERO;\n            exceedingAmounts[i] = exceedingAmounts[i].minus(swapAmount);\n        } else if (exceedingAmounts[i].gte(ZERO)) {\n            swapAmounts[i] = swapAmounts[i].minus(exceedingAmounts[i]); // This is the same as swapAmounts[i] = pathLimitAmounts[i]\n            exceedingAmounts[i] = ZERO;\n        } else {\n            const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                .times(ONE.div(derivativeSPaSs[i]))\n                .div(sumInverseDerivativeSPaSsForViableAmounts);\n            swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n            exceedingAmounts[i] = exceedingAmounts[i].plus(deltaSwapAmount);\n        }\n    });\n\n    // If there were no viable amounts (i.e all amounts were either negative or above limit)\n    // We run this extra loop to redistribute the excess\n    if (sumInverseDerivativeSPaSsForViableAmounts.isZero()) {\n        if (sumNegativeOrExceedingSwapAmounts.lt(ZERO)) {\n            // This means we need to redistribute to the exceeding amounts that\n            // were now set to the limit\n            swapAmounts.forEach((swapAmount, i) => {\n                if (exceedingAmounts[i].isZero()) {\n                    const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                        .times(ONE.div(derivativeSPaSs[i]))\n                        .div(sumInverseDerivativeSPaSsForExceedingAmounts);\n                    swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n                    exceedingAmounts[i] =\n                        exceedingAmounts[i].plus(deltaSwapAmount);\n                }\n            });\n        } else {\n            // This means we need to redistribute to the negative amounts that\n            // were now set to zero\n            swapAmounts.forEach((swapAmount, i) => {\n                if (swapAmounts[i].isZero()) {\n                    const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                        .times(ONE.div(derivativeSPaSs[i]))\n                        .div(sumInverseDerivativeSPaSsForNegativeAmounts);\n                    swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n                    exceedingAmounts[i] =\n                        exceedingAmounts[i].plus(deltaSwapAmount);\n                }\n            });\n        }\n    }\n    return [swapAmounts, exceedingAmounts];\n}\n\n// TODO: calculate EVM return (use bmath) and update pool balances like current SOR\nexport const calcTotalReturn = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    swapAmounts: OldBigNumber[],\n    inputDecimals: number\n): OldBigNumber => {\n    let totalReturn = new OldBigNumber(0);\n    // changing the contents of pools (parameter passed as reference)\n    paths.forEach((path, i) => {\n        totalReturn = totalReturn.plus(\n            getOutputAmountSwapForPath(\n                path,\n                swapType,\n                swapAmounts[i],\n                inputDecimals\n            )\n        );\n    });\n    return totalReturn;\n};\n","import { BigNumber as OldBigNumber, bnum, ZERO } from '../utils/bignumber';\nimport { getHighestLimitAmountsForPaths } from './helpersClass';\nimport { formatSwaps, optimizeSwapAmounts } from './sorClass';\nimport { NewPath, Swap, SwapTypes } from '../types';\nimport { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\n\nexport const getBestPaths = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    inputDecimals: number,\n    outputDecimals: number,\n    maxPools: number,\n    costReturnToken: BigNumber\n): [Swap[][], OldBigNumber, OldBigNumber, OldBigNumber] => {\n    // No paths available or totalSwapAmount == 0, return empty solution\n    if (paths.length == 0 || totalSwapAmount.isZero()) {\n        return [[], ZERO, ZERO, ZERO];\n    }\n\n    // Before we start the main loop, we first check if there is enough liquidity for this totalSwapAmount\n    const highestLimitAmounts = getHighestLimitAmountsForPaths(paths, maxPools);\n    const sumLimitAmounts = highestLimitAmounts.reduce(\n        (r: BigNumber[], pathLimit: BigNumber) => {\n            r.push(pathLimit.add(r[r.length - 1] || Zero));\n            return r;\n        },\n        []\n    );\n\n    // If the cumulative limit across all paths is lower than totalSwapAmount then no solution is possible\n    if (totalSwapAmount.gt(sumLimitAmounts[sumLimitAmounts.length - 1])) {\n        return [[], ZERO, ZERO, ZERO]; // Not enough liquidity, return empty\n    }\n\n    // We use the highest limits to define the initial number of pools considered and the initial guess for swapAmounts.\n    const initialNumPaths =\n        sumLimitAmounts.findIndex((cumulativeLimit) =>\n            // If below is true, it means we have enough liquidity\n            totalSwapAmount.lte(cumulativeLimit)\n        ) + 1;\n\n    const initialSwapAmounts = highestLimitAmounts.slice(0, initialNumPaths);\n\n    //  Since the sum of the first i highest limits will be less than totalSwapAmount, we remove the difference to the last swapAmount\n    //  so we are sure that the sum of swapAmounts will be equal to totalSwapAmount\n    const difference =\n        sumLimitAmounts[initialNumPaths - 1].sub(totalSwapAmount);\n    initialSwapAmounts[initialSwapAmounts.length - 1] =\n        initialSwapAmounts[initialSwapAmounts.length - 1].sub(difference);\n\n    const [bestPaths, bestSwapAmounts, bestTotalReturnConsideringFees] =\n        optimizeSwapAmounts(\n            paths,\n            swapType,\n            totalSwapAmount,\n            initialSwapAmounts,\n            highestLimitAmounts,\n            inputDecimals,\n            outputDecimals,\n            initialNumPaths,\n            maxPools,\n            costReturnToken\n        );\n\n    const [swaps, bestTotalReturn, marketSp] = formatSwaps(\n        bestPaths,\n        swapType,\n        bnum(formatFixed(totalSwapAmount, inputDecimals)),\n        bestSwapAmounts\n    );\n\n    if (bestTotalReturn.eq(0)) return [[], ZERO, ZERO, ZERO];\n\n    return [swaps, bestTotalReturn, marketSp, bestTotalReturnConsideringFees];\n};\n","import { Zero } from '@ethersproject/constants';\nimport { SwapInfo } from './types';\n\nexport const EMPTY_SWAPINFO: SwapInfo = {\n    tokenAddresses: [],\n    swaps: [],\n    swapAmount: Zero,\n    swapAmountForSwaps: Zero,\n    tokenIn: '',\n    tokenInForSwaps: '',\n    tokenOut: '',\n    tokenOutFromSwaps: '',\n    returnAmount: Zero,\n    returnAmountConsideringFees: Zero,\n    returnAmountFromSwaps: Zero,\n    marketSp: Zero.toString(),\n};\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport { AddressZero, Zero } from '@ethersproject/constants';\nimport { Contract } from '@ethersproject/contracts';\nimport cloneDeep from 'lodash.clonedeep';\nimport { SubgraphPoolBase, SwapInfo, SwapTypes, SwapV2 } from '../../types';\nimport { parseNewPool } from '../../pools';\nimport { BigNumber as OldBigNumber, ZERO, bnum } from '../../utils/bignumber';\nimport vaultAbi from '../../abi/Vault.json';\nimport { EMPTY_SWAPINFO } from '../../constants';\n\nexport const Lido = {\n    Networks: [1, 42],\n    stETH: {\n        1: '0xae7ab96520de3a18e5e111b5eaab095312d7fe84',\n        42: '0x4803bb90d18a1cb7a2187344fe4feb0e07878d05',\n    },\n    wstETH: {\n        1: '0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0',\n        42: '0xa387b91e393cfb9356a460370842bc8dbb2f29af',\n    },\n    WETH: {\n        1: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n        42: '0xdfcea9088c8a88a76ff74892c1457c17dfeef9c1',\n    },\n    DAI: {\n        1: '0x6b175474e89094c44da98b954eedeac495271d0f',\n        42: '0x04df6e4121c27713ed22341e7c7df330f56f289b',\n    },\n    USDC: {\n        1: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n        42: '0xc2569dd7d0fd715b054fbf16e75b001e5c0c1115',\n    },\n    USDT: {\n        1: '0xdac17f958d2ee523a2206206994597c13d831ec7',\n        42: '0xcc08220af469192c53295fdd34cfb8df29aa17ab',\n    },\n    StaticPools: {\n        // DAI/USDC/USDT\n        staBal: {\n            1: '0x06df3b2bbb68adc8b0e302443692037ed9f91b42000000000000000000000063',\n            42: '0x45f78862bd3aa5205e63141fa7f2d35f38eb87c30000000000000000000000fd',\n        },\n        // WETH/DAI (WETH/USDC on Kovan)\n        wethDai: {\n            1: '0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a',\n            42: '0x3a19030ed746bd1c3f2b0f996ff9479af04c5f0a000200000000000000000004',\n        },\n        // WETH/wstETH Lido Pool\n        wstEthWeth: {\n            1: '0x32296969ef14eb0c6d29669c550d4a0449130230000200000000000000000080',\n            42: '0xe08590bde837eb9b2d42aa1196469d6e08fe96ec000200000000000000000101',\n        },\n    },\n};\n\ntype Route = {\n    name: string;\n    tokenInDecimals: number;\n    tokenOutDecimals: number;\n    tokenAddresses: string[];\n    swaps: SwapV2[];\n};\n\ntype RouteMap = {\n    [id: string]: Route;\n};\n\nexport const Routes: { [network: number]: RouteMap } = {\n    1: {},\n    42: {},\n};\n\n// MAINNET STATIC ROUTES FOR LIDO <> Stable\n// DAI/wstETH: DAI > WETH > wstETH\nRoutes[1][`${Lido.DAI[1]}${Lido.wstETH[1]}0`] = {\n    name: 'DAI/wstETH-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/DAI: wstETH > WETH > DAI\nRoutes[1][`${Lido.wstETH[1]}${Lido.DAI[1]}0`] = {\n    name: 'wstETH/DAI-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n    ],\n};\n\n// DAI/wstETH: DAI > WETH > wstETH\nRoutes[1][`${Lido.DAI[1]}${Lido.wstETH[1]}1`] = {\n    name: 'DAI/wstETH-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/DAI: wstETH > WETH > DAI\nRoutes[1][`${Lido.wstETH[1]}${Lido.DAI[1]}1`] = {\n    name: 'wstETH/DAI-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// USDC/wstETH: USDC > DAI > WETH > wstETH\nRoutes[1][`${Lido.USDC[1]}${Lido.wstETH[1]}0`] = {\n    name: 'USDC/wstETH-SwapExactIn',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDC[1], Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[1][`${Lido.USDC[1]}${Lido.wstETH[1]}1`] = {\n    name: 'USDC/wstETH-SwapExactOut',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDC[1], Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/USDC: wstETH > WETH > DAI > USDC\nRoutes[1][`${Lido.wstETH[1]}${Lido.USDC[1]}0`] = {\n    name: 'wstETH/USDC-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1], Lido.USDC[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[1][`${Lido.wstETH[1]}${Lido.USDC[1]}1`] = {\n    name: 'wstETH/USDC-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1], Lido.USDC[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// USDT/wstETH: USDT > DAI > WETH > wstETH\nRoutes[1][`${Lido.USDT[1]}${Lido.wstETH[1]}0`] = {\n    name: 'USDT/wstETH-SwapExactIn',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDT[1], Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[1][`${Lido.USDT[1]}${Lido.wstETH[1]}1`] = {\n    name: 'USDT/wstETH-SwapExactOut',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDT[1], Lido.DAI[1], Lido.WETH[1], Lido.wstETH[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/USDT: wstETH > WETH > DAI > USDT\nRoutes[1][`${Lido.wstETH[1]}${Lido.USDT[1]}0`] = {\n    name: 'wstETH/USDT-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1], Lido.USDT[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[1][`${Lido.wstETH[1]}${Lido.USDT[1]}1`] = {\n    name: 'wstETH/USDT-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[1], Lido.WETH[1], Lido.DAI[1], Lido.USDT[1]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[1],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[1],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[1],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// KOVAN STATIC ROUTES FOR LIDO <> Stable\n// USDC/wstETH: USDC > WETH > wstETH\nRoutes[42][`${Lido.USDC[42]}${Lido.wstETH[42]}0`] = {\n    name: 'USDC/wstETH-SwapExactIn',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDC[42], Lido.WETH[42], Lido.wstETH[42]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/USDC: wstETH > WETH > USDC\nRoutes[42][`${Lido.wstETH[42]}${Lido.USDC[42]}0`] = {\n    name: 'wstETH/USDC-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[42], Lido.WETH[42], Lido.USDC[42]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n    ],\n};\n\n// USDC/wstETH: USDC > WETH > wstETH\nRoutes[42][`${Lido.USDC[42]}${Lido.wstETH[42]}1`] = {\n    name: 'USDC/wstETH-SwapExactOut',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [Lido.USDC[42], Lido.WETH[42], Lido.wstETH[42]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/USDC: wstETH > WETH > USDC\nRoutes[42][`${Lido.wstETH[42]}${Lido.USDC[42]}1`] = {\n    name: 'wstETH/USDC-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [Lido.wstETH[42], Lido.WETH[42], Lido.USDC[42]],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// DAI/wstETH: DAI > USDC > WETH > wstETH\nRoutes[42][`${Lido.DAI[42]}${Lido.wstETH[42]}0`] = {\n    name: 'DAI/wstETH-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.DAI[42],\n        Lido.USDC[42],\n        Lido.WETH[42],\n        Lido.wstETH[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[42][`${Lido.DAI[42]}${Lido.wstETH[42]}1`] = {\n    name: 'DAI/wstETH-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.DAI[42],\n        Lido.USDC[42],\n        Lido.WETH[42],\n        Lido.wstETH[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/DAI: wstETH > WETH > USDC > DAI\nRoutes[42][`${Lido.wstETH[42]}${Lido.DAI[42]}0`] = {\n    name: 'wstETH/DAI-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.wstETH[42],\n        Lido.WETH[42],\n        Lido.USDC[42],\n        Lido.DAI[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[42][`${Lido.wstETH[42]}${Lido.DAI[42]}1`] = {\n    name: 'wstETH/DAI-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.wstETH[42],\n        Lido.WETH[42],\n        Lido.USDC[42],\n        Lido.DAI[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// USDT/wstETH: USDT > USDC > WETH > wstETH\nRoutes[42][`${Lido.USDT[42]}${Lido.wstETH[42]}0`] = {\n    name: 'USDT/wstETH-SwapExactIn',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.USDT[42],\n        Lido.USDC[42],\n        Lido.WETH[42],\n        Lido.wstETH[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[42][`${Lido.USDT[42]}${Lido.wstETH[42]}1`] = {\n    name: 'USDT/wstETH-SwapExactOut',\n    tokenInDecimals: 6,\n    tokenOutDecimals: 18,\n    tokenAddresses: [\n        Lido.USDT[42],\n        Lido.USDC[42],\n        Lido.WETH[42],\n        Lido.wstETH[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// wstETH/USDT: wstETH > WETH > USDC > USDT\nRoutes[42][`${Lido.wstETH[42]}${Lido.USDT[42]}0`] = {\n    name: 'wstETH/USDT-SwapExactIn',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [\n        Lido.wstETH[42],\n        Lido.WETH[42],\n        Lido.USDC[42],\n        Lido.USDT[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '0',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n    ],\n};\n\nRoutes[42][`${Lido.wstETH[42]}${Lido.USDT[42]}1`] = {\n    name: 'wstETH/USDT-SwapExactOut',\n    tokenInDecimals: 18,\n    tokenOutDecimals: 6,\n    tokenAddresses: [\n        Lido.wstETH[42],\n        Lido.WETH[42],\n        Lido.USDC[42],\n        Lido.USDT[42],\n    ],\n    swaps: [\n        {\n            poolId: Lido.StaticPools.staBal[42],\n            amount: '',\n            assetInIndex: 2,\n            assetOutIndex: 3,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wethDai[42],\n            amount: '0',\n            assetInIndex: 1,\n            assetOutIndex: 2,\n            userData: '0x',\n        },\n        {\n            poolId: Lido.StaticPools.wstEthWeth[42],\n            amount: '0',\n            assetInIndex: 0,\n            assetOutIndex: 1,\n            userData: '0x',\n        },\n    ],\n};\n\n// Only want static routes for Lido <> Stable\nexport function isLidoStableSwap(\n    chainId: number,\n    tokenIn: string,\n    tokenOut: string\n): boolean {\n    if (!Lido.Networks.includes(chainId)) return false;\n\n    tokenIn = tokenIn.toLowerCase();\n    tokenOut = tokenOut.toLowerCase();\n\n    if (\n        (tokenIn === Lido.wstETH[chainId] && tokenOut === Lido.DAI[chainId]) ||\n        (tokenIn === Lido.wstETH[chainId] && tokenOut === Lido.USDC[chainId]) ||\n        (tokenIn === Lido.wstETH[chainId] && tokenOut === Lido.USDT[chainId]) ||\n        (tokenIn === Lido.DAI[chainId] && tokenOut === Lido.wstETH[chainId]) ||\n        (tokenIn === Lido.USDC[chainId] && tokenOut === Lido.wstETH[chainId]) ||\n        (tokenIn === Lido.USDT[chainId] && tokenOut === Lido.wstETH[chainId]) ||\n        (tokenIn === Lido.stETH[chainId] && tokenOut === Lido.DAI[chainId]) ||\n        (tokenIn === Lido.stETH[chainId] && tokenOut === Lido.USDC[chainId]) ||\n        (tokenIn === Lido.stETH[chainId] && tokenOut === Lido.USDT[chainId]) ||\n        (tokenIn === Lido.DAI[chainId] && tokenOut === Lido.stETH[chainId]) ||\n        (tokenIn === Lido.USDC[chainId] && tokenOut === Lido.stETH[chainId]) ||\n        (tokenIn === Lido.USDT[chainId] && tokenOut === Lido.stETH[chainId])\n    )\n        return true;\n    else return false;\n}\n\n// Uses Vault queryBatchSwap to get return amount for swap\nasync function queryBatchSwap(\n    swapType: SwapTypes,\n    swaps: SwapV2[],\n    assets: string[],\n    provider: Provider\n): Promise<BigNumber> {\n    const vaultAddr = '0xBA12222222228d8Ba445958a75a0704d566BF2C8';\n    const vaultContract = new Contract(vaultAddr, vaultAbi, provider);\n    const funds = {\n        sender: AddressZero,\n        recipient: AddressZero,\n        fromInternalBalance: false,\n        toInternalBalance: false,\n    };\n\n    try {\n        const deltas: BigNumber[] =\n            await vaultContract.callStatic.queryBatchSwap(\n                swapType,\n                swaps,\n                assets,\n                funds\n            );\n        // negative amounts represent tokens (or ETH) sent by the Vault\n        if (swapType === SwapTypes.SwapExactIn)\n            return deltas[assets.length - 1].mul(-1);\n        else return deltas[0];\n    } catch (err) {\n        console.error(\n            `SOR - Lido Static Route QueryBatchSwap Error. No swaps.`\n        );\n        return Zero;\n    }\n}\n\n/*\nSpot Price for path is product of each pools SP for relevant tokens.\n(See helpersClass getSpotPriceAfterSwapForPath)\n*/\nfunction calculateMarketSp(\n    swapType: SwapTypes,\n    swaps: SwapV2[],\n    assets: string[],\n    pools: SubgraphPoolBase[]\n): OldBigNumber {\n    const spotPrices: OldBigNumber[] = [];\n    for (let i = 0; i < swaps.length; i++) {\n        const swap = swaps[i];\n\n        // Find matching pool from list so we can use balances, etc\n        const pool = pools.filter((p) => p.id === swap.poolId);\n        if (pool.length !== 1) return bnum(0);\n\n        // This will get a specific pool type so we can call parse and spot price functions\n        const newPool = parseNewPool(pool[0]);\n        if (!newPool) return bnum(0);\n\n        // Parses relevant balances, etc\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const poolPairData: any = newPool.parsePoolPairData(\n            assets[swap.assetInIndex],\n            assets[swap.assetOutIndex]\n        );\n\n        // Calculate current spot price\n        let spotPrice: OldBigNumber;\n        if (swapType === SwapTypes.SwapExactIn)\n            spotPrice = newPool._spotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            );\n        // Amount = 0 to just get current SP\n        else\n            spotPrice = newPool._spotPriceAfterSwapTokenInForExactTokenOut(\n                poolPairData,\n                ZERO\n            ); // Amount = 0 to just get current SP\n\n        // console.log(`${swap.poolId} ${spotPrice.toString()}`);\n        spotPrices.push(spotPrice);\n    }\n\n    // SP for Path is product of all\n    return spotPrices.reduce((a, b) => a.times(b));\n}\n\nexport async function getStEthRate(\n    provider: Provider,\n    chainId: number\n): Promise<BigNumber> {\n    // Call stEthPerToken or tokensPerStETH to get the scaling factors in each direction.\n    const wstETHContract = new Contract(\n        Lido.wstETH[chainId],\n        ['function tokensPerStEth() external view returns (uint256)'],\n        provider\n    );\n    const rate = await wstETHContract.tokensPerStEth();\n    return rate;\n}\n\n/*\nUsed when SOR doesn't support paths with more than one hop.\nEnables swapping of stables <> wstETH via WETH/DAI pool which has good liquidity.\n*/\nexport async function getLidoStaticSwaps(\n    pools: SubgraphPoolBase[],\n    chainId: number,\n    tokenIn: string,\n    tokenOut: string,\n    swapType: SwapTypes,\n    swapAmount: BigNumber,\n    provider: Provider\n): Promise<SwapInfo> {\n    // Check for stETH tokens and convert to use wstETH for routing\n    let isWrappingIn,\n        isWrappingOut = false;\n    if (tokenIn === Lido.stETH[chainId]) {\n        tokenIn = Lido.wstETH[chainId];\n        isWrappingIn = true;\n    }\n    if (tokenOut === Lido.stETH[chainId]) {\n        tokenOut = Lido.wstETH[chainId];\n        isWrappingOut = true;\n    }\n\n    const swapInfo: SwapInfo = cloneDeep(EMPTY_SWAPINFO);\n    const staticRoute = Routes[chainId][`${tokenIn}${tokenOut}${swapType}`];\n    if (!staticRoute) return swapInfo;\n\n    swapInfo.tokenAddresses = staticRoute.tokenAddresses;\n    swapInfo.swaps = staticRoute.swaps;\n    swapInfo.swapAmount = swapAmount;\n    // if (swapType === SwapTypes.SwapExactIn)\n    //     swapInfo.swapAmount = scale(swapAmount, staticRoute.tokenInDecimals).dp(\n    //         0\n    //     );\n    // else\n    //     swapInfo.swapAmount = scale(\n    //         swapAmount,\n    //         staticRoute.tokenOutDecimals\n    //     ).dp(0);\n\n    swapInfo.swaps[0].amount = swapInfo.swapAmount.toString();\n    if (isWrappingIn) swapInfo.tokenIn = Lido.stETH[chainId];\n    else swapInfo.tokenIn = tokenIn;\n\n    if (isWrappingOut) swapInfo.tokenOut = Lido.stETH[chainId];\n    else swapInfo.tokenOut = tokenOut;\n\n    // Calculate SP as product of all pool SP in path\n    swapInfo.marketSp = calculateMarketSp(\n        swapType,\n        swapInfo.swaps,\n        swapInfo.tokenAddresses,\n        pools\n    ).toString();\n\n    // Unlike main SOR here we haven't calculated the return amount for swaps so use query call on Vault to get value.\n    swapInfo.returnAmount = await queryBatchSwap(\n        swapType,\n        swapInfo.swaps,\n        swapInfo.tokenAddresses,\n        provider\n    );\n\n    if (swapInfo.returnAmount.isZero()) {\n        return cloneDeep(EMPTY_SWAPINFO);\n    }\n\n    // Considering fees shouldn't matter as there won't be alternative options on V1\n    swapInfo.returnAmountConsideringFees = swapInfo.returnAmount;\n    return swapInfo;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport { Contract } from '@ethersproject/contracts';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\n\n// The unbutton ERC-20 wrapper is a generic wrapper which wraps any rebasing token\n// into a fixed balance version.\n// https://github.com/buttonwood-protocol/button-wrappers/blob/main/contracts/UnbuttonToken.sol#L18\n\nexport const TokensToUnbuttonWrapperMap = {\n    Networks: [1],\n    1: {\n        // underlying => wrapper\n\n        // AMPL => WAMPL\n        '0xd46ba6d942050d489dbd938a2c909a5d5039a161':\n            '0xedb171c18ce90b633db442f2a6f72874093b49ef',\n\n        // aAMPL -> ubAAMPL\n        '0x1e6bb68acec8fefbd87d192be09bb274170a0548':\n            '0xF03387d8d0FF326ab586A58E0ab4121d106147DF',\n    },\n};\n\n// Returns the current wrapper exchange rate,\n// ie) number of wrapper tokens for 1e18 (ONE) underlying token\nexport async function getWrapperRate(\n    provider: Provider,\n    wrapperAddress: string\n): Promise<BigNumber> {\n    const ubWrapper = new Contract(\n        wrapperAddress,\n        [\n            'function underlyingToWrapper(uint256 amount) external view returns (uint256)',\n        ],\n        provider\n    );\n    return ubWrapper.underlyingToWrapper(ONE);\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport { AddressZero, WeiPerEther as ONE } from '@ethersproject/constants';\nimport { Lido, getStEthRate } from './pools/lido';\nimport { SwapTypes, SwapInfo, SorConfig } from './types';\nimport {\n    TokensToUnbuttonWrapperMap,\n    getWrapperRate as getUnbuttonWrapperRate,\n} from './wrappers/unbutton';\nimport { isSameAddress } from './utils';\n\nexport interface WrappedInfo {\n    swapAmountOriginal: BigNumber;\n    swapAmountForSwaps: BigNumber;\n    tokenIn: TokenInfo;\n    tokenOut: TokenInfo;\n}\n\nexport interface TokenInfo {\n    addressOriginal: string;\n    addressForSwaps: string;\n    wrapType: WrapTypes;\n    rate: BigNumber;\n}\n\nexport enum WrapTypes {\n    None,\n    ETH, // ETH -> WETH\n    stETH, // stETH -> wSTETH\n    Unbutton, // [rebasing Token] -> ubToken\n}\n\nexport async function getWrappedInfo(\n    provider: Provider,\n    swapType: SwapTypes,\n    tokenIn: string,\n    tokenOut: string,\n    config: SorConfig,\n    swapAmount: BigNumber\n): Promise<WrappedInfo> {\n    // The Subgraph returns tokens in lower case format so we must match this\n    tokenIn = tokenIn.toLowerCase();\n    tokenOut = tokenOut.toLowerCase();\n\n    let swapAmountForSwaps = swapAmount;\n    let tokenInForSwaps = tokenIn;\n    let tokenInWrapType = WrapTypes.None;\n    let tokenOutForSwaps = tokenOut;\n    let tokenOutWrapType = WrapTypes.None;\n    let tokenInRate = ONE;\n    let tokenOutRate = ONE;\n\n    //--------------------------------------------------------------------------\n    // ETH/WETH\n\n    // Handle ETH wrapping\n    if (tokenIn === AddressZero) {\n        tokenInForSwaps = config.weth.toLowerCase();\n        tokenInWrapType = WrapTypes.ETH;\n    }\n\n    // Handle WETH unwrapping\n    if (tokenOut === AddressZero) {\n        tokenOutForSwaps = config.weth.toLowerCase();\n        tokenOutWrapType = WrapTypes.ETH;\n    }\n\n    //--------------------------------------------------------------------------\n    // stETH/wstETH\n\n    // Handle stETH wrapping\n    if (tokenIn === Lido.stETH[config.chainId]) {\n        tokenInForSwaps = Lido.wstETH[config.chainId];\n        tokenInWrapType = WrapTypes.stETH;\n        const rate = await getStEthRate(provider, config.chainId);\n        tokenInRate = rate;\n        if (swapType === SwapTypes.SwapExactIn)\n            swapAmountForSwaps = swapAmount.mul(rate).div(ONE);\n    }\n\n    // Handle wstETH unwrapping\n    if (tokenOut === Lido.stETH[config.chainId]) {\n        tokenOutForSwaps = Lido.wstETH[config.chainId];\n        tokenOutWrapType = WrapTypes.stETH;\n        const rate = await getStEthRate(provider, config.chainId);\n        tokenOutRate = rate;\n        if (swapType === SwapTypes.SwapExactOut)\n            swapAmountForSwaps = swapAmount.mul(rate).div(ONE);\n    }\n\n    //--------------------------------------------------------------------------\n    // ubTokens\n\n    // Gets a list of all the tokens and their unbutton wrappers\n    const tokensToUBWrapperMap =\n        TokensToUnbuttonWrapperMap[config.chainId] || {};\n\n    // Handle token unbutton wrapping\n    if (tokensToUBWrapperMap[tokenIn]) {\n        tokenInForSwaps = tokensToUBWrapperMap[tokenIn];\n        tokenInWrapType = WrapTypes.Unbutton;\n        tokenInRate = await getUnbuttonWrapperRate(provider, tokenInForSwaps);\n        if (swapType === SwapTypes.SwapExactIn)\n            swapAmountForSwaps = swapAmount.mul(tokenInRate).div(ONE);\n    }\n\n    // Handle unbutton token unwrapping\n    if (tokensToUBWrapperMap[tokenOut]) {\n        tokenOutForSwaps = tokensToUBWrapperMap[tokenOut];\n        tokenOutWrapType = WrapTypes.Unbutton;\n        tokenOutRate = await getUnbuttonWrapperRate(provider, tokenOutForSwaps);\n        if (swapType === SwapTypes.SwapExactOut)\n            swapAmountForSwaps = swapAmount.mul(tokenOutRate).div(ONE);\n    }\n\n    //--------------------------------------------------------------------------\n\n    return {\n        swapAmountOriginal: swapAmount,\n        swapAmountForSwaps: swapAmountForSwaps,\n        tokenIn: {\n            addressOriginal: tokenIn,\n            addressForSwaps: tokenInForSwaps,\n            wrapType: tokenInWrapType,\n            rate: tokenInRate,\n        },\n        tokenOut: {\n            addressOriginal: tokenOut,\n            addressForSwaps: tokenOutForSwaps,\n            wrapType: tokenOutWrapType,\n            rate: tokenOutRate,\n        },\n    };\n}\n\nexport function setWrappedInfo(\n    swapInfo: SwapInfo,\n    swapType: SwapTypes,\n    wrappedInfo: WrappedInfo,\n    config: SorConfig\n): SwapInfo {\n    if (swapInfo.swaps.length === 0) return swapInfo;\n\n    swapInfo.tokenIn = wrappedInfo.tokenIn.addressOriginal;\n    swapInfo.tokenOut = wrappedInfo.tokenOut.addressOriginal;\n\n    swapInfo.swapAmountForSwaps = swapInfo.swapAmount;\n    swapInfo.returnAmountFromSwaps = swapInfo.returnAmount;\n\n    swapInfo.tokenInForSwaps = wrappedInfo.tokenIn.addressForSwaps;\n    swapInfo.tokenOutFromSwaps = wrappedInfo.tokenOut.addressForSwaps;\n\n    // No wrapping required\n    if (\n        wrappedInfo.tokenIn.wrapType === WrapTypes.None &&\n        wrappedInfo.tokenOut.wrapType === WrapTypes.None\n    ) {\n        return swapInfo;\n    }\n\n    //--------------------------------------------------------------------------\n    // Wrappers which are 1:1 (ETH/WETH), ie UnscaledWrappers\n    // Replace weth with ZERO/ETH in assets for Vault to handle ETH directly\n    if (\n        wrappedInfo.tokenIn.wrapType === WrapTypes.ETH ||\n        wrappedInfo.tokenOut.wrapType === WrapTypes.ETH\n    ) {\n        swapInfo.tokenAddresses = swapInfo.tokenAddresses.map((addr) =>\n            isSameAddress(addr, config.weth) ? AddressZero : addr\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // Wrappers which are NOT 1:1 (stETH/wstETH, AMPL/WAMPL, all ubTokens etc)\n    // ie ScaledWrappers\n\n    const isScaledWrapper = (wrapType) =>\n        wrapType === WrapTypes.stETH || wrapType === WrapTypes.Unbutton;\n\n    // Scaling required for wrappers which don't scale 1:1 with the underlying token\n    // swap amount and return amounts are scaled if swap type is SwapExact\n\n    // Handle swap amount scaling\n    if (\n        (isScaledWrapper(wrappedInfo.tokenIn.wrapType) &&\n            swapType === SwapTypes.SwapExactIn) ||\n        (isScaledWrapper(wrappedInfo.tokenOut.wrapType) &&\n            swapType === SwapTypes.SwapExactOut)\n    ) {\n        swapInfo.swapAmount = wrappedInfo.swapAmountOriginal;\n        swapInfo.swapAmountForSwaps = wrappedInfo.swapAmountForSwaps;\n    }\n\n    // Handle return amount scaling\n    // SwapExactIn, unwrapped out, returnAmount is unwrapped amount out, returnAmountForSwaps is wrapped amount out\n    if (\n        swapType === SwapTypes.SwapExactIn &&\n        isScaledWrapper(wrappedInfo.tokenOut.wrapType)\n    ) {\n        swapInfo.returnAmount = swapInfo.returnAmount\n            .mul(ONE)\n            .div(wrappedInfo.tokenOut.rate);\n\n        swapInfo.returnAmountConsideringFees =\n            swapInfo.returnAmountConsideringFees\n                .mul(ONE)\n                .div(wrappedInfo.tokenOut.rate);\n    }\n\n    // SwapExactOut, unwrapped in, returnAmount us unwrapped amount in, returnAmountForSwaps is wrapped amount in\n    if (\n        swapType === SwapTypes.SwapExactOut &&\n        isScaledWrapper(wrappedInfo.tokenIn.wrapType)\n    ) {\n        swapInfo.returnAmount = swapInfo.returnAmount\n            .mul(ONE)\n            .div(wrappedInfo.tokenIn.rate);\n\n        swapInfo.returnAmountConsideringFees =\n            swapInfo.returnAmountConsideringFees\n                .mul(ONE)\n                .div(wrappedInfo.tokenIn.rate);\n    }\n\n    return swapInfo;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport cloneDeep from 'lodash.clonedeep';\nimport { bnum, scale } from './utils/bignumber';\nimport { EMPTY_SWAPINFO } from './constants';\nimport { SwapTypes, SwapV2, Swap, SwapInfo } from './types';\nimport { Zero } from '@ethersproject/constants';\n\n/**\n * @returns an array of deduplicated token addresses used in the provided swaps\n */\nconst getTokenAddresses = (swaps: Swap[][]): string[] => {\n    const tokenAddressesSet: Set<string> = new Set(\n        swaps.flatMap((sequence) =>\n            sequence.flatMap((swap): [string, string] => [\n                swap.tokenIn,\n                swap.tokenOut,\n            ])\n        )\n    );\n\n    return [...tokenAddressesSet];\n};\n\n/**\n * @returns an array of deduplicated token addresses used in the provided swaps\n */\nexport const getTokenAddressesForSwap = (swaps: Swap[]): string[] => {\n    const tokenAddressesSet: Set<string> = new Set(\n        swaps.flatMap((swap): [string, string] => [swap.tokenIn, swap.tokenOut])\n    );\n\n    return [...tokenAddressesSet];\n};\n\n/**\n * @dev Assumes that intermediate swaps have been properly formatted using the zero sentinel value\n * @returns the total amount of tokens used in the described batchSwap\n */\nconst getTotalSwapAmount = (swaps: SwapV2[]) => {\n    return swaps.reduce((acc, { amount }) => acc.add(amount), Zero);\n};\n\n/**\n * Formats a sequence of swaps to the format expected by the Balance Vault.\n * @dev Intermediate swaps' amounts are replaced with the sentinel value of zero\n *      and exact output sequences are reversed.\n * @param swapKind - a SwapTypes enum for whether the swap has an exact input or exact output\n * @param sequence - a sequence of swaps which form a path from the input token to the output token\n * @param tokenAddresses - an array of all the token address which are involved in the batchSwap\n * @returns\n */\nexport const formatSequence = (\n    swapKind: SwapTypes,\n    sequence: Swap[],\n    tokenAddresses: string[]\n): SwapV2[] => {\n    if (swapKind === SwapTypes.SwapExactOut) {\n        // GIVEN_OUT sequences must be passed to the vault in reverse order.\n        // After reversing the sequence we can treat them almost equivalently to GIVEN_IN sequences\n        sequence = sequence.reverse();\n    }\n\n    return sequence.map((swap, i) => {\n        // Multihop swaps can be executed by passing an `amountIn` value of zero for a swap. This will cause the amount out\n        // of the previous swap to be used as the amount in of the current one. In such a scenario, `tokenIn` must equal the\n        // previous swap's `tokenOut`.\n        let amountScaled = '0';\n\n        // First swap needs to be given a value so we inject this from SOR solution\n        if (i === 0) {\n            // If it's a GIVEN_IN swap then swapAmount is in terms of tokenIn\n            // and vice versa for GIVEN_OUT\n            const scalingFactor =\n                swapKind === SwapTypes.SwapExactIn\n                    ? swap.tokenInDecimals\n                    : swap.tokenOutDecimals;\n\n            amountScaled = scale(bnum(swap.swapAmount as string), scalingFactor)\n                .decimalPlaces(0, 1)\n                .toString();\n        }\n        const scalingFactorReturn =\n            swapKind === SwapTypes.SwapExactIn\n                ? swap.tokenOutDecimals\n                : swap.tokenInDecimals;\n\n        const returnScaled = scale(\n            bnum(swap.returnAmount ?? '0'),\n            scalingFactorReturn\n        )\n            .decimalPlaces(0, 1)\n            .toString();\n\n        const assetInIndex = tokenAddresses.indexOf(swap.tokenIn);\n        const assetOutIndex = tokenAddresses.indexOf(swap.tokenOut);\n        return {\n            poolId: swap.pool,\n            assetInIndex,\n            assetOutIndex,\n            amount: amountScaled,\n            userData: '0x',\n            returnAmount: returnScaled,\n        };\n    });\n};\n\nexport function formatSwaps(\n    swapsOriginal: Swap[][],\n    swapType: SwapTypes,\n    swapAmount: BigNumber,\n    tokenIn: string,\n    tokenOut: string,\n    returnAmount: BigNumber,\n    returnAmountConsideringFees: BigNumber,\n    marketSp: string\n): SwapInfo {\n    if (swapsOriginal.length === 0) {\n        return cloneDeep(EMPTY_SWAPINFO);\n    }\n\n    const swapsClone = cloneDeep(swapsOriginal);\n    const tokenAddresses = getTokenAddresses(swapsClone);\n    const swaps: SwapV2[] = swapsClone.flatMap((sequence) =>\n        formatSequence(swapType, sequence, tokenAddresses)\n    );\n\n    // We need to account for any rounding losses by adding dust to first path\n    const dust = swapAmount.sub(getTotalSwapAmount(swaps));\n    if (dust.gt(0)) {\n        swaps[0].amount = BigNumber.from(swaps[0].amount).add(dust).toString();\n    }\n\n    const swapInfo: SwapInfo = {\n        swapAmount,\n        swapAmountForSwaps: swapAmount,\n        returnAmount,\n        returnAmountFromSwaps: returnAmount,\n        returnAmountConsideringFees,\n        swaps,\n        tokenAddresses,\n        tokenIn,\n        tokenOut,\n        marketSp,\n    };\n\n    return swapInfo;\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n    PoolDataService,\n    SubgraphPoolBase,\n    SubgraphToken,\n    GraphQLArgs,\n} from './types';\n\nexport class PoolCacher {\n    private pools: SubgraphPoolBase[] = [];\n    private _finishedFetching = false;\n\n    constructor(private readonly poolDataService: PoolDataService) {}\n\n    public get finishedFetching(): boolean {\n        return this._finishedFetching;\n    }\n\n    public getPools(useBpts?: boolean): SubgraphPoolBase[] {\n        const pools = cloneDeep(this.pools);\n        // If we use join/exit paths add the pool token to its token list\n        if (useBpts) {\n            for (const pool of pools) {\n                if (\n                    pool.poolType === 'Weighted' ||\n                    pool.poolType === 'Investment'\n                ) {\n                    const BptAsToken: SubgraphToken = {\n                        address: pool.address,\n                        balance: pool.totalShares,\n                        decimals: 18,\n                        priceRate: '1',\n                        weight: '0',\n                    };\n                    pool.tokens.push(BptAsToken);\n                    pool.tokensList.push(pool.address);\n                }\n            }\n        }\n        return pools;\n    }\n\n    /*\n     * Saves updated pools data to internal cache.\n     *\n     * @param {GraphQLArgs} queryArgs - Optional query arguments to pass to pool data service.\n     * @returns {boolean} True if pools fetched successfully, False if not.\n     */\n    public async fetchPools(queryArgs?: GraphQLArgs): Promise<boolean> {\n        try {\n            this.pools = await this.poolDataService.getPools(queryArgs);\n            this._finishedFetching = true;\n            return true;\n        } catch (err) {\n            // On error clear all caches and return false so user knows to try again.\n            this._finishedFetching = false;\n            this.pools = [];\n            console.error(`Error: fetchPools(): ${err}`);\n            return false;\n        }\n    }\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n    SubgraphPoolBase,\n    PoolDictionary,\n    NewPath,\n    Swap,\n    PoolBase,\n    PoolFilter,\n    PoolTypes,\n    PoolPairBase,\n    SorConfig,\n    hopDictionary,\n} from '../types';\nimport { ZERO } from '../utils/bignumber';\nimport { parseNewPool } from '../pools';\nimport { Zero } from '@ethersproject/constants';\n\nconst BOOSTED_PATHS_MAX_LENGTH = 7;\n\ninterface edgeDict {\n    [node: string]: [string, string, string][];\n}\n\ninterface treeEdge {\n    edge: [string, string, string];\n    parentIndices: [number, number];\n    visitedNodes: string[];\n}\n\nexport const filterPoolsByType = (\n    pools: SubgraphPoolBase[],\n    poolTypeFilter: PoolFilter\n): SubgraphPoolBase[] => {\n    if (poolTypeFilter === PoolFilter.All) return pools;\n    return pools.filter((p) => p.poolType === poolTypeFilter);\n};\n\n/*\nThe purpose of this function is to build dictionaries of direct pools \nand plausible hop pools.\n*/\nexport function filterPoolsOfInterest(\n    allPools: PoolDictionary,\n    tokenIn: string,\n    tokenOut: string,\n    maxPools: number\n): [PoolDictionary, hopDictionary, hopDictionary] {\n    const directPools: PoolDictionary = {};\n    const hopsIn: hopDictionary = {};\n    const hopsOut: hopDictionary = {};\n\n    Object.keys(allPools).forEach((id) => {\n        const pool = allPools[id];\n        const tokenListSet = new Set(pool.tokensList);\n        const containsTokenIn = tokenListSet.has(tokenIn.toLowerCase());\n        const containsTokenOut = tokenListSet.has(tokenOut.toLowerCase());\n\n        // This is a direct pool as has both tokenIn and tokenOut\n        if (containsTokenIn && containsTokenOut) {\n            directPools[pool.id] = pool;\n            return;\n        }\n\n        if (maxPools > 1) {\n            if (containsTokenIn && !containsTokenOut) {\n                for (const hopToken of tokenListSet) {\n                    if (!hopsIn[hopToken]) hopsIn[hopToken] = new Set([]);\n                    hopsIn[hopToken].add(pool.id);\n                }\n            } else if (!containsTokenIn && containsTokenOut) {\n                for (const hopToken of [...tokenListSet]) {\n                    if (!hopsOut[hopToken]) hopsOut[hopToken] = new Set([]);\n                    hopsOut[hopToken].add(pool.id);\n                }\n            }\n        }\n    });\n    return [directPools, hopsIn, hopsOut];\n}\n\nexport function producePaths(\n    tokenIn: string,\n    tokenOut: string,\n    directPools: PoolDictionary,\n    hopsIn: hopDictionary,\n    hopsOut: hopDictionary,\n    pools: PoolDictionary\n): NewPath[] {\n    const paths: NewPath[] = [];\n\n    // Create direct paths\n    for (const id in directPools) {\n        const path = createPath([tokenIn, tokenOut], [pools[id]]);\n        paths.push(path);\n    }\n\n    for (const hopToken in hopsIn) {\n        if (hopsOut[hopToken]) {\n            let highestNormalizedLiquidityFirst = ZERO; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n            let highestNormalizedLiquidityFirstPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n            let highestNormalizedLiquiditySecond = ZERO; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n            let highestNormalizedLiquiditySecondPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n            for (const poolInId of [...hopsIn[hopToken]]) {\n                const poolIn = pools[poolInId];\n                const poolPairData = poolIn.parsePoolPairData(\n                    tokenIn,\n                    hopToken\n                );\n                const normalizedLiquidity =\n                    poolIn.getNormalizedLiquidity(poolPairData);\n                // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n                if (\n                    normalizedLiquidity.isGreaterThanOrEqualTo(\n                        highestNormalizedLiquidityFirst\n                    )\n                ) {\n                    highestNormalizedLiquidityFirst = normalizedLiquidity;\n                    highestNormalizedLiquidityFirstPoolId = poolIn.id;\n                }\n            }\n            for (const poolOutId of [...hopsOut[hopToken]]) {\n                const poolOut = pools[poolOutId];\n                const poolPairData = poolOut.parsePoolPairData(\n                    hopToken,\n                    tokenOut\n                );\n                const normalizedLiquidity =\n                    poolOut.getNormalizedLiquidity(poolPairData);\n                // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n                if (\n                    normalizedLiquidity.isGreaterThanOrEqualTo(\n                        highestNormalizedLiquiditySecond\n                    )\n                ) {\n                    highestNormalizedLiquiditySecond = normalizedLiquidity;\n                    highestNormalizedLiquiditySecondPoolId = poolOut.id;\n                }\n            }\n            if (\n                highestNormalizedLiquidityFirstPoolId &&\n                highestNormalizedLiquiditySecondPoolId\n            ) {\n                const path = createPath(\n                    [tokenIn, hopToken, tokenOut],\n                    [\n                        pools[highestNormalizedLiquidityFirstPoolId],\n                        pools[highestNormalizedLiquiditySecondPoolId],\n                    ]\n                );\n                paths.push(path);\n            }\n        }\n    }\n    return paths;\n}\n\n// We build a directed graph for the boosted pools.\n// Nodes are tokens and edges are triads: [pool.id, tokenIn, tokenOut].\n// The current criterion for including a pool into this graph is the following:\n// (a) We include every linear pool.\n// (b) Among preminted BPT pools and weighted pools, we include those that contain the pool token of a linear pool.\n// (c) Among every pool, we include those that contain the pool token of a pool from the previous step.\n// (d) We include connections of tokenIn and tokenOut to list of tokens from `connectingTokens` (only highest liquidity for each).\n// (e) When tokenIn or tokenOut are tokens offered at an LBP, we also include\n// the LBPs and the corresponding highest liquidity connections of the raising tokens with WETH.\n// (f) We include the pool weth/wsteth\n//\n// To build the paths using boosted pools we use the following algorithm.\n// Given a tokenIn and a tokenOut belonging to the graph, we want to find\n// all the connecting paths inside the graph, with the properties:\n// (a) They do not visit the same token twice\n// (b) They do not use the same pool twice in a row (since this\n// would never be optimal).\n// These paths can be organized as a directed tree having tokenIn as a root.\n// We build this tree by adding at each step all the possible continuations for\n// each branch. When a branch reaches tokenOut, we write down the corresponding path.\n// We only allow paths up to length BOOSTED_PATHS_MAX_LENGTH = 7\nexport function getBoostedGraph(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAllDict: PoolDictionary,\n    config: SorConfig\n): edgeDict {\n    // This should contain all pools in the Graph\n    const graphPoolsSet: Set<PoolBase> = new Set();\n    const allLinearPoolAddresses: string[] = [];\n    const poolsToCheckForLinearBpt: PoolBase[] = [];\n    const connectingTokens = config.connectingTokens\n        ? config.connectingTokens.map(\n              (connectingToken) => connectingToken.address\n          )\n        : [];\n    // Add all LinearPools (see step a)\n    // Create a list of pools that should be checked for Linear BPT (for step b)\n    // Add LBP pools with tokenIn or tokenOut and their corresponding highest liquidity connections\n    for (const id in poolsAllDict) {\n        const pool = poolsAllDict[id];\n        if (pool.poolType == PoolTypes.Linear) {\n            allLinearPoolAddresses.push(pool.address);\n            graphPoolsSet.add(pool);\n        } else {\n            const tokensList = pool.tokensList.map((address) =>\n                address.toLowerCase()\n            );\n            if (tokensList.includes(pool.address)) {\n                // Here we asssume that preminted pools are exactly those that\n                // are not linear and have their pool token in their tokensList.\n                poolsToCheckForLinearBpt.push(pool);\n            } else if (pool.poolType === PoolTypes.Weighted) {\n                // We want to consider Weighted Pools with Linear Bpt tokens\n                poolsToCheckForLinearBpt.push(pool);\n            }\n            if (config.lbpRaisingTokens && pool.isLBP) {\n                handleLBPCase(\n                    graphPoolsSet,\n                    config.lbpRaisingTokens,\n                    pool,\n                    tokenIn,\n                    tokenOut,\n                    connectingTokens,\n                    poolsAllDict\n                );\n            }\n        }\n    }\n    if (allLinearPoolAddresses.length == 0) return {};\n\n    // add best pools tokenIn -> connectingToken and connectingToken -> tokenOut\n    // these can be part of a longer path so do not rely on being directly connected\n    for (const connectingToken of connectingTokens) {\n        addMostLiquidPoolToSet(\n            tokenIn,\n            connectingToken,\n            poolsAllDict,\n            graphPoolsSet\n        );\n        addMostLiquidPoolToSet(\n            connectingToken,\n            tokenOut,\n            poolsAllDict,\n            graphPoolsSet\n        );\n    }\n    // As per step b - Among preminted BPT pools and weighted pools, we include those that contain the pool token of a linear pool.\n    const poolsWithLinearTokens: Set<string> = new Set();\n    for (const pool of poolsToCheckForLinearBpt) {\n        if (\n            pool.tokensList.some((token) =>\n                allLinearPoolAddresses.includes(token)\n            )\n        ) {\n            graphPoolsSet.add(pool);\n            poolsWithLinearTokens.add(pool.address);\n        }\n    }\n    // As per step c -  We include every pool that has a pool token from the previous step\n    for (const id in poolsAllDict) {\n        const pool = poolsAllDict[id];\n        if (pool.tokensList.some((token) => poolsWithLinearTokens.has(token))) {\n            graphPoolsSet.add(pool);\n        }\n    }\n    // Step f - add pool weth/wsteth when it exists\n    if (config.wETHwstETH && poolsAllDict[config.wETHwstETH.id]) {\n        graphPoolsSet.add(poolsAllDict[config.wETHwstETH.id]);\n    }\n    const graphPools: PoolBase[] = [...graphPoolsSet];\n    const edgeDict = getNodesAndEdges(graphPools);\n    return edgeDict;\n}\n\nfunction getNodesAndEdges(pools: PoolBase[]): edgeDict {\n    const edgesFromNode: edgeDict = {};\n    for (const pool of pools) {\n        const n = pool.tokensList.length;\n        for (let i = 0; i < n; i++) {\n            if (!edgesFromNode[pool.tokensList[i]])\n                edgesFromNode[pool.tokensList[i]] = [];\n            for (let j = 0; j < n; j++) {\n                if (i == j) continue;\n                const edge: [string, string, string] = [\n                    pool.id,\n                    pool.tokensList[i],\n                    pool.tokensList[j],\n                ];\n                edgesFromNode[pool.tokensList[i]].push(edge);\n            }\n        }\n    }\n    return edgesFromNode;\n}\n\nexport function getBoostedPaths(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAllDict: PoolDictionary,\n    config: SorConfig\n): NewPath[] {\n    const edgesFromNode = getBoostedGraph(\n        tokenIn,\n        tokenOut,\n        poolsAllDict,\n        config\n    );\n    const pathsInfo: [string[], string[]][] = [];\n    const rootTreeEdge: treeEdge = {\n        edge: ['', '', tokenIn],\n        parentIndices: [-1, -1],\n        visitedNodes: [],\n    };\n    const treeEdges: treeEdge[][] = [[rootTreeEdge]];\n    let iterate = true;\n    while (iterate) {\n        const n = treeEdges.length; // number of tree edge layers so far\n        const newTreeEdges: treeEdge[] = [];\n        // adds every possible treeEdge for each treeEdge of the previous layer\n        for (let i = 0; i < treeEdges[n - 1].length; i++) {\n            const treeEdge = treeEdges[n - 1][i];\n            const token = treeEdge.edge[2];\n            const edgesFromToken = edgesFromNode[token];\n            if (!edgesFromToken) continue;\n            for (const edge of edgesFromToken) {\n                // skip if the node was already visited or\n                // if the pool is the one from the previous edge\n                if (\n                    treeEdge.visitedNodes.includes(edge[2]) ||\n                    treeEdge.edge[0] == edge[0]\n                ) {\n                    continue;\n                }\n                if (edge[2] == tokenOut) {\n                    pathsInfo.push(getPathInfo(edge, treeEdge, treeEdges));\n                }\n                const newTreeEdge: treeEdge = {\n                    edge: edge,\n                    parentIndices: [n - 1, i],\n                    visitedNodes: treeEdge.visitedNodes.concat(edge[1]),\n                };\n                newTreeEdges.push(newTreeEdge);\n            }\n        }\n        if (newTreeEdges.length == 0) {\n            iterate = false;\n        } else treeEdges.push(newTreeEdges);\n        if (n == BOOSTED_PATHS_MAX_LENGTH) iterate = false;\n    }\n    return pathsInfoToPaths(pathsInfo, poolsAllDict);\n}\n\nfunction getPathInfo(\n    edge: [string, string, string],\n    treeEdge: treeEdge,\n    treeEdges: treeEdge[][]\n): [string[], string[]] {\n    const pathEdges: [string, string, string][] = [edge];\n    pathEdges.unshift(treeEdge.edge);\n    let indices = treeEdge.parentIndices;\n    while (indices[0] !== -1) {\n        pathEdges.unshift(treeEdges[indices[0]][indices[1]].edge);\n        indices = treeEdges[indices[0]][indices[1]].parentIndices;\n    }\n    const pools = pathEdges.map((pathEdge) => pathEdge[0]);\n    pools.splice(0, 1);\n    const tokens = pathEdges.map((pathEdge) => pathEdge[2]);\n    return [tokens, pools];\n}\n\nfunction pathsInfoToPaths(\n    flexBoostedPathsInfo: [string[], string[]][],\n    poolsAllDict: PoolDictionary\n): NewPath[] {\n    const paths: NewPath[] = [];\n    for (const boostedPathInfo of flexBoostedPathsInfo) {\n        const pools = boostedPathInfo[1].map((id) => poolsAllDict[id]);\n        // ignore paths of length 1 and 2\n        if (pools.length > 2) {\n            paths.push(createPath(boostedPathInfo[0], pools));\n        }\n    }\n    return paths;\n}\n\n// Creates a path with pools.length hops\n// i.e. tokens[0]>[Pool0]>tokens[1]>[Pool1]>tokens[2]>[Pool2]>tokens[3]\nexport function createPath(tokens: string[], pools: PoolBase[]): NewPath {\n    let tI: string, tO: string;\n    const swaps: Swap[] = [];\n    const poolPairData: PoolPairBase[] = [];\n    let id = '';\n\n    for (let i = 0; i < pools.length; i++) {\n        tI = tokens[i];\n        tO = tokens[i + 1];\n        const poolPair = pools[i].parsePoolPairData(tI, tO);\n        poolPairData.push(poolPair);\n        id = id + poolPair.id;\n\n        const swap: Swap = {\n            pool: pools[i].id,\n            tokenIn: tI,\n            tokenOut: tO,\n            tokenInDecimals: poolPair.decimalsIn,\n            tokenOutDecimals: poolPair.decimalsOut,\n        };\n\n        swaps.push(swap);\n    }\n\n    const path: NewPath = {\n        id,\n        swaps,\n        limitAmount: Zero,\n        poolPairData,\n        pools,\n    };\n\n    return path;\n}\n\nexport function getHighestLiquidityPool(\n    tokenIn: string,\n    tokenOut: string,\n    poolsOfInterest: PoolDictionary\n): string | null {\n    let highestNormalizedLiquidity = ZERO;\n    let highestNormalizedLiquidityPoolId: string | null = null;\n    for (const id in poolsOfInterest) {\n        const pool = poolsOfInterest[id];\n        const tokenListSet = new Set(pool.tokensList);\n\n        // If pool doesn't have tokenIn or tokenOut then ignore\n\n        if (\n            !tokenListSet.has(tokenIn.toLowerCase()) ||\n            !tokenListSet.has(tokenOut.toLowerCase())\n        )\n            continue;\n        const poolPairData = pool.parsePoolPairData(tokenIn, tokenOut);\n        const normalizedLiquidity = pool.getNormalizedLiquidity(poolPairData);\n        // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n        if (\n            normalizedLiquidity.isGreaterThanOrEqualTo(\n                highestNormalizedLiquidity\n            )\n        ) {\n            highestNormalizedLiquidity = normalizedLiquidity;\n            highestNormalizedLiquidityPoolId = id;\n        }\n    }\n    return highestNormalizedLiquidityPoolId;\n}\n\n// This function will only work correctly if the input is composable\n// i.e. each path's token out = next path's token in\nfunction composePaths(paths: NewPath[]): NewPath {\n    let id = '';\n    let swaps: Swap[] = [];\n    let poolPairData: PoolPairBase[] = [];\n    let pools: PoolBase[] = [];\n    for (const path of paths) {\n        id += path.id;\n        swaps = swaps.concat(path.swaps);\n        poolPairData = poolPairData.concat(path.poolPairData);\n        pools = pools.concat(path.pools);\n    }\n    const path: NewPath = {\n        id: id,\n        swaps: swaps,\n        poolPairData: poolPairData,\n        limitAmount: Zero,\n        pools: pools,\n    };\n    return path;\n}\n\n/*\nThe staBAL3 pool (STABALADDR) is the main stable pool that holds DAI/USDC/USDT and has the staBAL3 BPT.\nMetastable pools that contain a project token, i.e. TUSD, paired with staBAL3 BPT.\nUSDC connecting pool (USDCCONNECTINGPOOL) is a metastable pool containing USDC and staBAL3 BPT.\nThis setup should enable paths between the new project metastable pools and other liquidity. I.e. TUSD > BAL, which would look like:\nTUSD>[TUSDstaBALPool]>staBAL3>[ConnectingPool]>USDC>[BalWeightedPool]>BAL\n*/\nexport function getPathsUsingStaBalPool(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAll: PoolDictionary,\n    poolsFiltered: PoolDictionary,\n    config: SorConfig\n): NewPath[] {\n    // This will be the USDC/staBAL Connecting pool used in Polygon\n    const usdcConnectingPoolInfo = config.usdcConnectingPool;\n    if (!usdcConnectingPoolInfo) return [];\n\n    const usdcConnectingPool = poolsAll[usdcConnectingPoolInfo.id];\n    // staBal BPT token is the hop token between token and USDC connecting pool\n    const hopTokenStaBal = config.staBal3Pool?.address;\n\n    if (!usdcConnectingPool || !hopTokenStaBal) return [];\n\n    // Finds the best metastable Pool with tokenIn/staBal3Bpt or returns null if doesn't exist\n    const metastablePoolIdIn = getHighestLiquidityPool(\n        tokenIn,\n        hopTokenStaBal,\n        poolsFiltered\n    );\n    // Finds the best metastable Pool with tokenOut/staBal3Bpt or returns null if doesn't exist\n    const metastablePoolIdOut = getHighestLiquidityPool(\n        hopTokenStaBal,\n        tokenOut,\n        poolsFiltered\n    );\n\n    if (metastablePoolIdIn && !metastablePoolIdOut) {\n        // First part of path is multihop through metaStablePool and USDC Connecting Pools\n        // Last part of path is single hop through USDC/tokenOut highest liquidity pool\n        // i.e. tokenIn>[metaStablePool]>staBAL>[usdcConnecting]>USDC>[HighLiqPool]>tokenOut\n\n        const metaStablePoolIn = poolsFiltered[metastablePoolIdIn];\n\n        // tokenIn > [metaStablePool] > staBal > [UsdcConnectingPool] > USDC\n        const staBalPath = createPath(\n            [tokenIn, hopTokenStaBal, usdcConnectingPoolInfo.usdc],\n            [metaStablePoolIn, usdcConnectingPool]\n        );\n\n        // Hop out as it is USDC > tokenOut\n        const mostLiquidLastPool = getHighestLiquidityPool(\n            usdcConnectingPoolInfo.usdc,\n            tokenOut,\n            poolsFiltered\n        );\n        // No USDC>tokenOut pool so return empty path\n        if (mostLiquidLastPool === null) return [];\n\n        const lastPool = poolsFiltered[mostLiquidLastPool];\n        const pathEnd = createPath(\n            [usdcConnectingPoolInfo.usdc, tokenOut],\n            [lastPool]\n        );\n\n        return [composePaths([staBalPath, pathEnd])];\n    }\n\n    if (!metastablePoolIdIn && metastablePoolIdOut) {\n        // First part of path is single hop through tokenIn/USDC highest liquidity pool\n        // Last part of path is multihop through USDC Connecting Pools and metaStablePool\n        // i.e. i.e. tokenIn>[HighLiqPool]>USDC>[usdcConnecting]>staBAL>[metaStablePool]>tokenOut\n\n        // Hop in as it is tokenIn > USDC\n        const mostLiquidFirstPool = getHighestLiquidityPool(\n            tokenIn,\n            usdcConnectingPoolInfo.usdc,\n            poolsFiltered\n        );\n        // No tokenIn>USDC pool so return empty path\n        if (mostLiquidFirstPool === null) return [];\n\n        const metaStablePoolIn = poolsFiltered[metastablePoolIdOut];\n        const firstPool = poolsFiltered[mostLiquidFirstPool];\n\n        // USDC > [UsdcConnectingPool] > staBal > [metaStablePool] > tokenOut\n        const staBalPath = createPath(\n            [usdcConnectingPoolInfo.usdc, hopTokenStaBal, tokenOut],\n            [usdcConnectingPool, metaStablePoolIn]\n        );\n        const pathStart = createPath(\n            [tokenIn, usdcConnectingPoolInfo.usdc],\n            [firstPool]\n        );\n\n        return [composePaths([pathStart, staBalPath])];\n    }\n\n    // If we're here either the path doesn't use metastable pools (and so will not be routed through StaBAL)\n    // or both input and output tokens are in metastable pools and so should be handled by existing multihop algorithm\n    // (because it is tokenIn>[metaStablePoolIn]>staBal>[metaStablePoolOut]>tokenOut)\n    //\n    // We then return an empty set of paths\n    return [];\n}\n\nexport function parseToPoolsDict(\n    pools: SubgraphPoolBase[],\n    timestamp: number\n): PoolDictionary {\n    return Object.fromEntries(\n        cloneDeep(pools)\n            .filter(\n                (pool) =>\n                    pool.tokensList.length > 0 && pool.tokens[0].balance !== '0'\n            )\n            .map((pool) => [pool.id, parseNewPool(pool, timestamp)])\n            .filter(([, pool]) => pool !== undefined)\n    );\n}\n\nfunction getRaisingToken(\n    pool: PoolBase,\n    lbpRaisingTokens: string[],\n    token: string\n): string | undefined {\n    let theOtherToken: string | undefined;\n    const tokensList = pool.tokensList;\n    if (tokensList.includes(token) && !lbpRaisingTokens.includes(token)) {\n        for (let i = 0; i < 2; i++) {\n            if (tokensList[i] == token) {\n                theOtherToken = tokensList[1 - i];\n            }\n        }\n    }\n    return theOtherToken;\n}\n\nfunction handleLBPCase(\n    graphPoolsSet: Set<PoolBase>,\n    lbpRaisingTokens: string[],\n    poolLbp: PoolBase,\n    tokenIn: string,\n    tokenOut: string,\n    connectingTokens: string[],\n    poolsAllDict: PoolDictionary\n) {\n    // Tokens that will be used as LBP Base Token, e.g. USDC/DAI/WETH\n    const raisingTokens = lbpRaisingTokens.map((address) =>\n        address.toLowerCase()\n    );\n\n    if (raisingTokens.length === 0) return;\n\n    // Assuming tokenIn is the lbpToken find the corresponding base token if it exists\n    const raisingTokenIn: string | undefined = getRaisingToken(\n        poolLbp,\n        raisingTokens,\n        tokenIn\n    );\n    const raisingTokenOut: string | undefined = getRaisingToken(\n        poolLbp,\n        raisingTokens,\n        tokenOut\n    );\n    if (!raisingTokenIn && !raisingTokenOut) return;\n\n    // Add the LBP pool to the graph\n    graphPoolsSet.add(poolLbp);\n\n    // For each connecting token add most liquid pools with raisingToken and raisingTokenOut\n    for (const connectingToken of connectingTokens) {\n        if (raisingTokenIn && raisingTokenIn !== connectingToken) {\n            // raisingToken>[Pool]>connectingToken\n            addMostLiquidPoolToSet(\n                raisingTokenIn,\n                connectingToken,\n                poolsAllDict,\n                graphPoolsSet\n            );\n        }\n        if (raisingTokenOut && raisingTokenOut !== connectingToken) {\n            // connectingToken>[Pool]>raisingToken\n            addMostLiquidPoolToSet(\n                connectingToken,\n                raisingTokenOut,\n                poolsAllDict,\n                graphPoolsSet\n            );\n        }\n    }\n}\n\nfunction addMostLiquidPoolToSet(\n    tokenIn: string,\n    tokenOut: string,\n    pools: PoolDictionary,\n    graphPools: Set<PoolBase>\n): void {\n    const pool = getHighestLiquidityPool(tokenIn, tokenOut, pools);\n    if (pool) graphPools.add(pools[pool]);\n}\n","import { BigNumber, parseFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { SwapTypes, NewPath } from '../types';\nimport { getOutputAmountSwap } from '../pools';\nimport { BigNumber as OldBigNumber } from '../utils/bignumber';\n\nexport function calculatePathLimits(\n    paths: NewPath[],\n    swapType: SwapTypes\n): [NewPath[], BigNumber] {\n    let maxLiquidityAvailable = Zero;\n    paths.forEach((path) => {\n        // Original parsedPoolPairForPath here but this has already been done.\n        path.limitAmount = getLimitAmountSwapForPath(path, swapType);\n        // if (path.limitAmount.isNaN()) throw 'path.limitAmount.isNaN';\n        maxLiquidityAvailable = maxLiquidityAvailable.add(path.limitAmount);\n    });\n    const sortedPaths = paths.sort((a, b) => {\n        return b.limitAmount.gt(a.limitAmount) ? 1 : -1;\n    });\n    return [sortedPaths, maxLiquidityAvailable];\n}\n\nexport function getLimitAmountSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes\n): BigNumber {\n    const poolPairData = path.poolPairData;\n    let limit: OldBigNumber;\n    if (swapType === SwapTypes.SwapExactIn) {\n        limit = path.pools[poolPairData.length - 1].getLimitAmountSwap(\n            poolPairData[poolPairData.length - 1],\n            SwapTypes.SwapExactIn\n        );\n\n        for (let i = poolPairData.length - 2; i >= 0; i--) {\n            const poolLimitExactIn = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactIn\n            );\n            const poolLimitExactOut = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactOut\n            );\n            if (poolLimitExactOut.lte(limit)) {\n                limit = poolLimitExactIn;\n            } else {\n                const pulledLimit = getOutputAmountSwap(\n                    path.pools[i],\n                    path.poolPairData[i],\n                    SwapTypes.SwapExactOut,\n                    limit\n                );\n                limit = OldBigNumber.min(pulledLimit, poolLimitExactIn);\n            }\n        }\n        if (limit.isZero()) return Zero;\n        const result = parseFixed(\n            limit.dp(poolPairData[0].decimalsIn).toString(),\n            poolPairData[0].decimalsIn\n        );\n        return result;\n    } else {\n        limit = path.pools[0].getLimitAmountSwap(\n            poolPairData[0],\n            SwapTypes.SwapExactOut\n        );\n        for (let i = 1; i < poolPairData.length; i++) {\n            const poolLimitExactIn = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactIn\n            );\n            const poolLimitExactOut = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactOut\n            );\n            if (poolLimitExactIn.lte(limit)) {\n                limit = poolLimitExactOut;\n            } else {\n                const pushedLimit = getOutputAmountSwap(\n                    path.pools[i],\n                    path.poolPairData[i],\n                    SwapTypes.SwapExactIn,\n                    limit\n                );\n                limit = OldBigNumber.min(pushedLimit, poolLimitExactOut);\n            }\n        }\n        if (limit.isZero()) return Zero;\n        return parseFixed(\n            limit\n                .dp(poolPairData[poolPairData.length - 1].decimalsOut)\n                .toString(),\n            poolPairData[poolPairData.length - 1].decimalsOut\n        );\n    }\n}\n","import {\n    getPathsUsingStaBalPool,\n    parseToPoolsDict,\n    filterPoolsOfInterest,\n    producePaths,\n    getBoostedPaths,\n} from './filtering';\nimport { calculatePathLimits } from './pathLimits';\nimport {\n    SwapOptions,\n    SwapTypes,\n    NewPath,\n    SubgraphPoolBase,\n    SorConfig,\n    PoolDictionary,\n} from '../types';\n\nexport class RouteProposer {\n    cache: Record<string, { paths: NewPath[] }> = {};\n\n    constructor(private readonly config: SorConfig) {}\n\n    /**\n     * Given a list of pools and a desired input/output, returns a set of possible paths to route through\n     */\n    getCandidatePaths(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        pools: SubgraphPoolBase[],\n        swapOptions: SwapOptions\n    ): NewPath[] {\n        tokenIn = tokenIn.toLowerCase();\n        tokenOut = tokenOut.toLowerCase();\n        if (pools.length === 0) return [];\n\n        // If token pair has been processed before that info can be reused to speed up execution\n        // If timestamp has not been manually set in `getSwaps` then default (set on instantiation) is used which means cache will be used\n        const cache =\n            this.cache[\n                `${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`\n            ];\n        // forceRefresh can be set to force fresh processing of paths/prices\n        if (!swapOptions.forceRefresh && !!cache) {\n            // Using pre-processed data from cache\n            return cache.paths;\n        }\n\n        const poolsAllDict = parseToPoolsDict(pools, swapOptions.timestamp);\n\n        const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n            poolsAllDict,\n            tokenIn,\n            tokenOut,\n            swapOptions.maxPools\n        );\n\n        const pathData = producePaths(\n            tokenIn,\n            tokenOut,\n            directPools,\n            hopsIn,\n            hopsOut,\n            poolsAllDict\n        );\n\n        const boostedPaths = getBoostedPaths(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            this.config\n        );\n\n        const pathsUsingStaBal = getPathsUsingStaBalPool(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            poolsAllDict,\n            this.config\n        );\n\n        const combinedPathData = pathData\n            .concat(...boostedPaths)\n            .concat(...pathsUsingStaBal);\n        const [paths] = calculatePathLimits(combinedPathData, swapType);\n\n        this.cache[`${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`] =\n            {\n                paths: paths,\n            };\n        return paths;\n    }\n\n    /**\n     * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.\n     * @param {string} tokenIn - Address of tokenIn\n     * @param {string} tokenOut - Address of tokenOut\n     * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n     * @param {PoolDictionary} poolsAllDict - Dictionary of pools.\n     * @param {number }maxPools - Maximum number of pools to hop through.\n     * @returns {NewPath[]} Array of possible paths sorted by liquidity.\n     */\n    getCandidatePathsFromDict(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        poolsAllDict: PoolDictionary,\n        maxPools: number\n    ): NewPath[] {\n        tokenIn = tokenIn.toLowerCase();\n        tokenOut = tokenOut.toLowerCase();\n        if (Object.keys(poolsAllDict).length === 0) return [];\n\n        const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n            poolsAllDict,\n            tokenIn,\n            tokenOut,\n            maxPools\n        );\n\n        const pathData = producePaths(\n            tokenIn,\n            tokenOut,\n            directPools,\n            hopsIn,\n            hopsOut,\n            poolsAllDict\n        );\n\n        const boostedPaths = getBoostedPaths(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            this.config\n        );\n\n        const combinedPathData = pathData.concat(...boostedPaths);\n        const [paths] = calculatePathLimits(combinedPathData, swapType);\n        return paths;\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { bnum, scale } from './utils/bignumber';\nimport { SorConfig, TokenPriceService } from './types';\n\nexport class SwapCostCalculator {\n    private readonly tokenPriceCache: Record<string, string>;\n\n    constructor(\n        config: SorConfig,\n        private readonly tokenPriceService: TokenPriceService\n    ) {\n        this.tokenPriceCache = {\n            AddressZero: '1',\n            [config.weth.toLowerCase()]: '1',\n        };\n    }\n\n    /**\n     * Calculate the cost of spending a certain amount of gas in terms of a token.\n     * This allows us to determine whether an increased amount of tokens gained\n     * is worth spending this extra gas (e.g. by including an extra pool in a swap)\n     */\n    public async convertGasCostToToken(\n        tokenAddress: string,\n        tokenDecimals: number,\n        gasPriceWei: BigNumber,\n        swapGas: BigNumber = BigNumber.from('85000')\n    ): Promise<BigNumber> {\n        if (gasPriceWei.isZero() || swapGas.isZero()) return Zero;\n        const tokenPrice = await this.getNativeAssetPriceInToken(tokenAddress);\n        const tokenPriceWei = BigNumber.from(\n            scale(bnum(tokenPrice), tokenDecimals).dp(0).toString()\n        );\n\n        return gasPriceWei.mul(swapGas).mul(tokenPriceWei).div(ONE);\n    }\n\n    /**\n     * @param tokenAddress - the address of the token for which to express the native asset in terms of\n     * @param tokenPrice - the price of the native asset in terms of the provided token\n     */\n    public setNativeAssetPriceInToken(\n        tokenAddress: string,\n        tokenPrice: string\n    ): void {\n        this.tokenPriceCache[tokenAddress.toLowerCase()] = tokenPrice;\n    }\n\n    /**\n     * @param tokenAddress - the address of the token for which to express the native asset in terms of\n     */\n    private async getNativeAssetPriceInToken(\n        tokenAddress: string\n    ): Promise<string> {\n        // Check if we have token price cached\n        const cachedTokenPrice =\n            this.tokenPriceCache[tokenAddress.toLowerCase()];\n        if (cachedTokenPrice) return cachedTokenPrice;\n\n        try {\n            const ethPriceInToken =\n                await this.tokenPriceService.getNativeAssetPriceInToken(\n                    tokenAddress\n                );\n\n            //cache the price so we don't need to refetch it\n            this.setNativeAssetPriceInToken(tokenAddress, ethPriceInToken);\n\n            return ethPriceInToken;\n        } catch (err) {\n            console.log('Error Getting Token Price. Defaulting to 0.');\n            console.log(err);\n            return '0';\n        }\n    }\n}\n","export { SOR } from './wrapper';\nexport { BPTForTokensZeroPriceImpact as weightedBPTForTokensZeroPriceImpact } from './frontendHelpers/weightedHelpers';\nexport { BPTForTokensZeroPriceImpact as stableBPTForTokensZeroPriceImpact } from './frontendHelpers/stableHelpers';\nexport * from './types';\nexport { formatSequence, getTokenAddressesForSwap } from './formatSwaps';\nexport { RouteProposer } from './routeProposal';\nexport { parseToPoolsDict } from './routeProposal/filtering';\nexport { BigNumber as OldBigNumber, bnum, ZERO } from './utils/bignumber';\nexport { WeightedPool } from './pools/weightedPool/weightedPool';\nexport { StablePool } from './pools/stablePool/stablePool';\nexport { MetaStablePool } from './pools/metaStablePool/metaStablePool';\nexport { PhantomStablePool } from './pools/phantomStablePool/phantomStablePool';\nexport { ComposableStablePool } from './pools/composableStable/composableStablePool';\nexport { LinearPool } from './pools/linearPool/linearPool';\nexport { getSpotPriceAfterSwapForPath } from './router/helpersClass';\nexport * as WeightedMaths from './pools/weightedPool/weightedMath';\nexport * as StableMaths from './pools/stablePool/stableMath';\nexport * as StableMathBigInt from './pools/stablePool/stableMathBigInt';\nexport * as Gyro2Maths from './pools/gyro2Pool/gyro2Math';\nexport * as Gyro3Maths from './pools/gyro3Pool/gyro3Math';\nexport * as GyroEMaths from './pools/gyroEPool/gyroEMath/gyroEMath';\nexport {\n    balancesFromTokenInOut,\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n} from './pools/gyroEPool/gyroEMath/gyroEMathHelpers';\nexport * as LinearMaths from './pools/linearPool/linearMath';\nexport const ISOLATED_CONST = 'isolated';\n","import { BigNumber, BigNumberish, parseFixed } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport cloneDeep from 'lodash.clonedeep';\nimport { BigNumber as OldBigNumber } from './utils/bignumber';\nimport { getBestPaths } from './router';\nimport { getWrappedInfo, setWrappedInfo } from './wrapInfo';\nimport { formatSwaps } from './formatSwaps';\nimport { PoolCacher } from './poolCacher';\nimport { RouteProposer } from './routeProposal';\nimport { filterPoolsByType } from './routeProposal/filtering';\nimport { SwapCostCalculator } from './swapCostCalculator';\nimport { getLidoStaticSwaps, isLidoStableSwap } from './pools/lido';\nimport { isSameAddress } from './utils';\nimport { EMPTY_SWAPINFO } from './constants';\nimport {\n    SwapInfo,\n    SwapTypes,\n    NewPath,\n    PoolFilter,\n    Swap,\n    SubgraphPoolBase,\n    SwapOptions,\n    TokenPriceService,\n    PoolDataService,\n    SorConfig,\n} from './types';\nimport { Zero } from '@ethersproject/constants';\n\nexport class SOR {\n    private readonly poolCacher: PoolCacher;\n    public readonly routeProposer: RouteProposer;\n    readonly swapCostCalculator: SwapCostCalculator;\n    private useBpt: boolean;\n\n    private readonly defaultSwapOptions: SwapOptions = {\n        gasPrice: parseFixed('50', 9),\n        swapGas: BigNumber.from('85000'),\n        poolTypeFilter: PoolFilter.All,\n        maxPools: 4,\n        timestamp: Math.floor(Date.now() / 1000),\n        forceRefresh: false,\n    };\n\n    /**\n     * @param {Provider} provider - Provider.\n     * @param {SorConfig} config - Chain specific configuration for the SOR.\n     * @param {PoolDataService} poolDataService - Generic service that fetches pool data from an external data source.\n     * @param {TokenPriceService} tokenPriceService - Generic service that fetches token prices from an external price feed. Used in calculating swap cost.\n     */\n    constructor(\n        public provider: Provider,\n        private readonly config: SorConfig,\n        poolDataService: PoolDataService,\n        tokenPriceService: TokenPriceService\n    ) {\n        this.poolCacher = new PoolCacher(poolDataService);\n        this.routeProposer = new RouteProposer(config);\n        this.swapCostCalculator = new SwapCostCalculator(\n            config,\n            tokenPriceService\n        );\n    }\n\n    getPools(useBpts?: boolean): SubgraphPoolBase[] {\n        return this.poolCacher.getPools(useBpts);\n    }\n\n    /**\n     * fetchPools Retrieves pools information and saves to internal pools cache.\n     * @returns {boolean} True if pools fetched successfully, False if not.\n     */\n    async fetchPools(): Promise<boolean> {\n        return this.poolCacher.fetchPools();\n    }\n\n    /**\n     * getSwaps Retrieve information for best swap tokenIn>tokenOut.\n     * @param {string} tokenIn - Address of tokenIn.\n     * @param {string} tokenOut - Address of tokenOut.\n     * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n     * @param {BigNumberish} swapAmount - Either amountIn or amountOut depending on the `swapType` value.\n     * @param swapOptions\n     * @param useBpts Set to true to consider join/exit weighted pool paths (these will need formatted and submitted via Relayer)\n     * @returns Swap information including return amount and swaps structure to be submitted to Vault.\n     */\n    async getSwaps(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        swapAmount: BigNumberish,\n        swapOptions?: Partial<SwapOptions>,\n        useBpts = false\n    ): Promise<SwapInfo> {\n        if (!this.poolCacher.finishedFetching) return cloneDeep(EMPTY_SWAPINFO);\n\n        // Set any unset options to their defaults\n        const options: SwapOptions = {\n            ...this.defaultSwapOptions,\n            ...swapOptions,\n        };\n        if (this.useBpt !== useBpts) {\n            options.forceRefresh = true;\n            this.useBpt = useBpts;\n        }\n        const pools: SubgraphPoolBase[] = this.poolCacher.getPools(useBpts);\n        const filteredPools = filterPoolsByType(pools, options.poolTypeFilter);\n\n        const wrappedInfo = await getWrappedInfo(\n            this.provider,\n            swapType,\n            tokenIn,\n            tokenOut,\n            this.config,\n            BigNumber.from(swapAmount)\n        );\n\n        let swapInfo: SwapInfo;\n        if (isLidoStableSwap(this.config.chainId, tokenIn, tokenOut)) {\n            swapInfo = await getLidoStaticSwaps(\n                filteredPools,\n                this.config.chainId,\n                wrappedInfo.tokenIn.addressForSwaps,\n                wrappedInfo.tokenOut.addressForSwaps,\n                swapType,\n                wrappedInfo.swapAmountForSwaps,\n                this.provider\n            );\n        } else {\n            swapInfo = await this.processSwaps(\n                wrappedInfo.tokenIn.addressForSwaps,\n                wrappedInfo.tokenOut.addressForSwaps,\n                swapType,\n                wrappedInfo.swapAmountForSwaps,\n                filteredPools,\n                options\n            );\n        }\n\n        if (swapInfo.returnAmount.isZero()) return swapInfo;\n\n        swapInfo = setWrappedInfo(swapInfo, swapType, wrappedInfo, this.config);\n\n        return swapInfo;\n    }\n    /**\n     * getCostOfSwapInToken Calculates and saves price of a swap in outputToken denomination. Used to determine if extra swaps are cost effective.\n     * @param {string} outputToken - Address of outputToken.\n     * @param {number} outputTokenDecimals - Decimals of outputToken.\n     * @param {BigNumber} gasPrice - Gas price used to calculate cost.\n     * @param {BigNumber} swapGas - Gas cost of a swap. Default=85000.\n     * @returns {BigNumber} Price of a swap in outputToken denomination.\n     */\n    async getCostOfSwapInToken(\n        outputToken: string,\n        outputTokenDecimals: number,\n        gasPrice: BigNumber,\n        swapGas?: BigNumber\n    ): Promise<BigNumber> {\n        if (gasPrice.isZero()) return Zero;\n        return this.swapCostCalculator.convertGasCostToToken(\n            outputToken,\n            outputTokenDecimals,\n            gasPrice,\n            swapGas\n        );\n    }\n\n    // Will process swap/pools data and return best swaps\n    private async processSwaps(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        swapAmount: BigNumber,\n        pools: SubgraphPoolBase[],\n        swapOptions: SwapOptions\n    ): Promise<SwapInfo> {\n        if (pools.length === 0) return cloneDeep(EMPTY_SWAPINFO);\n\n        const paths = this.routeProposer.getCandidatePaths(\n            tokenIn,\n            tokenOut,\n            swapType,\n            pools,\n            swapOptions\n        );\n\n        if (paths.length == 0) return cloneDeep(EMPTY_SWAPINFO);\n\n        // Path is guaranteed to contain both tokenIn and tokenOut\n        let tokenInDecimals;\n        let tokenOutDecimals;\n        paths[0].swaps.forEach((swap) => {\n            // Inject token decimals to avoid having to query onchain\n            if (isSameAddress(swap.tokenIn, tokenIn)) {\n                tokenInDecimals = swap.tokenInDecimals;\n            }\n            if (isSameAddress(swap.tokenOut, tokenOut)) {\n                tokenOutDecimals = swap.tokenOutDecimals;\n            }\n        });\n\n        const costOutputToken = await this.getCostOfSwapInToken(\n            swapType === SwapTypes.SwapExactIn ? tokenOut : tokenIn,\n            swapType === SwapTypes.SwapExactIn\n                ? tokenOutDecimals\n                : tokenInDecimals,\n            swapOptions.gasPrice,\n            swapOptions.swapGas\n        );\n\n        // Returns list of swaps\n        const [swaps, total, marketSp, totalConsideringFees] =\n            this.getBestPaths(\n                paths,\n                swapAmount,\n                swapType,\n                tokenInDecimals,\n                tokenOutDecimals,\n                costOutputToken,\n                swapOptions.maxPools\n            );\n\n        const swapInfo = formatSwaps(\n            swaps,\n            swapType,\n            swapAmount,\n            tokenIn,\n            tokenOut,\n            total,\n            totalConsideringFees,\n            marketSp\n        );\n\n        return swapInfo;\n    }\n\n    /**\n     * Find optimal routes for trade from given candidate paths\n     */\n    private getBestPaths(\n        paths: NewPath[],\n        swapAmount: BigNumber,\n        swapType: SwapTypes,\n        tokenInDecimals: number,\n        tokenOutDecimals: number,\n        costOutputToken: BigNumber,\n        maxPools: number\n    ): [Swap[][], BigNumber, string, BigNumber] {\n        // swapExactIn - total = total amount swap will return of tokenOut\n        // swapExactOut - total = total amount of tokenIn required for swap\n\n        const [inputDecimals, outputDecimals] =\n            swapType === SwapTypes.SwapExactIn\n                ? [tokenInDecimals, tokenOutDecimals]\n                : [tokenOutDecimals, tokenInDecimals];\n\n        const [swaps, total, marketSp, totalConsideringFees] = getBestPaths(\n            paths,\n            swapType,\n            swapAmount,\n            inputDecimals,\n            outputDecimals,\n            maxPools,\n            costOutputToken\n        );\n\n        return [\n            swaps,\n            parseFixed(\n                total.dp(outputDecimals, OldBigNumber.ROUND_FLOOR).toString(),\n                outputDecimals\n            ),\n            marketSp.toString(),\n            parseFixed(\n                totalConsideringFees\n                    .dp(outputDecimals, OldBigNumber.ROUND_FLOOR)\n                    .toString(),\n                outputDecimals\n            ),\n        ];\n    }\n}\n","import {\n    BigNumber,\n    BigNumberish,\n    formatFixed,\n    parseFixed,\n} from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../utils/bignumber';\nimport * as stableMath from '../pools/stablePool/stableMath';\nimport { StablePoolPairData } from '../pools/stablePool/stablePool';\n\n/////////\n/// UI Helpers\n/////////\n\n// Get BPT amount for token amounts with zero-price impact\n// This function is the same regardless of whether we are considering\n// an Add or Remove liquidity operation: The spot prices of BPT in tokens\n// are the same regardless.\nexport function BPTForTokensZeroPriceImpact(\n    allBalances: BigNumberish[],\n    decimals: number[],\n    amounts: BigNumberish[], // This has to have the same lenght as allBalances\n    bptTotalSupply: BigNumberish,\n    amp: BigNumberish\n): BigNumber {\n    if (allBalances.length != amounts.length)\n        throw 'allBalances and amounts have to have same length';\n    // Calculate the amount of BPT adding this liquidity would result in\n    // if there were no price impact, i.e. using the spot price of tokenIn/BPT\n\n    // We downscale the pool balances once as this will be reused across tokens\n    const allBalancesDownScaled: OldBigNumber[] = allBalances.map(\n        (balance, i) => bnum(formatFixed(balance, decimals[i]))\n    );\n\n    const amountBPTOut = amounts.reduce((totalBptOut, amountIn, i) => {\n        // Calculate amount of BPT gained per token in\n        const poolPairData: StablePoolPairData = {\n            amp: BigNumber.from(amp),\n            allBalances: allBalancesDownScaled,\n            tokenIndexIn: i,\n            balanceOut: bptTotalSupply,\n            decimalsOut: 18,\n            swapFee: Zero,\n        } as unknown as StablePoolPairData;\n        const BPTPrice = stableMath._spotPriceAfterSwapTokenInForExactBPTOut(\n            ZERO,\n            poolPairData\n        );\n\n        // Multiply by amountIn to get contribution to total bpt out\n        const downscaledAmountIn = formatFixed(amountIn, decimals[i]);\n        const downscaledBptOut = bnum(downscaledAmountIn)\n            .div(BPTPrice)\n            .toString();\n        return BigNumber.from(totalBptOut).add(\n            parseFixed(downscaledBptOut, 18)\n        );\n    }, Zero);\n\n    return BigNumber.from(amountBPTOut);\n}\n","import {\n    BigNumber,\n    BigNumberish,\n    formatFixed,\n    parseFixed,\n} from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { bnum, ZERO } from '../utils/bignumber';\nimport * as weightedMath from '../pools/weightedPool/weightedMath';\nimport { WeightedPoolPairData } from '../pools/weightedPool/weightedPool';\n\n/////////\n/// UI Helpers\n/////////\n\n// Get BPT amount for token amounts with zero-price impact\n// This function is the same regardless of whether we are considering\n// an Add or Remove liquidity operation: The spot prices of BPT in tokens\n// are the same regardless.\nexport function BPTForTokensZeroPriceImpact(\n    balances: BigNumberish[],\n    decimals: number[],\n    normalizedWeights: BigNumberish[],\n    amounts: BigNumberish[],\n    bptTotalSupply: BigNumberish\n): BigNumber {\n    const amountBPTOut = amounts.reduce((totalBptOut, amountIn, i) => {\n        // Calculate amount of BPT gained per token in\n        const poolPairData: WeightedPoolPairData = {\n            balanceIn: balances[i],\n            decimalsIn: decimals[i],\n            balanceOut: bptTotalSupply,\n            weightIn: normalizedWeights[i],\n            swapFee: Zero,\n        } as WeightedPoolPairData;\n        const BPTPrice = weightedMath._spotPriceAfterSwapTokenInForExactBPTOut(\n            ZERO,\n            poolPairData\n        );\n\n        // Multiply by amountIn to get contribution to total bpt out\n        const downscaledAmountIn = formatFixed(amountIn, decimals[i]);\n        const downscaledBptOut = bnum(downscaledAmountIn)\n            .div(BPTPrice)\n            .toString();\n        return BigNumber.from(totalBptOut).add(\n            parseFixed(downscaledBptOut, 18)\n        );\n    }, Zero);\n\n    return BigNumber.from(amountBPTOut);\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","LARGE_ARRAY_SIZE","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","global","Object","freeSelf","self","root","Function","freeExports","exports","nodeType","freeModule","module","moduleExports","addMapEntry","map","pair","set","addSetEntry","add","arrayReduce","array","iteratee","accumulator","initAccum","index","length","isHostObject","toString","mapToArray","Array","size","forEach","key","overArg","func","transform","arg","setToArray","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Buffer","undefined","Symbol","Uint8Array","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","Map","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","this","clear","entry","ListCache","MapCache","Stack","__data__","arrayLikeKeys","inherited","isArray","isObjectLike","isArrayLike","isArrayLikeObject","isArguments","n","baseTimes","String","skipIndexes","isIndex","push","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","constructor","input","initCloneArray","source","copyArray","tag","getTag","isFunc","buffer","slice","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","Ctor","cloneArrayBuffer","dataView","byteOffset","byteLength","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","symbol","initCloneByTag","stacked","get","props","keysFunc","symbolsFunc","values","offset","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","baseIsNative","isFunction","test","arrayBuffer","newValue","getMapData","type","data","getValue","has","pop","hash","string","cache","pairs","other","ArrayBuffer","ctorString","isLength","baseKeys","BigNumber","config","EXPONENTIAL_AT","ROUNDING_MODE","DECIMAL_PLACES","ZERO","bnum","ONE","INFINITY","scale","decimalPlaces","scalePow","scaleMul","pow","times","val","BZERO","BigInt","BONE","_require","b","message","Error","_computeScalingFactor","tokenDecimals","decimalsDifference","MathSol","static","a","c","roundUp","divUp","divDown","product","aInflated","x","y","raw","LogExpMath","maxError","mulUpFixed","MAX_POW_RELATIVE_ERROR","sub","ONE_18","x_int256","MILD_EXPONENT_BOUND","y_int256","logx_times_y","LN_36_LOWER_BOUND","LN_36_UPPER_BOUND","ln_36_x","_ln_36","_ln","MIN_NATURAL_EXPONENT","MAX_NATURAL_EXPONENT","exp","firstAN","x0","a0","x1","a1","ONE_20","x2","a2","x3","a3","x4","a4","x5","a5","x6","a6","x7","a7","x8","a8","x9","a9","term","seriesSum","z","ONE_36","z_squared","num","sum","a10","x10","a11","x11","isSameAddress","address1","address2","getAddress","safeParseFixed","decimals","integer","fraction","split","parseFixed","safeValue","normaliseBalance","token","balance","mul","_a","priceRate","div","toBigInt","normaliseAmount","amount","scalingFactor","from","mulDownFixed","_upscale","denormaliseAmount","divDownFixed","_downscaleDown","ONE_BigInt","SwapTypes","PoolTypes","PoolFilter","MAX_INVARIANT_RATIO","_calcOutGivenIn","balanceIn","weightIn","balanceOut","weightOut","amountIn","fee","feeAmount","subtractFee","exponent","denominator","base","divUpFixed","power","powUpFixed","complementFixed","_calcInGivenOut","amountOut","ratio","addFee","_calcBptOutGivenExactTokensIn","balances","normalizedWeights","amountsIn","bptTotalSupply","swapFeePercentage","balanceRatiosWithFee","invariantRatioWithFees","i","invariantRatio","amountInWithoutFee","nonTaxableAmount","taxableAmount","swapFee","balanceRatio","powDown","_calcTokensOutGivenExactBptIn","bptAmountIn","totalBPT","bptRatio","amountsOut","_calcTokenOutGivenExactBptIn","normalizedWeight","amountOutWithoutFee","_calcBptInGivenExactTokensOut","balanceRatiosWithoutFee","invariantRatioWithoutFees","amountOutWithFee","taxableAmountPlusFees","_computeExitExactTokensOutInvariantRatio","_calcTokenInGivenExactBptOut","bptAmountOut","taxablePercentage","_spotPriceAfterSwapExactTokenInForTokenOut","poolPairData","Bi","parseFloat","formatFixed","decimalsIn","Bo","decimalsOut","wi","wo","Ai","toNumber","f","_spotPriceAfterSwapTokenInForExactTokenOut","_spotPriceAfterSwapExactTokenInForBPTOut","Bbpt","_spotPriceAfterSwapExactBPTInForTokenOut","_spotPriceAfterSwapBPTInForExactTokenOut","Ao","_spotPriceAfterSwapTokenInForExactBPTOut","Aobpt","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","_derivativeSpotPriceAfterSwapExactTokenInForBPTOut","_derivativeSpotPriceAfterSwapExactBPTInForTokenOut","Aibpt","PairTypes","totalSupply","previousInvariant","currentInvariant","protocolSwapFeePercentage","growth","k","numerator","invariant","swapFeeRatio","feeFactor","denominatorFactor","feeComplement","universalNormalizedLiquidity","derivativeSpotPriceAtZero","ans","isNaN","lt","isFinite","WeightedPool","pool","isLBP","totalWeight","weightedPool","id","address","totalShares","tokens","tokensList","poolType","Weighted","MAX_IN_RATIO","MAX_OUT_RATIO","parsePoolPairData","tokenIn","tokenOut","tokenIndexIn","findIndex","t","tI","weight","tokenIndexOut","tO","pairType","BptToToken","TokenToBpt","TokenToToken","Number","getNormalizedWeights","WeiPerEther","getNormalizedLiquidity","getLimitAmountSwap","swapType","SwapExactIn","updateTokenBalanceForPool","newBalance","updateTotalShares","T","find","newTotalShares","_exactTokenInForTokenOut","dp","normalizedWeightIn","normalizedWeightOut","returnAmt","err","_tokenInForExactTokenOut","balancesNormalised","filter","amountsOutNormalised","fill","amountsInNormalised","Zero","_invariant","A","totalCoins","plus","isZero","prevInv","inv","ATimesNpowN","P_D","j","minus","gt","amp","allBalances","tokenAmountIn","EONE","p","n_pow_n","_solveAnalyticalBalance","tokenAmountOut","multipliedBy","oldBN_A","sqrt","_poolDerivatives","is_first_derivative","wrt_out","D","S","twoaxy","partial_x","partial_y","partial_xx","partial_yy","partial_xy","_in","newInvariant","sumBalances","newBalanceTokenIndex","tokenIndex","nPowN","_getTokenBalanceGivenInvariantAndAllOtherBalances","amountInAfterFee","currentWeight","tokenBalancePercentageExcess","_tokenInForExactBPTOut","_feeFactor","bptSupply","is_BPT_out","D_P","AAdjusted","alpha","beta","gamma","minus_partial_D","partial_D","partial_xD","n_times_nplusone","partial_DD","term1","term2","term3","D_prime","_poolDerivativesBPT","AMP_PRECISION","_calculateInvariant","numTokens","prevInvariant","ampTimesTotal","initBalance","finalBalanceOut","finalBalanceIn","newBalances","inv2","prevTokenBalance","tokenBalance","_value","_out","balancesCopy","StablePool","Stable","AMP_DECIMALS","allBalancesScaled","amtScaled","subtractSwapFeeAmount","amt","scaleFactor","addSwapFeeAmount","console","error","MetaStablePool","MetaStable","tokenInPriceRate","tokenOutPriceRate","amountConverted","returnEvmWithRate","scalingFactorIn","scalingFactorOut","returnAmountConverted","priceRateIn","priceRateOut","_calcBptOutPerMainIn","mainIn","mainBalance","wrappedBalance","params","_toNominal","previousNominalMain","deltaNominalMain","_calcInvariantUp","_calcBptInPerMainOut","mainOut","_calcInvariantDown","_calcBptInPerWrappedOut","wrappedOut","nominalMain","_calcWrappedOutPerMainIn","rate","_calcWrappedInPerMainOut","_calcMainInPerBptOut","bptOut","_fromNominal","_calcMainOutPerBptIn","bptIn","_calcMainOutPerWrappedIn","wrappedIn","_calcMainInPerWrappedOut","_calcBptOutPerWrappedIn","_calcWrappedInPerBptOut","newBptBalance","_calcWrappedOutPerBptIn","nominalMainBalance","real","lowerTarget","fees","upperTarget","nominal","leftDerivativeToNominal","oneMinusFee","onePlusFee","rightDerivativeToNominal","leftDerivativeFromNominal","rightDerivativeFromNominal","_spotPriceAfterSwapBptOutPerMainIn","finalMainBalance","poolFactor","_spotPriceAfterSwapMainInPerBptOut","afterNominalMain","_spotPriceAfterSwapMainOutPerBptIn","_spotPriceAfterSwapBptInPerMainOut","_spotPriceAfterSwapMainInPerWrappedOut","_spotPriceAfterSwapWrappedInPerMainOut","afterMain","_spotPriceAfterSwapWrappedOutPerMainIn","_spotPriceAfterSwapMainOutPerWrappedIn","inversePrice","_spotPriceAfterSwapBptOutPerWrappedIn","_spotPriceAfterSwapWrappedOutPerBptIn","_spotPriceAfterSwapWrappedInPerBptOut","_spotPriceAfterSwapBptInPerWrappedOut","bptIndex","LinearPool","mainIndex","wrappedIndex","Linear","MAX_RATIO","ALMOST_ONE","MAX_TOKEN_BALANCE","indexOf","wrappedDecimals","BptToWrappedToken","BptToMainToken","WrappedTokenToBpt","MainTokenToBpt","WrappedTokenToMainToken","MainTokenToWrappedToken","bptBalanceScaled","virtualBptSupply","wrappedBalanceScaled","mainBalanceScaled","linearPoolPairData","balanceOutHuman","_mainTokenInForExactBPTOut","_BPTInForExactMainTokenOut","_BPTInForExactWrappedTokenOut","diff","_exactMainTokenInForBPTOut","_exactBPTInForMainTokenOut","_exactWrappedTokenInForBPTOut","_exactBPTInForWrappedTokenOut","_exactMainTokenInForWrappedOut","_exactWrappedTokenInForMainOut","_wrappedTokenInForExactBPTOut","_mainTokenInForExactWrappedOut","_wrappedTokenInForExactMainOut","bigintAmount","getTimeTillExpiry","expiryTime","currentBlockTimestamp","unitSeconds","ElementPool","principalToken","baseToken","Element","setCurrentBlockTimestamp","timestamp","realBalanceIn","realBalanceOut","Math","abs","AMP_PRECISION_BNUM","bnumBalanceOut","bnumSwapFee","_BPTInForExactTokenOut","tokenBalanceRatioWithoutFee","amountOutBeforeFee","gte","_exactTokenInForBPTOut","weightedBalanceRatio","_exactBPTInForTokenOut","bnumBalanceIn","PhantomStablePool","poolPairDataNoBpt","cloneDeep","removeBPT","amountConvertedEvm","returnEvm","amountsInBigInt","amountsOutBigInt","returnEvmWithFee","phantomStableMath._spotPriceAfterSwapExactTokenInForBPTOut","phantomStableMath._spotPriceAfterSwapExactBPTInForTokenOut","phantomStableMath._spotPriceAfterSwapExactTokenInForTokenOut","phantomStableMath._spotPriceAfterSwapTokenInForExactBPTOut","phantomStableMath._spotPriceAfterSwapBPTInForExactTokenOut","phantomStableMath._spotPriceAfterSwapTokenInForExactTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForBPTOut","phantomStableMath._derivativeSpotPriceAfterSwapExactBPTInForTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactBPTOut","phantomStableMath._derivativeSpotPriceAfterSwapBPTInForExactTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactTokenOut","ComposableStablePool","super","tokensWithoutBpt","SQRT_1E_NEG_1","SQRT_1E_NEG_3","SQRT_1E_NEG_5","SQRT_1E_NEG_7","SQRT_1E_NEG_9","SQRT_1E_NEG_11","SQRT_1E_NEG_13","SQRT_1E_NEG_15","SQRT_1E_NEG_17","ONE_XP","SMALL","SWAP_LIMIT_FACTOR","mulUp","mulDown","mulXpU","divXpU","mulDownMagU","divDownMagU","mulUpMagU","divUpMagU","mulUpXpToNpU","TenPower19","b1","b2","isNegative","mod","prod1","prod2","lte","mulDownXpToNpU","tolerance","guess","factor","intLog2Halved","makeInitialGuess","guessSquared","_findVirtualParams","sqrtAlpha","sqrtBeta","mb","bSquare","mc","_calculateQuadraticTerms","_calculateQuadratic","bterm0","bterm1","bSq2","bSq3","addTerm","sqrResult","virtualParamIn","virtualParamOut","virtInOver","virtOutUnder","_calculateNewSpotPrice","inAmount","outAmount","afterFeeMultiplier","TWO","virtOut","_normalizeBalances","scalingFactors","d","bal","_reduceFee","_addFee","Gyro2Pool","Gyro2","tokenInIndex","tokenOutIndex","tokenInIsToken0","normalizedBalances","maxAmountInAssetInPool","limitAmountInPlusSwapFee","inAmountLessFee","newSpotPrice","derivative","_SAFE_LARGE_POW3_THRESHOLD","MIDDECIMAL","_INVARIANT_SHRINKING_FACTOR_PER_STEP","_INVARIANT_MIN_ITERATIONS","root3Alpha","md","_calculateCubicTerms","_calculateCubic","alpha23","cterm","rootEst","_calculateCubicStartingPoint","_runNewtonIteration","radic","deltaAbsPrev","iteration","deltaAbs","deltaIsPos","_calcNewtonDelta","dfRootEst","deltaMinus","l","ret","_safeLargePow3ADown","deltaPlus","virtualOffset","virtualOffsetInOut","Gyro3Pool","list","tokenAddress","Gyro3","findToken","tokenTertiary","balanceTertiary","decimalsTertiary","MAX_BALANCES","MAX_INVARIANT","reduceFee","normalizeBalances","balancesFromTokenInOut","balanceTokenIn","balanceTokenOut","calcInvariantSqrt","termNp","s","termXp","u","v","lambda","dSq","calcMinAtxAChiySqPlusAtxSq","xy","w","calc2AtxAtyAChixAChiy","calcMinAtyAChixSqPlusAtySq","checkAssetBounds","derived","newBal","assetIndex","xPlus","r","termXp1","tauBeta","tauAlpha","termXp2","xp","maxBalances0","yPlus","yp","maxBalances1","calcYGivenX","ab","virtualOffset0","virtualOffset1","solveQuadraticSwap","calcXGivenY","ba","switchTau","tauValue","lamBar","q","sTerm","calcXpXpDivLambdaLambda","sqVars","calcSpotPriceYGivenX","solveDerivativeQuadraticSwap","calcSpotPriceXGivenY","setup","rVec","ixVar","y0","ls","R","calculateInvariantWithError","AtAChi","dSq2","calcAtAChi","invariantResult","square_root","mulDenominator","dSq3","calcAChiAChiInXp","calcOutGivenIn","ixIn","ixOut","calcGiven","balInNew","balOutNew","calcInGivenOut","calcSpotPriceAfterSwapOutGivenIn","newSpotPriceFactor","calcSpotPriceAfterSwapInGivenOut","calcDerivativePriceAfterSwapOutGivenIn","newDerivativeSpotPriceFactor","dPxDYIn","dPyDXIn","calcDerivativeSpotPriceAfterSwapInGivenOut","dPxDXOut","dPyDYOut","normalizedLiquidityXIn","normalizedLiquidityYIn","GyroEPool","tauAlphaX","tauAlphaY","tauBetaX","tauBetaY","gyroEParams","derivedGyroEParams","every","el","GyroE","orderedNormalizedBalances","invErr","virtualOffsetFunc","tokenRates","valuesInOutFrom01","GyroEV2Pool","tokenRateInOut","limitAmountIn","inAmountLessFeeScaled","inAmountScaledLessFee","outAmountScaled","derivativeScaled","rateAdjFactor","ONE_TO_THE_SIX_NUM","ONE_TO_THE_THIRTEEN_NUM","ONE_ETHER","CURVEMATH_MAX","CurveMathRevert","isUSDC","convertToNumber","baseDecimal","getParsedFxPoolData","isOriginSwap","baseReserves","viewNumeraireAmount","tokenOutLatestFXPrice","getBaseDecimals","tokenInLatestFXPrice","usdcReserves","baseTokenRate","givenAmountInNumeraire","calculatedNumeraireAmount","calculateGivenAmountInNumeraire","delta","epsilon","_oGLiq","_nGLiq","_oBals","_nBals","viewRawAmount","_amount","calculateMicroFee","_bal","_ideal","_beta","_delta","_threshold","_feeMargin","fee_","calculateFee","_gLiq","_bals","_weights","_length","psi_","calculateTrade","_inputAmt","_outputIndex","outputAmt_","_omega","_psi","prevAmount","enforceSwapInvariant","enforceHalts","SwapConvergenceFailed","_alpha","_nIdeal","_upperAlpha","_nHalt","_oHalt","UpperHalt","_lowerAlpha","LowerHalt","_diff","SwapInvariantViolation","spotPriceBeforeSwap","parsedFxPoolData","outputAmountInNumeraire","targetAmountInNumeraire","currentRate","outputAmount","maxBetaLimit","minBetaLimit","oBals0after","oBals1after","FxPool","Fx","latestFXPrice","_b","parsedReserves","tokenInNumeraire","tokenOutNumeraire","tokenInReservesInNumeraire","tokenOutReservesInNumeraire","poolBalancesToNumeraire","maxLimit","maxLimitAmount","_amt","CannotSwap","_amtWithFee","parseNewPool","swapEnabled","newPool","isLinear","includes","fromPool","poolTypeVersion","getOutputAmountSwap","priceErrorTolerance","process","env","PRICE_ERROR_TOLERANCE","log","OldBigNumber","INFINITESIMAL","MINIMUM_VALUE","getOutputAmountSwapForPath","path","inputDecimals","limitAmount","amounts","getAmounts","pools","unshift","getProdsSpotPrices","oneIfExactOut","SwapExactOut","getSpotPriceAfterSwap","getSpotPriceAfterSwapForPath","getDerivativeSpotPriceAfterSwapForPath","prodsSpotPrices","newTerm","getDerivativeSpotPriceAfterSwap","prodsFirstSpotPrices","getProdsFirstSpotPrices","EVMgetOutputAmountSwap","returnAmount","optimizePathDistribution","allPaths","totalSwapAmount","initialSwapAmounts","outputDecimals","costReturnToken","selectedPaths","exceedingAmounts","getBestPathIds","swapAmounts","paths","humanTotalSwapAmount","newSelectedPaths","historyOfSortedPathIds","sortedPathIdsJSON","JSON","stringify","sort","iterateSwapAmounts","pathIds","originalPaths","selectedPathExceedingAmounts","swapAmount","bestPathIndex","bestEffectivePrice","effectivePrice","outputAmountSwap","gasCost","getEffectivePriceSwapForPath","swaps","priceError","prices","iterationCount","isGreaterThan","iterateSwapAmountsApproximation","maxPrice","max","minPrice","min","sumInverseDerivativeSPaSs","sumSPaSDividedByDerivativeSPaSs","SPaSs","derivativeSPaSs","SPaS","derivative_SPaS","weighted_average_SPaS","deltaSwapAmount","redistributeInputAmounts","pricesForViableAmounts","swapAmountsSumWithRoundingErrors","roundingError","sumInverseDerivativeSPaSsForViableAmounts","sumInverseDerivativeSPaSsForNegativeAmounts","sumInverseDerivativeSPaSsForExceedingAmounts","sumNegativeOrExceedingSwapAmounts","calcTotalReturn","totalReturn","getBestPaths","maxPools","highestLimitAmounts","limitAmounts","getHighestLimitAmountsForPaths","sumLimitAmounts","reduce","pathLimit","initialNumPaths","cumulativeLimit","difference","bestPaths","bestSwapAmounts","bestTotalReturnConsideringFees","newSwapAmount","bestAmounts","totalNumberOfPools","acc","costReturnTokenHuman","improvementCondition","totalReturnConsideringFees","gasFees","isLessThan","_","optimizeSwapAmounts","bestTotalReturn","marketSp","highestSwapAmt","largestSwapPath","pathSwaps","swap","tokenInDecimals","tokenOutDecimals","totalSwapAmountWithRoundingErrors","dust","firstPathLastPoolIndex","formatSwaps","EMPTY_SWAPINFO","tokenAddresses","swapAmountForSwaps","tokenInForSwaps","tokenOutFromSwaps","returnAmountConsideringFees","returnAmountFromSwaps","Lido","Networks","stETH","wstETH","WETH","DAI","USDC","USDT","StaticPools","staBal","wethDai","wstEthWeth","Routes","getStEthRate","provider","chainId","wstETHContract","Contract","tokensPerStEth","getLidoStaticSwaps","isWrappingIn","isWrappingOut","swapInfo","staticRoute","assets","spotPrices","poolId","assetInIndex","assetOutIndex","spotPrice","calculateMarketSp","vaultContract","vaultAbi","funds","sender","AddressZero","recipient","fromInternalBalance","toInternalBalance","deltas","callStatic","queryBatchSwap","name","userData","TokensToUnbuttonWrapperMap","getWrapperRate","wrapperAddress","underlyingToWrapper","WrapTypes","getTokenAddresses","flatMap","sequence","getTotalSwapAmount","formatSequence","swapKind","reverse","amountScaled","scalingFactorReturn","returnScaled","PoolCacher","poolDataService","_finishedFetching","finishedFetching","getPools","useBpts","BptAsToken","fetchPools","queryArgs","BOOSTED_PATHS_MAX_LENGTH","filterPoolsOfInterest","allPools","directPools","hopsIn","hopsOut","tokenListSet","containsTokenIn","toLowerCase","containsTokenOut","hopToken","producePaths","createPath","highestNormalizedLiquidityFirstPoolId","highestNormalizedLiquiditySecondPoolId","highestNormalizedLiquidityFirst","highestNormalizedLiquiditySecond","poolInId","poolIn","normalizedLiquidity","isGreaterThanOrEqualTo","poolOutId","poolOut","getBoostedPaths","poolsAllDict","edgesFromNode","graphPoolsSet","allLinearPoolAddresses","poolsToCheckForLinearBpt","connectingTokens","connectingToken","lbpRaisingTokens","handleLBPCase","addMostLiquidPoolToSet","poolsWithLinearTokens","some","wETHwstETH","edge","getNodesAndEdges","getBoostedGraph","pathsInfo","treeEdges","parentIndices","visitedNodes","iterate","newTreeEdges","treeEdge","edgesFromToken","getPathInfo","newTreeEdge","concat","flexBoostedPathsInfo","boostedPathInfo","pathsInfoToPaths","pathEdges","indices","pathEdge","poolPair","getHighestLiquidityPool","poolsOfInterest","highestNormalizedLiquidity","highestNormalizedLiquidityPoolId","composePaths","parseToPoolsDict","fromEntries","getRaisingToken","theOtherToken","poolLbp","raisingTokens","raisingTokenIn","raisingTokenOut","graphPools","calculatePathLimits","maxLiquidityAvailable","limit","poolLimitExactIn","pulledLimit","poolLimitExactOut","pushedLimit","getLimitAmountSwapForPath","RouteProposer","getCandidatePaths","swapOptions","forceRefresh","pathData","boostedPaths","pathsUsingStaBal","poolsAll","poolsFiltered","usdcConnectingPoolInfo","usdcConnectingPool","hopTokenStaBal","staBal3Pool","metastablePoolIdIn","metastablePoolIdOut","metaStablePoolIn","staBalPath","usdc","mostLiquidLastPool","lastPool","mostLiquidFirstPool","firstPool","getPathsUsingStaBalPool","combinedPathData","getCandidatePathsFromDict","SwapCostCalculator","tokenPriceService","tokenPriceCache","weth","convertGasCostToToken","gasPriceWei","swapGas","tokenPrice","getNativeAssetPriceInToken","tokenPriceWei","setNativeAssetPriceInToken","cachedTokenPrice","ethPriceInToken","defaultSwapOptions","gasPrice","poolTypeFilter","All","floor","Date","now","poolCacher","routeProposer","swapCostCalculator","getSwaps","options","useBpt","filteredPools","filterPoolsByType","wrappedInfo","tokenInWrapType","None","tokenOutForSwaps","tokenOutWrapType","tokenInRate","tokenOutRate","ETH","tokensToUBWrapperMap","Unbutton","getUnbuttonWrapperRate","swapAmountOriginal","addressOriginal","addressForSwaps","wrapType","getWrappedInfo","isLidoStableSwap","processSwaps","addr","isScaledWrapper","setWrappedInfo","getCostOfSwapInToken","outputToken","outputTokenDecimals","costOutputToken","total","totalConsideringFees","swapsOriginal","swapsClone","ROUND_FLOOR","allBalancesDownScaled","amountBPTOut","totalBptOut","BPTPrice","stableMath._spotPriceAfterSwapTokenInForExactBPTOut","downscaledBptOut","weightedMath._spotPriceAfterSwapTokenInForExactBPTOut"],"mappings":";;;;;;;;;;;;;;;AAmEO,SAASA,EAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,GAAQ,CAAG,MAAOG,GAAKL,EAAOK,GAAO,CAC3F,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,GAAU,CAAC,MAAOG,GAAKL,EAAOK,GAAO,CAC9F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,EAAO,KAIhBO,KAAKR,EAAWK,EAAY,CAC9GH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,OACtE,GACA,0KCjEA,IAAIO,EAAmB,IAGnBC,EAAiB,4BAGjBC,EAAmB,iBAGnBC,EAAU,qBAEVC,EAAU,mBACVC,EAAU,gBAEVC,EAAU,oBACVC,EAAS,6BACTC,EAAS,eACTC,EAAY,kBACZC,EAAY,kBACZC,EAAa,mBACbC,EAAY,kBACZC,EAAS,eACTC,EAAY,kBACZC,EAAY,kBACZC,EAAa,mBAEbC,EAAiB,uBACjBC,EAAc,oBACdC,EAAa,wBACbC,EAAa,wBACbC,EAAU,qBACVC,EAAW,sBACXC,EAAW,sBACXC,EAAW,sBACXC,EAAkB,6BAClBC,EAAY,uBACZC,EAAY,uBASZC,EAAU,OAGVC,EAAe,8BAGfC,EAAW,mBAGXC,EAAgB,CAAA,EACpBA,EAAc5B,GAAW4B,EA7CV,kBA8CfA,EAAcd,GAAkBc,EAAcb,GAC9Ca,EAAc3B,GAAW2B,EAAc1B,GACvC0B,EAAcZ,GAAcY,EAAcX,GAC1CW,EAAcV,GAAWU,EAAcT,GACvCS,EAAcR,GAAYQ,EAAcvB,GACxCuB,EAActB,GAAasB,EAAcrB,GACzCqB,EAAcnB,GAAamB,EAAclB,GACzCkB,EAAcjB,GAAaiB,EAAchB,GACzCgB,EAAcP,GAAYO,EAAcN,GACxCM,EAAcL,GAAaK,EAAcJ,IAAa,EACtDI,EArDe,kBAqDWA,EAAczB,GACxCyB,EAAcf,IAAc,EAG5B,IAAIgB,EAA8B,iBAAVC,GAAsBA,GAAUA,EAAOC,SAAWA,QAAUD,EAGhFE,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKF,SAAWA,QAAUE,KAGxEC,EAAOL,GAAcG,GAAYG,SAAS,cAATA,GAGjCC,EAA4CC,IAAYA,EAAQC,UAAYD,EAG5EE,EAAaH,GAA4CI,IAAWA,EAAOF,UAAYE,EAGvFC,EAAgBF,GAAcA,EAAWF,UAAYD,EAUzD,SAASM,EAAYC,EAAKC,GAGxB,OADAD,EAAIE,IAAID,EAAK,GAAIA,EAAK,IACfD,CACR,CAUD,SAASG,EAAYD,EAAKzD,GAGxB,OADAyD,EAAIE,IAAI3D,GACDyD,CACR,CAsDD,SAASG,EAAYC,EAAOC,EAAUC,EAAaC,GACjD,IAAIC,GAAS,EACTC,EAASL,EAAQA,EAAMK,OAAS,EAKpC,IAHIF,GAAaE,IACfH,EAAcF,IAAQI,MAEfA,EAAQC,GACfH,EAAcD,EAASC,EAAaF,EAAMI,GAAQA,EAAOJ,GAE3D,OAAOE,CACR,CAwCD,SAASI,EAAanE,GAGpB,IAAIK,GAAS,EACb,GAAa,MAATL,GAA0C,mBAAlBA,EAAMoE,SAChC,IACE/D,KAAYL,EAAQ,GAC1B,CAAM,MAAOG,GAAK,CAEhB,OAAOE,CACR,CASD,SAASgE,EAAWd,GAClB,IAAIU,GAAS,EACT5D,EAASiE,MAAMf,EAAIgB,MAKvB,OAHAhB,EAAIiB,SAAQ,SAASxE,EAAOyE,GAC1BpE,IAAS4D,GAAS,CAACQ,EAAKzE,EAC5B,IACSK,CACR,CAUD,SAASqE,EAAQC,EAAMC,GACrB,OAAO,SAASC,GACd,OAAOF,EAAKC,EAAUC,GAC1B,CACC,CASD,SAASC,EAAWrB,GAClB,IAAIQ,GAAS,EACT5D,EAASiE,MAAMb,EAAIc,MAKvB,OAHAd,EAAIe,SAAQ,SAASxE,GACnBK,IAAS4D,GAASjE,CACtB,IACSK,CACR,CAGD,IASM0E,EATFC,EAAaV,MAAMW,UACnBC,EAAYnC,SAASkC,UACrBE,EAAcxC,OAAOsC,UAGrBG,EAAatC,EAAK,sBAGlBuC,GACEN,EAAM,SAASO,KAAKF,GAAcA,EAAWG,MAAQH,EAAWG,KAAKC,UAAY,KACvE,iBAAmBT,EAAO,GAItCU,GAAeP,EAAUd,SAGzBsB,GAAiBP,EAAYO,eAO7BC,GAAiBR,EAAYf,SAG7BwB,GAAaC,OAAO,IACtBJ,GAAaK,KAAKJ,IAAgBK,QAzQjB,sBAyQuC,QACvDA,QAAQ,yDAA0D,SAAW,KAI5EC,GAAS3C,EAAgBP,EAAKkD,YAASC,EACvCC,GAASpD,EAAKoD,OACdC,GAAarD,EAAKqD,WAClBC,GAAe1B,EAAQ/B,OAAO0D,eAAgB1D,QAC9C2D,GAAe3D,OAAO4D,OACtBC,GAAuBrB,EAAYqB,qBACnCC,GAASzB,EAAWyB,OAGpBC,GAAmB/D,OAAOgE,sBAC1BC,GAAiBZ,GAASA,GAAOa,cAAWZ,EAC5Ca,GAAapC,EAAQ/B,OAAO4C,KAAM5C,QAGlCoE,GAAWC,GAAUlE,EAAM,YAC3BmE,GAAMD,GAAUlE,EAAM,OACtBlD,GAAUoH,GAAUlE,EAAM,WAC1BoE,GAAMF,GAAUlE,EAAM,OACtBqE,GAAUH,GAAUlE,EAAM,WAC1BsE,GAAeJ,GAAUrE,OAAQ,UAGjC0E,GAAqBC,GAASP,IAC9BQ,GAAgBD,GAASL,IACzBO,GAAoBF,GAAS1H,IAC7B6H,GAAgBH,GAASJ,IACzBQ,GAAoBJ,GAASH,IAG7BQ,GAAczB,GAASA,GAAOjB,eAAYgB,EAC1C2B,GAAgBD,GAAcA,GAAYE,aAAU5B,EASxD,SAAS6B,GAAKC,GACZ,IAAI9D,GAAS,EACTC,EAAS6D,EAAUA,EAAQ7D,OAAS,EAGxC,IADA8D,KAAKC,UACIhE,EAAQC,GAAQ,CACvB,IAAIgE,EAAQH,EAAQ9D,GACpB+D,KAAKvE,IAAIyE,EAAM,GAAIA,EAAM,GAC1B,CACF,CAyFD,SAASC,GAAUJ,GACjB,IAAI9D,GAAS,EACTC,EAAS6D,EAAUA,EAAQ7D,OAAS,EAGxC,IADA8D,KAAKC,UACIhE,EAAQC,GAAQ,CACvB,IAAIgE,EAAQH,EAAQ9D,GACpB+D,KAAKvE,IAAIyE,EAAM,GAAIA,EAAM,GAC1B,CACF,CAuGD,SAASE,GAASL,GAChB,IAAI9D,GAAS,EACTC,EAAS6D,EAAUA,EAAQ7D,OAAS,EAGxC,IADA8D,KAAKC,UACIhE,EAAQC,GAAQ,CACvB,IAAIgE,EAAQH,EAAQ9D,GACpB+D,KAAKvE,IAAIyE,EAAM,GAAIA,EAAM,GAC1B,CACF,CAqFD,SAASG,GAAMN,GACbC,KAAKM,SAAW,IAAIH,GAAUJ,EAC/B,CA2FD,SAASQ,GAAcvI,EAAOwI,GAG5B,IAAInI,EAAUoI,GAAQzI,IAsrBxB,SAAqBA,GAEnB,OAmFF,SAA2BA,GACzB,OAmIF,SAAsBA,GACpB,QAASA,GAAyB,iBAATA,CAC1B,CArIQ0I,CAAa1I,IAAU2I,GAAY3I,EAC3C,CArFQ4I,CAAkB5I,IAAU0F,GAAeI,KAAK9F,EAAO,aAC1DwG,GAAqBV,KAAK9F,EAAO,WAAa2F,GAAeG,KAAK9F,IAAUY,EACjF,CA1rBiCiI,CAAY7I,GAljB9C,SAAmB8I,EAAGhF,GAIpB,IAHA,IAAIG,GAAS,EACT5D,EAASiE,MAAMwE,KAEV7E,EAAQ6E,GACfzI,EAAO4D,GAASH,EAASG,GAE3B,OAAO5D,CACR,CA2iBK0I,CAAU/I,EAAMkE,OAAQ8E,QACxB,GAEA9E,EAAS7D,EAAO6D,OAChB+E,IAAgB/E,EAEpB,IAAK,IAAIO,KAAOzE,GACTwI,IAAa9C,GAAeI,KAAK9F,EAAOyE,IACvCwE,IAAuB,UAAPxE,GAAmByE,GAAQzE,EAAKP,KACpD7D,EAAO8I,KAAK1E,GAGhB,OAAOpE,CACR,CAYD,SAAS+I,GAAYC,EAAQ5E,EAAKzE,GAChC,IAAIsJ,EAAWD,EAAO5E,GAChBiB,GAAeI,KAAKuD,EAAQ5E,IAAQ8E,GAAGD,EAAUtJ,UACxCiG,IAAVjG,GAAyByE,KAAO4E,KACnCA,EAAO5E,GAAOzE,EAEjB,CAUD,SAASwJ,GAAa3F,EAAOY,GAE3B,IADA,IAAIP,EAASL,EAAMK,OACZA,KACL,GAAIqF,GAAG1F,EAAMK,GAAQ,GAAIO,GACvB,OAAOP,EAGX,OAAQ,CACT,CA6BD,SAASuF,GAAUzJ,EAAO0J,EAAQC,EAAQC,EAAYnF,EAAK4E,EAAQQ,GACjE,IAAIxJ,EAIJ,GAHIuJ,IACFvJ,EAASgJ,EAASO,EAAW5J,EAAOyE,EAAK4E,EAAQQ,GAASD,EAAW5J,SAExDiG,IAAX5F,EACF,OAAOA,EAET,IAAKyJ,GAAS9J,GACZ,OAAOA,EAET,IAAI+J,EAAQtB,GAAQzI,GACpB,GAAI+J,GAEF,GADA1J,EA2XJ,SAAwBwD,GACtB,IAAIK,EAASL,EAAMK,OACf7D,EAASwD,EAAMmG,YAAY9F,GAG3BA,GAA6B,iBAAZL,EAAM,IAAkB6B,GAAeI,KAAKjC,EAAO,WACtExD,EAAO4D,MAAQJ,EAAMI,MACrB5D,EAAO4J,MAAQpG,EAAMoG,OAEvB,OAAO5J,CACR,CArYY6J,CAAelK,IACnB0J,EACH,OA6ON,SAAmBS,EAAQtG,GACzB,IAAII,GAAS,EACTC,EAASiG,EAAOjG,OAEpBL,IAAUA,EAAQS,MAAMJ,IACxB,OAASD,EAAQC,GACfL,EAAMI,GAASkG,EAAOlG,GAExB,OAAOJ,CACR,CAtPYuG,CAAUpK,EAAOK,OAErB,CACL,IAAIgK,EAAMC,GAAOtK,GACbuK,EAASF,GAAOtJ,GAAWsJ,GAAOrJ,EAEtC,GAAI6F,GAAS7G,GACX,OA0HN,SAAqBwK,EAAQd,GAC3B,GAAIA,EACF,OAAOc,EAAOC,QAEhB,IAAIpK,EAAS,IAAImK,EAAOR,YAAYQ,EAAOtG,QAE3C,OADAsG,EAAOE,KAAKrK,GACLA,CACR,CAjIYsK,CAAY3K,EAAO0J,GAE5B,GAAIW,GAAOlJ,GAAakJ,GAAOzJ,GAAY2J,IAAWlB,EAAS,CAC7D,GAAIlF,EAAanE,GACf,OAAOqJ,EAASrJ,EAAQ,GAG1B,GADAK,EA+XN,SAAyBgJ,GACvB,MAAqC,mBAAtBA,EAAOW,aAA8BY,GAAYvB,GAE5D,IAzVcwB,EAwVHzE,GAAaiD,GAvVrBS,GAASe,GAASvE,GAAauE,GAAS,CAAA,GADjD,IAAoBA,CA0VnB,CAnYcC,CAAgBP,EAAS,CAAE,EAAGvK,IAClC0J,EACH,OA6QR,SAAqBS,EAAQd,GAC3B,OAAO0B,GAAWZ,EAAQa,GAAWb,GAASd,EAC/C,CA/Qc4B,CAAYjL,EAhD3B,SAAoBqJ,EAAQc,GAC1B,OAAOd,GAAU0B,GAAWZ,EAAQ5E,GAAK4E,GAASd,EACnD,CA8CiC6B,CAAW7K,EAAQL,GAErD,KAAW,CACL,IAAKwC,EAAc6H,GACjB,OAAOhB,EAASrJ,EAAQ,GAE1BK,EA0YN,SAAwBgJ,EAAQgB,EAAKc,EAAWzB,GAC9C,IAAI0B,EAAO/B,EAAOW,YAClB,OAAQK,GACN,KAAK3I,EACH,OAAO2J,GAAiBhC,GAE1B,KAAKxI,EACL,KAAKC,EACH,OAAO,IAAIsK,GAAM/B,GAEnB,KAAK1H,EACH,OA3QN,SAAuB2J,EAAU5B,GAC/B,IAAIc,EAASd,EAAS2B,GAAiBC,EAASd,QAAUc,EAASd,OACnE,OAAO,IAAIc,EAAStB,YAAYQ,EAAQc,EAASC,WAAYD,EAASE,WACvE,CAwQYC,CAAcpC,EAAQK,GAE/B,KAAK9H,EAAY,KAAKC,EACtB,KAAKC,EAAS,KAAKC,EAAU,KAAKC,EAClC,KAAKC,EAAU,KAAKC,EAAiB,KAAKC,EAAW,KAAKC,EACxD,OA/MN,SAAyBsJ,EAAYhC,GACnC,IAAIc,EAASd,EAAS2B,GAAiBK,EAAWlB,QAAUkB,EAAWlB,OACvE,OAAO,IAAIkB,EAAW1B,YAAYQ,EAAQkB,EAAWH,WAAYG,EAAWxH,OAC7E,CA4MYyH,CAAgBtC,EAAQK,GAEjC,KAAKzI,EACH,OArQN,SAAkBsC,EAAKmG,EAAQyB,GAC7B,IAAItH,EAAQ6F,EAASyB,EAAU9G,EAAWd,IAAM,GAAQc,EAAWd,GACnE,OAAOK,EAAYC,EAAOP,EAAa,IAAIC,EAAIyG,YAChD,CAkQY4B,CAASvC,EAAQK,EAAQyB,GAElC,KAAKjK,EACL,KAAKK,EACH,OAAO,IAAI6J,EAAK/B,GAElB,KAAKhI,EACH,OAhQN,SAAqBwK,GACnB,IAAIxL,EAAS,IAAIwL,EAAO7B,YAAY6B,EAAO1B,OAAQ9H,EAAQiD,KAAKuG,IAEhE,OADAxL,EAAOyL,UAAYD,EAAOC,UACnBzL,CACR,CA4PY0L,CAAY1C,GAErB,KAAK/H,EACH,OApPN,SAAkBmC,EAAKiG,EAAQyB,GAC7B,IAAItH,EAAQ6F,EAASyB,EAAUrG,EAAWrB,IAAM,GAAQqB,EAAWrB,GACnE,OAAOG,EAAYC,EAAOH,EAAa,IAAID,EAAIuG,YAChD,CAiPYgC,CAAS3C,EAAQK,EAAQyB,GAElC,KAAK3J,EACH,OA3OeyK,EA2OI5C,EA1OhBzB,GAAgBjF,OAAOiF,GAAc9B,KAAKmG,IAAW,GAD9D,IAAqBA,CA6OpB,CA5acC,CAAelM,EAAOqK,EAAKZ,GAAWC,EAChD,CACF,CAEDG,IAAUA,EAAQ,IAAIxB,IACtB,IAAI8D,EAAUtC,EAAMuC,IAAIpM,GACxB,GAAImM,EACF,OAAOA,EAIT,GAFAtC,EAAMpG,IAAIzD,EAAOK,IAEZ0J,EACH,IAAIsC,EAAQ1C,EAsQhB,SAAoBN,GAClB,OAnOF,SAAwBA,EAAQiD,EAAUC,GACxC,IAAIlM,EAASiM,EAASjD,GACtB,OAAOZ,GAAQY,GAAUhJ,EApwB3B,SAAmBwD,EAAO2I,GAKxB,IAJA,IAAIvI,GAAS,EACTC,EAASsI,EAAOtI,OAChBuI,EAAS5I,EAAMK,SAEVD,EAAQC,GACfL,EAAM4I,EAASxI,GAASuI,EAAOvI,GAEjC,OAAOJ,CACR,CA2vBmC6I,CAAUrM,EAAQkM,EAAYlD,GACjE,CAgOQsD,CAAetD,EAAQ9D,GAAMyF,GACrC,CAxQwB4B,CAAW5M,GAASuF,GAAKvF,GAUhD,OA5vBF,SAAmB6D,EAAOC,GAIxB,IAHA,IAAIG,GAAS,EACTC,EAASL,EAAQA,EAAMK,OAAS,IAE3BD,EAAQC,IAC8B,IAAzCJ,EAASD,EAAMI,GAAQA,EAAOJ,KAKrC,CA0uBCgJ,CAAUR,GAASrM,GAAO,SAAS8M,EAAUrI,GACvC4H,IAEFS,EAAW9M,EADXyE,EAAMqI,IAIR1D,GAAY/I,EAAQoE,EAAKgF,GAAUqD,EAAUpD,EAAQC,EAAQC,EAAYnF,EAAKzE,EAAO6J,GACzF,IACSxJ,CACR,CAiDD,SAAS0M,GAAa/M,GACpB,SAAK8J,GAAS9J,KAyYE2E,EAzYiB3E,EA0YxBqF,GAAeA,KAAcV,MAvYvBqI,GAAWhN,IAAUmE,EAAanE,GAAU4F,GAAatD,GACzD2K,KAAK3F,GAAStH,IAqY/B,IAAkB2E,CApYjB,CA8CD,SAAS0G,GAAiB6B,GACxB,IAAI7M,EAAS,IAAI6M,EAAYlD,YAAYkD,EAAY1B,YAErD,OADA,IAAIrF,GAAW9F,GAAQoD,IAAI,IAAI0C,GAAW+G,IACnC7M,CACR,CA6GD,SAAS0K,GAAWZ,EAAQkC,EAAOhD,EAAQO,GACzCP,IAAWA,EAAS,CAAA,GAKpB,IAHA,IAAIpF,GAAS,EACTC,EAASmI,EAAMnI,SAEVD,EAAQC,GAAQ,CACvB,IAAIO,EAAM4H,EAAMpI,GAEZkJ,EAAWvD,EACXA,EAAWP,EAAO5E,GAAM0F,EAAO1F,GAAMA,EAAK4E,EAAQc,QAClDlE,EAEJmD,GAAYC,EAAQ5E,OAAkBwB,IAAbkH,EAAyBhD,EAAO1F,GAAO0I,EACjE,CACD,OAAO9D,CACR,CAiCD,SAAS+D,GAAW7J,EAAKkB,GACvB,IAqKiBzE,EACbqN,EAtKAC,EAAO/J,EAAI+E,SACf,OAsKgB,WADZ+E,SADarN,EApKAyE,KAsKmB,UAAR4I,GAA4B,UAARA,GAA4B,WAARA,EACrD,cAAVrN,EACU,OAAVA,GAvKDsN,EAAmB,iBAAP7I,EAAkB,SAAW,QACzC6I,EAAK/J,GACV,CAUD,SAASyD,GAAUqC,EAAQ5E,GACzB,IAAIzE,EAj8BN,SAAkBqJ,EAAQ5E,GACxB,OAAiB,MAAV4E,OAAiBpD,EAAYoD,EAAO5E,EAC5C,CA+7Ba8I,CAASlE,EAAQ5E,GAC7B,OAAOsI,GAAa/M,GAASA,OAAQiG,CACtC,CA9tBD6B,GAAK7C,UAAUgD,MAnEf,WACED,KAAKM,SAAWlB,GAAeA,GAAa,MAAQ,CAAA,CACrD,EAkEDU,GAAK7C,UAAkB,OAtDvB,SAAoBR,GAClB,OAAOuD,KAAKwF,IAAI/I,WAAeuD,KAAKM,SAAS7D,EAC9C,EAqDDqD,GAAK7C,UAAUmH,IA1Cf,SAAiB3H,GACf,IAAI6I,EAAOtF,KAAKM,SAChB,GAAIlB,GAAc,CAChB,IAAI/G,EAASiN,EAAK7I,GAClB,OAAOpE,IAAWK,OAAiBuF,EAAY5F,CAChD,CACD,OAAOqF,GAAeI,KAAKwH,EAAM7I,GAAO6I,EAAK7I,QAAOwB,CACrD,EAoCD6B,GAAK7C,UAAUuI,IAzBf,SAAiB/I,GACf,IAAI6I,EAAOtF,KAAKM,SAChB,OAAOlB,QAA6BnB,IAAdqH,EAAK7I,GAAqBiB,GAAeI,KAAKwH,EAAM7I,EAC3E,EAuBDqD,GAAK7C,UAAUxB,IAXf,SAAiBgB,EAAKzE,GAGpB,OAFWgI,KAAKM,SACX7D,GAAQ2C,SAA0BnB,IAAVjG,EAAuBU,EAAiBV,EAC9DgI,IACR,EAmHDG,GAAUlD,UAAUgD,MAjFpB,WACED,KAAKM,SAAW,EACjB,EAgFDH,GAAUlD,UAAkB,OArE5B,SAAyBR,GACvB,IAAI6I,EAAOtF,KAAKM,SACZrE,EAAQuF,GAAa8D,EAAM7I,GAE/B,QAAIR,EAAQ,KAIRA,GADYqJ,EAAKpJ,OAAS,EAE5BoJ,EAAKG,MAELhH,GAAOX,KAAKwH,EAAMrJ,EAAO,IAEpB,EACR,EAwDDkE,GAAUlD,UAAUmH,IA7CpB,SAAsB3H,GACpB,IAAI6I,EAAOtF,KAAKM,SACZrE,EAAQuF,GAAa8D,EAAM7I,GAE/B,OAAOR,EAAQ,OAAIgC,EAAYqH,EAAKrJ,GAAO,EAC5C,EAyCDkE,GAAUlD,UAAUuI,IA9BpB,SAAsB/I,GACpB,OAAO+E,GAAaxB,KAAKM,SAAU7D,IAAQ,CAC5C,EA6BD0D,GAAUlD,UAAUxB,IAjBpB,SAAsBgB,EAAKzE,GACzB,IAAIsN,EAAOtF,KAAKM,SACZrE,EAAQuF,GAAa8D,EAAM7I,GAO/B,OALIR,EAAQ,EACVqJ,EAAKnE,KAAK,CAAC1E,EAAKzE,IAEhBsN,EAAKrJ,GAAO,GAAKjE,EAEZgI,IACR,EAiGDI,GAASnD,UAAUgD,MA/DnB,WACED,KAAKM,SAAW,CACdoF,KAAQ,IAAI5F,GACZvE,IAAO,IAAK0D,IAAOkB,IACnBwF,OAAU,IAAI7F,GAEjB,EA0DDM,GAASnD,UAAkB,OA/C3B,SAAwBR,GACtB,OAAO2I,GAAWpF,KAAMvD,GAAa,OAAEA,EACxC,EA8CD2D,GAASnD,UAAUmH,IAnCnB,SAAqB3H,GACnB,OAAO2I,GAAWpF,KAAMvD,GAAK2H,IAAI3H,EAClC,EAkCD2D,GAASnD,UAAUuI,IAvBnB,SAAqB/I,GACnB,OAAO2I,GAAWpF,KAAMvD,GAAK+I,IAAI/I,EAClC,EAsBD2D,GAASnD,UAAUxB,IAVnB,SAAqBgB,EAAKzE,GAExB,OADAoN,GAAWpF,KAAMvD,GAAKhB,IAAIgB,EAAKzE,GACxBgI,IACR,EA+FDK,GAAMpD,UAAUgD,MApEhB,WACED,KAAKM,SAAW,IAAIH,EACrB,EAmEDE,GAAMpD,UAAkB,OAxDxB,SAAqBR,GACnB,OAAOuD,KAAKM,SAAiB,OAAE7D,EAChC,EAuDD4D,GAAMpD,UAAUmH,IA5ChB,SAAkB3H,GAChB,OAAOuD,KAAKM,SAAS8D,IAAI3H,EAC1B,EA2CD4D,GAAMpD,UAAUuI,IAhChB,SAAkB/I,GAChB,OAAOuD,KAAKM,SAASkF,IAAI/I,EAC1B,EA+BD4D,GAAMpD,UAAUxB,IAnBhB,SAAkBgB,EAAKzE,GACrB,IAAI4N,EAAQ5F,KAAKM,SACjB,GAAIsF,aAAiBzF,GAAW,CAC9B,IAAI0F,EAAQD,EAAMtF,SAClB,IAAKrB,IAAQ4G,EAAM3J,OAASzD,EAAmB,EAE7C,OADAoN,EAAM1E,KAAK,CAAC1E,EAAKzE,IACVgI,KAET4F,EAAQ5F,KAAKM,SAAW,IAAIF,GAASyF,EACtC,CAED,OADAD,EAAMnK,IAAIgB,EAAKzE,GACRgI,IACR,EAgcD,IAAIgD,GAAatE,GAAmBhC,EAAQgC,GAAkB/D,QAyhB9D,WACE,MAAO,EACR,EAlhBG2H,GAtQJ,SAAoBtK,GAClB,OAAO2F,GAAeG,KAAK9F,EAC5B,EAwXD,SAASkJ,GAAQlJ,EAAOkE,GAEtB,SADAA,EAAmB,MAAVA,EAAiBvD,EAAmBuD,KAE1B,iBAATlE,GAAqBuC,EAAS0K,KAAKjN,KAC1CA,GAAS,GAAKA,EAAQ,GAAK,GAAKA,EAAQkE,CAC5C,CAkCD,SAAS0G,GAAY5K,GACnB,IAAIoL,EAAOpL,GAASA,EAAMgK,YAG1B,OAAOhK,KAFqB,mBAARoL,GAAsBA,EAAKnG,WAAcE,EAG9D,CASD,SAASmC,GAAS3C,GAChB,GAAY,MAARA,EAAc,CAChB,IACE,OAAOc,GAAaK,KAAKnB,EAC/B,CAAM,MAAOxE,GAAK,CACd,IACE,OAAQwE,EAAO,EACrB,CAAM,MAAOxE,GAAK,CACf,CACD,MAAO,EACR,CAwDD,SAASoJ,GAAGvJ,EAAO8N,GACjB,OAAO9N,IAAU8N,GAAU9N,GAAUA,GAAS8N,GAAUA,CACzD,EAzOI/G,IAAYuD,GAAO,IAAIvD,GAAS,IAAIgH,YAAY,MAAQpM,GACxDsF,IAAOqD,GAAO,IAAIrD,KAAQhG,GAC1BrB,IAAW0K,GAAO1K,GAAQC,YAAcuB,GACxC8F,IAAOoD,GAAO,IAAIpD,KAAQ5F,GAC1B6F,IAAWmD,GAAO,IAAInD,KAAY1F,KACrC6I,GAAS,SAAStK,GAChB,IAAIK,EAASsF,GAAeG,KAAK9F,GAC7BoL,EAAO/K,GAAUc,EAAYnB,EAAMgK,iBAAc/D,EACjD+H,EAAa5C,EAAO9D,GAAS8D,QAAQnF,EAEzC,GAAI+H,EACF,OAAQA,GACN,KAAK3G,GAAoB,OAAO1F,EAChC,KAAK4F,GAAe,OAAOtG,EAC3B,KAAKuG,GAAmB,OAAOpG,EAC/B,KAAKqG,GAAe,OAAOnG,EAC3B,KAAKoG,GAAmB,OAAOjG,EAGnC,OAAOpB,CACX,GAsQA,IAAIoI,GAAUnE,MAAMmE,QA2BpB,SAASE,GAAY3I,GACnB,OAAgB,MAATA,GAqGT,SAAkBA,GAChB,MAAuB,iBAATA,GACZA,GAAS,GAAKA,EAAQ,GAAK,GAAKA,GAASW,CAC5C,CAxGyBsN,CAASjO,EAAMkE,UAAY8I,GAAWhN,EAC/D,CAgDD,IAAI6G,GAAWD,IAsLf,WACE,OAAO,CACR,EArKD,SAASoG,GAAWhN,GAGlB,IAAIqK,EAAMP,GAAS9J,GAAS2F,GAAeG,KAAK9F,GAAS,GACzD,OAAOqK,GAAOtJ,GAAWsJ,GAAOrJ,CACjC,CA0DD,SAAS8I,GAAS9J,GAChB,IAAIqN,SAAcrN,EAClB,QAASA,IAAkB,UAARqN,GAA4B,YAARA,EACxC,CA0DD,SAAS9H,GAAK8D,GACZ,OAAOV,GAAYU,GAAUd,GAAcc,GAtuB7C,SAAkBA,GAChB,IAAKuB,GAAYvB,GACf,OAAOvC,GAAWuC,GAEpB,IAAIhJ,EAAS,GACb,IAAK,IAAIoE,KAAO9B,OAAO0G,GACjB3D,GAAeI,KAAKuD,EAAQ5E,IAAe,eAAPA,GACtCpE,EAAO8I,KAAK1E,GAGhB,OAAOpE,CACR,CA2tBsD6N,CAAS7E,EAC/D,CAyCDjG,EAAAH,QA9VA,SAAmBjD,GACjB,OAAOyJ,GAAUzJ,GAAO,GAAM,EAC/B,oDCt3CDmO,EAASA,UAACC,OAAO,CACbC,eAAgB,EAAE,IAAK,KACvBC,cAAe,EACfC,eAAgB,WAGPC,EAAOC,EAAK,GACZC,EAAMD,EAAK,GACXE,EAAWF,EAAK,YAEb,SAAAG,EAAM3E,EAAkB4E,GACpC,MAAMC,EAAW,IAAIX,EAAAA,UAAUU,EAAczK,YACvC2K,EAAW,IAAIZ,EAASA,UAAC,IAAIa,IAAIF,GACvC,OAAO7E,EAAMgF,MAAMF,EACvB,CAEM,SAAUN,EAAKS,GACjB,OAAO,IAAIf,EAASA,UAACe,EAAI9K,WAC7B,CCnBO,MAAM+K,EAAQC,OAAO,GACfC,EAAOD,OAAO,GACdV,EAAMU,OAAO,uBAEpBE,EAAW,CAACC,EAAYC,KAC1B,IAAKD,EAAG,MAAM,IAAIE,MAAMD,EAAQ,EAO9B,SAAUE,EAAsBC,GAElC,MAAMC,EAAqBR,OAAO,IAAMO,EACxC,OAAOjB,EAAMU,OAAO,KAAOQ,CAC/B,OAoFaC,EAaTC,WAAWC,EAAWR,GAClB,MAAMS,EAAID,EAAIR,EAEd,OADAD,EAAUC,GAAK,GAAKS,GAAKD,GAAOR,EAAI,GAAKS,EAAID,EAAI,uBAC1CC,CACV,CAKDF,WAAWC,EAAWR,GAClBD,EAASC,GAAKQ,EAAG,uBAEjB,OADUA,EAAIR,CAEjB,CAcDO,WAAWC,EAAWR,GAClB,OAAOQ,GAAKR,EAAIQ,EAAIR,CACvB,CAKDO,WAAWC,EAAWR,GAClB,OAAOQ,EAAIR,EAAIQ,EAAIR,CACtB,CAEDO,WAAWC,EAAWR,GAClB,MAAMS,EAAID,EAAIR,EAEd,OADAD,EAASS,GAAKZ,GAASa,EAAID,GAAKR,EAAG,uBAC5BS,CACV,CAEDF,WAAWC,EAAWR,EAAWU,GAC7B,OAAOA,EAAUjI,KAAKkI,MAAMH,EAAGR,GAAKvH,KAAKmI,QAAQJ,EAAGR,EACvD,CAEDO,eAAeC,EAAWR,GAEtB,OADAD,EAASC,GAAKJ,EAAO,wBACdY,EAAIR,CACd,CAEDO,aAAaC,EAAWR,GAGpB,OAFAD,EAASC,GAAKJ,EAAO,wBAEjBY,GAAKZ,EACEA,EAEAE,GAAQU,EAAIV,GAAQE,CAElC,CAMDO,kBAAkBC,EAAWR,GACzB,MAAMa,EAAUL,EAAIR,EAGpB,OAFAD,EAASS,GAAKZ,GAASiB,EAAUL,GAAKR,EAAG,uBAErCa,GAAWjB,EACJA,GAQCiB,EAAUf,GAAQrH,KAAK0G,IAAMW,CAE5C,CAIDS,oBAAoBC,EAAWR,GAE3B,GADAD,EAASC,GAAKJ,EAAO,wBACjBY,GAAKZ,EACL,OAAOA,EAKP,OAHkBY,EAAI/H,KAAK0G,IAGRa,CAE1B,CAGDO,kBAAkBC,EAAWR,GAGzB,GAFAD,EAASC,GAAKJ,EAAO,wBAEjBY,GAAKZ,EACL,OAAOA,EACJ,CACH,MAAMkB,EAAYN,EAAI/H,KAAK0G,IAS3B,OARAY,EAASe,EAAYN,GAAK/H,KAAK0G,IAAK,wBAQ5B2B,EAAYhB,GAAQE,EAAIF,CACnC,CACJ,CAGDS,kBAAkBQ,EAAWC,GACzB,MAAMC,EAAMC,EAAWzB,IAAIsB,EAAGC,GACxBG,EAAW1I,KAAKrE,IAClBqE,KAAK2I,WAAWH,EAAKxI,KAAK4I,wBAC1BvB,GAGJ,OAAOrH,KAAKrE,IAAI6M,EAAKE,EACxB,CAEDZ,eAAeQ,EAAWC,GACtB,MAAMC,EAAMC,EAAWzB,IAAIsB,EAAGC,GACxBG,EAAW1I,KAAKrE,IAClBqE,KAAK2I,WAAWH,EAAKxI,KAAK4I,wBAC1BvB,GAEJ,OAAOrH,KAAK6I,IAAIL,EAAKE,EACxB,CAGDZ,uBAAuBQ,GACnB,OAAOA,EAAItI,KAAK0G,IAAM1G,KAAK0G,IAAM4B,EAAInB,CACxC,CAGDW,oBAAoBC,EAAWR,GAC3B,MAAMa,EAAUL,EAAIR,EAGpB,OAFAD,EAASS,GAAKZ,GAASiB,EAAUL,GAAKR,EAAG,uBAElCa,EAAUpI,KAAK0G,GACzB,EArFMmB,EAAAnB,IAAMU,OAAO,uBACbS,EAAAe,uBAAyBxB,OAAO,KAuF3C,MAAMqB,EA+DFX,WAAWQ,EAAWC,GAClB,GAAIA,IAAMpB,EAEN,OAAOnH,KAAK8I,OAGhB,GAAIR,GAAKnB,EACL,OAAOA,EAQXG,EACIgB,EACIlB,OACI,iFAER,0BAEJ,MAAM2B,EAAWT,EAMjBhB,EAASiB,EAAIvI,KAAKgJ,oBAAqB,0BACvC,MAAMC,EAAWV,EAEjB,IAAIW,EACJ,GACIlJ,KAAKmJ,kBAAoBJ,GACzBA,EAAW/I,KAAKoJ,kBAClB,CACE,MAAMC,EAAUrJ,KAAKsJ,OAAOP,GAM5BG,EACKG,EAAUrJ,KAAK8I,OAAUG,EACxBI,EAAUrJ,KAAK8I,OAAUG,EAAYjJ,KAAK8I,MACnD,MACGI,EAAelJ,KAAKuJ,IAAIR,GAAYE,EAYxC,OAVAC,GAAgBlJ,KAAK8I,OAGrBxB,EACItH,KAAKwJ,sBAAwBN,GACzBA,GAAgBlJ,KAAKyJ,qBACzB,gCAIGzJ,KAAK0J,IAAIR,EACnB,CAEDpB,WAAWQ,GAMP,GALAhB,EACIgB,GAAKtI,KAAKwJ,sBAAwBlB,GAAKtI,KAAKyJ,qBAC5C,2BAGAnB,EAAI,EAIJ,OAAQtI,KAAK8I,OAAS9I,KAAK8I,OAAU9I,KAAK0J,IAAItC,QAAQ,GAAKkB,GAoB/D,IAAIqB,EACArB,GAAKtI,KAAK4J,IACVtB,GAAKtI,KAAK4J,GACVD,EAAU3J,KAAK6J,IACRvB,GAAKtI,KAAK8J,IACjBxB,GAAKtI,KAAK8J,GACVH,EAAU3J,KAAK+J,IAEfJ,EAAUvC,OAAO,GAKrBkB,GAAKlB,OAAO,KAIZ,IAAIgB,EAAUpI,KAAKgK,OAEf1B,GAAKtI,KAAKiK,KACV3B,GAAKtI,KAAKiK,GACV7B,EAAWA,EAAUpI,KAAKkK,GAAMlK,KAAKgK,QAErC1B,GAAKtI,KAAKmK,KACV7B,GAAKtI,KAAKmK,GACV/B,EAAWA,EAAUpI,KAAKoK,GAAMpK,KAAKgK,QAErC1B,GAAKtI,KAAKqK,KACV/B,GAAKtI,KAAKqK,GACVjC,EAAWA,EAAUpI,KAAKsK,GAAMtK,KAAKgK,QAErC1B,GAAKtI,KAAKuK,KACVjC,GAAKtI,KAAKuK,GACVnC,EAAWA,EAAUpI,KAAKwK,GAAMxK,KAAKgK,QAErC1B,GAAKtI,KAAKyK,KACVnC,GAAKtI,KAAKyK,GACVrC,EAAWA,EAAUpI,KAAK0K,GAAM1K,KAAKgK,QAErC1B,GAAKtI,KAAK2K,KACVrC,GAAKtI,KAAK2K,GACVvC,EAAWA,EAAUpI,KAAK4K,GAAM5K,KAAKgK,QAErC1B,GAAKtI,KAAK6K,KACVvC,GAAKtI,KAAK6K,GACVzC,EAAWA,EAAUpI,KAAK8K,GAAM9K,KAAKgK,QAErC1B,GAAKtI,KAAK+K,KACVzC,GAAKtI,KAAK+K,GACV3C,EAAWA,EAAUpI,KAAKgL,GAAMhL,KAAKgK,QAQzC,IACIiB,EADAC,EAAYlL,KAAKgK,OAkDrB,OA9CAiB,EAAO3C,EACP4C,GAAaD,EAKbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,GACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,IACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,IACzC8D,GAAaD,EAEbA,EAAQA,EAAO3C,EAAKtI,KAAKgK,OAAS5C,OAAO,IACzC8D,GAAaD,EASH7C,EAAU8C,EAAalL,KAAKgK,OAAUL,EAAWvC,OAAO,IACrE,CAEDU,cAAcQ,GAYV,MAAM6C,IAPN7C,GAAKtI,KAAK8I,QAOM9I,KAAKoL,QAAUpL,KAAKoL,QAAW9C,EAAItI,KAAKoL,QAClDC,EAAaF,EAAIA,EAAKnL,KAAKoL,OAGjC,IAAIE,EAAMH,EAGND,EAAYI,EA2BhB,OAxBAA,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,IAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,IAE1BkE,EAAOA,EAAMD,EAAarL,KAAKoL,OAC/BF,GAAaI,EAAMlE,OAAO,IAKnB8D,EAAY9D,OAAO,EAC7B,CAKDU,WAAWC,GACP,GAAIA,EAAI/H,KAAK8I,OAIT,OAAO1B,QAAQ,GAAKpH,KAAKuJ,IAAKvJ,KAAK8I,OAAS9I,KAAK8I,OAAUf,GAkB/D,IAAIwD,EAAMpE,EACNY,GAAK/H,KAAK6J,GAAK7J,KAAK8I,SACpBf,GAAK/H,KAAK6J,GACV0B,GAAOvL,KAAK4J,IAGZ7B,GAAK/H,KAAK+J,GAAK/J,KAAK8I,SACpBf,GAAK/H,KAAK+J,GACVwB,GAAOvL,KAAK8J,IAIhByB,GAAOnE,OAAO,MACdW,GAAKX,OAAO,OAIHpH,KAAKkK,KACVnC,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKkK,GAC7BqB,GAAOvL,KAAKiK,IAGZlC,GAAK/H,KAAKoK,KACVrC,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKoK,GAC7BmB,GAAOvL,KAAKmK,IAGZpC,GAAK/H,KAAKsK,KACVvC,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKsK,GAC7BiB,GAAOvL,KAAKqK,IAGZtC,GAAK/H,KAAKwK,KACVzC,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKwK,GAC7Be,GAAOvL,KAAKuK,IAGZxC,GAAK/H,KAAK0K,KACV3C,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAK0K,GAC7Ba,GAAOvL,KAAKyK,IAGZ1C,GAAK/H,KAAK4K,KACV7C,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAK4K,GAC7BW,GAAOvL,KAAK2K,IAGZ5C,GAAK/H,KAAK8K,KACV/C,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAK8K,GAC7BS,GAAOvL,KAAK6K,IAGZ9C,GAAK/H,KAAKgL,KACVjD,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKgL,GAC7BO,GAAOvL,KAAK+K,IAGZhD,GAAK/H,KAAKwL,MACVzD,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAKwL,IAC7BD,GAAOvL,KAAKyL,KAGZ1D,GAAK/H,KAAK0L,MACV3D,EAAKA,EAAI/H,KAAKgK,OAAUhK,KAAK0L,IAC7BH,GAAOvL,KAAK2L,KAUhB,MAAMR,GAAMpD,EAAI/H,KAAKgK,QAAUhK,KAAKgK,QAAWjC,EAAI/H,KAAKgK,QAClDqB,EAAaF,EAAIA,EAAKnL,KAAKgK,OAGjC,IAAIsB,EAAMH,EAGND,EAAYI,EA2BhB,OAxBAA,EAAOA,EAAMD,EAAarL,KAAKgK,OAC/BkB,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKgK,OAC/BkB,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKgK,OAC/BkB,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKgK,OAC/BkB,GAAaI,EAAMlE,OAAO,GAE1BkE,EAAOA,EAAMD,EAAarL,KAAKgK,OAC/BkB,GAAaI,EAAMlE,OAAO,IAK1B8D,GAAa9D,OAAO,IAMZmE,EAAML,GAAa9D,OAAO,IACrC,EA3bMqB,EAAAK,OAAS1B,OAAO,uBAIhBqB,EAAAuB,OAAS5C,OAAO,yBAChBqB,EAAA2C,OAAShE,OAAO,yCAShBqB,EAAAgB,qBAAuBrC,OAAO,yBAC9BqB,EAAAe,qBAAuBpC,OAAO,yBAI9BqB,EAAAU,kBACH/B,OAAOqB,EAAWK,QAAU1B,OAAO,sBAChCqB,EAAAW,kBACHhC,OAAOqB,EAAWK,QAAU1B,OAAO,sBAEhCqB,EAAAO,oBACH5B,OAAO,IAAMA,OAAO,KAAOqB,EAAWuB,OAGnCvB,EAAAmB,GAAKxC,OAAO,yBACZqB,EAAAoB,GAAKzC,OACR,4DAEGqB,EAAAqB,GAAK1C,OAAO,wBACZqB,EAAAsB,GAAK3C,OAAO,gCAGZqB,EAAAwB,GAAK7C,OAAO,0BACZqB,EAAAyB,GAAK9C,OAAO,sCACZqB,EAAA0B,GAAK/C,OAAO,0BACZqB,EAAA2B,GAAKhD,OAAO,+BACZqB,EAAA4B,GAAKjD,OAAO,yBACZqB,EAAA6B,GAAKlD,OAAO,4BACZqB,EAAA8B,GAAKnD,OAAO,yBACZqB,EAAA+B,GAAKpD,OAAO,0BACZqB,EAAAgC,GAAKrD,OAAO,yBACZqB,EAAAiC,GAAKtD,OAAO,yBACZqB,EAAAkC,GAAKvD,OAAO,yBACZqB,EAAAmC,GAAKxD,OAAO,yBACZqB,EAAAoC,GAAKzD,OAAO,wBACZqB,EAAAqC,GAAK1D,OAAO,yBACZqB,EAAAsC,GAAK3D,OAAO,wBACZqB,EAAAuC,GAAK5D,OAAO,yBACZqB,EAAAgD,IAAMrE,OAAO,wBACbqB,EAAA+C,IAAMpE,OAAO,yBACbqB,EAAAkD,IAAMvE,OAAO,uBACbqB,EAAAiD,IAAMtE,OAAO,yBC1TjB,MAAMwE,EAAgB,CAACC,EAAkBC,IAC5CC,EAAAA,WAAWF,KAAcE,EAAAA,WAAWD,YAIxBE,EAAehU,EAAeiU,EAAW,GACrD,MAAOC,EAASC,GAAYnU,EAAMoU,MAAM,KACxC,IAAKD,EACD,OAAOE,EAAUA,WAACrU,EAAOiU,GAE7B,MAAMK,EAAYJ,EAAU,IAAMC,EAAS1J,MAAM,EAAGwJ,GACpD,OAAOI,EAAUA,WAACC,EAAWL,EACjC,CAGO,MAAMM,EACTC,UAGA,OAAOH,aAAWG,EAAMC,QAAS,IAC5BC,IAAIL,EAAAA,WAA0B,QAAfM,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,KACvCE,IAAInG,EAAAA,aACJoG,UAAU,EAINC,EAAkB,CAC3BC,EACAR,WAGA,MAAMS,EAAgBvF,EAAsBN,OAAOoF,EAAMP,WACzD,OAAO9F,EAAAA,UAAU+G,KDrBL,SAASF,EAAgBC,GAKrC,OAAOpF,EAAQsF,aAAaH,EAAQC,EACxC,CCe0BG,CAASJ,EAAQC,GAAe7Q,YACjDsQ,IAAIL,EAAAA,WAA0B,QAAfM,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,KACvCE,IAAInG,EAAAA,aACJoG,UAAU,EAINO,EAAoB,CAC7BL,EACAR,WAOA,ODPY,SAAeQ,EAAgBC,GAC3C,OAAOpF,EAAQyF,aAAaN,EAAQC,EACxC,CCKWM,CAHFP,EAASQ,EACVpG,OAAOiF,EAAUA,WAAgB,QAAfM,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,IAAIvQ,YAC5BsL,EAAsBN,OAAOoF,EAAMP,WACJ,ECzCzD,IAAYwB,EAKAC,EAqKAC,EA1KAF,QAGXA,eAAA,GAHWA,EAAAA,oBAAAA,QAAAA,UAGX,CAAA,IAFGA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,eAGQC,QAUXA,eAAA,GAVWA,EAAAA,oBAAAA,QAAAA,UAUX,CAAA,IATGA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,GAAA,GAAA,KA4JQC,QA0BXA,gBAAA,GA1BWA,EAAAA,QAAUA,aAAVA,mBA0BX,CAAA,IAzBG,IAAA,MACAA,EAAA,SAAA,WACAA,EAAA,OAAA,SACAA,EAAA,WAAA,aACAA,EAAA,uBAAA,yBACAA,EAAA,WAAA,aACAA,EAAA,QAAA,UACAA,EAAA,cAAA,gBACAA,EAAA,iBAAA,mBACAA,EAAA,MAAA,QACAA,EAAA,MAAA,QACAA,EAAA,MAAA,QAEAA,EAAA,WAAA,aACAA,EAAA,OAAA,SACAA,EAAA,YAAA,cACAA,EAAA,cAAA,gBACAA,EAAA,YAAA,cACAA,EAAA,cAAA,gBACAA,EAAA,YAAA,cACAA,EAAA,aAAA,eACAA,EAAA,WAAA,aACAA,EAAA,WAAA,aACAA,EAAA,YAAA,cC/MJ,MAAMC,EAAsBxG,OAAO,uBAOnB,SAAAyG,EACZC,EACAC,EACAC,EACAC,EACAC,EACAC,GAGAD,EA0BJ,SAAqBlB,EAAgBmB,GACjC,MAAMC,EAAYvG,EAAQc,WAAWqE,EAAQmB,GAC7C,OAAOnB,EAASoB,CACpB,CA7BeC,CAAYH,EAAUC,GACjC,MAAMG,EAAWzG,EAAQyF,aAAaS,EAAUE,GAC1CM,EAAc1G,EAAQlM,IAAImS,EAAWI,GACrCM,EAAO3G,EAAQ4G,WAAWX,EAAWS,GACrCG,EAAQ7G,EAAQ8G,WAAWH,EAAMF,GACvC,OAAOzG,EAAQsF,aAAaa,EAAYnG,EAAQ+G,gBAAgBF,GACpE,CAIgB,SAAAG,EACZf,EACAC,EACAC,EACAC,EACAa,EACAX,GAEA,MAAMK,EAAO3G,EAAQ4G,WAAWT,EAAYA,EAAac,GACnDR,EAAWzG,EAAQ4G,WAAWR,EAAWF,GACzCW,EAAQ7G,EAAQ8G,WAAWH,EAAMF,GACjCS,EAAQlH,EAAQgB,IAAI6F,EAAO7G,EAAQnB,KAEzC,OAQJ,SAAgBsG,EAAgBmB,GAC5B,OAAOtG,EAAQ4G,WAAWzB,EAAQnF,EAAQ+G,gBAAgBT,GAC9D,CAVWa,CADUnH,EAAQc,WAAWmF,EAAWiB,GACvBZ,EAC5B,CAmFM,SAAUc,EACZC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAuB,IAAIjT,MAAc8S,EAAUlT,QAEzD,IAAIsT,EAAyBrI,EAC7B,IAAK,IAAIsI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCF,EAAqBE,GAAK5H,EAAQyF,aAC9BzF,EAAQlM,IAAIuT,EAASO,GAAIL,EAAUK,IACnCP,EAASO,IAEbD,EAAyB3H,EAAQlM,IAC7B6T,EACA3H,EAAQsF,aAAaoC,EAAqBE,GAAIN,EAAkBM,KAIxE,IAAIC,EAAiB7H,EAAQnB,IAC7B,IAAK,IAAI+I,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CACtC,IAAIE,EAEJ,GAAIJ,EAAqBE,GAAKD,EAAwB,CAClD,MAAMI,EAAmB/H,EAAQsF,aAC7B+B,EAASO,GACT5H,EAAQgB,IAAI2G,EAAwB3H,EAAQnB,MAE1CmJ,EAAgBhI,EAAQgB,IAAIuG,EAAUK,GAAIG,GAC1CE,EAAUjI,EAAQc,WACpBkH,EACAP,GAEJK,EAAqB9H,EAAQlM,IACzBiU,EACA/H,EAAQgB,IAAIgH,EAAeC,GAElC,MACGH,EAAqBP,EAAUK,GAGnC,MAAMM,EAAelI,EAAQyF,aACzBzF,EAAQlM,IAAIuT,EAASO,GAAIE,GACzBT,EAASO,IAGbC,EAAiB7H,EAAQsF,aACrBuC,EACA7H,EAAQmI,QAAQD,EAAcZ,EAAkBM,IAEvD,CAED,OAAIC,EAAiB7H,EAAQnB,IAClBmB,EAAQsF,aACXkC,EACAxH,EAAQgB,IAAI6G,EAAgB7H,EAAQnB,MAGjCS,CAEf,UAEgB8I,EACZf,EACAgB,EACAC,GAcA,MAAMC,EAAWvI,EAAQyF,aAAa4C,EAAaC,GAE7CE,EAAa,IAAI/T,MAAc4S,EAAShT,QAC9C,IAAK,IAAIuT,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCY,EAAWZ,GAAK5H,EAAQsF,aAAa+B,EAASO,GAAIW,GAGtD,OAAOC,CACX,CAEM,SAAUC,EACZ7D,EACA8D,EACAL,EACAb,EACAC,GAcA,MAAMI,EAAiB7H,EAAQ4G,WAC3B5G,EAAQgB,IAAIwG,EAAgBa,GAC5Bb,GAGEU,EAAelI,EAAQ8G,WACzBe,EACA7H,EAAQyF,aAAazF,EAAQnB,IAAK6J,IAIhCC,EAAsB3I,EAAQsF,aAChCV,EACA5E,EAAQ+G,gBAAgBmB,IAQtBF,EAAgBhI,EAAQc,WAC1B6H,EACA3I,EAAQ+G,gBAAgB2B,IAEtBX,EAAmB/H,EAAQgB,IAAI2H,EAAqBX,GACpDC,EAAUjI,EAAQc,WAAWkH,EAAeP,GAKlD,OAJkBzH,EAAQlM,IACtBiU,EACA/H,EAAQgB,IAAIgH,EAAeC,GAGnC,CAEM,SAAUW,EACZvB,EACAC,EACAkB,EACAhB,EACAC,GAGA,MAAMoB,EAA0B,IAAIpU,MAAc+T,EAAWnU,QAE7D,IAAIyU,EAA4BxJ,EAChC,IAAK,IAAIsI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCiB,EAAwBjB,GAAK5H,EAAQ4G,WACjC5G,EAAQgB,IAAIqG,EAASO,GAAIY,EAAWZ,IACpCP,EAASO,IAEbkB,EAA4B9I,EAAQlM,IAChCgV,EACA9I,EAAQc,WAAW+H,EAAwBjB,GAAIN,EAAkBM,KAIzE,MAAMC,EAoEV,SACIR,EACAC,EACAkB,EACAK,EACAC,EACArB,GAEA,IAAII,EAAiB7H,EAAQnB,IAE7B,IAAK,IAAI+I,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAItC,IAAImB,EACJ,GAAID,EAA4BD,EAAwBjB,GAAI,CACxD,MAAMG,EAAmB/H,EAAQsF,aAC7B+B,EAASO,GACT5H,EAAQ+G,gBAAgB+B,IAEtBd,EAAgBhI,EAAQgB,IAAIwH,EAAWZ,GAAIG,GAC3CiB,EAAwBhJ,EAAQ4G,WAClCoB,EACAhI,EAAQ+G,gBAAgBU,IAG5BsB,EAAmB/I,EAAQlM,IACvBiU,EACAiB,EAEP,MACGD,EAAmBP,EAAWZ,GAGlC,MAAMM,EAAelI,EAAQyF,aACzBzF,EAAQgB,IAAIqG,EAASO,GAAImB,GACzB1B,EAASO,IAGbC,EAAiB7H,EAAQsF,aACrBuC,EACA7H,EAAQmI,QAAQD,EAAcZ,EAAkBM,IAEvD,CACD,OAAOC,CACX,CAjH2BoB,CACnB5B,EACAC,EACAkB,EACAK,EACAC,EACArB,GAGJ,OAAOzH,EAAQc,WACX0G,EACAxH,EAAQ+G,gBAAgBc,GAEhC,CAEO,MAAMqB,EAA+B,CACxCtE,EACA8D,EACAS,EACA3B,EACAS,KAcA,MAAMJ,EAAiB7H,EAAQ4G,WAC3B5G,EAAQlM,IAAI0T,EAAgB2B,GAC5B3B,GAEJ,GAAIK,EAAiB9B,EACjB,MAAM,IAAInG,MAAM,4BAIpB,MAAMsI,EAAelI,EAAQ8G,WACzBe,EACA7H,EAAQ4G,WAAW5G,EAAQnB,IAAK6J,IAE9BZ,EAAqB9H,EAAQc,WAC/B8D,EACA5E,EAAQgB,IAAIkH,EAAclI,EAAQnB,MAGhCuK,EAAoBpJ,EAAQ+G,gBAAgB2B,GAC5CV,EAAgBhI,EAAQc,WAC1BgH,EACAsB,GAEErB,EAAmB/H,EAAQgB,IAAI8G,EAAoBE,GAEzD,OAAOhI,EAAQlM,IACXiU,EACA/H,EAAQ4G,WAAWoB,EAAehI,EAAQ+G,gBAAgBkB,IAC7D,EA8HW,SAAAoB,EACZlE,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDC,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD4D,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KACpD2D,EAAK5E,EAAO6E,WACZC,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACvD,OAAOrJ,GAEE2K,EAAKO,GACLH,IAAO,EAAIM,IAAMV,GAAMQ,EAAKR,EAAKQ,EAAKE,OAASJ,EAAKC,GAAMA,GAAMD,GAG7E,CAIgB,SAAAK,EACZ/E,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDC,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD4D,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KAG1D,OAAOxH,GAEE2K,GAAMI,IAJJxE,EAAO6E,WAISL,OAAUE,EAAKC,GAAMD,GAAMC,GAC7CH,IAAO,EAJNH,WAAWC,EAAWA,YAACH,EAAarB,QAAS,MAI9B4B,GAG7B,CAIgB,SAAAM,EACZhF,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CU,EAAOZ,WACTC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDC,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD6D,EAAK5E,EAAO6E,WACZC,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACvD,OAAOrJ,EACF2K,IAAOQ,EAAKR,EAAKQ,EAAKE,IAAM,EAAIJ,IAAON,KAAQ,EAAIM,IAC/CO,GAAQ,EAAIH,IAAM,EAAIJ,IAAOA,GAE1C,CA0BgB,SAAAQ,EACZlF,EACAmE,GAEA,MAAMc,EAAOZ,WACTC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDE,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KAG1D,OAAOxH,GACD,EAHQuG,EAAO6E,WAGHI,OAAY,EAAIN,GAAMA,GAChCM,GACC,EAJCZ,WAAWC,EAAAA,YAAYH,EAAarB,YAI3B,EAAI6B,IACfA,EACAH,EAEZ,CAIgB,SAAAW,EACZnF,EACAmE,GAEA,MAAMc,EAAOZ,WAAWC,EAAWA,YAACH,EAAarD,UAAW,KACtD0D,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDE,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KACpDmE,EAAKpF,EAAO6E,WACZC,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACvD,OAAOrJ,EACFwL,GACI,EAAIH,IAAM,EAAIH,IACfA,GACC,EAAKS,IAAO,EAAIN,EAAIA,EAAIH,GAAOH,MAAS,EAAIG,GAC7CH,EAEZ,CAIgB,SAAAa,EACZrF,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CU,EAAOZ,WAAWC,EAAWA,YAACH,EAAanD,WAAY,KACvD0D,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnDuE,EAAQtF,EAAO6E,WAErB,OAAOpL,IACA6L,EAAQL,GAAQA,KAAU,EAAIP,GAAMN,IACjCkB,EAAQL,IAAS,EAHjBZ,WAAWC,EAAWA,YAACH,EAAarB,QAAS,OAGlB,EAAI4B,IAAOA,GAEpD,CAQgB,SAAAa,EACZvF,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDC,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD4D,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KACpD2D,EAAK5E,EAAO6E,WAElB,OAAOpL,GAAMiL,EAAKC,IAAOH,GAAMJ,GAAMQ,EAAKR,EAAKQ,EADrCP,WAAWC,EAAWA,YAACH,EAAarB,QAAS,SACK4B,EAAKC,GAAMD,GAC3E,CAIgB,SAAAc,EACZxF,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDC,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD4D,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KACpDmE,EAAKpF,EAAO6E,WAElB,OAAOpL,GAEE2K,GAAMI,IAAOY,EAAKZ,MAASG,EAAKD,GAAMC,GAAMD,EAAKC,KAChDS,EAAKZ,IAAO,IAAM,EAJlBH,WAAWC,EAAWA,YAACH,EAAarB,QAAS,MAIlB4B,GAAM,GAG/C,CAIgB,SAAAe,EACZzF,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CU,EAAOZ,WAAWC,EAAWA,YAACH,EAAanD,WAAY,KACvD0D,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnD6D,EAAK5E,EAAO6E,WAElB,OAAOpL,KACC,EAAIiL,IAAOO,IAASL,EAAKR,EAAKQ,EAF5BP,WAAWC,EAAWA,YAACH,EAAarB,QAAS,OAEN,EAAI4B,IAAON,IAAOM,EAAKA,GAE5E,CA2BgB,SAAAgB,EACZ1F,EACAmE,GAEA,MAAMc,EAAOZ,WAAWC,EAAWA,YAACH,EAAarD,UAAW,KACtD0D,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDE,EAAKN,WAAWC,EAAWA,YAACH,EAAalD,UAAW,KACpD0E,EAAQ3F,EAAO6E,WAErB,OAAOpL,IAEG,EAHA4K,WAAWC,EAAWA,YAACH,EAAarB,QAAS,OAGnC,EAAI6B,MAAS,EAAIA,KAC3B,EAAIgB,EAAQV,KAAU,EAAIN,GAAMH,GAG9C,KCzrBKoB,mIDsYC,SACFC,EACAC,EACAC,EACAC,GAIA,MAAMC,EAASpL,EAAQyF,aAAayF,EAAkBD,GAKtD,GAAIG,GAAUpL,EAAQnB,IAClB,OAAOS,EAgBX,MAAM+L,EAAIrL,EAAQyF,aACdzF,EAAQsF,aAAa6F,EAA2BC,EAASpL,EAAQnB,KACjEuM,GAEEE,EAAYtL,EAAQsF,aAAa0F,EAAaK,GAC9C3E,EAAc1G,EAAQ+G,gBAAgBsE,GAE5C,OAAO3E,GAAepH,EAChBA,EACAU,EAAQyF,aAAa6F,EAAW5E,EAC1C,wJAhEgB,SACZY,EACAD,GASA,IAAIkE,EAAYvL,EAAQnB,IACxB,IAAK,IAAI+I,EAAI,EAAGA,EAAIN,EAAkBjT,OAAQuT,IAC1C2D,EAAYvL,EAAQsF,aAChBiG,EACAvL,EAAQmI,QAAQd,EAASO,GAAIN,EAAkBM,KAIvD,GAAI2D,EAAY,EAAG,MAAM3L,MAAM,0BAE/B,OAAO2L,CACX,qDAyTgB,SACZpG,EACAmE,GAEA,MAAMc,EAAOZ,WAAWC,EAAWA,YAACH,EAAarD,UAAW,KACtD0D,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDE,EAAKN,WAAWC,EAAAA,YAAYH,EAAalD,YACzCmE,EAAKpF,EAAO6E,WACZC,EAAIT,WAAWC,EAAAA,YAAYH,EAAarB,UAC9C,OAAOrJ,GAEEwL,GACI,EAAIH,IAAM,EAAIH,KAAQ,IACrB,EAAIA,GACNA,GACC,EAAKS,IAAO,EAAIN,EAAIA,EAAIH,GAAOH,MAAS,EAAIG,GACjDH,GAAM,EAGlB,sNAjEgB,SACZxE,EACAmE,GAEA,MAAMC,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CU,EAAOZ,WACTC,cAAYH,EAAanD,WAAW6D,WAAY,KAE9CH,EAAKL,WAAWC,EAAWA,YAACH,EAAapD,SAAU,KACnDuE,EAAQtF,EAAO6E,WAErB,OAAOpL,MAEI6L,EAAQL,GAAQA,KAAU,EAAIP,IAAMN,IAAO,EAAIM,KAChDY,EAAQL,IAAS,GAAK,EAJtBZ,WAAWC,EAAWA,YAACH,EAAarB,QAAS,OAIb,EAAI4B,IAAOA,GAAM,GAG/D,qJA3KM,SACF5D,EACAE,EACAD,EACAG,EACAmF,GAEA,MAAMC,EACFzL,EAAQnB,IACRmB,EAAQsF,aAAatF,EAAQ+G,gBAAgBb,GAAWsF,GACtDE,EAAoB1L,EAAQmI,QAC9BnI,EAAQnB,IAAOwH,EAAWoF,EAAaxF,EACvCjG,EAAQ+G,gBAAgBb,IAE5B,OAAOlG,EAAQyF,aACXzF,EAAQnB,IACPsH,EAAaD,EAAWuF,GAAcxF,EAAYyF,GAE3D,sLA9fgB,SACZzF,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMgF,EAAYtL,EAAQc,WAAWmF,EAAWG,GAChD,IAAIM,EAAc1G,EAAQc,WAAWqF,EAAYD,GACjD,MAAMyF,EAAgB3L,EAAQ+G,gBAAgBT,GAC9CI,EAAc1G,EAAQc,WAAW4F,EAAaiF,GAC9C,MAAMhF,EAAO3G,EAAQ4G,WACjBX,EACAjG,EAAQlM,IAAIkM,EAAQc,WAAWuF,EAAUsF,GAAgB1F,IAEvDQ,EAAWzG,EAAQ4G,WAAWV,EAAWE,EAAWA,GAK1D,OAJAM,EAAc1G,EAAQc,WAClB4F,EACA1G,EAAQ8G,WAAWH,EAAMF,IAEtBzG,EAAQ4G,WAAW0E,EAAW5E,EAKzC,2IAIgB,SACZT,EACAC,EACAC,EACAC,EACAa,EACAX,GAEA,IAAIgF,EAAYtL,EAAQc,WAAWmF,EAAWG,GAC9C,MAAMuF,EAAgB3L,EAAQ+G,gBAAgBT,GACxCK,EAAO3G,EAAQ4G,WACjBT,EACAnG,EAAQgB,IAAImF,EAAYc,IAEtBR,EAAWzG,EAAQ4G,WAAWV,EAAWE,EAAWF,GAC1DoF,EAAYtL,EAAQc,WAChBwK,EACAtL,EAAQ8G,WAAWH,EAAMF,IAE7B,MAAMC,EAAc1G,EAAQc,WACxBd,EAAQc,WAAWqF,EAAYD,GAC/ByF,GAEJ,OAAO3L,EAAQ4G,WAAW0E,EAAW5E,EAKzC,IE/GM,SAAUkF,EACZC,GAEA,MAAMC,EAAMlN,EAAK,GAAGoG,IAAI6G,GACxB,OAAIC,EAAIC,SAAWD,EAAIE,GAAGrN,KAAUmN,EAAIG,WAAmBtN,EACpDmN,CACX,EDkCA,SAAKf,GACDA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,aAAA,GAAA,cACH,CAJD,CAAKA,IAAAA,EAIJ,CAAA,UAaYmB,EAaTjM,gBAAgBkM,EAAwBC,GACpC,IAAKD,EAAKE,YACN,MAAM,IAAIzM,MAAM,oCACpB,MAAM0M,EAAe,IAAIJ,EACrBC,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKE,YACLF,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,YAGT,OADIP,IAAOE,EAAaF,OAAQ,GACzBE,CACV,CAEDnS,YACIoS,EACAC,EACAvE,EACAoE,EACAI,EACAC,EACAC,GAnCJxU,KAAAyU,SAAsB/G,QAASA,UAACgH,SAQhC1U,KAAA2U,aAAetI,EAAAA,WAAW,MAAO,IACjCrM,KAAA4U,cAAgBvI,EAAAA,WAAW,MAAO,IAClCrM,KAAKiU,OAAG,EA2BJjU,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAKkU,YAAc7H,EAAAA,WAAW6H,EAAa,GAC9C,CAEDW,kBAAkBC,EAAiBC,GAC/B,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GACjBlH,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAChB8B,EAAW1B,EAAUA,WAAC8I,EAAGC,OAAQ,IAClC1I,IAAIhG,EAAAA,aACJmG,IAAI7M,KAAKkU,aAERmB,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GACjBrH,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SACjBgC,EAAY5B,EAAUA,WAACiJ,EAAGF,OAAQ,IACnC1I,IAAIhG,EAAAA,aACJmG,IAAI7M,KAAKkU,aAEd,IAAIqB,EAEAA,EADAT,GAAW9U,KAAKqU,QACLzB,EAAU4C,WACdT,GAAY/U,KAAKqU,QACbzB,EAAU6C,WAEV7C,EAAU8C,aAmBzB,MAhB2C,CACvCtB,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAWzB,EAAAA,WAAWyB,EAAWyD,GACjCvD,WAAY3B,EAAAA,WAAW2B,EAAYyD,GACnC8D,SAAUA,EACVxH,SAAUA,EACVE,UAAWA,EACX6B,QAAS9P,KAAK8P,QAIrB,CAED8F,uBACI,OAAO5V,KAAKuU,OAAOhZ,KAAK2Z,GACpB7I,EAAUA,WAAC6I,EAAEE,OAAQ,IAAI1I,IAAIhG,EAAGmP,aAAEhJ,IAAI7M,KAAKkU,aAAapH,YAE/D,CAEDgJ,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,OAAIA,IAAavI,QAASA,UAACwI,YAChBxP,EACH6K,EAAWA,YACPH,EAAarD,UAAUpB,IAAI1M,KAAK2U,cAAc9H,IAAInG,EAAGmP,aACrD1E,EAAaI,aAId9K,EACH6K,EAAWA,YACPH,EAAanD,WAAWtB,IAAI1M,KAAK4U,eAAe/H,IAAInG,EAAGmP,aACvD1E,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAEjCvK,EAAc5L,KAAKqU,QAAS7H,IAC5BxM,KAAKoW,kBAAkBD,GAG3B,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAMDC,yBACIrF,EACAnE,GAEA,GAAIA,EAAO4G,QAAS,OAAO5G,EAC3B,MAAMkB,EAAW7B,EAAAA,WAAWW,EAAOyJ,GAAG,GAAI,GAAGra,WAAY,IAAI0Q,WACvDyE,EAAaJ,EAAaI,WAC1BE,EAAcN,EAAaM,YAC3B3D,EAAYzB,aACd8E,EAAarD,UAAU1R,WACvB,GAAKmV,GACPzE,WACIkB,EAAa3B,aACf8E,EAAanD,WAAW5R,WACxB,GAAKqV,GACP3E,WACI4J,EAAqBvF,EAAapD,SAASjB,WAC3C6J,EAAsBxF,EAAalD,UAAUnB,WAC7CgD,EAAUqB,EAAarB,QAAQhD,WACrC,IAAI8J,EACJ,IA4BI,OA1BIA,EADAzF,EAAaoE,WAAa3C,EAAU6C,WACxBxG,EACR,CAACnB,EAAW1G,OAAO,IACnB,CAACsP,EAAoB7O,EAAQnB,IAAMgQ,GACnC,CAACxI,EAAU9G,OAAO,IAClB4G,EACA8B,GAEGqB,EAAaoE,WAAa3C,EAAU4C,WAC/BlF,EACRtC,EACA2I,EACAzI,EACAJ,EACAgC,GAGQjC,EACRC,EACA4I,EACA1I,EACA2I,EACAzI,EACA4B,GAIDlJ,EAAMH,EAAKmQ,EAAUxa,aAAc,GAC7C,CAAC,MAAOya,GACL,OAAOrQ,CACV,CACJ,CAMDsQ,yBACI3F,EACAnE,GAEA,GAAIA,EAAO4G,QAAS,OAAO5G,EAC3B,MAAM8B,EAAYzC,EAAAA,WACdW,EAAOyJ,GAAG,GAAI,GAAGra,WACjB,IACF0Q,WACIyE,EAAaJ,EAAaI,WAC1BE,EAAcN,EAAaM,YAC3B3D,EAAYzB,aACd8E,EAAarD,UAAU1R,WACvB,GAAKmV,GACPzE,WACIkB,EAAa3B,aACf8E,EAAanD,WAAW5R,WACxB,GAAKqV,GACP3E,WACI4J,EAAqBvF,EAAapD,SAASjB,WAC3C6J,EAAsBxF,EAAalD,UAAUnB,WAC7CgD,EAAUqB,EAAarB,QAAQhD,WACrC,IAAI8J,EACJ,IA4BI,OA1BIA,EADAzF,EAAaoE,WAAa3C,EAAU6C,WACxB1E,EACRjD,EACA4I,EACA5H,EACAd,EACA8B,GAEGqB,EAAaoE,WAAa3C,EAAU4C,WAC/B/E,EACR,CAACzC,EAAY5G,OAAO,IACpB,CAACuP,EAAqB9O,EAAQnB,IAAMiQ,GACpC,CAAC7H,EAAW1H,OAAO,IACnB0G,EACAgC,GAGQjB,EACRf,EACA4I,EACA1I,EACA2I,EACA7H,EACAgB,GAIDlJ,EAAMH,EAAKmQ,EAAUxa,aAAc,GAC7C,CAAC,MAAOya,GACL,OAAOrQ,CACV,CACJ,CAODyJ,8BAA8BC,GAE1B,MAAM6G,EAAqB/W,KAAKuU,OAC3ByC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C9Y,KAAK2Z,GAAM3I,EAAiB2I,KACjC,IACI,MAAM+B,EAAuBhH,EACzB8G,EACA7G,EAAYpD,WACZ9M,KAAKsU,YAAYxH,YAMrB,OAHmBmK,EAAqB1b,KAAI,CAACwM,EAAG0H,IAC5CpC,EAAkBtF,EAAG/H,KAAKuU,OAAO9E,MAEnBlU,KAAKwM,GAAM5B,EAAAA,UAAU+G,KAAKnF,IAC/C,CAAC,MAAO8O,GACL,OAAO,IAAIva,MAAMya,EAAmB7a,QAAQgb,KAAK1Q,EACpD,CACJ,CAODyI,8BAA8BG,GAC1B,IAEI,MAAM+H,EAAsB,IAAI7a,MAAM8S,EAAUlT,QAAQgb,KACpD9P,OAAO,IAEL2P,EAAqB,IAAIza,MAAM8S,EAAUlT,QAAQgb,KACnD9P,OAAO,IAEXpH,KAAKuU,OACAyC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C7X,SAAQ,CAACgQ,EAAOiD,KACb0H,EAAoB1H,GAAK1C,EACrB3F,OAAOgI,EAAUK,GAAGrT,YACpBoQ,GAEJuK,EAAmBtH,GAAKlD,EAAiBC,EAAM,IAEvD,MAAMwE,EAAe/B,EACjB8H,EACA/W,KAAK4V,uBACLuB,EACAnX,KAAKsU,YAAYxH,WACjB9M,KAAK8P,QAAQhD,YAEjB,OAAO3G,EAASA,UAAC+G,KAAK8D,EAAa5U,WACtC,CAAC,MAAOya,GACL,OAAOO,MACV,CACJ,CAEDlG,2CACIC,EACAnE,GAEA,OAAImE,EAAaoE,WAAa3C,EAAU6C,WAC7BzD,EACHhF,EACAmE,GAEGA,EAAaoE,WAAa3C,EAAU4C,WACpCtD,EACHlF,EACAmE,GAGGD,EACHlE,EACAmE,EAGX,CAEDY,2CACIZ,EACAnE,GAEA,OAAImE,EAAaoE,WAAa3C,EAAU6C,WAC7BpD,EACHrF,EACAmE,GAEGA,EAAaoE,WAAa3C,EAAU4C,WACpCrD,EACHnF,EACAmE,GAGGY,EACH/E,EACAmE,EAGX,CAEDoB,qDACIpB,EACAnE,GAEA,OAAImE,EAAaoE,WAAa3C,EAAU6C,WAC7BhD,EACHzF,EACAmE,GAEGA,EAAaoE,WAAa3C,EAAU4C,WACpC9C,EACH1F,EACAmE,GAGGoB,EACHvF,EACAmE,EAGX,CAEDqB,qDACIrB,EACAnE,GAEA,OAAOwF,EACHxF,EACAmE,EAEP,WE9bWkG,EACZC,EACApI,GAEA,IAAI3D,EAAM/E,EACV,MAAM+Q,EAAarI,EAAShT,OAC5B,IAAK,IAAIuT,EAAI,EAAGA,EAAI8H,EAAY9H,IAC5BlE,EAAMA,EAAIiM,KAAKtI,EAASO,IAE5B,GAAIlE,EAAIkM,SACJ,OAAOjR,EAEX,IAAIkR,EAAUlR,EACVmR,EAAMpM,EAGV,MACMqM,EADYnR,EAAK6K,EAAAA,YAAYgG,EAAG,IACRrQ,MAAMsQ,GAAcA,GAElD,IAAK,IAAI9H,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC1B,IAAIoI,EAAMpR,EAAK8Q,GAAYtQ,MAAMiI,EAAS,IAC1C,IAAK,IAAI4I,EAAI,EAAGA,EAAIP,EAAYO,IAE5BD,EAAMA,EAAI5Q,MAAMiI,EAAS4I,IAAI7Q,MAAMsQ,GAAY1K,IAAI8K,GAcvD,GAZAD,EAAUC,EAEVA,EAAMlR,EAAK8Q,GACNtQ,MAAM0Q,GACN1Q,MAAM0Q,GACNH,KAAKI,EAAY3Q,MAAMsE,GAAKtE,MAAM4Q,IAClChL,IACGpG,EAAK8Q,EAAa,GACbtQ,MAAM0Q,GACNH,KAAKI,EAAYG,MAAM,GAAG9Q,MAAM4Q,KAGzCF,EAAIK,GAAGN,IACP,GAAIC,EAAII,MAAML,GAAS7D,GAAGpN,EAAK,QAC3B,WAED,GAAIiR,EAAQK,MAAMJ,GAAK9D,GAAGpN,EAAK,QAClC,KAEP,CAED,OAAOkR,CACX,CAegB,SAAAnB,EACZxJ,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAC5B,IAAIqX,EAAgBnL,EACpBmL,EAAgBA,EACXlR,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YACxByQ,IAAIuL,EAAAA,YAAKhc,YAGd,MAAMub,EAAMN,EAAWC,EAAGpI,GAC1B,IAAImJ,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAa9Q,EAAKyI,EAAShT,QACjC,IAAIoc,EAAU5R,EACV4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAGtC,GAFA6I,EAAUA,EAAQrR,MAAMsQ,GAEpB9H,GAAKuF,EACL1M,EAAI4G,EAASO,GAAG+H,KAAKW,OAClB,IAAI1I,GAAK4F,EAGZ,SAFA/M,EAAI4G,EAASO,EAGhB,CACDlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,EACxB,CAGD,MAAMC,EAAIgQ,EAAwBhN,EAAKoM,EAAKL,EAAGgB,EAASD,GAIxD,OAAOnJ,EAASmG,GAAe0C,MAAMxP,EACzC,CAegB,SAAAuO,EACZ9J,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtB0X,EAAiBxL,EAEjB2K,EAAMN,EAAWC,EAAGpI,GAC1B,IAAImJ,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAa9Q,EAAKyI,EAAShT,QACjC,IAAIoc,EAAU5R,EACV4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAGtC,GAFA6I,EAAUA,EAAQrR,MAAMsQ,GAEpB9H,GAAK4F,EACL/M,EAAI4G,EAASO,GAAGsI,MAAMS,OACnB,IAAI/I,GAAKuF,EAGZ,SAFA1M,EAAI4G,EAASO,EAGhB,CACDlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,EACxB,CAMD,OAHUiQ,EAAwBhN,EAAKoM,EAAKL,EAAGgB,EAASD,GAInDN,MAAM7I,EAAS8F,IACfyD,aAAaL,EAAAA,YAAKhc,YAClByQ,IAAIuL,EAAIvC,YAAChN,IAAIiH,GAAS1T,WAC/B,CAGM,SAAUmc,EACZhN,EACAoM,EACAL,EACAgB,EACAD,GAGA,MAAMK,EAAUjS,EAAK6K,EAAAA,YAAYgG,EAAG,IAEpCe,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAI6L,EAAQzR,MAAMqR,GAASrR,MAAMqR,IAElD,MAAM/Q,EAAIgE,EAAIiM,KAAKG,EAAI9K,IAAI6L,EAAQzR,MAAMqR,KAKzC,OAJUX,EACLI,MAAMxQ,GACNiQ,KAAKG,EAAII,MAAMxQ,GAAGN,MAAM0Q,EAAII,MAAMxQ,IAAIiQ,KAAKa,EAAEpR,MAAM,IAAI0R,QAEnD9L,IAAI,EACjB,CAMA,SAAS+L,GACLtB,EACApI,EACA8F,EACAK,EACAwD,EACAC,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAI1B,EAAWC,EAAGpI,GACxB,IAAI8J,EAAIxS,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,GAAgBvF,GAAK4F,IAC1B2D,EAAIA,EAAExB,KAAKtI,EAASO,KAG5B,MAAMnH,EAAI4G,EAAS8F,GACbzM,EAAI2G,EAASmG,GAGbtN,EADYtB,EAAK6K,EAAAA,YAAYgG,EAAG,IAClBrQ,MAAMsQ,GAAcA,GAClChQ,EAAIyR,EAAEjB,MAAMgB,GAAG9R,MAAMc,GAAGyP,KAAKuB,GAC7BE,EAASxS,EAAK,GAAGQ,MAAMc,GAAGd,MAAMqB,GAAGrB,MAAMsB,GACzC2Q,EAAYD,EAAOzB,KAAKzP,EAAEd,MAAMsB,GAAGtB,MAAMsB,IAAIiP,KAAKjQ,EAAEN,MAAMsB,IAC1D4Q,EAAYF,EAAOzB,KAAKzP,EAAEd,MAAMqB,GAAGrB,MAAMqB,IAAIkP,KAAKjQ,EAAEN,MAAMqB,IAChE,IAAIqL,EACJ,GAAIkF,EACAlF,EAAMuF,EAAUrM,IAAIsM,OACjB,CACH,MAAMC,EAAa3S,EAAK,GAAGQ,MAAMc,GAAGd,MAAMsB,GACpC8Q,EAAa5S,EAAK,GAAGQ,MAAMc,GAAGd,MAAMqB,GACpCgR,EAAaF,EAAW5B,KAAK6B,GAAY7B,KAAKjQ,GAC9C4L,EAAY1M,EAAK,GAClBQ,MAAMiS,GACNjS,MAAMkS,GACNlS,MAAMqS,GACNvB,MAAMqB,EAAWnS,MAAMkS,EAAUnS,IAAI,KACrC+Q,MAAMsB,EAAWpS,MAAMiS,EAAUlS,IAAI,KACpCuH,EAAc2K,EAAUlS,IAAI,GAAGC,MAAMkS,GAC3CxF,EAAMR,EAAUtG,IAAI0B,GAChBuK,IACAnF,EAAMA,EAAI1M,MAAMkS,GAAWtM,IAAIqM,GAEtC,CACD,OAAOvF,CACX,CAQgB,SAAAzC,GACZlE,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAC5BoO,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,cAAKhc,aAExD8S,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CvB,EAAyBxJ,EAAQmE,IAErC,IAAIwC,EAAMiF,GACNtB,EACApI,EACA8F,EACAK,GACA,GACA,GAGJ,OADA1B,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMmR,EAAIvC,YAAChN,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,EAAAA,YAAKhc,aACxDuX,CACX,CAIgB,SAAA5B,GACZ/E,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtByY,EAAMzC,EAAyB9J,EAAQmE,GACxClK,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YACxByQ,IAAIuL,EAAAA,YAAKhc,YACd8S,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,GACrDrK,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAAM/K,GACxD,IAAI2G,EAAMiF,GACNtB,EACApI,EACA8F,EACAK,GACA,GACA,GAGJ,OADA1B,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMmR,EAAIvC,YAAChN,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,EAAAA,YAAKhc,aACxDuX,CACX,CAQgB,SAAApB,GACZvF,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAO5B,OANAoO,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,cAAKhc,aAExD8S,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CvB,EAAyBxJ,EAAQmE,IAE9ByH,GACHtB,EACApI,EACA8F,EACAK,GACA,GACA,EAER,CAIgB,SAAA7C,GACZxF,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtByY,EAAMzC,EAAyB9J,EAAQmE,GACxClK,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YACxByQ,IAAIuL,EAAAA,YAAKhc,YACd8S,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,GACrDrK,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAAM/K,GACxD,MAAMsG,EAAY8E,EAAAA,YAAKvL,IAAIiD,GAAS1T,WACpC,OAAOwc,GACHtB,EACApI,EACA8F,EACAK,GACA,GACA,GACFxI,IAAIyG,EACV,CAwBgB,SAAAjB,GACZrF,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlK,WAAEA,EAAUgH,aAAEA,EAAYvD,YAAEA,EAAW3B,QAAEA,GAC7DqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtByY,EAqBV,SACIvM,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtBkQ,EAAehE,EAOf+F,EAAmBsE,EAAWC,EAAGpI,GAEjCsK,EAAetB,EAAY7C,GAC5BmC,KAAKxG,GACLnE,IAAIqL,EAAY7C,IAChBpO,MAAM8L,GAIX,IAAI0G,EAAcjT,EAClB,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAI5C,MAAMiK,EAyBV,SACIpC,EACApI,EACAyI,EACAgC,GAEA,IAAItB,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAarI,EAAShT,OAC5B,IAAI0d,EAAQlT,EACR4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAI8H,EAAY9H,IAC5BmK,EAAQA,EAAM3S,MAAMsQ,GAChB9H,GAAKkK,IACLrR,EAAI4G,EAASO,GAIjBlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,IAIzB,OAAOiQ,EAAwBhN,EAAKoM,EAAKL,EAAGsC,EAAOvB,EACvD,CAjDQwB,CACIvC,EACApI,EACAsK,EACAxE,GAEF8E,EAAmBJ,EAAqB3B,MAAM7I,EAAS8F,IAGvD+E,EAAgB7K,EAAS8F,GAAcnI,IAAI4M,GAC3CO,EAA+BtT,EAAIqR,MAAMgC,GAG/C,OAAOD,EAAiBjN,IACpBnG,EAAIqR,MACAiC,EACK/S,MAAM6I,EAAQ1T,YACdyQ,IAAIuL,EAAIvC,YAACzZ,aAG1B,CA5EgB6d,CAAuBjN,EAAQmE,GACrCmC,EA9BV,SACIpE,EACAyK,EACA7J,GAEA,IAAI2J,EAAcjT,EAClB,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAE5C,MAAMsK,EAAgB7K,EAASyK,GAAY9M,IAAI4M,GACzCO,EAA+BtT,EAAIqR,MAAMgC,GAC/C,OAAOrT,EAAIqR,MACPiC,EACK/S,MAAM6I,EAAQ1T,YACdyQ,IAAIuL,EAAIvC,YAACzZ,YAEtB,CAcsB8d,CAAWhL,EAAU8F,EAAclF,GACrDZ,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,EAAItS,MAAMqM,IAC/D,IAAIK,EAwGR,SACI2D,EACApI,EACAiL,EACAnF,EACA6D,EACAuB,EACAtB,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAI1B,EAAWC,EAAGpI,GACxB,IAAI8J,EAAIxS,EACJ6T,EAAMtB,EAAElM,IAAI0K,GAChB,IAAK,IAAI9H,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,IACLgE,EAAIA,EAAExB,KAAKtI,EAASO,IACpB4K,EAAMA,EAAIpT,MAAM8R,GAAGlM,IAAIqC,EAASO,GAAGxI,MAAMsQ,KAGjD,MAAMjP,EAAI4G,EAAS8F,GAEbsF,EAAY7T,EAAK6K,EAAAA,YAAYgG,EAAG,IAChCiD,EAAQD,EAAUrT,MAAMsQ,GAAcA,GACtCiD,EAAOD,EAAMtT,MAAM+R,GACnByB,EAAQ/T,EAAIqR,MAAMwC,GAClBrB,EAAYzS,EAAK,GAClBQ,MAAMsT,GACNtT,MAAMqB,GACNkP,KAAKgD,GACLhD,KAAKiD,EAAMxT,MAAM8R,IAChB2B,EAAkBL,EAAIpT,MAAMsQ,EAAa,GAAGQ,MAAM0C,EAAMxT,MAAMqB,IAC9DqS,EAAYnU,EAAKuR,MAAM2C,GAC7B,IAAI/G,EACJ,GAAIkF,EACAlF,EAAMuF,EAAUrM,IAAI6N,GAAiBzT,MAAMkT,GAAWtN,IAAIkM,OACvD,CACH,MAAMK,EAAa3S,EAAK,GAAGQ,MAAMsT,GAC3BK,EAAaH,EACbI,EAAmBtD,GAAcA,EAAa,GAC9CuD,EAAatU,EAAKuR,MAAMsC,EAAIpT,MAAM4T,GAAkBhO,IAAIkM,IAC9D,GAAIqB,EAAY,CACZ,MAAMW,EAAQ3B,EAAWnS,MAAM0T,GAAW9N,IAAIqM,EAAUlS,IAAI,IACtDgU,EAAQvU,EAAK,GAAGQ,MAAM2T,GAAY/N,IAAIqM,GACtC+B,EAAQH,EAAWjO,IAAI8N,GAE7B,GADAhH,EAAMoH,EAAMhD,MAAMiD,GAAOxD,KAAKyD,GAAOhU,MAAM8R,GAAGlM,IAAIsN,GAC9CrB,EAAS,CACT,MAAMoC,EAAU1U,EAAKuR,MAAMmB,EAAUrM,IAAI8N,IACzChH,EAAMA,EAAI9G,IAAIqO,GAASjU,MAAM8R,GAAGlM,IAAIsN,EACvC,CACJ,MACGxG,EAAMlN,EAAK,GACNQ,MAAM2T,GACN/N,IAAI8N,GACJ5C,MAAM+C,EAAW7T,MAAMiS,GAAWrM,IAAI8N,EAAU3T,IAAI,KACpD+Q,MAAMqB,EAAWvM,IAAIqM,IACtBJ,IACAnF,EAAMA,EACD1M,MAAMiS,GACNrM,IAAI6N,GACJzT,MAAMkT,GACNtN,IAAIkM,GAGpB,CACD,OAAOpF,CACX,CAzKcwH,CACN7D,EACApI,EACAzI,EAAK6K,EAAWA,YAACtD,EAAYyD,IAAc+F,KAAKxK,GAChDgI,GACA,GACA,GACA,GAGJ,OADArB,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMqM,IACjBK,CACX,6XC7ZA,MAAMyH,GAAgBhU,OAAO,KAE7B,SAASiU,GAAoBpD,EAAa/I,GAYtC,IAAI3D,EAAMpE,EACV,MAAMmU,EAAYpM,EAAShT,OAC3B,IAAK,IAAIuT,EAAI,EAAGA,EAAI6L,EAAW7L,IAC3BlE,GAAY2D,EAASO,GAEzB,GAAIlE,GAAOpE,EACP,OAAOA,EAGX,IAAIoU,EAAgBpU,EAChBiM,EAAY7H,EAChB,MAAMiQ,EAAgBvD,EAAM7Q,OAAOkU,GAEnC,IAAK,IAAI7L,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC1B,IAAI4K,EAAMjH,EACV,IAAK,IAAI0E,EAAI,EAAGA,EAAIwD,EAAWxD,IAE3BuC,EAAMxS,EAAQM,QACVN,EAAQ6E,IAAI2N,EAAKjH,GACjBvL,EAAQ6E,IAAIwC,EAAS4I,GAAI1Q,OAAOkU,KAqBxC,GAjBAC,EAAgBnI,EAChBA,EAAYvL,EAAQM,QAChBN,EAAQ6E,IAEJ7E,EAAQM,QACJN,EAAQ6E,IAAI8O,EAAejQ,GAC3B6P,IACAvT,EAAQ6E,IAAI2N,EAAKjT,OAAOkU,IAC5BlI,GAGJvL,EAAQM,QACJN,EAAQ6E,IAAI8O,EAAgBJ,GAAehI,GAC3CgI,IACAvT,EAAQ6E,IAAItF,OAAOkU,EAAY,GAAIjB,IAGvCjH,EAAYmI,GACZ,GAAInI,EAAYmI,GAAiB,EAC7B,OAAOnI,OAER,GAAImI,EAAgBnI,GAAa,EACpC,OAAOA,CAEd,CACD,MAAM,IAAI3L,MAAM,yCACpB,CAIgB,SAAAoG,GACZoK,EACA/I,EACA8F,EACAK,EACAnH,EACAC,GAEAD,EAoZJ,SAAqBlB,EAAgBmB,GACjC,MAAMC,EAAYvG,EAAQc,WAAWqE,EAAQmB,GAC7C,OAAOnB,EAASoB,CACpB,CAvZeC,CAAYH,EAAUC,GACjC,MAAMiF,EAAYiI,GAAoBpD,EAAK/I,GAErCuM,EAAcvM,EAAS8F,GAC7B9F,EAAS8F,GAAgByG,EAAcvN,EACvC,MAAMwN,EAAkB7B,GACpB5B,EACA/I,EACAkE,EACAiC,GAEJ,OAAOnG,EAASmG,GAAiBqG,EAAkBtU,OAAO,EAC9D,CAEgB,SAAAyH,GACZoJ,EACA/I,EACA8F,EACAK,EACAvG,EACAX,GAEA,MAAMiF,EAAYiI,GAAoBpD,EAAK/I,GAC3CA,EAASmG,GAAiBxN,EAAQgB,IAAIqG,EAASmG,GAAgBvG,GAE/D,MAAM6M,EAAiB9B,GACnB5B,EACA/I,EACAkE,EACA4B,GAGJ,IAAI9G,EAAWrG,EAAQlM,IACnBkM,EAAQgB,IAAI8S,EAAgBzM,EAAS8F,IACrC5N,OAAO,IAGX,OADA8G,EAqXJ,SAAgBlB,EAAgBmB,GAC5B,OAAOtG,EAAQ4G,WAAWzB,EAAQnF,EAAQ+G,gBAAgBT,GAC9D,CAvXea,CAAOd,EAAUC,GACrBD,CACX,CAWM,SAAUe,GACZgJ,EACA/I,EACAE,EACAC,EACAC,GAMA,IAAImK,EAAcrS,OAAO,GACzB,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,GAA4BvK,EAASO,GAIzC,MAAMF,EAAiC,IAAIjT,MAAM8S,EAAUlT,QAE3D,IAAIsT,EAAyBpI,OAAO,GACpC,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CACtC,MAAMsK,EAAgBlS,EAAQyF,aAAa4B,EAASO,GAAIgK,GACxDlK,EAAqBE,GAAK5H,EAAQyF,aAC9B4B,EAASO,GAAKL,EAAUK,GACxBP,EAASO,IAEbD,GAEI3H,EAAQsF,aAAaoC,EAAqBE,GAAIsK,EACrD,CAGD,MAAM6B,EAAwB,IAAItf,MAAM4S,EAAShT,QACjD,IAAK,IAAIuT,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CACtC,IAAIE,EAGJ,GAAIJ,EAAqBE,GAAKD,EAAwB,CAClD,MAAMI,EAAmB/H,EAAQsF,aAC7B+B,EAASO,GACTD,EAAyB3H,EAAQnB,KAE/BmJ,EAAgBT,EAAUK,GAAKG,EAErCD,EACIC,EACA/H,EAAQsF,aACJ0C,EACAhI,EAAQnB,IAAM4I,EAEzB,MACGK,EAAqBP,EAAUK,GAEnCmM,EAAYnM,GAAKP,EAASO,GAAKE,CAClC,CAGD,MAAMoD,EAAmBsI,GAAoBpD,EAAK/I,GAC5CsK,EAAe6B,GAAoBpD,EAAK2D,GAExClM,EAAiB7H,EAAQyF,aAAakM,EAAczG,GAG1D,OAAIrD,EAAiB7H,EAAQnB,IAClBmB,EAAQsF,aACXkC,EACAK,EAAiB7H,EAAQnB,KAGtBU,OAAO,EAEtB,CAYgB,SAAA2J,GACZkH,EACA/I,EACA8F,EACAhE,EACA3B,EACAlB,GAGA,MAAM4E,EAAmBsI,GAAoBpD,EAAK/I,GAU5CwK,EACFG,GACI5B,EACA/I,EAZarH,EAAQc,WACzBd,EAAQ4G,WACJ5G,EAAQlM,IAAI0T,EAAgB2B,GAC5B3B,GAEJ0D,GASIiC,GAEFrF,EAAqB9H,EAAQgB,IAC/B6Q,EACAxK,EAAS8F,IAKb,IAAIyE,EAAcrS,OAAO,GACzB,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAc5R,EAAQlM,IAAI8d,EAAavK,EAASO,IAKpD,MAAMsK,EAAgBlS,EAAQyF,aAC1B4B,EAAS8F,GACTyE,GAEExI,EAAoBpJ,EAAQ+G,gBAAgBmL,GAC5ClK,EAAgBhI,EAAQc,WAC1BgH,EACAsB,GAEErB,EAAmB/H,EAAQgB,IAAI8G,EAAoBE,GAEzD,OAAOhI,EAAQlM,IACXiU,EACA/H,EAAQ4G,WAAWoB,EAAehI,EAAQgB,IAAIhB,EAAQnB,IAAKyH,IAEnE,CAOM,SAAUsC,GACZwH,EACA/I,EACAmB,EACAhB,EACAC,GAMA,IAAImK,EAAcrS,OAAO,GACzB,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,GAA4BvK,EAASO,GAIzC,MAAMiB,EAAoC,IAAIpU,MAAM+T,EAAWnU,QAC/D,IAAIyU,EAA4BvJ,OAAO,GACvC,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CACtC,MAAMsK,EAAgBlS,EAAQ4G,WAAWS,EAASO,GAAIgK,GACtD/I,EAAwBjB,GAAK5H,EAAQ4G,WACjCS,EAASO,GAAKY,EAAWZ,GACzBP,EAASO,IAEbkB,GAEI9I,EAAQc,WAAW+H,EAAwBjB,GAAIsK,EACtD,CAGD,MAAM6B,EAAwB,IAAItf,MAAM4S,EAAShT,QACjD,IAAK,IAAIuT,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAItC,IAAImB,EACJ,GAAID,EAA4BD,EAAwBjB,GAAI,CACxD,MAAMG,EAAmB/H,EAAQsF,aAC7B+B,EAASO,GACT5H,EAAQ+G,gBAAgB+B,IAEtBd,EAAgBQ,EAAWZ,GAAKG,EAEtCgB,EACIhB,EACA/H,EAAQ4G,WACJoB,EACAhI,EAAQnB,IAAM4I,EAEzB,MACGsB,EAAmBP,EAAWZ,GAElCmM,EAAYnM,GAAKP,EAASO,GAAKmB,CAClC,CAGD,MAAMmC,EAAmBsI,GAAoBpD,EAAK/I,GAC5CsK,EAAe6B,GAAoBpD,EAAK2D,GACxClM,EAAiB7H,EAAQyF,aAAakM,EAAczG,GAG1D,OAAOlL,EAAQc,WACX0G,EACAxH,EAAQ+G,gBAAgBc,GAEhC,CAEgB,SAAAY,GACZ2H,EACA/I,EACAyK,EACAzJ,EACAb,EACAC,GAIA,MAAMyD,EAAmBsI,GAAoBpD,EAAK/I,GAO5CwK,EACFG,GACI5B,EACA/I,EATarH,EAAQc,WACzBd,EAAQ4G,WAAWY,EAAiBa,EAAab,GACjD0D,GASI4G,GAEFnJ,EAAsBtB,EAASyK,GAAcD,EAInD,IAAID,EAAcrS,OAAO,GACzB,IAAK,IAAIqI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,GAA4BvK,EAASO,GAKzC,MAAMsK,EAAgBlS,EAAQyF,aAC1B4B,EAASyK,GACTF,GAEExI,EAAoBpJ,EAAQ+G,gBAAgBmL,GAI5ClK,EAAgBhI,EAAQc,WAC1B6H,EACAS,GAKJ,OAHyBT,EAAsBX,EAK3ChI,EAAQsF,aAAa0C,EAAehI,EAAQnB,IAAM4I,EAE1D,UAEgBW,GACZf,EACAgB,EACAb,GAcA,MAAMe,EAAWvI,EAAQyF,aAAa4C,EAAab,GAE7CgB,EAAuB,IAAI/T,MAAM4S,EAAShT,QAChD,IAAK,IAAIuT,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCY,EAAWZ,GAAK5H,EAAQsF,aAAa+B,EAASO,GAAIW,GAGtD,OAAOC,CACX,CAEA,SAASwJ,GACL5B,EACA/I,EACAkE,EACAuG,GAIA,MAAM6B,EAAgBvD,EAAM7Q,OAAO8H,EAAShT,QAC5C,IAAIqP,EAAM2D,EAAS,GACf2I,EAAM3I,EAAS,GAAK9H,OAAO8H,EAAShT,QACxC,IAAK,IAAI4b,EAAI,EAAGA,EAAI5I,EAAShT,OAAQ4b,IACjCD,EAAMhQ,EAAQM,QACVN,EAAQ6E,IAAI7E,EAAQ6E,IAAImL,EAAK3I,EAAS4I,IAAK1Q,OAAO8H,EAAShT,SAC3DkX,GAEJ7H,GAAY2D,EAAS4I,GAGzBvM,GAAY2D,EAASyK,GAErB,MAAMkC,EAAOhU,EAAQ6E,IAAI0G,EAAWA,GAE9BpL,EAAIH,EAAQ6E,IACd7E,EAAQ6E,IACJ7E,EAAQK,MAAM2T,EAAMhU,EAAQ6E,IAAI8O,EAAe3D,IAC/CuD,IAEJlM,EAASyK,IAEPpS,EACFgE,EACA1D,EAAQ6E,IAAI7E,EAAQM,QAAQiL,EAAWoI,GAAgBJ,IAG3D,IAAIU,EAAmB3U,EAGnB4U,EAAelU,EAAQK,MAAM2T,EAAO7T,EAAGoL,EAAY7L,GAEvD,IAAK,IAAIkI,EAAI,EAAGA,EAAI,IAAKA,IAQrB,GAPAqM,EAAmBC,EAEnBA,EAAelU,EAAQK,MACnBL,EAAQ6E,IAAIqP,EAAcA,GAAgB/T,EAC1CH,EAAQ6E,IAAIqP,EAAc3U,OAAO,IAAMG,EAAI6L,GAG3C2I,EAAeD,GACf,GAAIC,EAAeD,GAAoB,EACnC,OAAOC,OAER,GAAID,EAAmBC,GAAgB,EAC1C,OAAOA,EAGf,MAAM,IAAItU,MAAM,2CACpB,CAuOgB,SAAAmR,GACZX,EACA/I,EACA8F,EACAK,EACAwD,EACAC,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAIsC,GAAoBpD,EAAK/I,GACnC,IAAI8J,EAAI5R,OAAO,GACf,IAAK,IAAIqI,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,GAAgBvF,GAAK4F,IAC1B2D,GAAK9J,EAASO,IAGtB,MAAMnH,EAAI4G,EAAS8F,GACbzM,EAAI2G,EAASmG,GACbtN,EAAIkQ,EAAM7Q,OAAOmQ,GACjBhQ,EAAIQ,GAAKiR,EAAID,GAAKA,EAAIqC,GACtBnC,EAAS7R,OAAO,GAAKW,EAAIO,EAAIC,EAC7B2Q,EAAYD,EAASlR,EAAIQ,EAAIA,EAAIhB,EAAIgB,EACrC4Q,EAAYF,EAASlR,EAAIO,EAAIA,EAAIf,EAAIe,EAC3C,IAAIqL,EACJ,GAAIkF,EACAlF,EAAM9L,EAAQ4G,WAAWyK,EAAWC,OACjC,CAEH,MAAMC,EAAahS,OAAO,GAAKW,EAAIQ,EAC7B8Q,EAAajS,OAAO,GAAKW,EAAIO,EAC7BgR,EAAaF,EAAaC,EAAa9R,EACvC4L,EACF/L,OAAO,GAAK8R,EAAYC,EAAYG,EACpCF,EAAaD,EAAYA,EACzBE,EAAaH,EAAYA,EACvB3K,EAAc2K,EAAYA,EAAYC,EAC5CxF,EAAM9L,EAAQ4G,WAAW0E,EAAW5E,GAChCuK,IACAnF,EAAM9L,EAAQc,WACVd,EAAQc,WAAWgL,EAAKwF,GACxBD,GAGX,CACD,OAAOvF,CACX,CAEM,SAAUwH,GACZlD,EACA/I,EACAiL,EACAnF,EAEA6D,EAEAuB,EAEAtB,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAIsC,GAAoBpD,EAAK/I,GACnC,IAAI8J,EAAI5R,OAAO,GACXiT,EAAMtB,EAAI3R,OAAOmQ,GACrB,IAAK,IAAI9H,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,IACLgE,GAAQ9J,EAASO,GACjB4K,EAAOA,EAAMtB,GAAM3R,OAAOmQ,GAAcrI,EAASO,KAGzD,MAAMnH,EAAI4G,EAAS8F,GACbuF,EAAQtC,EAAM7Q,OAAOmQ,GACrBiD,EAAOD,EAAQvB,EACfyB,EAAQrT,OAAOgU,IAAiBb,EAChCrB,EAAY9R,OAAO,GAAKmT,EAAQjS,EAAIkS,EAAOC,EAAQ1B,EACnD2B,EACFL,EAAMjT,OAAOmQ,EAAa,GAAK6D,GAAgBX,EAAQnS,EAkC3D,OA/BYT,EAAQ4G,WACfyK,EAAYiB,EAAaO,EAC1B3B,EA8BR,mUA9IM,SACFd,EACA/I,EACAmG,EACAhG,EACAP,GAEAI,EAASmG,GAAiBxN,EAAQgB,IAAIqG,EAASmG,GAAgBvG,GAC/D,MAAMuB,EAAanB,EAAS3T,KAAI,CAACygB,EAAQ/f,IACrCA,GAASoZ,EAAgBvG,EAAY1H,OAAO,KAoBhD,OATY+T,GACRlD,EACA/I,EAVAG,EACAoB,GACIwH,EACA/I,EACAmB,EACAhB,EACAjI,OAAO,IAMXiO,EAMR,2CA/DM,SACF4C,EACA/I,EACAmG,EACAhG,EACAnB,GAIA,MAAM+N,EAAO3L,GACT2H,EACA/I,EACAmG,EACAnH,EACAmB,EACAjI,OAAO,IAaX,OAXA8H,EAASmG,GAAiBnG,EAASmG,GAAiB4G,EAExCd,GACRlD,EACA/I,EAHwBrH,EAAQgB,IAAIwG,EAAgBnB,GAKpDmH,EAMR,2CAnGM,SACF4C,EACA/I,EACA8F,EACA3F,EACAnB,GAGAgB,EAAS8F,GAAgB9F,EAAS8F,GAAgB9G,EAElD,MAAMkB,EAAYF,EAAS3T,KAAI,CAACygB,EAAQ/f,IACpCA,GAAS+Y,EAAe9G,EAAW9G,OAAO,KAW9C,IAAIuM,EAAMwH,GACNlD,EACA/I,EAVAG,EACAJ,GACIgJ,EACA/I,EACAE,EACAC,EACAjI,OAAO,IAMX4N,GAMJ,OADArB,EAAM9L,EAAQ4G,WAAW5G,EAAQnB,IAAKiN,GAC/BA,CACX,6CAhHgB,SACZsE,EACA/I,EACA8F,EACAK,EACAnH,EACAC,GAEA,MAAMqF,EAAgB3L,EAAQ+G,gBAAgBT,GACxC+N,EAAe,IAAIhN,GACzBA,EAAS8F,GAAgBnN,EAAQlM,IAC7BuT,EAAS8F,GACTnN,EAAQc,WAAWuF,EAAUsF,IAEjCtE,EAASmG,GAAiBxN,EAAQgB,IAC9BqG,EAASmG,GACTxH,GACIoK,EACAiE,EACAlH,EACAK,EACAnH,EACAC,IAGR,IAAIwF,EAAMiF,GACNX,EACA/I,EACA8F,EACAK,GACA,GACA,GAMJ,OAJA1B,EAAM9L,EAAQyF,aACVzF,EAAQnB,IACRmB,EAAQsF,aAAawG,EAAKH,IAEvBG,CACX,2CA8EM,SACFsE,EACA/I,EACA8F,EACA3F,EACAP,GAGA,MACMyK,EAAMxI,GACRkH,EAFiB,IAAI/I,GAIrB8F,EACAlG,EACAO,EACAjI,OAAO,IAEX8H,EAAS8F,GAAgB9F,EAAS8F,GAAgBuE,EAClD,IAAI5F,EAAMwH,GACNlD,EACA/I,EACAG,EAAiBP,EACjBkG,GAMJ,OADArB,EAAM9L,EAAQ4G,WAAW5G,EAAQnB,IAAKiN,GAC/BA,CACX,6CAvGgB,SACZsE,EACA/I,EACA8F,EACAK,EACAvG,EACAX,GAEA,MACMoL,EAAM1K,GACRoJ,EAFiB,IAAI/I,GAIrB8F,EACAK,EACAvG,EACAX,GAEJe,EAAS8F,GAAgB9F,EAAS8F,GAAgBuE,EAClDrK,EAASmG,GAAiBxN,EAAQgB,IAAIqG,EAASmG,GAAgBvG,GAC/D,IAAI6E,EAAMiF,GACNX,EACA/I,EACA8F,EACAK,GACA,GACA,GAEJ,MAAM7B,EAAgB3L,EAAQ+G,gBAAgBT,GAK9C,OAJAwF,EAAM9L,EAAQ4G,WACV5G,EAAQnB,IACRmB,EAAQc,WAAWgL,EAAKH,IAErBG,CACX,UCthBawI,GAcTrU,gBAAgBkM,GACZ,IAAKA,EAAKiE,IAAK,MAAM,IAAIxQ,MAAM,iCAC/B,OAAO,IAAI0U,GACPnI,EAAKI,GACLJ,EAAKK,QACLL,EAAKiE,IACLjE,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WAEZ,CAEDxS,YACIoS,EACAC,EACA4D,EACAnI,EACAwE,EACAC,EACAC,GAjCJxU,KAAAyU,SAAsB/G,QAASA,UAAC0O,OAQhCpc,KAAA2U,aAAetI,EAAAA,WAAW,MAAO,IACjCrM,KAAA4U,cAAgBvI,EAAAA,WAAW,MAAO,IA0B9BrM,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAKiY,IAAM5L,EAAUA,WAAC4L,EAAKkE,GAAWE,cACtCrc,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,CACrB,CAEDK,kBAAkBC,EAAiBC,GAC/B,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GACjBlH,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhBoJ,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GACjBrH,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAGjBiM,EAAclY,KAAKuU,OAAOhZ,KAAI,EAAGkR,aAAchG,EAAKgG,KACpD6P,EAAoBtc,KAAKuU,OAAOhZ,KAAI,EAAGkR,aACzCJ,EAAUA,WAACI,EAAS,MAqBxB,MAlByC,CACrC2H,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVjH,UAAWzB,EAAAA,WAAWyB,EAAWyD,GACjCvD,WAAY3B,EAAAA,WAAW2B,EAAYyD,GACnC3B,QAAS9P,KAAK8P,QACdoI,cACAoE,oBACArE,IAAKjY,KAAKiY,IACVjD,aAAcA,EACdK,cAAeA,EACf9D,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GAI3B,CAEDqE,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAKA,OAAIA,IAAavI,QAASA,UAACwI,YAChBxP,EACH6K,EAAWA,YACPH,EAAarD,UAAUpB,IAAI1M,KAAK2U,cAAc9H,IAAInG,EAAGmP,aACrD1E,EAAaI,aAId9K,EACH6K,EAAWA,YACPH,EAAanD,WAAWtB,IAAI1M,KAAK4U,eAAe/H,IAAInG,EAAGmP,aACvD1E,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IACI,GAAIA,EAAOyK,SAAU,OAAOjR,EAE5B,MAUM+V,EAVgBvc,KAAKwc,sBACvBnQ,EAAAA,WACIW,EAAOyJ,GAAGtF,EAAaI,YAAYnV,WACnC+U,EAAaI,YAEjBJ,EAAarB,SAKepD,IAC5B,KAAO,GAAKyE,EAAaI,aAkB7B,OAAO3K,EAAMH,EAfDoH,GACR7N,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKkR,GAChCA,EAAQK,aAEZqE,EAAa6D,aACb7D,EAAakE,cACbkH,EAAUzP,WACV1F,OAAO,IAOWhL,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GAEL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IACI,GAAIA,EAAOyK,SAAU,OAAOjR,EAG5B,MAAM+V,EAAYlQ,EAAUA,WAACW,EAAOyJ,GAAG,IAAIra,WAAY,IAEvD,IAAIqgB,EAAM5N,GACN7O,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKkR,GAChCA,EAAQK,aAEZqE,EAAa6D,aACb7D,EAAakE,cACbkH,EAAUzP,WACV1F,OAAO,IAIX,MAAMsV,EAActV,OAAO,KAAO,GAAK+J,EAAaI,aACpDkL,GAAOA,EAAMC,EAActV,OAAO,IAAMsV,EAMxC,OAAOjW,EAJYzG,KAAK2c,iBACpBxW,EAASA,UAAC+G,KAAKuP,GACftL,EAAarB,SAEM1T,YAAYyQ,IAC/B,IAAMsE,EAAaI,WAE1B,CAAC,MAAOsF,GAEL,OADA+F,QAAQC,MAAM,mBAAmBhG,EAAIrP,WAC9BhB,CACV,CACJ,CAODyJ,8BAA8BC,GAG1B,MAAM6G,EAAqB/W,KAAKuU,OAC3ByC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C9Y,KAAK2Z,GAAM3I,EAAiB2I,KACjC,IACI,MAAM+B,EAAuBhH,GACzB8G,EACA7G,EAAYpD,WACZ9M,KAAKsU,YAAYxH,YAMrB,OAHmBmK,EAAqB1b,KAAI,CAACwM,EAAG0H,IAC5CpC,EAAkBtF,EAAG/H,KAAKuU,OAAO9E,MAEnBlU,KAAKwM,GAAM5B,EAAAA,UAAU+G,KAAKnF,IAC/C,CAAC,MAAO8O,GACL,OAAO,IAAIva,MAAMya,EAAmB7a,QAAQgb,KAAK1Q,EACpD,CACJ,CAODyI,8BAA8BG,GAC1B,IAGI,MAAM+H,EAAsB,IAAI7a,MAAM8S,EAAUlT,QAAQgb,KACpD9P,OAAO,IAEL2P,EAAqB,IAAIza,MAAM8S,EAAUlT,QAAQgb,KACnD9P,OAAO,IAEXpH,KAAKuU,OACAyC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C7X,SAAQ,CAACgQ,EAAOiD,KACb0H,EAAoB1H,GAAK1C,EACrB3F,OAAOgI,EAAUK,GAAGrT,YACpBoQ,GAEJuK,EAAmBtH,GAAKlD,EAAiBC,EAAM,IAEvD,MAAMwE,EAAe/B,GACjBjP,KAAKiY,IAAInL,WACTiK,EACAI,EACAnX,KAAKsU,YAAYxH,WACjB9M,KAAK8P,QAAQhD,YAEjB,OAAO3G,EAASA,UAAC+G,KAAK8D,EAAa5U,WACtC,CAAC,MAAOya,GACL,OAAOO,MACV,CACJ,CAEDlG,2CACIC,EACAnE,GAEA,OAAOkE,GAA2ClE,EAAQmE,EAC7D,CAEDY,2CACIZ,EACAnE,GAEA,OAAO+E,GAA2C/E,EAAQmE,EAC7D,CAEDoB,qDACIpB,EACAnE,GAEA,OAAOuF,GACHvF,EACAmE,EAEP,CAEDqB,qDACIrB,EACAnE,GAEA,OAAOwF,GACHxF,EACAmE,EAEP,CAEDqL,sBAAsBxP,EAAmB8C,GAErC,MAAM1B,EAAYpB,EAAON,IAAIoD,GAASnU,IAAI+K,cAAImC,IAAI,IAAIgE,IAAInG,EAAGmP,aAC7D,OAAO7I,EAAOnE,IAAIuF,EACrB,CAEDuO,iBAAiB3P,EAAmB8C,GAEhC,MAAM1B,EAAY1H,EAAAA,YAAImC,IAAIiH,GAC1B,OAAO9C,EAAON,IAAIhG,EAAGmP,aAAEla,IAAIyS,EAAUvF,IAAI,IAAIgE,IAAIuB,EACpD,EA/TM+N,GAAYE,aAAG,QCjBbS,GAcThV,gBAAgBkM,GACZ,IAAKA,EAAKiE,IAAK,MAAM,IAAIxQ,MAAM,qCAC/B,OAAO,IAAIqV,GACP9I,EAAKI,GACLJ,EAAKK,QACLL,EAAKiE,IACLjE,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WAEZ,CAEDxS,YACIoS,EACAC,EACA4D,EACAnI,EACAwE,EACAC,EACAC,GAjCJxU,KAAAyU,SAAsB/G,QAASA,UAACqP,WAQhC/c,KAAA2U,aAAetI,EAAAA,WAAW,MAAO,IACjCrM,KAAA4U,cAAgBvI,EAAAA,WAAW,MAAO,IA0B9BrM,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAKiY,IAAM5L,EAAUA,WAAC4L,EAAK6E,GAAeT,cAC1Crc,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,CACrB,CAEDK,kBACIC,EACAC,GAEA,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GAEjBzD,EAAa4D,EAAGlJ,SAChB+Q,EAAmB3Q,EAAUA,WAAC8I,EAAGvI,UAAW,IAC5CkB,EAAYwD,EAAWA,YACzBjF,EAAUA,WAAC8I,EAAG1I,QAAS8E,GAAY7E,IAAIsQ,GAAkBnQ,IAAInG,EAAAA,aAC7D6K,GAGE8D,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GAEjB5D,EAAc6D,EAAGrJ,SACjBgR,EAAoB5Q,EAAUA,WAACiJ,EAAG1I,UAAW,IAC7CoB,EAAasD,EAAWA,YAC1BjF,EAAUA,WAACiJ,EAAG7I,QAASgF,GAAa/E,IAAIuQ,GAAmBpQ,IAAInG,EAAAA,aAC/D+K,GAIEyG,EAAclY,KAAKuU,OAAOhZ,KAAI,EAAGkR,UAASG,eAC5CnG,EAAKgG,GAASxF,MAAMR,EAAKmG,MAEvB0P,EAAoBtc,KAAKuU,OAAOhZ,KAAI,EAAGkR,UAASG,eAClDP,aAAWI,EAAS,IAAIC,IAAIL,EAAAA,WAAWO,EAAW,KAAKC,IAAInG,EAAGmP,eAuBlE,MApB6C,CACzCzB,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVjH,UAAWzB,EAAAA,WAAWyB,EAAWyD,GACjCvD,WAAY3B,EAAAA,WAAW2B,EAAYyD,GACnC3B,QAAS9P,KAAK8P,QACdoI,cACAoE,oBACArE,IAAKjY,KAAKiY,IACVjD,aAAcA,EACdK,cAAeA,EACf9D,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpBuL,mBACAC,oBAIP,CAEDnH,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAMA,OAAIA,IAAavI,QAASA,UAACwI,YAChBxP,EACH6K,cACIH,EAAarD,UACRpB,IAAI1M,KAAK2U,cACT9H,IAAIsE,EAAa6L,kBACtB7L,EAAaI,aAId9K,EACH6K,cACIH,EAAanD,WACRtB,IAAI1M,KAAK4U,eACT/H,IAAIsE,EAAa8L,mBACtB9L,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IACI,GAAIA,EAAOyK,SAAU,OAAOjR,EAI5B,MAQM0W,EARald,KAAKwc,sBACpBnQ,EAAAA,WACIW,EAAOyJ,GAAGtF,EAAaI,YAAYnV,WACnC+U,EAAaI,YAEjBJ,EAAarB,SAIZpD,IAAIyE,EAAa6L,kBACjBnQ,IAAInG,EAAGmP,aAENe,EAAY/I,GACd7N,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKkR,GAChCA,EAAQK,aAEZqE,EAAa6D,aACb7D,EAAakE,cACb6H,EAAgBpQ,WAChB1F,OAAO,IAGL+V,EAAoBhX,EAAAA,UAAU+G,KAAK0J,GACpClK,IAAIhG,EAAAA,aACJmG,IAAIsE,EAAa8L,mBAEtB,OAAOxW,EAAK6K,EAAWA,YAAC6L,EAAmB,IAC9C,CAAC,MAAOtG,GAEL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IACI,GAAIA,EAAOyK,SAAU,OAAOjR,EAC5B,MAAM+K,EAAaJ,EAAaI,WAC1BE,EAAcN,EAAaM,YAI3B2L,EACFjM,EAAa6L,iBAAiBlQ,WAC9B1F,OAAO,KAAO,GAAKmK,IAEjB8L,EACFlM,EAAa8L,kBAAkBnQ,WAC/B1F,OAAO,KAAO,GAAKqK,IASjByL,EANe9V,OACjB4F,EACK/F,MAAM,IAAMwK,GACZgF,GAAG,GACHra,YAGWihB,EAAoBjW,OAAO,IAAM,IAa/CkW,EAXezO,GACjB7O,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKkR,GAChCA,EAAQK,aAEZqE,EAAa6D,aACb7D,EAAakE,cACb6H,EACA9V,OAAO,IAISA,OAAO,IAAM,IAAOgW,EAMxC,OAAO3W,EAJkBzG,KAAK2c,iBAC1BxW,EAASA,UAAC+G,KAAKoQ,GACfnM,EAAarB,SAEY1T,YAAYyQ,IACrC,IAAMsE,EAAaI,WAE1B,CAAC,MAAOsF,GAEL,OADA+F,QAAQC,MAAM,mBAAmBhG,EAAIrP,WAC9BhB,CACV,CACJ,CAODyJ,8BAA8BC,GAG1B,MAAM6G,EAAqB/W,KAAKuU,OAC3ByC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C9Y,KAAK2Z,GAAM3I,EAAiB2I,KACjC,IACI,MAAM+B,EAAuBhH,GACzB8G,EACA7G,EAAYpD,WACZ9M,KAAKsU,YAAYxH,YAKrB,OAHmBmK,EAAqB1b,KAAI,CAACwM,EAAG0H,IAC5CtJ,EAAAA,UAAU+G,KAAKG,EAAkBtF,EAAG/H,KAAKuU,OAAO9E,IAAIrT,aAG3D,CAAC,MAAOya,GACL,OAAO,IAAIva,MAAMya,EAAmB7a,QAAQgb,KAAK1Q,EACpD,CACJ,CAODyI,8BAA8BG,GAC1B,IAGI,MAAM+H,EAAsB,IAAI7a,MAAM8S,EAAUlT,QAAQgb,KACpD9P,OAAO,IAEL2P,EAAqB,IAAIza,MAAM8S,EAAUlT,QAAQgb,KACnD9P,OAAO,IAEXpH,KAAKuU,OACAyC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C7X,SAAQ,CAACgQ,EAAOiD,KACb0H,EAAoB1H,GAAK1C,EACrB3F,OAAOgI,EAAUK,GAAGrT,YACpBoQ,GAEJuK,EAAmBtH,GAAKlD,EAAiBC,EAAM,IAEvD,MAAMwE,EAAe/B,GACjBjP,KAAKiY,IAAInL,WACTiK,EACAI,EACAnX,KAAKsU,YAAYxH,WACjB9M,KAAK8P,QAAQhD,YAEjB,OAAO3G,EAASA,UAAC+G,KAAK8D,EAAa5U,WACtC,CAAC,MAAOya,GACL,OAAOO,MACV,CACJ,CAEDlG,2CACIC,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAShD,OAJe/L,GAHSlE,EAAO/F,MAC3BqK,EAAAA,YAAYH,EAAa6L,iBAAkB,KAI3C7L,GAEUtE,IAAI0Q,GAAatW,MAAMuW,EACxC,CAEDzL,2CACIZ,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAShD,OAJelL,GAHS/E,EAAO/F,MAC3BqK,EAAAA,YAAYH,EAAa8L,kBAAmB,KAI5C9L,GAEUtE,IAAI0Q,GAAatW,MAAMuW,EACxC,CAEDjL,qDACIpB,EACAnE,GAEA,MAAMwQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAEhD,OAAO1K,GACHvF,EACAmE,GACFlK,MAAMuW,EACX,CAEDhL,qDACIrB,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAEhD,OAAOzK,GACHxF,EACAmE,GAECtE,IAAI0Q,GACJtW,MAAMuW,GACNvW,MAAMuW,EACd,CAEDhB,sBAAsBxP,EAAmB8C,GAErC,MAAM1B,EAAYpB,EAAON,IAAIoD,GAASnU,IAAI+K,cAAImC,IAAI,IAAIgE,IAAInG,EAAGmP,aAC7D,OAAO7I,EAAOnE,IAAIuF,EACrB,CAEDuO,iBAAiB3P,EAAmB8C,GAEhC,MAAM1B,EAAY1H,EAAAA,YAAImC,IAAIiH,GAC1B,OAAO9C,EAAON,IAAIhG,EAAGmP,aAAEla,IAAIyS,EAAUvF,IAAI,IAAIgE,IAAIuB,EACpD,ECtbC,SAAUqP,GACZC,EACAC,EACAC,EACAzD,EACA0D,GAIA,GAAI1D,GAAa/S,OAAO,GACpB,OAAO0W,GAAWJ,EAAQG,GAG9B,MAAME,EAAsBD,GAAWH,EAAaE,GAE9CG,EADmBF,GAAWH,EAAcD,EAAQG,GACdE,EACtC3K,EAAY6K,GACdF,EACAH,EACAC,GAEJ,OAAOhW,EAAQM,QAAQN,EAAQ6E,IAAIyN,EAAW6D,GAAmB5K,EACrE,CAEM,SAAU8K,GACZC,EACAR,EACAC,EACAzD,EACA0D,GAGA,MAAME,EAAsBD,GAAWH,EAAaE,GAE9CG,EAAmBD,EADAD,GAAWH,EAAcQ,EAASN,GAErDzK,EAAYgL,GACdL,EACAH,EACAC,GAEJ,OAAOhW,EAAQK,MAAML,EAAQ6E,IAAIyN,EAAW6D,GAAmB5K,EACnE,CAEM,SAAUiL,GACZC,EACAX,EACAC,EACAzD,EACA0D,GAGA,MAAMU,EAAcT,GAAWH,EAAaE,GACtC/K,EAAoBmL,GACtBM,EACAX,EACAC,GAGErE,EAAe4E,GACjBG,EAFsBX,EAAiBU,EAIvCT,GAMJ,OAAO1D,EAJetS,EAAQM,QAC1BN,EAAQ6E,IAAIyN,EAAWX,GACvB1G,EAGR,CAEM,SAAU0L,GACZd,EACAC,EACAC,EACAzD,EACA0D,GAGA,MAAME,EAAsBD,GAAWH,EAAaE,GAE9CG,EADmBF,GAAWH,EAAcD,EAAQG,GACdE,EAC5C,OAAOlW,EAAQyF,aAAa0Q,EAAkBH,EAAOY,KACzD,CAEM,SAAUC,GACZP,EACAR,EACAC,EACAzD,EACA0D,GAGA,MAEMG,EAFsBF,GAAWH,EAAaE,GAC3BC,GAAWH,EAAcQ,EAASN,GAE3D,OAAOhW,EAAQ4G,WAAWuP,EAAkBH,EAAOY,KACvD,CAEM,SAAUE,GACZC,EACAjB,EACAC,EACAzD,EACA0D,GAGA,GAAI1D,GAAa/S,OAAO,GACpB,OAAOyX,GAAaD,EAAQf,GAEhC,MAAME,EAAsBD,GAAWH,EAAaE,GAC9CzK,EAAY6K,GACdF,EACAH,EACAC,GAQJ,OADuBgB,GADEd,EAJAlW,EAAQK,MAC7BL,EAAQ6E,IAAI0G,EAAWwL,GACvBzE,GAGkD0D,GAC9BF,CAC5B,CAEM,SAAUmB,GACZC,EACApB,EACAC,EACAzD,EACA0D,GAGA,MAAME,EAAsBD,GAAWH,EAAaE,GAC9CzK,EAAYgL,GACdL,EACAH,EACAC,GAQJ,OAAOF,EADgBkB,GADEd,EAJAlW,EAAQM,QAC7BN,EAAQ6E,IAAI0G,EAAW2L,GACvB5E,GAGkD0D,EAE1D,CAEM,SAAUmB,GACZC,EACAtB,EACAC,EACAzD,EACA0D,GAOA,OAAOF,EADgBkB,GAHKf,GAAWH,EAAaE,GAC3BhW,EAAQsF,aAAa8R,EAAWpB,EAAOY,MAEVZ,EAE1D,CAEM,SAAUqB,GACZZ,EACAX,EACAC,EACAzD,EACA0D,GAOA,OADuBgB,GAHKf,GAAWH,EAAaE,GAC3BhW,EAAQc,WAAW2V,EAAYT,EAAOY,MAETZ,GAC9BF,CAC5B,CAEM,SAAUwB,GACZF,EACAtB,EACAC,EACAzD,EACA0D,GAGA,GAAI1D,GAAa/S,OAAO,GAEpB,OAAOS,EAAQsF,aAAa8R,EAAWpB,EAAOY,MAGlD,MAAMF,EAAcT,GAAWH,EAAaE,GACtC/K,EAAoBmL,GACtBM,EACAX,EACAC,GAGErE,EAAe4E,GACjBG,EAFsBX,EAAiBqB,EAIvCpB,GAMJ,OAJsBhW,EAAQM,QAC1BN,EAAQ6E,IAAIyN,EAAWX,GACvB1G,GAEmBqH,CAC3B,CAEM,SAAUiF,GACZR,EACAjB,EACAC,EACAzD,EACA0D,GAGA,GAAI1D,GAAa/S,OAAO,GAEpB,OAAOS,EAAQ4G,WAAWmQ,EAAQf,EAAOY,MAG7C,MAAMF,EAAcT,GAAWH,EAAaE,GACtC/K,EAAoBmL,GACtBM,EACAX,EACAC,GAEEwB,EAAgBlF,EAAYyE,EASlC,OAR0B/W,EAAQ4G,WAC9B5G,EAAQK,MACJL,EAAQ6E,IAAI2S,EAAevM,GAC3BqH,GACAoE,EACJV,EAAOY,MAGgBb,CAC/B,CAEM,SAAU0B,GACZP,EACApB,EACAC,EACAzD,EACA0D,GAGA,MAAMU,EAAcT,GAAWH,EAAaE,GACtC/K,EAAoBmL,GACtBM,EACAX,EACAC,GAEEwB,EAAgBlF,EAAY4E,EASlC,OAAOnB,EARmB/V,EAAQ4G,WAC9B5G,EAAQK,MACJL,EAAQ6E,IAAI2S,EAAevM,GAC3BqH,GACAoE,EACJV,EAAOY,KAIf,CAEA,SAASR,GACLsB,EACA3B,EACAC,GAEA,OAAO0B,EAAqB1X,EAAQc,WAAWiV,EAAgBC,EAAOY,KAC1E,CAEA,SAASL,GACLmB,EACA3B,EACAC,GAEA,OACI0B,EAAqB1X,EAAQsF,aAAayQ,EAAgBC,EAAOY,KAEzE,CAEA,SAASX,GAAW0B,EAAc3B,GAG9B,GAAI2B,EAAO3B,EAAO4B,YAAa,CAC3B,MAAMC,EAAO7X,EAAQsF,aACjB0Q,EAAO4B,YAAcD,EACrB3B,EAAO1P,KAEX,OAAOtG,EAAQgB,IAAI2W,EAAME,EAC5B,CAAM,GAAIF,GAAQ3B,EAAO8B,YACtB,OAAOH,EACJ,CACH,MAAME,EAAO7X,EAAQsF,aACjBqS,EAAO3B,EAAO8B,YACd9B,EAAO1P,KAEX,OAAOtG,EAAQgB,IAAI2W,EAAME,EAC5B,CACL,CAEA,SAASb,GAAae,EAAiB/B,GAEnC,OAAI+B,EAAU/B,EAAO4B,YACV5X,EAAQyF,aACXsS,EAAU/X,EAAQsF,aAAa0Q,EAAO1P,IAAK0P,EAAO4B,aAClD5X,EAAQnB,IAAMmX,EAAO1P,KAElByR,GAAW/B,EAAO8B,YAClBC,EAEA/X,EAAQyF,aACXsS,EAAU/X,EAAQsF,aAAa0Q,EAAO1P,IAAK0P,EAAO8B,aAClD9X,EAAQnB,IAAMmX,EAAO1P,IAGjC,CAEA,SAAS0R,GAAwB7S,EAAgB6Q,GAC7C,MAAMiC,EAAcjY,EAAQ+G,gBAAgBiP,EAAO1P,KAC7C4R,EAAalY,EAAQnB,IAAMmX,EAAO1P,IACxC,OAAInB,GAAU6Q,EAAO4B,YACVM,EACA/S,GAAU6Q,EAAO8B,YACjB9X,EAAQnB,IAERoZ,CAEf,CAEA,SAASE,GAAyBhT,EAAgB6Q,GAC9C,MAAMiC,EAAcjY,EAAQ+G,gBAAgBiP,EAAO1P,KAC7C4R,EAAalY,EAAQnB,IAAMmX,EAAO1P,IACxC,OAAInB,EAAS6Q,EAAO4B,YACTM,EACA/S,EAAS6Q,EAAO8B,YAChB9X,EAAQnB,IAERoZ,CAEf,CAEA,SAASG,GAA0BjT,EAAgB6Q,GAC/C,MAAMiC,EAAcjY,EAAQ+G,gBAAgBiP,EAAO1P,KAC7C4R,EAAalY,EAAQnB,IAAMmX,EAAO1P,IACxC,OAAInB,GAAU6Q,EAAO4B,YACV5X,EAAQ4G,WAAW5G,EAAQnB,IAAKqZ,GAChC/S,GAAU6Q,EAAO8B,YACjB9X,EAAQnB,IAERmB,EAAQ4G,WAAW5G,EAAQnB,IAAKoZ,EAE/C,CAEA,SAASI,GAA2BlT,EAAgB6Q,GAChD,MAAMiC,EAAcjY,EAAQ+G,gBAAgBiP,EAAO1P,KAC7C4R,EAAalY,EAAQnB,IAAMmX,EAAO1P,IACxC,OAAInB,EAAS6Q,EAAO4B,YACT5X,EAAQ4G,WAAW5G,EAAQnB,IAAKqZ,GAChC/S,EAAS6Q,EAAO8B,YAChB9X,EAAQnB,IAERmB,EAAQ4G,WAAW5G,EAAQnB,IAAKoZ,EAE/C,CAqCM,SAAUK,GACZzC,EACAC,EACAC,EACAzD,EACA0D,GAEA,MAAMuC,EAAmB1C,EAASC,EAE5BvK,EAAYgL,GADUN,GAAWH,EAAaE,GAGhDD,EACAC,GAEJ,IAAIwC,EAAaxY,EAAQnB,IAIzB,OAHIyT,GAAa/S,OAAO,KACpBiZ,EAAaxY,EAAQ4G,WAAW2E,EAAW+G,IAExCtS,EAAQ4G,WACX4R,EACAL,GAAyBI,EAAkBvC,GAEnD,CAIM,SAAUyC,GACZ1B,EACAjB,EACAC,EACAzD,EACA0D,GAEA,MAAME,EAAsBD,GAAWH,EAAaE,GAC9CzK,EAAYgL,GACdL,EACAH,EACAC,GAEJ,IAAIwC,EAAaxY,EAAQnB,IACrByT,GAAa/S,OAAO,KACpBiZ,EAAaxY,EAAQ4G,WAAW2E,EAAW+G,IAE/C,MACMoG,EAAmBxC,EADAlW,EAAQc,WAAWiW,EAAQyB,GAEpD,OAAOxY,EAAQc,WACX0X,EACAH,GAA2BK,EAAkB1C,GAErD,CAIM,SAAU2C,GACZzB,EACApB,EACAC,EACAzD,EACA0D,GAEA,MAAME,EAAsBD,GAAWH,EAAaE,GAC9CzK,EAAYgL,GACdL,EACAH,EACAC,GAEEwC,EAAaxY,EAAQyF,aAAa8F,EAAW+G,GAC7C6D,EAAmBnW,EAAQsF,aAAa4R,EAAOsB,GAC/CE,EAAmB1Y,EAAQgB,IAAIkV,EAAqBC,GAC1D,OAAOnW,EAAQ4G,WACX5G,EAAQnB,IACRmB,EAAQc,WACJ0X,EACAJ,GAA0BM,EAAkB1C,IAGxD,CAIM,SAAU4C,GACZtC,EACAR,EACAC,EACAzD,EACA0D,GAEA,MAAMuC,EAAmBvY,EAAQgB,IAAI8U,EAAaQ,GAE5C/K,EAAYgL,GADUN,GAAWH,EAAaE,GAGhDD,EACAC,GAEEwC,EAAaxY,EAAQ4G,WAAW2E,EAAW+G,GACjD,OAAOtS,EAAQ4G,WACXoR,GAAwBO,EAAkBvC,GAC1CwC,EAER,CAIM,SAAUK,GACZpC,EACAX,EACAC,EACAzD,EACA0D,GAEA,MAEM0C,EAFsBzC,GAAWH,EAAaE,GAC3BhW,EAAQc,WAAW2V,EAAYT,EAAOY,MAE/D,OAAO5W,EAAQc,WACXuX,GAA2BK,EAAkB1C,GAC7CA,EAAOY,KAEf,CAIM,SAAUkC,GACZxC,EACAR,EACAC,EACAzD,EACA0D,GAEA,MAAM+C,EAAYjD,EAAcQ,EAChC,OAAOtW,EAAQ4G,WACXoR,GAAwBe,EAAW/C,GACnCA,EAAOY,KAEf,CAIM,SAAUoC,GACZnD,EACAC,EACAC,EACAzD,EACA0D,GAEA,OAAOhW,EAAQyF,aACXuQ,EAAOY,KACPuB,GAAyBrC,EAAcD,EAAQG,GAEvD,CAIM,SAAUiD,GACZ7B,EACAtB,EACAC,EACAzD,EACA0D,GAEA,MAEM0C,EAFsBzC,GAAWH,EAAaE,GAC3BhW,EAAQsF,aAAa8R,EAAWpB,EAAOY,MAE1DsC,EAAelZ,EAAQc,WACzBsX,GAA0BM,EAAkB1C,GAC5CA,EAAOY,MAEX,OAAO5W,EAAQ4G,WAAW5G,EAAQnB,IAAKqa,EAC3C,CAIM,SAAUC,GACZ/B,EACAtB,EACAC,EACAzD,EACA0D,GAEA,GAAI1D,GAAa/S,OAAO,GACpB,OAAOyW,EAAOY,KAElB,MACM3L,EAAoBmL,GADNH,GAAWH,EAAaE,GAGxCD,EACAC,GAEJ,OAAOhW,EAAQ4G,WACXqE,EACAjL,EAAQc,WAAWwR,EAAW0D,EAAOY,MAE7C,CAIM,SAAUwC,GACZlC,EACApB,EACAC,EACAzD,EACA0D,GAEA,MACM/K,EAAoBmL,GADNH,GAAWH,EAAaE,GAGxCD,EACAC,GAEJ,OAAOhW,EAAQK,MACXL,EAAQ6E,IAAIyN,EAAW0D,EAAOY,MAC9B3L,EAER,CAIM,SAAUoO,GACZtC,EACAjB,EACAC,EACAzD,EACA0D,GAEA,GAAI1D,GAAa/S,OAAO,GACpB,OAAOS,EAAQ4G,WAAW5G,EAAQnB,IAAKmX,EAAOY,MAGlD,MACM3L,EAAoBmL,GADNH,GAAWH,EAAaE,GAGxCD,EACAC,GAEJ,OAAOhW,EAAQ4G,WACXqE,EACAjL,EAAQc,WAAWwR,EAAW0D,EAAOY,MAE7C,CAIM,SAAU0C,GACZ7C,EACAX,EACAC,EACAzD,EACA0D,GAEA,MACM/K,EAAoBmL,GADNH,GAAWH,EAAaE,GAGxCD,EACAC,GAEJ,OAAOhW,EAAQM,QACXN,EAAQ6E,IAAIyN,EAAW0D,EAAOY,MAC9B3L,EAER,CDzmBWgK,GAAYT,aAAG,MEddzJ,gRDkVN,SACF1D,EACAgB,EACAb,EACA+R,GAcA,MAAMhR,EAAWvI,EAAQyF,aAAa4C,EAAab,GAC7CgB,EAAuB,IAAI/T,MAAM4S,EAAShT,QAAQgb,KAAK/P,GAC7D,IAAK,IAAIsI,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAE7BA,GAAK2R,IACL/Q,EAAWZ,GAAK5H,EAAQsF,aAAa+B,EAASO,GAAIW,IAG1D,OAAOC,CACX,ulBC7WA,SAAYuC,GACRA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,wBAAA,GAAA,0BACAA,EAAAA,EAAA,wBAAA,GAAA,0BACAA,EAAAA,EAAA,kBAAA,GAAA,oBACAA,EAAAA,EAAA,kBAAA,GAAA,mBACH,CAPD,CAAYA,KAAAA,GAOX,CAAA,UAoBYyO,GAoBTvZ,gBAAgBkM,GACZ,QAAuB/V,IAAnB+V,EAAKsN,UACL,MAAM,IAAI7Z,MAAM,gCACpB,QAA0BxJ,IAAtB+V,EAAKuN,aACL,MAAM,IAAI9Z,MAAM,mCACpB,IAAKuM,EAAKyL,YACN,MAAM,IAAIhY,MAAM,kCACpB,IAAKuM,EAAK2L,YACN,MAAM,IAAIlY,MAAM,kCACpB,OAAO,IAAI4Z,GACPrN,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACLR,EAAKsN,UACLtN,EAAKuN,aACLvN,EAAKyL,YACLzL,EAAK2L,YAEZ,CAED3d,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACA8M,EACAC,EACA9B,EACAE,GApDJ3f,KAAAyU,SAAsB/G,QAASA,UAAC8T,OAchCxhB,KAASyhB,UAAGpV,EAAAA,WAAW,KAAM,IAC7BrM,KAAA0hB,WAAarV,EAAAA,WAAW,OAAQ,IAEhCrM,KAAA2hB,kBAAoBxb,YAAU+G,KAAK,KAAKlG,IAAI,OAAO6B,IAAI,KAqCnD7I,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAKshB,UAAYA,EACjBthB,KAAKohB,SAAWphB,KAAKwU,WAAWoN,QAAQ5hB,KAAKqU,SAC7CrU,KAAKuhB,aAAeA,EACpBvhB,KAAK6hB,gBAAkB7hB,KAAKuU,OAAOvU,KAAKuhB,cAActV,SACtDjM,KAAKyf,YAAcpT,EAAAA,WAAWoT,EAAa,IAC3Czf,KAAK2f,YAActT,EAAAA,WAAWsT,EAAa,GAC9C,CAED9K,kBAAkBC,EAAiBC,GAC/B,IAAIQ,EAEJ,MAAMJ,EAAKnV,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAASS,KAC5D,IAAKK,EAAI,MAAM1N,MAAM,kCAAkCqN,KACvD,MAAMvD,EAAa4D,EAAGlJ,SAChB6B,EAAYzB,EAAUA,WAAC8I,EAAG1I,QAAS8E,GAEnC+D,EAAKtV,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAASU,KAC5D,IAAKO,EAAI,MAAM7N,MAAM,mCAAmCsN,KACxD,MAAMtD,EAAc6D,EAAGrJ,SACjB+B,EAAa3B,EAAUA,WAACiJ,EAAG7I,QAASgF,GAKlC8D,EAFJ3J,EAAckJ,EAAS9U,KAAKqU,SACxBzI,EAAcmJ,EAAU/U,KAAKuU,OAAOvU,KAAKuhB,cAAclN,SAC5CzB,GAAUkP,kBACTlP,GAAUmP,eACnBnW,EAAcmJ,EAAU/U,KAAKqU,SAChCzI,EAAckJ,EAAS9U,KAAKuU,OAAOvU,KAAKuhB,cAAclN,SAC3CzB,GAAUoP,kBACTpP,GAAUqP,eAEtBrW,EAAckJ,EAAS9U,KAAKuU,OAAOvU,KAAKuhB,cAAclN,SAC3CzB,GAAUsP,wBACTtP,GAAUuP,wBAI9B,MAAM7F,EAAoBtc,KAAKuU,OAAOhZ,KAAI,EAAGkR,aACzCJ,EAAUA,WAACI,EAAS,MAKlB2V,EAAmB9F,EAAkBtc,KAAKohB,UAC1CiB,EAAmBriB,KAAK2hB,kBAAkB9Y,IAAIuZ,GA4BpD,MA1ByC,CACrChO,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfc,SAAUA,EACVT,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAWA,EACXE,WAAYA,EACZ8B,QAAS9P,KAAK8P,QACd8N,eAAgBhX,EACZH,EAAKzG,KAAKuU,OAAOvU,KAAKuhB,cAAc9U,SACpCzM,KAAK6hB,iBAETS,qBAAsBhG,EAAkBtc,KAAKuhB,cAC7CM,gBAAiB7hB,KAAK6hB,gBACtBpD,KAAMpS,EAAAA,WAAWrM,KAAKuU,OAAOvU,KAAKuhB,cAAc3U,UAAW,IAC3D6S,YAAazf,KAAKyf,YAClBE,YAAa3f,KAAK2f,YAClB4C,kBAAmBjG,EAAkBtc,KAAKshB,WAC1Cc,mBACAC,mBAIP,CAGDvM,uBAAuB3E,GACnB,OAAOxK,CAGV,CAEDoP,mBACI5E,EACA6E,GAGA,MAAMwM,EAAqBrR,EACrBsR,EAAkB7b,EACpBH,EAAK0K,EAAanD,WAAW5R,aAC5B+U,EAAaM,aAGlB,GAAIuE,IAAavI,QAASA,UAACwI,YAAa,CACpC,GAAIuM,EAAmBjN,WAAa3C,GAAUqP,eAC1C,OAAOjiB,KAAK0iB,2BACRvR,EACAsR,EACKxb,MAAMjH,KAAK0hB,WAAWtlB,YACtByQ,IAAInG,EAAGmP,YAACzZ,aAEd,GACHomB,EAAmBjN,WAAa3C,GAAUoP,kBAG1C,OAAOpb,EAAMH,EAAKzG,KAAK2hB,kBAAkBvlB,aAAc,IACpD,GACHomB,EAAmBjN,WAAa3C,GAAUmP,eAI1C,OAAO/hB,KAAK2iB,2BACRH,EACAC,EACKxb,MAAMjH,KAAK0hB,WAAWtlB,YACtByQ,IAAInG,EAAGmP,YAACzZ,aAEd,GACHomB,EAAmBjN,WAAa3C,GAAUkP,kBAC5C,CAQE,OAPc9hB,KAAK4iB,8BACfzR,EACAsR,EACKxb,MAAMjH,KAAK0hB,WAAWtlB,YACtByQ,IAAInG,EAAGmP,YAACzZ,YAIpB,CAAM,GACHomB,EAAmBjN,WACf3C,GAAUuP,yBACdK,EAAmBjN,WACf3C,GAAUsP,wBAChB,CAOE,OAAOtb,EANOH,EACV0K,EAAanD,WACRtB,IAAI1M,KAAK0hB,YACT7U,IAAInG,EAAAA,aACJtK,aAEY+U,EAAaM,YACrC,CAAM,OAAOhL,EAAK,EACtB,CACG,GACI+b,EAAmBjN,WAAa3C,GAAUqP,gBAC1CO,EAAmBjN,WAAa3C,GAAUoP,kBAC5C,CAOE,OAAOpb,EANOH,EACV0K,EAAanD,WACRtB,IAAI1M,KAAKyhB,WACT5U,IAAInG,EAAAA,aACJtK,aAEY+U,EAAaM,YACrC,CAAM,GACH+Q,EAAmBjN,WAAa3C,GAAUmP,gBAC1CS,EAAmBjN,WAAa3C,GAAUkP,mBAC1CU,EAAmBjN,WACf3C,GAAUuP,yBACdK,EAAmBjN,WACf3C,GAAUsP,wBAChB,CAOE,OAAOtb,EANOH,EACV0K,EAAanD,WACRtB,IAAI1M,KAAK0hB,YACT7U,IAAInG,EAAAA,aACJtK,aAEY+U,EAAaM,YACrC,CAAM,OAAOhL,EAAK,EAE1B,CAGDyP,0BAA0B1J,EAAe2J,GAErC,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCAGpB,GAAImE,EAAc5L,KAAKqU,QAAS7H,GAAQ,CACpC,MACMqW,EADqBxW,EAAAA,WAAWgK,EAAE5J,QAAS4J,EAAEpK,UACnBpD,IAAIsN,GAC9BI,EAAiBvW,KAAKsU,YAAY3Y,IAAIknB,GAC5C7iB,KAAKoW,kBAAkBG,EAC1B,CAEDF,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,OAAImE,EAAaoE,WAAa3C,GAAUqP,eAC7BjiB,KAAK8iB,2BAA2B3R,EAAcnE,GAC9CmE,EAAaoE,WAAa3C,GAAUmP,eACpC/hB,KAAK+iB,2BAA2B5R,EAAcnE,GAC9CmE,EAAaoE,WAAa3C,GAAUoP,kBACpChiB,KAAKgjB,8BAA8B7R,EAAcnE,GACjDmE,EAAaoE,WAAa3C,GAAUkP,kBACpC9hB,KAAKijB,8BAA8B9R,EAAcnE,GAExDmE,EAAaoE,WAAa3C,GAAUuP,wBAE7BniB,KAAKkjB,+BAA+B/R,EAAcnE,GAEzDmE,EAAaoE,WAAa3C,GAAUsP,wBAE7BliB,KAAKmjB,+BAA+BhS,EAAcnE,GAC/CvG,EAAK,EACtB,CAED0c,+BACIhS,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDuY,GACRzC,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAED0c,+BACI/R,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBD+X,GACRjC,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDsc,2BACI3R,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDgX,GACRlB,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDuc,2BACI5R,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDqY,GACRvC,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDwc,8BACI7R,EACAnE,GAEA,IAkBI,OAAOpG,EAAMH,EAfD0Y,GACR9S,aAAWW,EAAO5Q,WAAY,IAAI0Q,WAClCqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAMV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDyc,8BACI9R,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBD6Y,GACR/C,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,OAAImE,EAAaoE,WAAa3C,GAAUqP,eAC7BjiB,KAAK0iB,2BAA2BvR,EAAcnE,GAC9CmE,EAAaoE,WAAa3C,GAAUmP,eACpC/hB,KAAK2iB,2BAA2BxR,EAAcnE,GAC9CmE,EAAaoE,WAAa3C,GAAUoP,kBACpChiB,KAAKojB,8BAA8BjS,EAAcnE,GACjDmE,EAAaoE,WAAa3C,GAAUkP,kBACpC9hB,KAAK4iB,8BAA8BzR,EAAcnE,GAExDmE,EAAaoE,WAAa3C,GAAUuP,wBAE7BniB,KAAKqjB,+BAA+BlS,EAAcnE,GAEzDmE,EAAaoE,WAAa3C,GAAUsP,wBAE7BliB,KAAKsjB,+BAA+BnS,EAAcnE,GAC/CvG,EAAK,EACtB,CAED6c,+BACInS,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDiY,GACRnC,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAED6c,+BACIlS,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDyY,GACR3C,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOrQ,CACV,CACJ,CAEDkc,2BACIvR,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAmBhD,OAAOwK,EAAMH,EAhBDkY,GACRpC,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaI,WACb,EAEP,CAAC,MAAOsF,GACL,OAAOrQ,CACV,CACJ,CAEDmc,2BACIxR,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBDyX,GACR3B,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaI,WACb,EAEP,CAAC,MAAOsF,GACL,OAAOrQ,CACV,CACJ,CAED4c,8BACIjS,EACAnE,GAEA,IAGI,MAAMuP,EAAYlQ,EAAAA,WAAWW,EAAO5Q,WAAY,IAkBhD,OAAOwK,EAAMH,EAhBD2Y,GACR7C,EAAUzP,WACVqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaI,WACb,EAEP,CAAC,MAAOsF,GACL,OAAOrQ,CACV,CACJ,CAEDoc,8BACIzR,EACAnE,GAEA,IAoBI,OAAOpG,EAAMH,EAjBD4X,GAERhS,EAAUA,WAACW,EAAO5Q,WAAY,IAAI0Q,WAClCqE,EAAaoR,kBAAkBzV,WAC/BqE,EAAamR,qBAAqBxV,WAClCqE,EAAakR,iBAAiBvV,WAC9B,CACIqB,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,aAOV1Q,aAAc,IAAIqa,GACpCtF,EAAaI,WACb,EAEP,CAAC,MAAOsF,GACL,OAAOrQ,CACV,CACJ,CAGDyJ,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAIDlG,2CACIC,EACAnE,GAEA,IACI,MAAMuW,EAAelX,EAAAA,WACjBW,EAAOyJ,GAAG,IAAIra,WACd,IACF0Q,WACI6Q,EAAcxM,EAAaoR,kBAAkBzV,WAC7C8Q,EAAiBzM,EAAamR,qBAAqBxV,WACnDqN,EAAYhJ,EAAakR,iBAAiBvV,WAC1C+Q,EAAS,CACX1P,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,YAE5B,IAAIzU,EACJ,GAAI8Y,EAAaoE,WAAa3C,GAAUqP,eACpC5pB,EAAS8nB,GACLoD,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUmP,eAC3C1pB,EAASmoB,GACL+C,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUoP,kBAC3C3pB,EAAS2oB,GACLuC,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUkP,kBAC3CzpB,EAAS4oB,GACLsC,EACA5F,EACAC,EACAzD,EACA0D,QAED,GACH1M,EAAaoE,WAAa3C,GAAUuP,wBAEpC9pB,EAASwoB,GACL0C,EACA5F,EACAC,EACAzD,EACA0D,OAED,IACH1M,EAAaoE,WAAa3C,GAAUsP,wBASjC,OAAOzb,EAAK,GAPfpO,EAASyoB,GACLyC,EACA5F,EACAC,EACAzD,EACA0D,EAEa,CACrB,OAAOjX,EAAMH,EAAKpO,EAAO+D,aAAc,IAAIqa,GACvCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOpQ,EAAK,EACf,CACJ,CAEDsL,2CACIZ,EACAnE,GAEA,IACI,MAAMuW,EAAelX,EAAAA,WACjBW,EAAOyJ,GAAG,IAAIra,WACd,IACF0Q,WACI6Q,EAAcxM,EAAaoR,kBAAkBzV,WAC7C8Q,EAAiBzM,EAAamR,qBAAqBxV,WACnDqN,EAAYhJ,EAAakR,iBAAiBvV,WAC1C+Q,EAAS,CACX1P,IAAKgD,EAAarB,QAAQhD,WAC1B2S,YAAatO,EAAasO,YAAY3S,WACtC6S,YAAaxO,EAAawO,YAAY7S,WACtC2R,KAAMtN,EAAasN,KAAK3R,YAE5B,IAAIzU,EACJ,GAAI8Y,EAAaoE,WAAa3C,GAAUqP,eACpC5pB,EAASioB,GACLiD,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUmP,eAC3C1pB,EAASooB,GACL8C,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUoP,kBAC3C3pB,EAAS6oB,GACLqC,EACA5F,EACAC,EACAzD,EACA0D,QAED,GAAI1M,EAAaoE,WAAa3C,GAAUkP,kBAC3CzpB,EAAS8oB,GACLoC,EACA5F,EACAC,EACAzD,EACA0D,QAED,GACH1M,EAAaoE,WAAa3C,GAAUuP,wBAEpC9pB,EAASqoB,GACL6C,EACA5F,EACAC,EACAzD,EACA0D,OAED,IACH1M,EAAaoE,WAAa3C,GAAUsP,wBASjC,OAAOzb,EAAK,GAPfpO,EAASsoB,GACL4C,EACA5F,EACAC,EACAzD,EACA0D,EAEa,CACrB,OAAOjX,EAAMH,EAAKpO,EAAO+D,aAAc,IAAIqa,GACvCtF,EAAaM,YACb,EAEP,CAAC,MAAOoF,GACL,OAAOpQ,EAAK,EACf,CACJ,CAED8L,qDAEIpB,EAEAnE,GAEA,OAAOvG,EAAK,EACf,CAED+L,qDAEIrB,EAEAnE,GAEA,OAAOvG,EAAK,EACf,WC/rBW+c,GACZC,EACAC,EACAC,GAEA,IAAIzO,EACAwO,EAAwBD,EAClBA,EAAaC,EACb,EAEV,OADAxO,GAAQyO,EACDzO,CACX,OC9Oa0O,GAeT9b,gBAAgBkM,GACZ,IAAKA,EAAKyP,WAAY,MAAM,IAAIhc,MAAM,kCACtC,IAAKuM,EAAK2P,YACN,MAAM,IAAIlc,MAAM,mCACpB,IAAKuM,EAAK6P,eACN,MAAM,IAAIpc,MAAM,sCAEpB,IAAKuM,EAAK8P,UAAW,MAAM,IAAIrc,MAAM,iCAErC,OAAO,IAAImc,GACP5P,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACLR,EAAKyP,WACLzP,EAAK2P,YACL3P,EAAK6P,eACL7P,EAAK8P,UAEZ,CAED9hB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACAiP,EACAE,EACAE,EACAC,GA/CJ9jB,KAAAyU,SAAsB/G,QAASA,UAACqW,QAiD5B/jB,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAKyjB,WAAaA,EAClBzjB,KAAK2jB,YAAcA,EACnB3jB,KAAK6jB,eAAiBA,EACtB7jB,KAAK8jB,UAAYA,EACjB9jB,KAAK0jB,sBAAwB,CAChC,CAEDM,yBAAyBC,GACrBjkB,KAAK0jB,sBAAwBO,CAChC,CAEDpP,kBAAkBC,EAAiBC,GAC/B,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GACjBzD,EAAa4D,EAAGlJ,SAEhBoJ,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GACjB5D,EAAc6D,EAAGrJ,SAGjBiY,EAAgB7X,EAAUA,WAAC8I,EAAG1I,QAAS8E,GACvC4S,EAAiB9X,EAAUA,WAACiJ,EAAG7I,QAASgF,GAC9C,IAAI3D,EAAYoW,EACZlW,EAAamW,EACbrP,GAAW9U,KAAK6jB,eAChB/V,EAAYoW,EAAcvoB,IAAIqE,KAAKsU,aAC5BS,GAAY/U,KAAK6jB,iBACxB7V,EAAamW,EAAexoB,IAAIqE,KAAKsU,cAsBzC,MAnB0C,CACtCF,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACV8O,eAAgB7jB,KAAK6jB,eACrBC,UAAW9jB,KAAK8jB,UAChBvS,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,YACAE,aACA8B,QAAS9P,KAAK8P,QACdwE,YAAatU,KAAKsU,YAClBmP,WAAYzjB,KAAKyjB,WACjBE,YAAa3jB,KAAK2jB,YAClBD,sBAAuB1jB,KAAK0jB,sBAInC,CAED5N,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,MAAMpB,EAAgBvI,EAAAA,WAAW,MAAO,IACxC,GAAI2J,IAAavI,QAASA,UAACwI,YAAa,CAGpC,MAAM7E,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNxjB,KAAKyjB,WACLzjB,KAAK0jB,sBACL1jB,KAAK2jB,aAET,OAAOld,GAAM2K,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,MAAQ,GAAK,EAAIA,IAAM9D,EAClE,CACG,OAAO3K,EACH6K,EAAWA,YACPH,EAAanD,WAAWtB,IAAIkI,GAAe/H,IAAInG,EAAAA,aAC/CyK,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBD7MlC,SACZ1W,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAM8E,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEX/R,EAAK5E,EAAO6E,WAClB,OAAOpL,EACH+K,GACKJ,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MAC9C,GAAK,EAAIA,IACdkP,KAAKC,IACDzS,EACIJ,GACCJ,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MAC9C,GAAK,EAAIA,KAElBpD,EAEhB,CC8Ke0E,CAAyBxJ,EAAQmE,EAC3C,CAED2F,yBACI3F,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBDlLlC,SACZ1W,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAM8E,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEXvR,EAAKpF,EAAO6E,WAClB,OAAOpL,GACF2K,GACIA,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC/C,GAAK,EAAIA,IACdkP,KAAKC,KACAjS,EACGhB,GACCA,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC/C,GAAK,EAAIA,KAElBpD,EAEhB,CCmJegF,CAAyB9J,EAAQmE,EAC3C,CAGDlB,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDlG,2CACIC,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBD9JlC,SACZ1W,EACAmE,GAEA,MAAMW,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEX/R,EAAK5E,EAAO6E,WAClB,OAAOpL,EACH,IACM2K,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,IACDtD,EAAKR,IAAO8D,EACbkP,KAAKC,IACD,GACKjT,IAAO,EAAI8D,IACPtD,EAAKR,KAAQ,EAAI8D,GAClB1D,IAAO,EAAI0D,MACL,GAAK,EAAIA,GAAb,IACDtD,EAAKR,IAAO8D,GAErBpD,GAEpB,CC+HeZ,CAA2ClE,EAAQmE,EAC7D,CAEDY,2CACIZ,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBDlIlC,SACZ1W,EACAmE,GAEA,MAAMW,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEXvR,EAAKpF,EAAO6E,WAClB,OAAOpL,GACF2K,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,KACA9C,EAAKZ,IAAO0D,EACdkP,KAAKC,KAEIjT,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,KACA9C,EAAKZ,IAAO0D,EAHrB,GAKDpD,EAEhB,CCsGeC,CAA2C/E,EAAQmE,EAC7D,CAEDoB,qDACIpB,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBDrGlC,SACZ1W,EACAmE,GAEA,MAAMW,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEX/R,EAAK5E,EAAO6E,WAClB,OAAOpL,OAGO2K,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,KACI,GAAK,EAAIA,GAAb,IACD,EAAIA,IACRtD,EAAKR,KAAQ,EAAI8D,IAEjBtD,EAAKR,MAAS,EAAI8D,IACd9D,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MACzC,GAAK,EAAIA,GAAb,GACNA,EACJpD,EACIsS,KAAKC,KACCjT,IAAO,EAAI8D,IACRtD,EAAKR,KAAQ,EAAI8D,GAClB1D,IAAO,EAAI0D,MACL,GAAK,EAAIA,GAAb,IACI,GAAK,EAAIA,GAAb,IACD,EAAIA,IACJtD,EAAKR,KAAQ,EAAI8D,IACjBtD,EAAKR,MAAS,EAAI8D,IACd9D,IAAO,EAAI8D,IACPtD,EAAKR,KAAQ,EAAI8D,GAClB1D,IAAO,EAAI0D,MACL,GAAK,EAAIA,GAAb,GACNA,MAElB9D,IAAO,EAAI8D,IAAMtD,EAAKR,KAAQ,EAAI8D,GAAK1D,IAAO,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,IACDtD,EAAKR,IAAO8D,EACbkP,KAAKC,IACD,GACKjT,IAAO,EAAI8D,IACPtD,EAAKR,KAAQ,EAAI8D,GAClB1D,IAAO,EAAI0D,MACL,GAAK,EAAIA,GAAb,IACDtD,EAAKR,IAAO8D,GAErBpD,IACJ,EAGhB,CCyCeS,CACHvF,EACAmE,EAEP,CAEDqB,qDACIrB,EACAnE,GAGA,OADAmE,EAAauS,sBAAwB1jB,KAAK0jB,sBD/ClC,SACZ1W,EACAmE,GAEA,MAAMW,EAAIT,WAAWC,EAAWA,YAACH,EAAarB,QAAS,KACjDsB,EAAKC,WACPC,cAAYH,EAAarD,UAAWqD,EAAaI,aAE/CC,EAAKH,WACPC,cAAYH,EAAanD,WAAYmD,EAAaM,cAEhDyD,EAAIsO,GACNrS,EAAasS,WACbtS,EAAauS,sBACbvS,EAAawS,aAEXvR,EAAKpF,EAAO6E,WAClB,OAAOpL,GACD2K,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC3C,GAAK,EAAIA,GAAb,IACI,GAAK,EAAIA,GAAb,IACD,EAAIA,KACH9C,EAAKZ,KAAQ,EAAI0D,KACjB9C,EAAKZ,MAAS,EAAI0D,IACf9D,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC1C,GAAK,EAAIA,GAAb,GACNA,EACJpD,EACIsS,KAAKC,KACCjT,IAAO,EAAI8D,GAAK1D,IAAO,EAAI0D,KAAO9C,EAAKZ,KAAQ,EAAI0D,MAC3C,GAAK,EAAIA,GAAb,IACI,GAAK,EAAIA,GAAb,IACD,EAAIA,KACH9C,EAAKZ,KAAQ,EAAI0D,KACjB9C,EAAKZ,MAAS,EAAI0D,IACf9D,IAAO,EAAI8D,GACR1D,IAAO,EAAI0D,KACT9C,EAAKZ,KAAQ,EAAI0D,MACb,GAAK,EAAIA,GAAb,GACNA,GAG5B,CCMe1C,CACHxF,EACAmE,EAEP,ECtPL,MAAMmT,GAAqB7d,EAAK,cAEhB4Q,GACZC,EACApI,GAEA,IAAI3D,EAAM/E,EACV,MAAM+Q,EAAarI,EAAShT,OAC5B,IAAK,IAAIuT,EAAI,EAAGA,EAAI8H,EAAY9H,IAC5BlE,EAAMA,EAAIiM,KAAKtI,EAASO,IAE5B,GAAIlE,EAAIkM,SACJ,OAAOjR,EAEX,IAAIkR,EAAUlR,EACVmR,EAAMpM,EAEV,MACMqM,EADYnR,EAAK6K,EAAAA,YAAYgG,EAAG,IACRrQ,MAAMsQ,GAAcA,GAElD,IAAK,IAAI9H,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC1B,IAAIoI,EAAMpR,EAAK8Q,GAAYtQ,MAAMiI,EAAS,IAC1C,IAAK,IAAI4I,EAAI,EAAGA,EAAIP,EAAYO,IAE5BD,EAAMA,EAAI5Q,MAAMiI,EAAS4I,IAAI7Q,MAAMsQ,GAAY1K,IAAI8K,GAcvD,GAZAD,EAAUC,EAEVA,EAAMlR,EAAK8Q,GACNtQ,MAAM0Q,GACN1Q,MAAM0Q,GACNH,KAAKI,EAAY3Q,MAAMsE,GAAKtE,MAAM4Q,IAClChL,IACGpG,EAAK8Q,EAAa,GACbtQ,MAAM0Q,GACNH,KAAKI,EAAYG,MAAM,GAAG9Q,MAAM4Q,KAGzCF,EAAIK,GAAGN,IACP,GAAIC,EAAII,MAAML,GAAS7D,GAAGpN,EAAK,QAC3B,WAED,GAAIiR,EAAQK,MAAMJ,GAAK9D,GAAGpN,EAAK,QAClC,KAEP,CAED,OAAOkR,CACX,CAegB,SAAAnB,GACZxJ,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAE5B,IAAIqX,EAAgBnL,EACpBmL,EAAgBA,EACXlR,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YACxByQ,IAAIuL,EAAAA,YAAKhc,YAGd,MAAMub,EAAMN,GAAWC,EAAGpI,GAC1B,IAAImJ,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAa9Q,EAAKyI,EAAShT,QACjC,IAAIoc,EAAU5R,EACV4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAGtC,GAFA6I,EAAUA,EAAQrR,MAAMsQ,GAEpB9H,GAAKuF,EACL1M,EAAI4G,EAASO,GAAG+H,KAAKW,OAClB,IAAI1I,GAAK4F,EAGZ,SAFA/M,EAAI4G,EAASO,EAGhB,CACDlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,EACxB,CAGD,MAAMC,EAAIgQ,GAAwBhN,EAAKoM,EAAKL,EAAGgB,EAASD,GAIxD,OAAOnJ,EAASmG,GAAe0C,MAAMxP,EACzC,CAegB,SAAAuO,GACZ9J,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtB0X,EAAiBxL,EAEjB2K,EAAMN,GAAWC,EAAGpI,GAC1B,IAAImJ,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAa9Q,EAAKyI,EAAShT,QACjC,IAAIoc,EAAU5R,EACV4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IAAK,CAGtC,GAFA6I,EAAUA,EAAQrR,MAAMsQ,GAEpB9H,GAAK4F,EACL/M,EAAI4G,EAASO,GAAGsI,MAAMS,OACnB,IAAI/I,GAAKuF,EAGZ,SAFA1M,EAAI4G,EAASO,EAGhB,CACDlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,EACxB,CAMD,OAHUiQ,GAAwBhN,EAAKoM,EAAKL,EAAGgB,EAASD,GAInDN,MAAM7I,EAAS8F,IACfyD,aAAaL,EAAAA,YAAKhc,YAClByQ,IAAIuL,EAAIvC,YAAChN,IAAIiH,GAAS1T,WAC/B,CAOgB,SAAA6d,GACZjN,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgB5Q,YAChBA,EAAWuD,aACXA,EAAYlF,QACZA,GACAqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtBkQ,EAAehE,EAGf+F,EAAmBsE,GAAWC,EAAGpI,GAEjCqV,EAAiB9d,EAAK6K,EAAAA,YAAY+Q,EAAkB5Q,IACpD+H,EAAe+K,EAChB/M,KAAKxG,GACLnE,IAAI0X,GACJtd,MAAM8L,GAIX,IAAI0G,EAAchT,EAAK,GACvB,IAAK,IAAIgJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAI5C,MAOMqK,EANFD,GACIvC,EACApI,EACAsK,EACAxE,GAEsC+C,MAAM7I,EAAS8F,IAGvD+E,EAAgB7K,EAAS8F,GAAcnI,IAAI4M,GAC3CO,EAA+BvT,EAAK,GAAGsR,MAAMgC,GAG7CyK,EAAc/d,EAAK6K,EAAAA,YAAYxB,EAAS,KAC9C,OAAOgK,EAAiBjN,IACpBpG,EAAK,GAAGsR,MAAMiC,EAA6B/S,MAAMud,IAEzD,CAEgB,SAAAC,GACZzX,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgB9Q,WAChBA,EAAU8D,cACVA,EAAavF,QACbA,GACAqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtB0X,EAAiBxL,EAGjB+F,EAAmBsE,GAAWC,EAAGpI,GAIvC,IAAIuK,EAAchT,EAAK,GACvB,IAAK,IAAIgJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAI5C,MAAMsK,EAAgB7K,EAASmG,GAAexI,IAAI4M,GAC5CiL,EAA8BxV,EAASmG,GACxC0C,MAAMS,GACN3L,IAAIqC,EAASmG,IAMZ2E,EALuBvT,EAAK,GAAGsR,MACjCtR,EAAK,GAAGsR,MAAM2M,GAA6Bzd,MAAM8S,IAKhDhC,MAAM2M,GACN7X,IAAIpG,EAAK,GAAGsR,MAAM2M,IAEjBF,EAAc/d,EAAK6K,EAAAA,YAAYxB,EAAS,KACxC6U,EAAqBnM,EAAe3L,IACtCpG,EAAK,GAAGsR,MAAMyM,EAAYvd,MAAM+S,KAEpC9K,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAAM4M,GAGxD,MAAMnL,EAAenC,GAAWC,EAAGpI,GAInC,OADsBzI,EAAK6K,EAAAA,YAAY+Q,EAAkB9Q,IACpCtK,MACjBR,EAAK,GAAGsR,MAAMyB,EAAa3M,IAAIkG,IAEvC,CAIA,SAAS8G,GACLvC,EACApI,EACAyI,EACAgC,GAEA,IAAItB,EAAIV,EACJpM,EAAM/E,EACV,MAAM+Q,EAAarI,EAAShT,OAC5B,IAAI0d,EAAQlT,EACR4B,EAAI9B,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAI8H,EAAY9H,IAC5BmK,EAAQA,EAAM3S,MAAMsQ,GAChB9H,GAAKkK,IACLrR,EAAI4G,EAASO,GAIjBlE,EAAMA,EAAIiM,KAAKlP,GAEf+P,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAIvE,IAIzB,OAAOiQ,GAAwBhN,EAAKoM,EAAKL,EAAGsC,EAAOvB,EACvD,CAGM,SAAUE,GACZhN,EACAoM,EACAL,EACAgB,EACAD,GAGA,MAAMK,EAAUjS,EAAK6K,EAAAA,YAAYgG,EAAG,IAEpCe,EAAIA,EAAEpR,MAAM0Q,GAAK9K,IAAI6L,EAAQzR,MAAMqR,GAASrR,MAAMqR,IAElD,MAAM/Q,EAAIgE,EAAIiM,KAAKG,EAAI9K,IAAI6L,EAAQzR,MAAMqR,KAKzC,IAAItQ,EAcJ,OAZIA,EADA2P,EAAIiN,IAAIrd,GACJoQ,EACCI,MAAMxQ,GACNiQ,KAAKG,EAAII,MAAMxQ,GAAGN,MAAM0Q,EAAII,MAAMxQ,IAAIiQ,KAAKa,EAAEpR,MAAM,IAAI0R,QAExDpR,EACCwQ,MAAMJ,GACN1Q,MAAMM,EAAEwQ,MAAMJ,IACdH,KAAKa,EAAEpR,MAAM,IACb0R,OACAZ,MAAMxQ,EAAEwQ,MAAMJ,IAGhB3P,EAAE6E,IAAI,EACjB,CAMgB,SAAAgY,GACZ7X,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAC5B,MAAMiL,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgBrN,aAChBA,EAAYlF,QACZA,EAAO2B,YACPA,GACAN,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtBqX,EAAgBnL,EAEhB+F,EAAmBsE,GAAWC,EAAGpI,GAIvC,IAAIuK,EAAchT,EAAK,GACvB,IAAK,IAAIgJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAI5C,MAAMsK,EAAgB7K,EAAS8F,GAAcnI,IAAI4M,GAC3CiL,EAA8BxV,EAAS8F,GACxCwC,KAAKW,GACLtL,IAAIqC,EAAS8F,IACZ8P,EAAuBre,EAAK,GAAG+Q,KACjCkN,EAA4B3M,MAAMtR,EAAK,IAAIQ,MAAM8S,IAK/CC,EAA+B0K,EAChC3M,MAAM+M,GACNjY,IAAI6X,EAA4B3M,MAAMtR,EAAK,KAE1C+d,EAAc/d,EAAK6K,EAAAA,YAAYxB,EAAS,KACxCgK,EAAmB3B,EAAclR,MACnCR,EAAK,GAAGsR,MAAMyM,EAAYvd,MAAM+S,KAEpC9K,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAKsC,GAGrD,MAAMN,EAAenC,GAAWC,EAAGpI,GAInC,OAFuBzI,EAAK6K,EAAAA,YAAY+Q,EAAkB5Q,IAEpCxK,MAClBuS,EAAa3M,IAAIkG,GAAkBgF,MAAMtR,EAAK,IAEtD,CAOgB,SAAAse,GACZ/X,EACAmE,GAIA,GAAInE,EAAOyK,SAAU,OAAOzK,EAE5B,MAAMiL,IAAEA,EAAGC,YAAEA,EAAW7C,cAAEA,EAAavF,QAAEA,GAAYqB,EAC/CjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtBoP,EAAclD,EAOd+F,EAAmBsE,GAAWC,EAAGpI,GAEjC8V,EAAgBve,EAAK6K,EAAWA,YAACH,EAAakR,iBAAkB,KAChE7I,EAAewL,EAChBjN,MAAM7H,GACNrD,IAAImY,GACJ/d,MAAM8L,GAIX,IAAI0G,EAAchT,EAAK,GACvB,IAAK,IAAIgJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAG5C,MAAMiK,EACFG,GACIvC,EACApI,EACAsK,EACAnE,GAEFsP,EACFzV,EAASmG,GAAe0C,MAAM2B,GAG5BK,EAAgB7K,EAASmG,GAAexI,IAAI4M,GAC5CO,EAA+BvT,EAAK,GAAGsR,MAAMgC,GAQnD,OAPY4K,EAAmB1d,MAC3BP,EAAIqR,MACAiC,EACK/S,MAAM6I,EAAQ1T,YACdyQ,IAAIuL,EAAIvC,YAACzZ,aAI1B,CAEgB,SAAAwc,GACZtB,EACApI,EACA8F,EACAK,EACAwD,EACAC,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAI1B,GAAWC,EAAGpI,GACxB,IAAI8J,EAAIxS,EACR,IAAK,IAAIiJ,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,GAAgBvF,GAAK4F,IAC1B2D,EAAIA,EAAExB,KAAKtI,EAASO,KAG5B,MAAMnH,EAAI4G,EAAS8F,GACbzM,EAAI2G,EAASmG,GAGbtN,EADYtB,EAAK6K,EAAAA,YAAYgG,EAAG,IAClBrQ,MAAMsQ,GAAcA,GAClChQ,EAAIyR,EAAEjB,MAAMgB,GAAG9R,MAAMc,GAAGyP,KAAKuB,GAC7BE,EAASxS,EAAK,GAAGQ,MAAMc,GAAGd,MAAMqB,GAAGrB,MAAMsB,GACzC2Q,EAAYD,EAAOzB,KAAKzP,EAAEd,MAAMsB,GAAGtB,MAAMsB,IAAIiP,KAAKjQ,EAAEN,MAAMsB,IAC1D4Q,EAAYF,EAAOzB,KAAKzP,EAAEd,MAAMqB,GAAGrB,MAAMqB,IAAIkP,KAAKjQ,EAAEN,MAAMqB,IAChE,IAAIqL,EACJ,GAAIkF,EACAlF,EAAMuF,EAAUrM,IAAIsM,OACjB,CACH,MAAMC,EAAa3S,EAAK,GAAGQ,MAAMc,GAAGd,MAAMsB,GACpC8Q,EAAa5S,EAAK,GAAGQ,MAAMc,GAAGd,MAAMqB,GACpCgR,EAAaF,EAAW5B,KAAK6B,GAAY7B,KAAKjQ,GAC9C4L,EAAY1M,EAAK,GAClBQ,MAAMiS,GACNjS,MAAMkS,GACNlS,MAAMqS,GACNvB,MAAMqB,EAAWnS,MAAMkS,EAAUnS,IAAI,KACrC+Q,MAAMsB,EAAWpS,MAAMiS,EAAUlS,IAAI,KACpCuH,EAAc2K,EAAUlS,IAAI,GAAGC,MAAMkS,GAC3CxF,EAAMR,EAAUtG,IAAI0B,GAChBuK,IACAnF,EAAMA,EAAI1M,MAAMkS,GAAWtM,IAAIqM,GAEtC,CACD,OAAOvF,CACX,CAMgB,SAAAwH,GACZ7D,EACApI,EACAiL,EACAnF,EACA6D,EACAuB,EACAtB,GAEA,MAAMvB,EAAarI,EAAShT,OACtB6c,EAAI1B,GAAWC,EAAGpI,GACxB,IAAI8J,EAAIxS,EACJ6T,EAAMtB,EAAElM,IAAI0K,GAChB,IAAK,IAAI9H,EAAI,EAAGA,EAAI8H,EAAY9H,IACxBA,GAAKuF,IACLgE,EAAIA,EAAExB,KAAKtI,EAASO,IACpB4K,EAAMA,EAAIpT,MAAM8R,GAAGlM,IAAIqC,EAASO,GAAGxI,MAAMsQ,KAGjD,MAAMjP,EAAI4G,EAAS8F,GACbuF,EAAQ9T,EAAK6Q,EAAElb,YAAY6K,MAAMsQ,GAAcA,GAC/CiD,EAAOD,EAAMtT,MAAM+R,GACnByB,EAAQ6J,GAAmBvM,MAAMwC,GACjCrB,EAAYzS,EAAK,GAClBQ,MAAMsT,GACNtT,MAAMqB,GACNkP,KAAKgD,GACLhD,KAAKiD,EAAMxT,MAAM8R,IAChB2B,EAAkBL,EAAIpT,MAAMsQ,EAAa,GAC1CtQ,MAAMqd,IACNvM,MAAM0C,EAAMxT,MAAMqB,IACjBqS,EAAYnU,EAAKuR,MAAM2C,GAC7B,IAAI/G,EACJ,GAAIkF,EACAlF,EAAMuF,EAAUrM,IAAI6N,GAAiBzT,MAAMkT,GAAWtN,IAAIkM,OACvD,CACH,MAAMK,EAAa3S,EAAK,GAAGQ,MAAMsT,GAC3BK,EAAaH,EACbI,EAAmBtD,GAAcA,EAAa,GAC9CuD,EAAatU,EAAKuR,MAAMsC,EAAIpT,MAAM4T,GAAkBhO,IAAIkM,IAC9D,GAAIqB,EAAY,CACZ,MAAMW,EAAQ3B,EAAWnS,MAAM0T,GAAW9N,IAAIqM,EAAUlS,IAAI,IACtDgU,EAAQvU,EAAK,GAAGQ,MAAM2T,GAAY/N,IAAIqM,GACtC+B,EAAQH,EAAWjO,IAAI8N,GAE7B,GADAhH,EAAMoH,EAAMhD,MAAMiD,GAAOxD,KAAKyD,GAAOhU,MAAM8R,GAAGlM,IAAIsN,GAC9CrB,EAAS,CACT,MAAMoC,EAAU1U,EAAKuR,MAAMmB,EAAUrM,IAAI8N,IACzChH,EAAMA,EAAI9G,IAAIqO,GAASjU,MAAM8R,GAAGlM,IAAIsN,EACvC,CACJ,MACGxG,EAAMlN,EAAK,GACNQ,MAAM2T,GACN/N,IAAI8N,GACJ5C,MAAM+C,EAAW7T,MAAMiS,GAAWrM,IAAI8N,EAAU3T,IAAI,KACpD+Q,MAAMqB,EAAWvM,IAAIqM,IACtBJ,IACAnF,EAAMA,EACD1M,MAAMiS,GACNrM,IAAI6N,GACJzT,MAAMkT,GACNtN,IAAIkM,GAGpB,CACD,OAAOpF,CACX,CA2DA,SAASuG,GACLhL,EACAyK,EACA7J,GAEA,IAAI2J,EAAcjT,EAClB,IAAK,IAAIiJ,EAAI,EAAGA,EAAIP,EAAShT,OAAQuT,IACjCgK,EAAcA,EAAYjC,KAAKtI,EAASO,IAE5C,MAAMsK,EAAgB7K,EAASyK,GAAY9M,IAAI4M,GACzCO,EAA+BtT,EAAIqR,MAAMgC,GAC/C,OAAOrT,EAAIqR,MACPiC,EACK/S,MAAM6I,EAAQ1T,YACdyQ,IAAIuL,EAAIvC,YAACzZ,YAEtB,CChqBA,IAAYwW,IAAZ,SAAYA,GACRA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,aAAA,GAAA,cACH,CAJD,CAAYA,KAAAA,GAIX,CAAA,UAaYqS,GAaTnd,gBAAgBkM,GACZ,IAAKA,EAAKiE,IAAK,MAAM,IAAIxQ,MAAM,wCAC/B,OAAO,IAAIwd,GACPjR,EAAKI,GACLJ,EAAKK,QACLL,EAAKiE,IACLjE,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WAEZ,CAGD1M,iBACIqJ,GAEA,MAAM+T,EAAoBC,EAAUhU,GAC9BiQ,EAAWjQ,EAAaiQ,SAS9B,OARiB,GAAbA,IACA8D,EAAkBhN,YAAYzZ,OAAO2iB,EAAU,GAC/C8D,EAAkB5I,kBAAkB7d,OAAO2iB,EAAU,GACjDA,EAAWjQ,EAAa6D,eACxBkQ,EAAkBlQ,cAAgB,GAClCoM,EAAWjQ,EAAakE,gBACxB6P,EAAkB7P,eAAiB,IAEpC6P,CACV,CAEDljB,YACIoS,EACAC,EACA4D,EACAnI,EACAwE,EACAC,EACAC,GAjDJxU,KAAAyU,SAAsB/G,QAASA,UAACqP,WAQhC/c,KAAA0hB,WAAarV,EAAAA,WAAW,OAAQ,IA2C5BrM,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAKiY,IAAM5L,EAAUA,WAAC4L,EAAKgN,GAAkB5I,cAC7Crc,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,CACrB,CAEDK,kBACIC,EACAC,GAEA,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GACjBlH,EAAYrH,EAAK0O,EAAG1I,SACrBxF,MAAMR,EAAK0O,EAAGvI,YACd6J,GAAGtB,EAAGlJ,UACN7P,WACCmV,EAAa4D,EAAGlJ,SAChB+Q,EAAmB3Q,EAAUA,WAAC8I,EAAGvI,UAAW,IAE5CyI,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GACjBrH,EAAavH,EAAK6O,EAAG7I,SACtBxF,MAAMR,EAAK6O,EAAG1I,YACd6J,GAAGnB,EAAGrJ,UACN7P,WACCqV,EAAc6D,EAAGrJ,SACjBgR,EAAoB5Q,EAAUA,WAACiJ,EAAG1I,UAAW,IAG7CsL,EAAclY,KAAKuU,OAAOhZ,KAAI,EAAGkR,UAASG,eAC5CnG,EAAKgG,GAASxF,MAAMR,EAAKmG,MAEvB0P,EAAoBtc,KAAKuU,OAAOhZ,KAAI,EAAGkR,UAASG,eAClDP,aAAWI,EAAS,IAAIC,IAAIL,EAAAA,WAAWO,EAAW,KAAKC,IAAInG,EAAGmP,eAIlE,IAAIN,EAEAA,EADA3J,EAAckJ,EAAS9U,KAAKqU,SACjBzB,GAAU4C,WACd5J,EAAcmJ,EAAU/U,KAAKqU,SACzBzB,GAAU6C,WAEV7C,GAAU8C,aAGzB,MAAM0L,EAAWphB,KAAKwU,WAAWoN,QAAQ5hB,KAAKqU,SAGxCgO,EAAmBriB,KAAKsU,YAExBnD,EAA0C,CAC5CiD,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfc,SAAUA,EACV6L,SAAUA,EACVtM,QAASA,EACTC,SAAUA,EACVjH,UAAWzB,EAAAA,WAAWyB,EAAWyD,GACjCvD,WAAY3B,EAAAA,WAAW2B,EAAYyD,GACnC3B,QAAS9P,KAAK8P,QACdoI,cACAoE,oBACArE,IAAKjY,KAAKiY,IACVjD,aAAcA,EACdK,cAAeA,EACf9D,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpBuL,mBACAC,oBACAoF,oBAGJ,OAAO4C,GAAkBG,UAAUjU,EACtC,CAED2E,uBACI3E,GAEA,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAGA,OAAiBvI,QAASA,UAACwI,YAGhBxP,EACH6K,cACIH,EAAanD,WACRtB,IAAI1M,KAAK0hB,YACT7U,IAAIsE,EAAa8L,mBACtB9L,EAAaM,aAc5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCAGpB,GAAImE,EAAc5L,KAAKqU,QAAS7H,GAAQ,CACpC,MACMqW,EADqBxW,EAAAA,WAAWgK,EAAE5J,QAAS4J,EAAEpK,UACnBpD,IAAIsN,GAC9BI,EAAiBvW,KAAKsU,YAAY3Y,IAAIknB,GAC5C7iB,KAAKoW,kBAAkBG,EAC1B,CAEDF,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IAGI,GAAIA,EAAOyK,SAAU,OAAOjR,EAI5B,MAIM6e,EAJgBrlB,KAAKwc,sBACvBnQ,EAAUA,WAACW,EAAOyJ,GAAG,IAAIra,WAAY,IACrC+U,EAAarB,SAGZpD,IAAIyE,EAAa6L,kBACjBnQ,IAAInG,EAAGmP,aAEZ,IAAIyP,EAEJ,GAAInU,EAAaoE,WAAa3C,GAAU6C,WAAY,CAChD,MAAM8P,EAAkBjpB,MACpB6U,EAAamL,kBAAkBpgB,QACjCgb,KAAK9P,OAAO,IACdme,EAAgBpU,EAAa6D,cACzBqQ,EAAmBvY,WAEvBwY,EAAYrW,GACRjP,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CyY,EACApU,EAAakR,iBAAiBvV,WAC9B1F,OAAO,GAEd,MACGke,EADOnU,EAAaoE,WAAa3C,GAAU4C,WAC/BlF,GACRtQ,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAakE,cACbgQ,EAAmBvY,WACnBqE,EAAakR,iBAAiBvV,WAC9B1F,OAAO,IAGCyG,GACR7N,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACb7D,EAAakE,cACbgQ,EAAmBvY,WACnB1F,OAAO,IAIf,MAAM+V,EAAoBhX,EAAAA,UAAU+G,KAAKoY,GACpC5Y,IAAIhG,EAAAA,aACJmG,IAAIsE,EAAa8L,mBAGtB,OAAOxW,EAAK6K,EAAWA,YAAC6L,EAAmB,IAC9C,CAAC,MAAOtG,GAEL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IAGI,GAAIA,EAAOyK,SAAU,OAAOjR,EAG5B,MAAM6e,EAAqBhZ,EAAUA,WAACW,EAAOyJ,GAAG,IAAIra,WAAY,IAC3DsQ,IAAIyE,EAAa8L,mBACjBpQ,IAAInG,EAAGmP,aAEZ,IAAIyP,EAEJ,GAAInU,EAAaoE,WAAa3C,GAAU6C,WACpC6P,EAAYvU,GACR/Q,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACbqQ,EAAmBvY,WACnBqE,EAAakR,iBAAiBvV,WAC9B1F,OAAO,SAER,GAAI+J,EAAaoE,WAAa3C,GAAU4C,WAAY,CACvD,MAAMgQ,EAAmBlpB,MACrB6U,EAAamL,kBAAkBpgB,QACjCgb,KAAK9P,OAAO,IACdoe,EAAiBrU,EAAakE,eAC1BgQ,EAAmBvY,WAEvBwY,EAAY7U,GACRzQ,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5C0Y,EACArU,EAAakR,iBAAiBvV,WAC9B1F,OAAO,GAEd,MACGke,EAAYzW,GACR7O,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACb7D,EAAakE,cACbgQ,EAAmBvY,WACnB1F,OAAO,IAIf,MAAM+V,EAAoBhX,EAAAA,UAAU+G,KAAKoY,GACpC5Y,IAAIhG,EAAAA,aACJmG,IAAIsE,EAAa6L,kBAEhByI,EAAmBzlB,KAAK2c,iBAC1BQ,EACAhM,EAAarB,SAIjB,OAAOrJ,EAAK6K,EAAWA,YAACmU,EAAkB,IAC7C,CAAC,MAAO5O,GAEL,OADA+F,QAAQC,MAAM,iCAAiChG,EAAIrP,WAC5ChB,CACV,CACJ,CAQDyJ,8BAA8BC,GAE1B,MAAM,IAAIzI,MACN,uEAEP,CAQDwH,8BAA8BG,GAE1B,MAAM,IAAI3H,MACN,uEAEP,CAGDyJ,2CACIC,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAE1CC,EAAkBlQ,EAAO/F,MAC3BR,EAAK6K,cAAYH,EAAa6L,iBAAkB,MAEpD,IAAI3kB,EAkBJ,OAhBIA,EADA8Y,EAAaoE,WAAa3C,GAAU6C,WD6RhC,SACZzI,EACAmE,GAEA,MAAM8G,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgB5Q,YAChBA,EAAWuD,aACXA,EAAYlF,QACZA,GACAqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtBwS,EAAY4G,GAAWhL,EAAU8F,EAAclF,GACrD,IAAIyU,EAAiB9d,EAAK6K,EAAAA,YAAY+Q,EAAkB5Q,IACxDvC,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMqM,IAEjBiR,EAAiBA,EAAe/M,KAC5BqN,GAAuB7X,EAAQmE,IAEnC,IAAIwC,EAAMwH,GACN7D,EACApI,EACAqV,EACAvP,GACA,GACA,GACA,GAGJ,OADArB,EAAMlN,EAAK,GAAGoG,IAAI8G,EAAI1M,MAAMqM,IACrBK,CACX,CC9TqB+R,CACLxI,EACA/L,GAEGA,EAAaoE,WAAa3C,GAAU4C,WDiWvC,SACZxI,EACAmE,GAEA,MAAM8G,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgBhN,cAChBA,EAAavF,QACbA,EAAOyB,WACPA,GACAJ,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtBmb,EAAO8I,GAAuB/X,EAAQmE,GACtCmC,EAAY4G,GAAWhL,EAAUmG,EAAevF,GACtD,IAAIkV,EAAgBve,EAAK6K,EAAAA,YAAY+Q,EAAkB9Q,IAgBvD,OAdArC,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CkE,EAAKpP,IAAIyG,IAEb0R,EAAgBA,EAAcjN,MAAM/K,GAExBmO,GACR7D,EACApI,EACA8V,EACA3P,GACA,GACA,GACA,GACFxI,IAAIyG,EAEV,CCnYqBqS,CACLzI,EACA/L,GD0MA,SACZnE,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAC5BoO,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,cAAKhc,aAExD8S,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CvB,GAAyBxJ,EAAQmE,IAErC,IAAIwC,EAAMiF,GACNtB,EACApI,EACA8F,EACAK,GACA,GACA,GAGJ,OADA1B,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMmR,EAAIvC,YAAChN,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,EAAAA,YAAKhc,aACxDuX,CACX,CC/NgBiS,CACI1I,EACA/L,GAGL9Y,EAAOwU,IAAI0Q,GAAatW,MAAMuW,EACxC,CAGDzL,2CACIZ,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAE1CC,EAAkBlQ,EAAO/F,MAC3BqK,EAAAA,YAAYH,EAAa8L,kBAAmB,KAEhD,IAAI5kB,EAkBJ,OAhBIA,EADA8Y,EAAaoE,WAAa3C,GAAU6C,WDgShC,SACZzI,EACAmE,GAEA,MAAM8G,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgBrN,aAChBA,EAAYvD,YACZA,EAAW3B,QACXA,GACAqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtByY,EAAMU,GAAuBjN,EAAQmE,GACrCmC,EAAY4G,GAAWhL,EAAU8F,EAAclF,GACrDZ,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,EAAItS,MAAMqM,IAC/D,IAAIiR,EAAiB9d,EAAK6K,EAAAA,YAAY+Q,EAAkB5Q,IACxD8S,EAAiBA,EAAe/M,KAAKxK,GACrC,IAAI2G,EAAMwH,GACN7D,EACApI,EACAqV,EACAvP,GACA,GACA,GACA,GAGJ,OADArB,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMqM,IACjBK,CACX,CC9TqBkS,CACL3I,EACA/L,GAEGA,EAAaoE,WAAa3C,GAAU4C,WDqWvC,SACZxI,EACAmE,GAEA,MAAM8G,IACFA,EAAGC,YACHA,EAAWmK,iBACXA,EAAgB9Q,WAChBA,EAAU8D,cACVA,EAAavF,QACbA,GACAqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtBwS,EAAY4G,GAAWhL,EAAUmG,EAAevF,GACtDZ,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9C/K,EAAOH,IAAIyG,IAEf,IAAI0R,EAAgBve,EAAK6K,EAAAA,YAAY+Q,EAAkB9Q,IAavD,OAZAyT,EAAgBA,EAAcjN,MAC1B0M,GAAuBzX,EAAQmE,IAEvBgK,GACR7D,EACApI,EACA8V,EACA3P,GACA,GACA,GACA,GACFxI,IAAIyG,EAEV,CCtYqBwS,CACL5I,EACA/L,GDoMA,SACZnE,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IACtByY,EAAMzC,GAAyB9J,EAAQmE,GACxClK,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YACxByQ,IAAIuL,EAAAA,YAAKhc,YACd8S,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,GACrDrK,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAAM/K,GACxD,IAAI2G,EAAMiF,GACNtB,EACApI,EACA8F,EACAK,GACA,GACA,GAGJ,OADA1B,EAAMjN,EAAImG,IAAI8G,EAAI1M,MAAMmR,EAAIvC,YAAChN,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,EAAAA,YAAKhc,aACxDuX,CACX,CCxNgBoS,CACI7I,EACA/L,GAGL9Y,EAAOwU,IAAI0Q,GAAatW,MAAMuW,EACxC,CAEDjL,qDACIpB,EACAnE,GAEA,MAAMwQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAE1CC,EAAkBlQ,EAAO/F,MAC3BqK,EAAAA,YAAYH,EAAa6L,iBAAkB,KAE/C,IAAI3kB,EAoBJ,OAlBIA,EADA8Y,EAAaoE,WAAa3C,GAAU6C,WD8ahC,SACZzI,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlK,WAAEA,EAAUyD,YAAEA,EAAWuD,aAAEA,EAAYlF,QAAEA,GAC7DqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtBwS,EAAY4G,GAAWhL,EAAU8F,EAAclF,GACrDZ,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMqM,IAEjB,IAAIiR,EAAiB9d,EAAK6K,EAAAA,YAAYtD,EAAYyD,IAalD,OAZA8S,EAAiBA,EAAe/M,KAC5BqN,GAAuB7X,EAAQmE,IAEvBgK,GACR7D,EACApI,EACAqV,EACAvP,GACA,GACA,GACA,EAGR,CCxcgBgR,CACI9I,EACA/L,GAEDA,EAAaoE,WAAa3C,GAAU4C,WDmgBvC,SACZxI,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWpK,UAAEA,EAASyD,WAAEA,EAAU8D,cAAEA,EAAavF,QAAEA,GAC5DqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtBmb,EAAO8I,GAAuB/X,EAAQmE,GACtCmC,EAAY4G,GAAWhL,EAAUmG,EAAevF,GACtDZ,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CkE,EAAKpP,IAAIyG,IAEb,IAAI0R,EAAgBve,EAAK6K,EAAAA,YAAYxD,EAAWyD,IAWhD,OAVAyT,EAAgBA,EAAcjN,MAAM/K,GACxBmO,GACR7D,EACApI,EACA8V,EACA3P,GACA,GACA,GACA,GAEOxI,IAAIyG,EACnB,CC5hBgB2S,CACI/I,EACA/L,GD2WJ,SACZnE,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAQ5B,OANAoO,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAC5CxK,EAAO/F,MAAMmR,EAAAA,YAAKvP,IAAIiH,GAAS1T,YAAYyQ,IAAIuL,cAAKhc,aAExD8S,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9CvB,GAAyBxJ,EAAQmE,IAE9ByH,GACHtB,EACApI,EACA8F,EACAK,GACA,GACA,EAER,CC/XgB6Q,CACIhJ,EACA/L,GAGL9Y,EAAO4O,MAAMuW,EACvB,CAEDhL,qDACIrB,EACAnE,GAEA,MAAMuQ,EAAc9W,EAChB6K,EAAWA,YAACH,EAAa6L,iBAAkB,KAEzCQ,EAAe/W,EACjB6K,EAAWA,YAACH,EAAa8L,kBAAmB,KAE1CC,EAAkBlQ,EAAO/F,MAC3BqK,EAAAA,YAAYH,EAAa8L,kBAAmB,KAEhD,IAAI5kB,EAoBJ,OAlBIA,EADA8Y,EAAaoE,WAAa3C,GAAU6C,WD0ahC,SACZzI,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlK,WAAEA,EAAUyD,YAAEA,EAAWuD,aAAEA,EAAYlF,QAAEA,GAC7DqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtByY,EAAMU,GAAuBjN,EAAQmE,GACrCmC,EAAY4G,GAAWhL,EAAU8F,EAAclF,GACrDZ,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,EAAItS,MAAMqM,IAC/D,IAAIiR,EAAiB9d,EAAK6K,EAAAA,YAAYtD,EAAYyD,IAElD,OADA8S,EAAiBA,EAAe/M,KAAKxK,GAC9BmO,GACH7D,EACApI,EACAqV,EACAvP,GACA,GACA,GACA,GACFnI,IAAIyG,EACV,CChcgB6S,CACIjJ,EACA/L,GAEDA,EAAaoE,WAAa3C,GAAU4C,WDgcvC,SACZxI,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWpK,UAAEA,EAASyD,WAAEA,EAAU8D,cAAEA,EAAavF,QAAEA,GAC5DqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtByY,EAAMkL,GAAuBzX,EAAQmE,GACrCmC,EAAY4G,GAAWhL,EAAUmG,EAAevF,GACtDZ,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAC9C/K,EAAOH,IAAIyG,IAEf,IAAI0R,EAAgBve,EAAK6K,EAAAA,YAAYxD,EAAWyD,IAWhD,OAVAyT,EAAgBA,EAAcjN,MAAMwB,GACxB4B,GACR7D,EACApI,EACA8V,EACA3P,GACA,GACA,GACA,GAEOxI,IAAIyG,EAAUtM,IAAI,GACjC,CCzdgBof,CACIlJ,EACA/L,GDmWJ,SACZnE,EACAmE,GAEA,MAAM8G,IAAEA,EAAGC,YAAEA,EAAWlD,aAAEA,EAAYK,cAAEA,EAAavF,QAAEA,GACnDqB,EACEjC,EAAW,IAAIgJ,GACfpX,EAAIoO,EAAShT,OACbob,EAAIW,EAAIpL,IAAI/L,IAAMA,EAAI,IAEtB0jB,EAAc/d,EAAK6K,EAAAA,YAAYxB,EAAS,KACxCyJ,EAAMzC,GAAyB9J,EAAQmE,GAAclK,MACvDR,EAAK,GAAGsR,MAAMyM,IAElBtV,EAAS8F,GAAgB9F,EAAS8F,GAAcwC,KAAK+B,GACrDrK,EAASmG,GAAiBnG,EAASmG,GAAe0C,MAAM/K,GACxD,MAAMsG,EAAY7M,EAAK,GAAGsR,MAAMyM,GAChC,OAAO5L,GACHtB,EACApI,EACA8F,EACAK,GACA,GACA,GACFxI,IAAIyG,EACV,CCxXgB+S,CACInJ,EACA/L,GAGL9Y,EAAOwU,IAAI0Q,GAAatW,MAAMuW,GAAcvW,MAAMuW,EAC5D,CAEDhB,sBAAsBxP,EAAmB8C,GAErC,MAAM1B,EAAYpB,EAAON,IAAIoD,GAASnU,IAAI+K,cAAImC,IAAI,IAAIgE,IAAInG,EAAGmP,aAC7D,OAAO7I,EAAOnE,IAAIuF,EACrB,CAEDuO,iBAAiB3P,EAAmB8C,GAEhC,MAAM1B,EAAY1H,EAAAA,YAAImC,IAAIiH,GAC1B,OAAO9C,EAAON,IAAIhG,EAAGmP,aAAEla,IAAIyS,EAAUvF,IAAI,IAAIgE,IAAIuB,EACpD,EAjfM6W,GAAY5I,aAAG,EC5BpB,MAAOiK,WAA6BrB,GACtCjjB,YACIoS,EACAC,EACA4D,EACAnI,EACAwE,EACAC,EACAC,GAEA+R,MAAMnS,EAAIC,EAAS4D,EAAKnI,EAASwE,EAAaC,EAAQC,EACzD,CAED1M,gBAAgBkM,GACZ,IAAKA,EAAKiE,IACN,MAAM,IAAIxQ,MAAM,2CACpB,OAAO,IAAI6e,GACPtS,EAAKI,GACLJ,EAAKK,QACLL,EAAKiE,IACLjE,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WAEZ,CAEDgC,yBACIrF,EACAnE,GAEA,IAII,GAAIA,EAAOyK,SAAU,OAAOjR,EAC5B,MAAM6e,EAAqBhZ,EAAUA,WAACW,EAAOyJ,GAAG,IAAIra,WAAY,IAC3DsQ,IAAIyE,EAAa6L,kBACjBnQ,IAAInG,EAAGmP,aAEZ,IAAIyP,EAEJ,GAAInU,EAAaoE,WAAa3C,GAAU6C,WAAY,CAChD,MAAM8P,EAAkBjpB,MACpB6U,EAAamL,kBAAkBpgB,QACjCgb,KAAK9P,OAAO,IACdme,EAAgBpU,EAAa6D,cACzBqQ,EAAmBvY,WAEvBwY,EAAYrW,GACRjP,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CyY,EACApU,EAAakR,iBAAiBvV,WAC9BqE,EAAarB,QAAQhD,WAE5B,MACGwY,EADOnU,EAAaoE,WAAa3C,GAAU4C,WAC/BlF,GACRtQ,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAakE,cACbgQ,EAAmBvY,WACnBqE,EAAakR,iBAAiBvV,WAC9BqE,EAAarB,QAAQhD,YAGbe,GACR7N,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACb7D,EAAakE,cACbgQ,EAAmBvY,WACnBqE,EAAarB,QAAQhD,YAI7B,MAAMqQ,EAAoBhX,EAAAA,UAAU+G,KAAKoY,GACpC5Y,IAAIhG,EAAAA,aACJmG,IAAIsE,EAAa8L,mBAGtB,OAAOxW,EAAK6K,EAAWA,YAAC6L,EAAmB,KAAK1G,GAC5CtF,EAAaM,YAEpB,CAAC,MAAOoF,GAEL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IACI,GAAIA,EAAOyK,SAAU,OAAOjR,EAG5B,MAAM6e,EAAqBhZ,EAAUA,WAACW,EAAOyJ,GAAG,IAAIra,WAAY,IAC3DsQ,IAAIyE,EAAa8L,mBACjBpQ,IAAInG,EAAGmP,aAEZ,IAAIyP,EAEJ,GAAInU,EAAaoE,WAAa3C,GAAU6C,WACpC6P,EAAYvU,GACR/Q,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACbqQ,EAAmBvY,WACnBqE,EAAakR,iBAAiBvV,WAC9BqE,EAAarB,QAAQhD,iBAEtB,GAAIqE,EAAaoE,WAAa3C,GAAU4C,WAAY,CACvD,MAAMgQ,EAAmBlpB,MACrB6U,EAAamL,kBAAkBpgB,QACjCgb,KAAK9P,OAAO,IACdoe,EAAiBrU,EAAakE,eAC1BgQ,EAAmBvY,WAEvBwY,EAAY7U,GACRzQ,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5C0Y,EACArU,EAAakR,iBAAiBvV,WAC9BqE,EAAarB,QAAQhD,WAE5B,MACGwY,EAAYzW,GACR7O,KAAKiY,IAAInL,WACTqE,EAAamL,kBAAkB/gB,KAAKgM,GAAMA,EAAEuF,aAC5CqE,EAAa6D,aACb7D,EAAakE,cACbgQ,EAAmBvY,WACnBqE,EAAarB,QAAQhD,YAI7B,MAAMqQ,EAAoBhX,EAAAA,UAAU+G,KAAKoY,GACpC5Y,IAAIhG,EAAAA,aACJmG,IAAIsE,EAAa6L,kBAGtB,OAAOvW,EAAK6K,EAAWA,YAAC6L,EAAmB,KAAK1G,GAC5CtF,EAAaM,YAEpB,CAAC,MAAOoF,GAEL,OADA+F,QAAQC,MAAM,iCAAiChG,EAAIrP,WAC5ChB,CACV,CACJ,CAODyJ,8BAA8BC,GAG1B,MAAMsW,EAAmBxmB,KAAKuU,OAAOyC,QAChC9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAEpC0C,EAAqByP,EAAiBjrB,KAAK2Z,GAC7C3I,EAAiB2I,KAErB,IACI,MAAM+B,EAAuBhH,GACzB8G,EACA7G,EAAYpD,WACZ9M,KAAKsU,YAAYxH,YAMrB,OAHmBmK,EAAqB1b,KAAI,CAACwM,EAAG0H,IAC5CpC,EAAkBtF,EAAGye,EAAiB/W,MAExBlU,KAAKwM,GAAM5B,EAAAA,UAAU+G,KAAKnF,IAC/C,CAAC,MAAO8O,GACL,OAAO,IAAIva,MAAMya,EAAmB7a,QAAQgb,KAAK1Q,EACpD,CACJ,CAODyI,8BAA8BG,GAC1B,IAGI,MAAM+H,EAAsB,IAAI7a,MAAM8S,EAAUlT,QAAQgb,KACpD9P,OAAO,IAEL2P,EAAqB,IAAIza,MAAM8S,EAAUlT,QAAQgb,KACnD9P,OAAO,IAEXpH,KAAKuU,OACAyC,QAAQ9B,IAAOtJ,EAAcsJ,EAAEb,QAASrU,KAAKqU,WAC7C7X,SAAQ,CAACgQ,EAAOiD,KACb0H,EAAoB1H,GAAK1C,EACrB3F,OAAOgI,EAAUK,GAAGrT,YACpBoQ,GAEJuK,EAAmBtH,GAAKlD,EAAiBC,EAAM,IAEvD,MAAMwE,EAAe/B,GACjBjP,KAAKiY,IAAInL,WACTiK,EACAI,EACAnX,KAAKsU,YAAYxH,WACjB9M,KAAK8P,QAAQhD,YAEjB,OAAO3G,EAASA,UAAC+G,KAAK8D,EAAa5U,WACtC,CAAC,MAAOya,GAEL,OADA+F,QAAQC,MAAMhG,GACPO,MACV,CACJ,EC/OE,MAAMqP,GAAgBtgB,EAASA,UAAC+G,KAAK,sBAC/BwZ,GAAgBvgB,EAASA,UAAC+G,KAAK,qBAC/ByZ,GAAgBxgB,EAASA,UAAC+G,KAAK,oBAC/B0Z,GAAgBzgB,EAASA,UAAC+G,KAAK,mBAC/B2Z,GAAgB1gB,EAASA,UAAC+G,KAAK,kBAC/B4Z,GAAiB3gB,EAASA,UAAC+G,KAAK,iBAChC6Z,GAAiB5gB,EAASA,UAAC+G,KAAK,gBAChC8Z,GAAiB7gB,EAASA,UAAC+G,KAAK,eAChC+Z,GAAiB9gB,EAASA,UAAC+G,KAAK,cAGhCga,GAAS/gB,EAASA,UAAC+G,KAAK,IAAIlG,IAAI,IAGhCmgB,GAAQhhB,EAASA,UAAC+G,KAAK,IAAIlG,IAAI,GAG/BogB,GAAoBjhB,EAAAA,UAAU+G,KAAK,sBCFhC,SAAAma,GAAMtf,EAAcR,GAEhC,OADgBQ,EAAE2E,IAAInF,GACPsB,IAAI,GAAGgE,IAAInG,eAAK/K,IAAI,EACvC,CAEgB,SAAAuM,GAAMH,EAAcR,GAEhC,OADkBQ,EAAE2E,IAAIhG,EAAGmP,aACVhN,IAAI,GAAGgE,IAAItF,GAAG5L,IAAI,EACvC,CAEgB,SAAA2rB,GAAQvf,EAAcR,GAElC,OADgBQ,EAAE2E,IAAInF,GACPsF,IAAInG,EAAAA,YACvB,CAEgB,SAAAyB,GAAQJ,EAAcR,GAElC,OADkBQ,EAAE2E,IAAIhG,EAAGmP,aACVhJ,IAAItF,EACzB,CAEgB,SAAAggB,GAAOxf,EAAcR,GACjC,OAAOQ,EAAE2E,IAAInF,GAAGsF,IAAIqa,GACxB,CAEgB,SAAAM,GAAOzf,EAAcR,GACjC,GAAIA,EAAEkQ,SAAU,MAAM,IAAIhQ,MAAM,iBAChC,OAAOM,EAAE2E,IAAIwa,IAAQra,IAAItF,EAC7B,CAEgB,SAAAkgB,GAAY1f,EAAcR,GACtC,OAAOQ,EAAE2E,IAAInF,GAAGsF,IAAInG,EAAGmP,YAC3B,CAEgB,SAAA6R,GAAY3f,EAAcR,GACtC,GAAIA,EAAEkQ,SAAU,MAAM,IAAIhQ,MAAM,iBAChC,OAAOM,EAAE2E,IAAIhG,EAAAA,aAAKmG,IAAItF,EAC1B,CAEgB,SAAAogB,GAAU5f,EAAcR,GACpC,MAAMa,EAAUL,EAAE2E,IAAInF,GACtB,OAAIa,EAAQ4P,GAAG,GAAW5P,EAAQS,IAAI,GAAGgE,IAAInG,eAAK/K,IAAI,GAC7CyM,EAAQyL,GAAG,GAAWzL,EAAQzM,IAAI,GAAGkR,IAAInG,eAAKmC,IAAI,GAC/C1C,EAASA,UAAC+G,KAAK,EAC/B,CAEgB,SAAA0a,GAAU7f,EAAcR,GACpC,GAAIA,EAAEkQ,SAAU,MAAM,IAAIhQ,MAAM,iBAKhC,OAJIF,EAAEsM,GAAG,KACLtM,EAAIA,EAAEmF,KAAK,GACX3E,EAAIA,EAAE2E,KAAK,IAEX3E,EAAE0P,SACKtR,EAASA,UAAC+G,KAAK,GAElBnF,EAAEiQ,GAAG,GAAWjQ,EAAE2E,IAAIhG,EAAGmP,aAAEhN,IAAI,GAAGgE,IAAItF,GAAG5L,IAAI,GACrCoM,EAAE2E,IAAIhG,EAAGmP,aAAEla,IAAI,GAAGkR,IAAItF,EAAEsB,IAAI,GAEhD,CAEgB,SAAAgf,GAAa9f,EAAcR,GACvC,MAAMugB,EAAa3hB,EAAAA,UAAU+G,KAAK,IAAIlG,IAAI,IACpC+gB,EAAKxgB,EAAEsF,IAAIib,GACXE,EAAKzgB,EAAE0gB,aACP1gB,EAAEmF,KAAK,GAAGwb,IAAIJ,GAAYpb,KAAK,GAC/BnF,EAAE2gB,IAAIJ,GACNK,EAAQpgB,EAAE2E,IAAIqb,GACdK,EAAQrgB,EAAE2E,IAAIsb,GACpB,OAAOG,EAAME,IAAI,IAAMD,EAAMC,IAAI,GAC3BF,EAAMxsB,IAAIysB,EAAMvb,IAAIib,IAAajb,IAAIib,GACrCK,EAAMxsB,IAAIysB,EAAMvb,IAAIib,IAAajf,IAAI,GAAGgE,IAAIib,GAAYnsB,IAAI,EACtE,CAEgB,SAAA2sB,GAAevgB,EAAcR,GACzC,MAAMugB,EAAa3hB,EAAAA,UAAU+G,KAAK,IAAIlG,IAAI,IACpC+gB,EAAKxgB,EAAEsF,IAAIib,GACXE,EAAKzgB,EAAE0gB,aACP1gB,EAAEmF,KAAK,GAAGwb,IAAIJ,GAAYpb,KAAK,GAC/BnF,EAAE2gB,IAAIJ,GACNK,EAAQpgB,EAAE2E,IAAIqb,GACdK,EAAQrgB,EAAE2E,IAAIsb,GACpB,OAAOG,EAAMvD,IAAI,IAAMwD,EAAMxD,IAAI,GAC3BuD,EAAMxsB,IAAIysB,EAAMvb,IAAIib,IAAajb,IAAIib,GACrCK,EAAMxsB,IAAIysB,EAAMvb,IAAIib,IAAansB,IAAI,GAAGkR,IAAIib,GAAYjf,IAAI,EACtE,CAMgB,SAAA8P,GAAK1W,EAAkBsmB,GACnC,GAAItmB,EAAMwV,SACN,OAAOtR,EAASA,UAAC+G,KAAK,GAE1B,IAAIsb,EAqBR,SAA0BvmB,GACtB,OAAIA,EAAM2iB,IAAIle,EAAAA,aACHP,EAASA,UAAC+G,KAAK,GACjBlG,IA0Db,SAAuBsB,GACnB,IAAIxH,EAAI,EAER,IAAK,IAAI2O,EAAI,IAAKA,GAAK,EAAGA,GAAQ,EAAG,CACjC,MAAMgZ,EAAStiB,EAAAA,UAAU+G,KAAK,GAAGlG,IAAIyI,GACjCnH,EAAEsc,IAAI6D,KACNngB,EAAIA,EAAEuE,IAAI4b,GACV3nB,GAAK2O,EAAI,EAEhB,CAED,OAAO3O,CACX,CAtEiB4nB,CAAczmB,EAAM4K,IAAInG,EAAAA,eAC5BgG,IAAIhG,EAAGmP,aAER5T,EAAMomB,IAAI,MACHpB,GAEPhlB,EAAMomB,IAAI,OACHliB,EAASA,UAAC+G,KAAK,eAEtBjL,EAAMomB,IAAI,QACHrB,GAEP/kB,EAAMomB,IAAI,SACHliB,EAASA,UAAC+G,KAAK,gBAEtBjL,EAAMomB,IAAI,UACHtB,GAEP9kB,EAAMomB,IAAI,WACHliB,EAASA,UAAC+G,KAAK,iBAEtBjL,EAAMomB,IAAI,YACHvB,GAEP7kB,EAAMomB,IAAI,aACHliB,EAASA,UAAC+G,KAAK,kBAEtBjL,EAAMomB,IAAI,cACHxB,GAEP5kB,EAAMomB,IAAI,eACHliB,EAASA,UAAC+G,KAAK,mBAEtBjL,EAAMomB,IAAI,gBACHzB,GAEP3kB,EAAMomB,IAAI,iBACHliB,EAASA,UAAC+G,KAAK,oBAEtBjL,EAAMomB,IAAI,kBACH1B,GAEP1kB,EAAMomB,IAAI,mBACHliB,EAASA,UAAC+G,KAAK,qBAEtBjL,EAAMomB,IAAI,oBACH3B,GAEPzkB,EAAMomB,IAAI,qBACHliB,EAASA,UAAC+G,KAAK,sBAEtBjL,EAAMomB,IAAI,sBACH5B,GAEJxkB,CAEf,CAhFgB0mB,CAAiB1mB,GAI7B,IAAK,MAAMwN,KAAK,IAAInT,MAAM,GAAG4a,KAAK,GAC9BsR,EAAQA,EAAM7sB,IAAIsG,EAAMyK,IAAIhG,EAAAA,aAAKmG,IAAI2b,IAAQ3b,IAAI,GAIrD,MAAM+b,EAAeJ,EAAM9b,IAAI8b,GAAO3b,IAAInG,EAAAA,aAC1C,IAEQkiB,EAAaP,IAAIpmB,EAAMtG,IAAI0rB,GAAMmB,EAAOD,OACxCK,EAAahE,IAAI3iB,EAAM4G,IAAIwe,GAAMmB,EAAOD,KAG5C,MAAM,IAAI9gB,MAAM,0BAEpB,OAAO+gB,CACX,UCrHgBK,GACZzV,EACA0V,EACAC,GAEA,MAAO,CAAC5gB,GAAQiL,EAAW2V,GAAWzB,GAAQlU,EAAW0V,GAC7D,CAMgB,SAAAzN,GACZnM,EACA4Z,EACAC,GAaA,MAAOhhB,EAAGihB,EAAIC,EAASC,GAAMC,GACzBja,EACA4Z,EACAC,GAKJ,OAFkBK,GAAoBrhB,EAAGihB,EAAIC,EAASC,EAG1D,UAEgBC,GACZja,EACA4Z,EACAC,GAEA,MAAMhhB,EAAIrB,EAAAA,YAAImC,IAAIV,GAAQ2gB,EAAWC,IAC/BM,EAASlhB,GAAQ+G,EAAS,GAAI6Z,GAC9BO,EAAShC,GAAQpY,EAAS,GAAI4Z,GAC9BE,EAAKK,EAAO1tB,IAAI2tB,GAChBJ,EAAK5B,GAAQpY,EAAS,GAAIA,EAAS,IAIzC,IAAI+Z,EAAU3B,GACVA,GAAQA,GAAQpY,EAAS,GAAIA,EAAS,IAAK4Z,GAC3CA,GAEJ,MAAMS,EAAOphB,GACTmf,GACIA,GAAQA,GAAQpY,EAAS,GAAIA,EAAS,IAAKxI,EAAGmP,YAACnJ,IAAI,IACnDoc,GAEJC,GAGES,EAAOrhB,GACTmf,GAAQpY,EAAS,GAAIA,EAAS,IAC9BmY,GAAM0B,EAAUA,IAKpB,OAFAE,EAAUA,EAAQttB,IAAI4tB,GAAM5tB,IAAI6tB,GAEzB,CAACzhB,EAAGihB,EAAIC,EAASC,EAC5B,CAEM,SAAUE,GACZrhB,EACAihB,EACAC,EACAC,GAEA,MAAM3a,EAAc8Y,GAAMtf,EAAGrB,EAAGmP,YAACnJ,IAAI,IAE/B+c,EAAUnC,GAAQA,GAAQ4B,EAAIxiB,cAAIgG,IAAI,IAAK3E,GAG3C2hB,EAAY/Q,GADDsQ,EAAQttB,IAAI8tB,GACItjB,EAASA,UAAC+G,KAAK,IAKhD,OAFkB/E,GADA6gB,EAAGrtB,IAAI+tB,GACYnb,EAGzC,CAOM,SAAUV,GACZC,EACAE,EACAE,EACAyb,EACAC,GAkBA,MAAMC,EAAa/b,EAAUnS,IAAI0rB,GAAMsC,EAAgBjjB,EAAAA,YAAI/K,IAAI,KACzDmuB,EAAe9b,EAAWrS,IAAI2rB,GAAQsC,EAAiBljB,EAAAA,YAAImC,IAAI,KAE/DiG,EAAY3G,GACdmf,GAAQwC,EAAc5b,GACtB2b,EAAWluB,IAAIuS,IAGnB,GAAIY,EAAUkJ,GAAGhK,GAAa,MAAM,IAAIvG,MAAM,yBAE9C,OAAOqH,CACX,CAEM,SAAUD,GACZf,EACAE,EACAc,EACA6a,EACAC,GAeA,GAAI9a,EAAUkJ,GAAGhK,GAAa,MAAM,IAAIvG,MAAM,yBAI9C,MAAMoiB,EAAa/b,EAAUnS,IAAI0rB,GAAMsC,EAAgBjjB,EAAAA,YAAI/K,IAAI,KACzDmuB,EAAe9b,EAAWrS,IAAI2rB,GAAQsC,EAAiBljB,EAAAA,YAAImC,IAAI,KAOrE,OALiBX,GACbmf,GAAMwC,EAAY/a,GAClBgb,EAAajhB,IAAIiG,GAIzB,CAMgB,SAAAib,GACZ7a,EACA8a,EACAC,EACAN,EACAC,EACA9Z,GAeA,MAAMoa,EAAqBxjB,EAAAA,YAAImC,IAAIiH,GAOnC,OAFqB3H,GAJN+G,EAAS,GAAGvT,IAAIguB,GACNhuB,IAAI2rB,GAAQ4C,EAAoBF,IAErC1C,GAAQ4C,EADZhb,EAAS,GAAGvT,IAAIiuB,GACwB/gB,IAAIohB,IAIhE,UAOgB1X,GACZrD,EACA+a,EACAL,GAoBA,OAFmBzhB,GAJPhC,EAAAA,UAAU+G,KAAK,GAAGR,IAAIhG,EAAAA,aAClBwI,EAAS,GAAGvT,IAAIiuB,GACJ/gB,IAAIohB,GAKpC,CAGgB,SAAAzX,GACZtD,EACA8a,EACAC,EACAN,EACAC,EACA9Z,GAeA,MAAMqa,EAAMhkB,EAAAA,UAAU+G,KAAK,GAAGR,IAAIhG,EAAAA,aAC5BwjB,EAAqBxjB,EAAAA,YAAImC,IAAIiH,GAE7BqD,EADSjE,EAAS,GAAGvT,IAAIguB,GACNhuB,IAAI2rB,GAAQ4C,EAAoBF,IACnDI,EAAUlb,EAAS,GAAGvT,IAAIiuB,GAC1Brb,EAAc+Y,GAAQ8C,EAAQvhB,IAAIohB,GAAYG,EAAQvhB,IAAIohB,IAKhE,OAFmB3C,GAFJnf,GAAQgiB,EAAKD,GAEO/hB,GAAQgL,EAAW5E,GAG1D,8UAKgB,SACZW,EACA0a,GAaA,OADgB1a,EAAS,GAAGvT,IAAIiuB,GACjB/c,IAAI,EACvB,ICzSgB,SAAAwd,GACZnb,EACAjD,GAEA,MAAMqe,EAAiBre,EAAS1Q,KAAKgvB,GAAMle,aAAW,IAAKke,KAE3D,OAAOrb,EAAS3T,KAAI,CAACivB,EAAKvuB,IACtBuuB,EAAI9d,IAAIhG,EAAAA,aAAKmG,IAAIyd,EAAeruB,KAExC,CAMgB,SAAAwuB,GAAWvc,EAAqB4B,GAC5C,MAAM1B,EAAYF,EAASxB,IAAIoD,GAASjD,IAAInG,EAAAA,aAC5C,OAAOwH,EAASrF,IAAIuF,EACxB,CAEgB,SAAAsc,GAAQxc,EAAqB4B,GACzC,OAAO5B,EAASxB,IAAIhG,eAAKmG,IAAInG,cAAImC,IAAIiH,GACzC,OCca6a,GAWT7iB,gBAAgBkM,GACZ,IAAKA,EAAK8U,YAAc9U,EAAK+U,SACzB,MAAM,IAAIthB,MACN,uDAGR,OAAO,IAAIkjB,GACP3W,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACLR,EAAK8U,UACL9U,EAAK+U,SAEZ,CAED/mB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACAsU,EACAC,GApCJ/oB,KAAAyU,SAAsB/G,QAASA,UAACkd,MAsC5B5qB,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAU9D,EAAe8D,EAAS,IACvC9P,KAAKsU,YAActI,EAAesI,EAAa,IAC/CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAK8oB,UAAY9c,EAAe8c,EAAW,IAC3C9oB,KAAK+oB,SAAW/c,EAAe+c,EAAU,GAC5C,CAEDlU,kBAAkBC,EAAiBC,GAC/B,MAAM8V,EAAe7qB,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAI+V,EAAe,EAAG,KAAM,gCAC5B,MAAM1V,EAAKnV,KAAKuU,OAAOsW,GACjB/c,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhB6e,EAAgB9qB,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAI+V,EAAgB,EAAG,KAAM,iCAC7B,MAAMxV,EAAKtV,KAAKuU,OAAOuW,GACjB9c,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAEjB8e,EAAmC,IAAjBF,EAqBxB,MAnBwC,CACpCzW,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAW9B,EAAe8B,EAAWyD,GACrCvD,WAAYhC,EAAegC,EAAYyD,GACvC3B,QAAS9P,KAAK8P,QACdgZ,UAAWiC,EACL/qB,KAAK8oB,UACL3gB,GAAQzB,EAAAA,YAAK1G,KAAK+oB,UACxBA,SAAUgC,EACJ/qB,KAAK+oB,SACL5gB,GAAQzB,EAAAA,YAAK1G,KAAK8oB,WAI/B,CAEDhT,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,GAAIA,IAAavI,QAASA,UAACwI,YAAa,CACpC,MACM+U,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAOXwZ,EAAyB3D,GALbjM,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,UAIb5gB,GAAQzB,EAAAA,YAAKyK,EAAa2X,WAAWjgB,IACjCV,GAAQzB,EAAGmP,YAAE1E,EAAa4X,YAM5BmC,EAA2B/iB,GAHX8iB,EAAuBpiB,IACzCmiB,EAAmB,IAInBtkB,EAAAA,YAAImC,IAAIsI,EAAarB,UAEzB,OAAOrJ,EACH6K,EAAAA,YACIgW,GAAQ4D,EAA0B9D,IAClC,IAGX,CACG,OAAO3gB,EACH6K,cACIgW,GAAQnW,EAAanD,WAAYoZ,IACjCjW,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IACI,MACMge,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UAGXoC,EAAkBV,GADPze,EAAegB,EAAO5Q,WAAY,IACN+U,EAAarB,SAEpDma,EAAYpc,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACAxB,EACAC,GAGJ,OAAOnjB,EAAK6K,EAAWA,YAAC2Y,EAAW,IACtC,CAAC,MAAOpN,GACL,OAAOpW,EAAK,EACf,CACJ,CAEDqQ,yBACI3F,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAE9C4uB,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UASXiB,EAAWU,GAPO7b,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACAN,EACAC,GAEsCzY,EAAarB,SAEvD,OAAOrJ,EAAK6K,EAAWA,YAAC0Y,EAAU,IACrC,CAAC,MAAOnN,GACL,OAAOpW,EAAK,EACf,CACJ,CAGDwJ,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDlG,2CACIC,EACAnE,GAEA,IACI,MACMge,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UAEXiB,EAAWhe,EAAegB,EAAO5Q,WAAY,IAC7C+uB,EAAkBV,GAAWT,EAAU7Y,EAAarB,SAQpDsb,EAAerB,GACjBiB,EACAhB,EATcnc,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACAxB,EACAC,GAMAD,EACAC,EACAzY,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvO,GACL,OAAOpW,EAAK,EACf,CACJ,CAEDsL,2CACIZ,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAE9C4uB,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UAEXoC,EAAkBtc,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACAN,EACAC,GAGEwB,EAAerB,GACjBiB,EAFaN,GAAQS,EAAiBha,EAAarB,SAInDma,EACAN,EACAC,EACAzY,EAAarB,SAGjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvO,GACL,OAAOpW,EAAK,EACf,CACJ,CAED8L,qDACIpB,EACAnE,GAEA,IACI,MACMge,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UAGXoC,EAAkBV,GADPze,EAAegB,EAAO5Q,WAAY,IACN+U,EAAarB,SAQpDub,EACF9Y,GACIyY,EATUnd,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACAxB,EACAC,GAMIA,GAGR,OAAOnjB,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxO,GACL,OAAOpW,EAAK,EACf,CACJ,CAED+L,qDACIrB,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAE9C4uB,EAAqBX,GADV,CAAClZ,EAAarD,UAAWqD,EAAanD,YACC,CACpDmD,EAAaI,WACbJ,EAAaM,cAEX2B,EAAYiI,GACd2P,EACA7Z,EAAa2X,UACb3X,EAAa4X,WAEVY,EAAgBC,GAAmBf,GACtCzV,EACAjC,EAAa2X,UACb3X,EAAa4X,UAEXoC,EAAkBtc,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACAN,EACAC,GAIEyB,EACF7Y,GACIwY,EAJSN,GAAQS,EAAiBha,EAAarB,SAM/Cma,EACAN,EACAC,EACAzY,EAAarB,SAGrB,OAAOrJ,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxO,GACL,OAAOpW,EAAK,EACf,CACJ,ECvcE,MAAM6kB,GAA6BnlB,EAAAA,UAAU+G,KAAK,IAAIlG,IAAI,IAAI0F,IAAI,KAC5D6e,GAAaplB,EAASA,UAAC+G,KAAK,IAAIlG,IAAI,GAMpCwkB,GAAuC,EACvCC,GAA4B,ECYzB,SAAApQ,GACZnM,EACAwc,GASA,MAAO3jB,EAAGihB,EAAIE,EAAIyC,GAAMC,GAAqB1c,EAAUwc,GACvD,OAAOG,GAAgB9jB,EAAGihB,EAAIE,EAAIyC,EAAID,EAC1C,CAOgB,SAAAE,GACZ1c,EACAwc,GAEA,MAAMI,EAAqBxE,GAAQoE,EAAYA,GACzCnR,EAAQ+M,GAAQwE,EAASJ,GACzB3jB,EAAIrB,EAAAA,YAAImC,IAAI0R,GAEZyO,EAAK1B,GAAQA,GADLpY,EAAS,GAAGvT,IAAIuT,EAAS,IAAIvT,IAAIuT,EAAS,IACtBwc,GAAaA,GACzCK,EAAQzE,GAAQpY,EAAS,GAAIA,EAAS,IACvCvT,IAAI2rB,GAAQpY,EAAS,GAAIA,EAAS,KAClCvT,IAAI2rB,GAAQpY,EAAS,GAAIA,EAAS,KAIvC,MAAO,CAACnH,EAAGihB,EAHA1B,GAAQyE,EAAOL,GACfpE,GAAQA,GAAQpY,EAAS,GAAIA,EAAS,IAAKA,EAAS,IAGnE,CAIM,SAAU2c,GACZ9jB,EACAihB,EACAE,EACAyC,EACAD,GAEA,IAAIM,EAAUC,GAA6BlkB,EAAGihB,EAAIE,GAElD,OADA8C,EAAUE,GAAoBnkB,EAAGihB,EAAIE,EAAIyC,EAAID,EAAYM,GAClDA,CACX,UAIgBC,GACZlkB,EACAihB,EACAE,GAEA,MAAMiD,EAAQ9E,GAAM2B,EAAIA,GAAIrtB,IAAI0rB,GAAMA,GAAMtf,EAAGmhB,GAAKxiB,EAAAA,YAAIgG,IAAI,KAS5D,OADW2a,GAPEnf,GAAM8gB,EAAIjhB,EAAE2E,IAAI,IAAI/Q,IAC7BuM,GAAMyQ,GAAKwT,EAAOhmB,EAAAA,UAAU+G,KAAK,IAAKnF,EAAE2E,IAAI,KAIlChG,EAAAA,YAAImC,IAAId,GACD6c,IAAIle,EAAGmP,YAAChJ,IAAI,IAAMnG,EAAAA,YAAIgG,IAAI,GAAGG,IAAI,GAAKnG,cAAIgG,IAAI,GAGvE,CAOgB,SAAAwf,GACZnkB,EACAihB,EACAE,EACAyC,EACAD,EACAM,GAEA,IAAII,EAAejmB,EAAAA,UAAU+G,KAAK,GAClC,IAAK,IAAImf,EAAY,EAAGA,EAAY,MAAOA,EAAW,CAGlD,MAAOC,EAAUC,GAAcC,GAC3BzkB,EACAihB,EACAE,EACAyC,EACAD,EACAM,GAIJ,GACIM,EAASjE,IAAI,IACZgE,GAAaZ,IAA6Bc,EAG3C,OAAOP,EACX,GACIK,GAAaZ,IACba,EAAS1H,IACLwH,EAAavf,IACT1G,EAASA,UAAC+G,KAAKse,MAKvB,OAAOQ,EAEXI,EAAeE,EACCN,EAAZO,EAAsBP,EAAQrwB,IAAI2wB,GACvBN,EAAQnjB,IAAIyjB,EAC9B,CAED,MAAM,IAAI7kB,MACN,kEAER,CAGgB,SAAA+kB,GACZzkB,EACAihB,EACAE,EACAyC,EACAD,EACAM,GAIA,IAAIS,EAAYtmB,EAAAA,UAAU+G,KAAK,GAG/Buf,EADiBnF,GAAQ0E,EAASA,GACbtf,IAAI,GACzB+f,EAAYA,EAAU5jB,IAClBye,GAAQA,GAAQA,GAAQmF,EAAWf,GAAaA,GAAaA,IAEjEe,EAAYA,EAAU5jB,IAAIye,GAAQ0E,EAAShD,GAAItc,IAAI,IAAI7D,IAAIqgB,GAE3D,MAAMwD,WCpKNC,EACAjB,EACAnB,GAEA,IAAIqC,EAAMzmB,EAAAA,UAAU+G,KAAK,GACzB,GAAIyf,EAAEtE,IAAIiD,IAENsB,EAAMD,EAAEjgB,IAAIigB,GAAG9f,IAAInG,eAAKgG,IAAIigB,GAAG9f,IAAInG,EAAGmP,aACtC+W,EAAMA,EAAI/jB,IACN+jB,EACKlgB,IAAIgf,GACJ7e,IAAInG,EAAAA,aACJgG,IAAIgf,GACJ7e,IAAInG,EAAAA,aACJgG,IAAIgf,GACJ7e,IAAInG,EAAGmP,cAEhB+W,EAAMA,EAAIlgB,IAAIhG,EAAGmP,aAAEhJ,IAAI0d,OACpB,CACHqC,EAAMD,EAAEjgB,IAAIigB,GAAG9f,IAAInG,EAAAA,aAMnBkmB,EAAMA,EAAIlgB,IAAIigB,EAAE9f,IAAInG,EAAAA,cAAM/K,IAAIixB,EAAIlgB,IAAIigB,EAAEzE,IAAIxhB,EAAAA,cAAMmG,IAAInG,EAAGmP,cAEzD,IAAIvN,EAAIskB,EAER,IAAK,IAAInd,EAAI,EAAGA,EAAI,EAAGA,IACnBnH,EAAIA,EACCoE,IAAIgf,EAAW7e,IAAI0e,KACnB1e,IAAI0e,IACJ5vB,IAAI2M,EAAEoE,IAAIgf,EAAWxD,IAAIqD,MAElCqB,EAAMA,EAAI/jB,IAAIP,GAMdskB,EAAMA,EAAIlgB,IAAI6e,IAAY1e,IAAI0d,EAAE1d,IAAI0e,IACvC,CACD,OAAOqB,CACX,CDwHuBC,CAAoBb,EAASN,EAAYe,GAI5D,IAAIK,EAAYxF,GAAQA,GAAQ0E,EAASA,GAAUhD,GACnD8D,EAAY3kB,GAAQ2kB,EAAUnxB,IAAI2rB,GAAQ0E,EAAS9C,IAAMuD,GACzDK,EAAYA,EAAUnxB,IAAIwM,GAAQwjB,EAAIc,IAEtC,MAAMF,EAAaO,EAAUlI,IAAI8H,GAKjC,MAAO,CAJUH,EACXO,EAAUjkB,IAAI6jB,GACdA,EAAW7jB,IAAIikB,GAEHP,EACtB,CAUM,SAAU1e,GACZC,EACAE,EACAE,EACA6e,GAoBA,MAAMlD,EAAa/b,EAAUnS,IAAI0rB,GAAM0F,EAAermB,EAAAA,YAAI/K,IAAI,KAExDmT,EADed,EAAWrS,IAAI2rB,GAAQyF,EAAermB,EAAAA,YAAImC,IAAI,KACpC6D,IAAIwB,GAAUrB,IAAIgd,EAAWluB,IAAIuS,IAEhE,GAAIY,EAAUkJ,GAAGhK,GAAa,MAAM,IAAIvG,MAAM,yBAE9C,OAAOqH,CACX,CAKM,SAAUD,GACZf,EACAE,EACAc,EACAie,GAqBA,GAAIje,EAAUkJ,GAAGhK,GAAa,MAAM,IAAIvG,MAAM,yBAK9C,MAAMoiB,EAAa/b,EAAUnS,IAAI0rB,GAAM0F,EAAermB,EAAAA,YAAI/K,IAAI,KACxDmuB,EAAe9b,EAAWrS,IAAI2rB,GAAQyF,EAAermB,EAAAA,YAAImC,IAAI,KAOnE,OALiBX,GACbmf,GAAMwC,EAAY/a,GAClBgb,EAAajhB,IAAIiG,GAIzB,CAMM,SAAUib,GACZ7a,EACA8a,EACAC,EACA+C,EACAld,GAeA,MAAMoa,EAAqBxjB,EAAAA,YAAImC,IAAIiH,GASnC,OAFqB3H,GANN+G,EAAS,GAAGvT,IAAIqxB,GACNrxB,IAAI2rB,GAAQ4C,EAAoBF,IAGrC1C,GAAQ4C,EADZhb,EAAS,GAAGvT,IAAIqxB,GACwBnkB,IAAIohB,IAKhE,UAOgB1X,GACZrD,EACA+a,EACA+C,GAoBA,OAFmB7kB,GAJPhC,EAAAA,UAAU+G,KAAK,GAAGR,IAAIhG,EAAAA,aAClBwI,EAAS,GAAGvT,IAAIqxB,GACJnkB,IAAIohB,GAKpC,CAGM,SAAUzX,GACZtD,EACA8a,EACAC,EACA+C,EACAld,GAeA,MAAMqa,EAAMhkB,EAAAA,UAAU+G,KAAK,GAAGR,IAAIhG,EAAAA,aAC5BwjB,EAAqBxjB,EAAAA,YAAImC,IAAIiH,GAE7BqD,EADSjE,EAAS,GAAGvT,IAAIqxB,GACNrxB,IAAI2rB,GAAQ4C,EAAoBF,IACnDI,EAAUlb,EAAS,GAAGvT,IAAIqxB,GAC1Bze,EAAc+Y,GAAQ8C,EAAQvhB,IAAIohB,GAAYG,EAAQvhB,IAAIohB,IAMhE,OAFmB3C,GAFJnf,GAAQgiB,EAAKD,GAEO/hB,GAAQgL,EAAW5E,GAG1D,oWAOgB,SACZW,EACA0a,GAaA,OADgB1a,EAAS,GAAGvT,IAAIiuB,GACjB/c,IAAI,EACvB,iCEhWaogB,GAUDnlB,iBAAiBolB,EAAMC,EAActQ,GACzC,MAAMrQ,EAAQ0gB,EAAK5W,MACdpB,GAAMnJ,EAAAA,WAAWmJ,EAAEb,WAAatI,aAAWohB,KAEhD,IAAK3gB,EAAO,MAAM,IAAI/E,MAAMoV,GAC5B,OAAOrQ,CACV,CAED1E,gBAAgBkM,GACZ,IAAKA,EAAK0X,WAAY,MAAM,IAAIjkB,MAAM,2BAEtC,GACIuE,EAAegI,EAAK0X,WAAY,IAAIrD,IAAI,IACxCrc,EAAegI,EAAK0X,WAAY,IAAI9G,IAAIle,EAAAA,aAExC,MAAM,IAAIe,MAAM,gCAEpB,GAA2B,IAAvBuM,EAAKO,OAAOrY,OACZ,MAAM,IAAIuL,MAAM,4CAEpB,OAAO,IAAIwlB,GACPjZ,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACLR,EAAK0X,WAEZ,CAED1pB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACAkX,GA/CJ1rB,KAAAyU,SAAsB/G,QAASA,UAAC0f,MAiD5BptB,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAU9D,EAAe8D,EAAS,IACvC9P,KAAKsU,YAActI,EAAesI,EAAa,IAC/CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAK0rB,WAAa1f,EAAe0f,EAAY,GAChD,CAED7W,kBAAkBC,EAAiBC,GAC/B,MAAMI,EAAK8X,GAAUI,UACjBrtB,KAAKuU,OACLO,EACA,iCAEEhH,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhBqJ,EAAK2X,GAAUI,UACjBrtB,KAAKuU,OACLQ,EACA,kCAEE/G,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAEjBqhB,EAAgBttB,KAAKuU,OAAO+B,MAC7BpB,GACGnJ,EAAUA,WAACmJ,EAAEb,WAAatI,EAAAA,WAAWgJ,IACrChJ,EAAUA,WAACmJ,EAAEb,WAAatI,EAAAA,WAAW+I,KAG7C,IAAKwY,EACD,MAAM,IAAI7lB,MAAM,6CAEpB,MAAM8lB,EAAkBD,EAAc7gB,QAChC+gB,EAAmBF,EAAcrhB,SAiBvC,MAfwC,CACpCmI,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB+b,iBAAkB7X,OAAO6X,GACzB1f,UAAW9B,EAAe8B,EAAWyD,GACrCvD,WAAYhC,EAAegC,EAAYyD,GACvC8b,gBAAiBvhB,EAAeuhB,EAAiBC,GACjD1d,QAAS9P,KAAK8P,QAIrB,CAEDgG,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,GAAIA,IAAavI,QAASA,UAACwI,YAAa,CACpC,MAUM+U,EAAqBX,GAVV,CACblZ,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAEA,CACbpc,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBAOXzlB,EAAIuf,GAJQjM,GACd2P,EACAhrB,KAAK0rB,YAEoB1rB,KAAK0rB,YAC5BT,EAAyB9iB,GAC3Bmf,GACI0D,EAAmB,GAAGrvB,IAAIoM,GAC1BijB,EAAmB,GAAGrvB,IAAIoM,IAE9BA,GACFc,IAAId,GAIAmjB,EAA2B/iB,GAHX8iB,EAAuBpiB,IACzCmiB,EAAmB,IAInBtkB,EAAAA,YAAImC,IAAIsI,EAAarB,UAEzB,OAAOrJ,EACH6K,EAAAA,YACIgW,GAAQ4D,EAA0B9D,IAClC,IAGX,CACG,OAAO3gB,EACH6K,cACIgW,GAAQnW,EAAanD,WAAYoZ,IACjCjW,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IACI,MAAMkC,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAE7CP,EAAkBV,GADPze,EAAegB,EAAO5Q,WAAY,IACN+U,EAAarB,SAEpDma,EAAYpc,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACA6B,GAEJ,OAAOvmB,EAAK6K,EAAWA,YAAC2Y,EAAW,IACtC,CAAC,MAAOpN,GACL,OAAOpW,EAAK,EACf,CACJ,CAEDqQ,yBACI3F,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAC9C8S,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAQ7C1B,EAAWU,GANO7b,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACA+C,GAEsC7b,EAAarB,SAEvD,OAAOrJ,EAAK6K,EAAWA,YAAC0Y,EAAU,IACrC,CAAC,MAAOnN,GACL,OAAOpW,EAAK,EACf,CACJ,CAGDwJ,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDlG,2CACIC,EACAnE,GAEA,IACI,MAAMkC,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAE7C1B,EAAWhe,EAAegB,EAAO5Q,WAAY,IAC7C+uB,EAAkBV,GAAWT,EAAU7Y,EAAarB,SASpDsb,EAAerB,GACjBiB,EACAhB,EATcnc,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACA6B,GAOAA,EACA7b,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvO,GACL,OAAOpW,EAAK,EACf,CACJ,CAEDsL,2CACIZ,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAC9C8S,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAE7CP,EAAkBtc,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACA+C,GAIE5B,EAAerB,GACjBiB,EAHaN,GAAQS,EAAiBha,EAAarB,SAKnDma,EACA+C,EACA7b,EAAarB,SAGjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvO,GACL,OAAOpW,EAAK,EACf,CACJ,CAED8L,qDACIpB,EACAnE,GAEA,IACI,MAAMkC,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAG7CP,EAAkBV,GADPze,EAAegB,EAAO5Q,WAAY,IACN+U,EAAarB,SAQpDub,EACF9Y,GACIyY,EARUnd,GACdmd,EAAmB,GACnBA,EAAmB,GACnBG,EACA6B,GAMIA,GAGR,OAAOvmB,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxO,GACL,OAAOpW,EAAK,EACf,CACJ,CAED+L,qDACIrB,EACAnE,GAEA,IACI,MAAMid,EAAYje,EAAegB,EAAO5Q,WAAY,IAC9C8S,EAAW,CACbiC,EAAarD,UACbqD,EAAanD,WACbmD,EAAaoc,iBAOXvC,EAAqBX,GAAmBnb,EAL7B,CACbiC,EAAaI,WACbJ,EAAaM,YACbN,EAAaqc,mBASXR,EAAqB1F,GALTjM,GACd2P,EACAhrB,KAAK0rB,YAGqC1rB,KAAK0rB,YAE7CP,EAAkBtc,GACpBmc,EAAmB,GACnBA,EAAmB,GACnBf,EACA+C,GAIE3B,EACF7Y,GACIwY,EAJSN,GAAQS,EAAiBha,EAAarB,SAM/Cma,EACA+C,EACA7b,EAAarB,SAGrB,OAAOrJ,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxO,GACL,OAAOpW,EAAK,EACf,CACJ,EClfE,MAAMgnB,GAAetnB,EAASA,UAAC+G,KAAK,IAAIlG,IAAI,IAGtC0mB,GAAgBvnB,EAAAA,UAAU+G,KAAK,IAAIlG,IAAI,IAAI0F,IAAI,GCmD5C,SAAAihB,GAAUzf,EAAqB4B,GAC3C,MAAM1B,EAAYkZ,GAAQpZ,EAAU4B,GACpC,OAAO5B,EAASrF,IAAIuF,EACxB,CAEgB,SAAAY,GAAOd,EAAqB4B,GACxC,OAAO3H,GAAQ+F,EAAUxH,EAAAA,YAAImC,IAAIiH,GACrC,CAKgB,SAAA8d,GACZ1e,EACAjD,GAEA,MAAMqe,EAAiBre,EAAS1Q,KAAKgvB,GAAMle,aAAW,IAAKke,KAE3D,OAAOrb,EAAS3T,KAAI,CAACivB,EAAKvuB,IACtBuuB,EAAI9d,IAAIhG,EAAAA,aAAKmG,IAAIyd,EAAeruB,KAExC,UAEgB4xB,GACZC,EACAC,EACAhD,GAEA,OAAOA,EACD,CAAC+C,EAAgBC,GACjB,CAACA,EAAiBD,EAC5B,CAuCM,SAAUE,GACZ1lB,EACAC,EACA8P,EACAkS,GAEA,IAAIrjB,EASR,SACIoB,EACAC,EACA8P,EACAkS,GAEA,IAAI0D,EAAStG,GAAUA,GAAUA,GAAUrf,EAAGA,GAAI+P,EAAErQ,GAAIqQ,EAAErQ,GAAGrM,IACzDgsB,GAAUA,GAAUA,GAAUpf,EAAGA,GAAI8P,EAAE6V,GAAI7V,EAAE6V,IAEjDD,EAASA,EAAOplB,IACZ4e,GAAYA,GAAYA,GAAYnf,EAAGC,GAAI8P,EAAErQ,EAAE0E,IAAI,IAAK2L,EAAE6V,IAE9D,MAAMC,EAAS5G,GAAOgD,EAAE6D,EAAG7D,EAAE6D,GACxBzyB,IAAI+rB,GAAYH,GAAOgD,EAAE6D,EAAE1hB,IAAI,GAAI6d,EAAE8D,GAAIhW,EAAEiW,SAC3C3yB,IAAI+rB,GAAYA,GAAYH,GAAOgD,EAAE8D,EAAG9D,EAAE8D,GAAIhW,EAAEiW,QAASjW,EAAEiW,SAEhE,IAAIpnB,EAAMohB,GAAe2F,EAAOvhB,KAAK,GAAIyhB,GAOzC,OANAjnB,EAAMA,EAAIvL,IACN2sB,GACIZ,GAAYA,GAAYuG,EAAOplB,IAAI,GAAIwP,EAAEiW,QAASjW,EAAEiW,QACpD9G,GAAON,GAAQqD,EAAEgE,OAGlBrnB,CACX,CAjCcsnB,CAA2BlmB,EAAGC,EAAG8P,EAAGkS,GAAG5uB,IAmCrD,SACI2M,EACAC,EACA8P,EACAkS,GAEA,IAAI0D,EAASxG,GACTA,GAAYA,GAAYnf,EAAGA,GAAGO,IAAI8e,GAAUpf,EAAGA,IAAK8P,EAAErQ,EAAE0E,IAAI,IAC5D2L,EAAE6V,GAGN,MAAMO,EAAKhH,GAAYlf,EAAGD,EAAEoE,IAAI,IAChCuhB,EAASA,EACJtyB,IAAI8rB,GAAYA,GAAYgH,EAAIpW,EAAErQ,GAAIqQ,EAAErQ,IACxCa,IAAI4e,GAAYA,GAAYgH,EAAIpW,EAAE6V,GAAI7V,EAAE6V,IAC7C,IAAIC,EAAS5G,GAAOgD,EAAEpf,EAAGof,EAAE6D,GAAGzyB,IAC1B+rB,GAAYA,GAAYH,GAAOgD,EAAEmE,EAAGnE,EAAE8D,GAAIhW,EAAEiW,QAASjW,EAAEiW,SAE3DH,EAASA,EAAOxyB,IACZ+rB,GAAYH,GAAOgD,EAAEmE,EAAGnE,EAAE6D,GAAGzyB,IAAI4rB,GAAOgD,EAAEpf,EAAGof,EAAE8D,IAAKhW,EAAEiW,SAE1DH,EAAS3G,GAAO2G,EAAQ5G,GAAOA,GAAOA,GAAOgD,EAAEgE,IAAKhE,EAAEgE,KAAMhE,EAAEgE,KAAMhE,EAAEgE,MACtE,MAAMrnB,EAAMohB,GAAe2F,EAAQE,GACnC,OAAOjnB,CACX,CA1DQynB,CAAsBrmB,EAAGC,EAAG8P,EAAGkS,IAEnCrjB,EAAMA,EAAIvL,IA0Dd,SACI2M,EACAC,EACA8P,EACAkS,GAEA,IAAI0D,EAAStG,GAAUA,GAAUA,GAAUrf,EAAGA,GAAI+P,EAAE6V,GAAI7V,EAAE6V,GAAGvyB,IACzDgsB,GAAUA,GAAUA,GAAUpf,EAAGA,GAAI8P,EAAErQ,GAAIqQ,EAAErQ,IAEjDimB,EAASA,EAAOtyB,IAAIgsB,GAAUA,GAAUA,GAAUrf,EAAGC,GAAI8P,EAAE6V,EAAExhB,IAAI,IAAK2L,EAAErQ,IACxE,IAAImmB,EAAS5G,GAAOgD,EAAEpf,EAAGof,EAAEpf,GAAGxP,IAC1B+rB,GAAYA,GAAYH,GAAOgD,EAAEmE,EAAGnE,EAAEmE,GAAIrW,EAAEiW,QAASjW,EAAEiW,SAE3DH,EAASA,EAAOxyB,IAAI+rB,GAAYH,GAAOgD,EAAEpf,EAAEuB,IAAI,GAAI6d,EAAEmE,GAAIrW,EAAEiW,SAC3DH,EAAS3G,GAAO2G,EAAQ5G,GAAOA,GAAOA,GAAOgD,EAAEgE,IAAKhE,EAAEgE,KAAMhE,EAAEgE,KAAMhE,EAAEgE,MACtE,IAAIrnB,EAAMohB,GAAe2F,EAAOvhB,KAAK,GAAIyhB,GAEzC,OADAjnB,EAAMA,EAAIvL,IAAI2sB,GAAe2F,EAAOplB,IAAI,GAAI2e,GAAON,GAAQqD,EAAEgE,OACtDrnB,CACX,CA5EkB0nB,CAA2BtmB,EAAGC,EAAG8P,EAAGkS,IAClD,MAAM1T,EAAM8Q,GAAUrf,EAAGA,GAAG3M,IAAIgsB,GAAUpf,EAAGA,IAAIsE,IAAIqa,IAErD,OADAhgB,EAAMA,EAAI8Q,GAAG,GAAKW,GAAKzR,EAAKf,EAASA,UAAC+G,KAAK,IAAM/G,EAASA,UAAC+G,KAAK,GACzD,CAAChG,EAAK2P,EACjB,CAgGM,SAAUgY,GACZhR,EACAiR,EACA1b,EACA2b,EACAC,GAEA,GAAmB,IAAfA,EAAkB,CAClB,MAAMC,EAUd,SAAsB5W,EAAgBkS,EAAuB2E,GACzD,MAAMC,EAAU3H,GAAO+C,EAAE6E,QAAQ9mB,EAAEO,IAAI0hB,EAAE8E,SAAS/mB,GAAIiiB,EAAEgE,KAClDe,EAAU9H,GAAO+C,EAAE6E,QAAQ7mB,EAAEM,IAAI0hB,EAAE8E,SAAS9mB,GAAIgiB,EAAEgE,KACxD,IAAIgB,EAAKjH,GACLb,GAAYA,GAAYyH,EAAE3mB,EAAG8P,EAAEiW,QAASjW,EAAErQ,GAC1CmnB,GAOJ,OALAI,EAAKA,EAAG5zB,IACJ2zB,EAAQtX,GAAG7R,YAAU+G,KAAK,IACpBua,GAAYyH,EAAE3mB,EAAG8P,EAAE6V,GACnB5F,GAAeX,GAAUuH,EAAE5mB,EAAG+P,EAAE6V,GAAIoB,IAEvCC,CACX,CAvBsBC,CAAa3R,EAAQiR,EAAS1b,GAC5C,GAAI2b,EAAO/W,GAAGyV,KAAiBsB,EAAO/W,GAAGiX,GACrC,MAAM,IAAIxnB,MAAM,wBACvB,KAAM,CACH,MAAMgoB,EAqBd,SAAsBpX,EAAgBkS,EAAuB2E,GACzD,MAAMC,EAAU3H,GAAO+C,EAAE6E,QAAQ9mB,EAAEO,IAAI0hB,EAAE8E,SAAS/mB,GAAIiiB,EAAEgE,KAClDe,EAAU9H,GAAO+C,EAAE6E,QAAQ7mB,EAAEM,IAAI0hB,EAAE8E,SAAS9mB,GAAIgiB,EAAEgE,KACxD,IAAImB,EAAKpH,GACLb,GAAYA,GAAYyH,EAAE3mB,EAAG8P,EAAEiW,QAASjW,EAAE6V,GAC1CiB,GAOJ,OALAO,EAAKA,EAAG/zB,IACJ2zB,EAAQtX,GAAG7R,YAAU+G,KAAK,IACpBua,GAAYyH,EAAE3mB,EAAG8P,EAAErQ,GACnBsgB,GAAeX,GAAUuH,EAAE5mB,EAAG+P,EAAErQ,GAAIsnB,IAEvCI,CACX,CAlCsBC,CAAa9R,EAAQiR,EAAS1b,GAC5C,GAAI2b,EAAO/W,GAAGyV,KAAiBsB,EAAO/W,GAAGyX,GACrC,MAAM,IAAIhoB,MAAM,wBACvB,CACL,CAgCM,SAAUmoB,GACZtnB,EACAuV,EACA0M,EACA2E,GAEA,MAAMW,EAAc,CAChBvnB,EAAGwnB,GAAejS,EAAQ0M,EAAG2E,GAC7B3mB,EAAGwnB,GAAelS,EAAQ0M,EAAG2E,IAajC,OAVUc,GACNnS,EAAOyQ,OACPhmB,EACAuV,EAAOqQ,EACPrQ,EAAO7V,EACPknB,EACAW,EACAtF,EAAE6E,QACF7E,EAAEgE,IAGV,CAEM,SAAU0B,GACZ1nB,EACAsV,EACA0M,EACA2E,GAEA,MAAMgB,EAAc,CAChB5nB,EAAGynB,GAAelS,EAAQ0M,EAAG2E,GAC7B3mB,EAAGunB,GAAejS,EAAQ0M,EAAG2E,IAejC,OAbUc,GACNnS,EAAOyQ,OACP/lB,EACAsV,EAAO7V,EACP6V,EAAOqQ,EACPgB,EACAgB,EACA,CACI5nB,EAAGiiB,EAAE8E,SAAS/mB,EAAEoE,KAAK,GACrBnE,EAAGgiB,EAAE8E,SAAS9mB,GAElBgiB,EAAEgE,IAGV,CAEM,SAAUuB,GACZzX,EACAkS,EACA2E,EACAiB,GAEA,MAAMC,EAAWD,EAAY5F,EAAE8E,SAAW9E,EAAE6E,QACtCjB,EAAS3G,GAAO4I,EAAS9nB,EAAGiiB,EAAEgE,KAEpC,IAAIxmB,EAAIqoB,EAAS9nB,EAAE0P,GAAG7R,YAAU+G,KAAK,IAC/B2a,GAAaF,GAAUA,GAAUuH,EAAE5mB,EAAG+P,EAAEiW,QAASjW,EAAErQ,GAAImmB,GACvDtG,GAAaJ,GAAYA,GAAYyH,EAAE3mB,EAAG8P,EAAEiW,QAASjW,EAAErQ,GAAImmB,GAIjE,OAFApmB,EAAIA,EAAEpM,IAAIksB,GAAaF,GAAUuH,EAAE5mB,EAAG+P,EAAE6V,GAAI1G,GAAO4I,EAAS7nB,EAAGgiB,EAAEgE,OAE1DxmB,CACX,CAEM,SAAUgoB,GACZ1X,EACAkS,EACA2E,EACAiB,GAEA,MAAMC,EAAWD,EAAY5F,EAAE6E,QAAU7E,EAAE8E,SACrClB,EAAS3G,GAAO4I,EAAS9nB,EAAGiiB,EAAEgE,KAEpC,IAAIhnB,EAAI6oB,EAAS9nB,EAAEuL,GAAG1N,YAAU+G,KAAK,IAC/B2a,GAAaF,GAAUA,GAAUuH,EAAE5mB,EAAG+P,EAAEiW,QAASjW,EAAE6V,GAAIC,EAAOzhB,KAAK,IACnEmb,GACIJ,GAAYA,GAAYyH,EAAE3mB,EAAEmE,KAAK,GAAI2L,EAAEiW,QAASjW,EAAE6V,GAClDC,GAIV,OADA5mB,EAAIA,EAAE5L,IAAIksB,GAAaF,GAAUuH,EAAE5mB,EAAG+P,EAAErQ,GAAIwf,GAAO4I,EAAS7nB,EAAGgiB,EAAEgE,OAC1DhnB,CACX,CAEA,SAASyoB,GACL1B,EACAhmB,EACA4lB,EACAlmB,EACAknB,EACAW,EACAT,EACAb,GAEA,MAAM8B,EAAkB,CACpB/nB,EAAG4e,GAAOre,IAAI6e,GAAYA,GAAYR,GAAQoH,GAASA,IACvD/lB,EAAG2e,GAAOre,IAAI+e,GAAUA,GAAUV,GAAQoH,GAASA,KAEjDgC,EAAa,CACfvoB,EAAG5B,EAAAA,UAAU+G,KAAK,GAClB3F,EAAGpB,EAAAA,UAAU+G,KAAK,GAClBlF,EAAG7B,EAAAA,UAAU+G,KAAK,IAEhBqiB,EAAKjnB,EAAEO,IAAIgnB,EAAGvnB,GAChBinB,EAAGvX,GAAG7R,EAAAA,UAAU+G,KAAK,IACrBojB,EAAE/oB,EAAIsgB,GACFJ,GAAYA,GAAY8H,EAAG7iB,KAAK,GAAIwhB,GAAIlmB,GACxCwf,GAAO6I,EAAO9nB,EAAGgmB,IAGrB+B,EAAE/oB,EAAIsgB,GACFF,GAAUA,GAAU4H,EAAG7iB,KAAK,GAAIwhB,GAAIlmB,GACpCwf,GAAO6I,EAAO/nB,EAAGimB,GAAK5yB,IAAI,IAGlC,MAAM40B,EAAiB,CACnBjoB,EAAGkf,GAAOC,GAAYA,GAAY4I,EAAO9nB,EAAG2lB,GAAIA,GAAIK,GACpDhmB,EAAGif,GAAOG,GAAUA,GAAU0I,EAAO/nB,EAAG4lB,GAAIA,GAAIK,EAAI5yB,IAAI,IAAIA,IAAI,IAepE,OAbA40B,EAAMjoB,EAAI4e,GAAOre,IAAI0nB,EAAMjoB,GAC3BioB,EAAMhoB,EAAI2e,GAAOre,IAAI0nB,EAAMhoB,GAE3B+nB,EAAEtoB,EAAIwoB,GAAwBloB,EAAG4mB,EAAGZ,EAAQJ,EAAGlmB,EAAGonB,EAASb,GAAK7hB,KAAK,GACrE4jB,EAAEtoB,EAAIsoB,EAAEtoB,EAAErM,IAAI2sB,GAAeb,GAAYyH,EAAE3mB,EAAG2mB,EAAE3mB,GAAIgoB,EAAMhoB,IAC1D+nB,EAAEtoB,EAAIsoB,EAAEtoB,EAAEgQ,GAAG7R,YAAU+G,KAAK,IACtByL,GAAK2X,EAAEtoB,EAAG7B,EAASA,UAAC+G,KAAK,IACzB/G,YAAU+G,KAAK,GACjBojB,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAGgQ,GAAG7R,EAASA,UAAC+G,KAAK,IAC/BojB,EAAEvoB,EAAI8f,GAAayI,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAIwf,GAAON,GAAQqJ,EAAMhoB,GAAG5M,IAAI,IAE7D20B,EAAEvoB,EAAI8f,GAAayI,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAIwf,GAAON,GAAQqJ,EAAMjoB,IAEnDgoB,EAAEvoB,EAAEpM,IAAIk0B,EAAGtnB,EACtB,CAEgB,SAAAioB,GACZloB,EACA4mB,EACAZ,EACAJ,EACAlmB,EACAonB,EACAb,GAEA,MAAMkC,EAAS,CACXnoB,EAAGif,GAAOgH,EAAKA,GACfhmB,EAAGof,GAAUuH,EAAE5mB,EAAG4mB,EAAE5mB,IAElBgoB,EAAa,CACfvoB,EAAG5B,EAAAA,UAAU+G,KAAK,GAClB3F,EAAGpB,EAAAA,UAAU+G,KAAK,GAClBlF,EAAG7B,EAAAA,UAAU+G,KAAK,IAEtB,IAAIihB,EAAS3G,GAAOD,GAAO6H,EAAQ9mB,EAAG8mB,EAAQ7mB,GAAIkoB,EAAOnoB,GACrD6lB,EAAOnW,GAAG7R,EAAAA,UAAU+G,KAAK,KACzBojB,EAAEvoB,EAAI4f,GAAU8I,EAAOloB,EAAG2lB,EAAExhB,IAAI,IAChC4jB,EAAEvoB,EAAI8f,GAAaF,GAAU2I,EAAEvoB,EAAGC,GAAImmB,EAAOxyB,IAAI,MAEjD20B,EAAEvoB,EAAI0f,GAAYA,GAAYyH,EAAE3mB,EAAG2mB,EAAE3mB,GAAI2lB,EAAExhB,IAAI,IAC/C4jB,EAAEvoB,EAAI8f,GAAaJ,GAAY6I,EAAEvoB,EAAGC,GAAImmB,IAGxCiB,EAAQ9mB,EAAEuL,GAAG1N,EAASA,UAAC+G,KAAK,IAC5BojB,EAAE/oB,EAAIsgB,GACFF,GAAUA,GAAUuH,EAAE5mB,EAAGA,GAAIN,EAAE0E,IAAI,IACnC8a,GAAO4H,EAAQ9mB,EAAGimB,GAAK7hB,KAAK,GAAG/Q,IAAI,IAGvC20B,EAAE/oB,EAAIsgB,GACFJ,GAAYA,GAAYyH,EAAE3mB,EAAEmE,KAAK,GAAIpE,GAAIN,EAAE0E,IAAI,IAC/C8a,GAAO4H,EAAQ9mB,EAAGimB,IAG1B+B,EAAEvoB,EAAIuoB,EAAEvoB,EAAEpM,IAAI20B,EAAE/oB,GAChB4mB,EAAS3G,GAAOD,GAAO6H,EAAQ7mB,EAAG6mB,EAAQ7mB,GAAIkoB,EAAOnoB,GAAG3M,IAAI,GAC5D20B,EAAE/oB,EAAIogB,GAAU8I,EAAOloB,EAAG2lB,GAC1BoC,EAAE/oB,EAAIsgB,GAAaF,GAAU2I,EAAE/oB,EAAG2mB,GAAIC,GAEtCmC,EAAEtoB,EAAI6f,GACFJ,GAAYA,GAAYyH,EAAE3mB,EAAEmE,KAAK,GAAIpE,GAAI4lB,EAAExhB,IAAI,IAC/C8a,GAAO4H,EAAQ7mB,EAAGgmB,IAEtB+B,EAAE/oB,EAAI+oB,EAAE/oB,EAAE5L,IAAI20B,EAAEtoB,GAAGrM,IAAIgsB,GAAUrf,EAAGA,IACpCgoB,EAAE/oB,EAAI+oB,EAAE/oB,EAAEyQ,GAAG7R,YAAU+G,KAAK,IACtB0a,GAAU0I,EAAE/oB,EAAG+mB,GACf5G,GAAY4I,EAAE/oB,EAAG+mB,GAEvBgC,EAAEvoB,EAAIuoB,EAAEvoB,EAAEpM,IAAI20B,EAAE/oB,GAChB+oB,EAAEvoB,EAAIuoB,EAAEvoB,EAAEiQ,GAAG7R,YAAU+G,KAAK,IACtB0a,GAAU0I,EAAEvoB,EAAGumB,GACf5G,GAAY4I,EAAEvoB,EAAGumB,GAEvBH,EAAS3G,GAAOD,GAAO6H,EAAQ9mB,EAAG8mB,EAAQ9mB,GAAImoB,EAAOnoB,GAAG3M,IAAI,GAE5D,OAAOksB,GADKF,GAAUA,GAAU8I,EAAOloB,EAAGP,GAAIA,GACrBmmB,GAAQxyB,IAAI20B,EAAEvoB,EAC3C,CCrcM,SAAU2oB,GACZpoB,EACAuV,EACA0M,EACA2E,GAEA,MAAMW,EAAc,CAChBvnB,EAAGwnB,GAAejS,EAAQ0M,EAAG2E,GAC7B3mB,EAAGwnB,GAAelS,EAAQ0M,EAAG2E,IAYjC,OAV2ByB,GACvB9S,EAAOyQ,OACPhmB,EACAuV,EAAOqQ,EACPrQ,EAAO7V,EACPknB,EACAW,EACAtF,EAAE6E,QACF7E,EAAEgE,IAGV,CAEM,SAAUqC,GACZroB,EACAsV,EACA0M,EACA2E,GAEA,MAAMgB,EAAc,CAChB5nB,EAAGynB,GAAelS,EAAQ0M,EAAG2E,GAC7B3mB,EAAGunB,GAAejS,EAAQ0M,EAAG2E,IAejC,OAb2ByB,GACvB9S,EAAOyQ,OACP/lB,EACAsV,EAAO7V,EACP6V,EAAOqQ,EACPgB,EACAgB,EACA,CACI5nB,EAAGiiB,EAAE8E,SAAS/mB,EAAEoE,KAAK,GACrBnE,EAAGgiB,EAAE8E,SAAS9mB,GAElBgiB,EAAEgE,IAGV,CAEA,SAASoC,GACLrC,EACAhmB,EACA4lB,EACAlmB,EACAknB,EACAW,EACAT,EACAb,GAEA,MAAM8B,EAAkB,CACpB/nB,EAAG4e,GAAOre,IAAI6e,GAAYA,GAAYR,GAAQoH,GAASA,IACvD/lB,EAAG2e,GAAOre,IAAI+e,GAAUA,GAAUV,GAAQoH,GAASA,KAEjDgC,EAAa,CACfvoB,EAAG5B,EAAAA,UAAU+G,KAAK,GAClB3F,EAAGpB,EAAAA,UAAU+G,KAAK,GAClBlF,EAAG7B,EAAAA,UAAU+G,KAAK,IAEhBqiB,EAAKjnB,EAAEO,IAAIgnB,EAAGvnB,GACpBgoB,EAAE/oB,EAAIsgB,GAAaJ,GAAYyG,EAAGlmB,GAAIwf,GAAO6I,EAAO9nB,EAAGgmB,IAEvD,MAAMgC,EAAiB,CACnBjoB,EAAGkf,GAAOC,GAAYA,GAAY4I,EAAO9nB,EAAG2lB,GAAIA,GAAIK,GACpDhmB,EAAGif,GAAOG,GAAUA,GAAU0I,EAAO/nB,EAAG4lB,GAAIA,GAAIK,EAAI5yB,IAAI,IAAIA,IAAI,IAmBpE,OAjBA40B,EAAMjoB,EAAI4e,GAAOre,IAAI0nB,EAAMjoB,GAC3BioB,EAAMhoB,EAAI2e,GAAOre,IAAI0nB,EAAMhoB,GAE3B+nB,EAAEtoB,EAAIwoB,GAAwBloB,EAAG4mB,EAAGZ,EAAQJ,EAAGlmB,EAAGonB,EAASb,GAAK7hB,KAAK,GACrE4jB,EAAEtoB,EAAIsoB,EAAEtoB,EAAErM,IAAI2sB,GAAeb,GAAYyH,EAAE3mB,EAAG2mB,EAAE3mB,GAAIgoB,EAAMhoB,IAC1D+nB,EAAEtoB,EAAIsoB,EAAEtoB,EAAEgQ,GAAG7R,YAAU+G,KAAK,IACtByL,GAAK2X,EAAEtoB,EAAG7B,EAASA,UAAC+G,KAAK,IACzB/G,YAAU+G,KAAK,GAErBojB,EAAEtoB,EAAIsf,GAAQA,GAAQgJ,EAAEtoB,EAAGsmB,GAASA,GACpCgC,EAAEtoB,EAAIG,GAAQonB,EAAIe,EAAEtoB,GAEhBsoB,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAGgQ,GAAG7R,EAASA,UAAC+G,KAAK,IAC/BojB,EAAEvoB,EAAI8f,GAAayI,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAIwf,GAAON,GAAQqJ,EAAMhoB,GAAG5M,IAAI,IAE7D20B,EAAEvoB,EAAI8f,GAAayI,EAAE/oB,EAAEsB,IAAIynB,EAAEtoB,GAAIwf,GAAON,GAAQqJ,EAAMjoB,IAEnDgoB,EAAEvoB,CACb,CAMA,SAAS8oB,GACL3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACAC,GAEA,MAAM7B,EAAI4B,EAAKvoB,GACTP,EAAEA,EAACkmB,EAAEA,EAACI,OAAEA,GAAWzQ,GAClBjU,EAAIonB,GAAM9hB,EACXnH,EAAI+nB,GAAejS,EAAQiR,EAASgC,GACpCvpB,EAAIwoB,GAAelS,EAAQiR,EAASgC,GACpCG,EAAKvqB,cAAImC,IAAIV,GAAQzB,cAAK4gB,GAAQgH,EAAQA,KAC1Cxc,EAAIpL,EAAAA,YAAImC,IAAIsF,GAElB,IAAI+iB,EAiBJ,OAfIA,EAAIvY,GADM,IAAVoY,EAEIzJ,GAAQA,GAAQ4H,EAAGA,GAAIxoB,cAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQ4G,EAAGA,MAAMrlB,IACxDV,GAAQmf,GAAQ1d,EAAGf,IAAId,GAAI6B,EAAGf,IAAId,IAAKuf,GAAQgH,EAAQA,KAM3DhH,GAAQA,GAAQ4H,EAAGA,GAAIxoB,cAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQtf,EAAGA,MAAMa,IACxDV,GAAQmf,GAAQ0J,EAAGnoB,IAAItB,GAAIypB,EAAGnoB,IAAItB,IAAK+f,GAAQgH,EAAQA,KAL3DnoB,EAASA,UAAC+G,KAAK,IAWhB,CAAEtD,KAAIonB,KAAIhpB,IAAGkmB,IAAGI,SAAQvmB,IAAGR,IAAG0pB,KAAInf,IAAGod,IAAGgC,IACnD,UC/GgBC,GACZjiB,EACA2O,EACAiR,GAEA,MAAOxmB,EAAGC,GAAK2G,EAEf,GAAI5G,EAAE3M,IAAI4M,GAAGyP,GAAGyV,IAAe,MAAM,IAAIhmB,MAAM,uBAC/C,MAAM2pB,EFkCJ,SACF9oB,EACAC,EACA8P,EACAkS,GAEA,MAAM8G,EAAO9J,GAAOgD,EAAEgE,IAAKhE,EAAEgE,KAIvBJ,EAAS3G,GACXE,GAAYA,GAAY6C,EAAEmE,EAAGrW,EAAEiW,QAAQ3yB,IAAI4uB,EAAEpf,GAAIkN,EAAEiW,QACnD+C,GAGJ,IAAInqB,EAAMohB,GACNb,GAAYnf,EAAG+P,EAAErQ,GAAGa,IAAI4e,GAAYlf,EAAG8P,EAAE6V,IACzCC,GAIAF,EAASxG,GAAYA,GAAYnf,EAAG+P,EAAEiW,QAASjW,EAAE6V,GAAGvyB,IACpD8rB,GAAYA,GAAYlf,EAAG8P,EAAEiW,QAASjW,EAAErQ,IAQ5C,OANAd,EAAMA,EAAIvL,IAAI2sB,GAAe2F,EAAQzG,GAAO+C,EAAE6D,EAAGiD,KAGjDpD,EAASxG,GAAYnf,EAAG+P,EAAE6V,GAAGvyB,IAAI8rB,GAAYlf,EAAG8P,EAAErQ,IAClDd,EAAMA,EAAIvL,IAAI2sB,GAAe2F,EAAQzG,GAAO+C,EAAE8D,EAAGgD,KAE1CnqB,CACX,CEjEmBoqB,CAAWhpB,EAAGC,EAAGsV,EAAQiR,GAElCyC,EAAkBvD,GAAkB1lB,EAAGC,EAAGsV,EAAQiR,GAClD0C,EAAcD,EAAgB,GACpC,IAAI1a,EAAM0a,EAAgB,GAGtB1a,EADA2a,EAAYxZ,GAAG,GACT4P,GAAU/Q,EAAIlb,IAAI,GAAI61B,EAAY9kB,IAAI,IAEtCmK,EAAImB,GAAG,GACPW,GAAK9B,EAAK1Q,EAAAA,UAAU+G,KAAK,IACzB/G,EAAAA,UAAU+G,KAAK,IAAIlG,IAAI,GAGjC6P,EAAM8Q,GAAU9J,EAAOyQ,OAAQhmB,EAAE3M,IAAI4M,IAChCsE,IAAIqa,IACJvrB,IAAIkb,GACJlb,IAAI,GACJ+Q,IAAI,IAET,MAAM+kB,EAAiBjK,GACnBN,GFqIQ,SACZ7O,EACAkS,GAEA,MAAMmH,EAAOnK,GAAOA,GAAOgD,EAAEgE,IAAKhE,EAAEgE,KAAMhE,EAAEgE,KAC5C,IAAIrnB,EAAMygB,GAAUtP,EAAEiW,OAAQ9G,GAAOD,GAAOgD,EAAE6D,EAAE1hB,IAAI,GAAI6d,EAAE8D,GAAIqD,IAC9DxqB,EAAMA,EAAIvL,IACNgsB,GACIA,GAAUH,GAAOD,GAAOgD,EAAE6D,EAAEzyB,IAAI,GAAI4uB,EAAE6D,EAAEzyB,IAAI,IAAK+1B,GAAOrZ,EAAEiW,QAC1DjW,EAAEiW,SAGVpnB,EAAMA,EAAIvL,IAAI6rB,GAAOD,GAAOgD,EAAE8D,EAAG9D,EAAE8D,GAAIqD,IACvC,MAAMvD,EAASvG,GAAU2C,EAAEmE,EAAGrW,EAAEiW,QAAQ3yB,IAAI4uB,EAAEpf,GAE9C,OADAjE,EAAMA,EAAIvL,IAAI6rB,GAAOD,GAAO4G,EAAQA,GAASuD,IACtCxqB,CACX,CEpJQyqB,CAAiB9T,EAAQiR,GAASjmB,IAAIqe,KAEpC9T,EAAYkV,GACd8I,EAAOz1B,IAAI61B,GAAa3oB,IAAIgO,GAC5B4a,GAiBJ,GAfA5a,EAAMgR,GAAahR,EAAK4a,GAExB5a,EAAMA,EACDlb,IACGksB,GAAazU,EAAWqe,GACnB/kB,IACGmR,EAAOyQ,OACF5hB,IAAImR,EAAOyQ,QACXzhB,IAAI1G,EAASA,UAAC+G,KAAK,IAAIlG,IAAI,MAEnC0F,IAAI,IACJG,IAAIqa,KAEZvrB,IAAI,GAELyX,EAAUzX,IAAIkb,GAAKmB,GAAG0V,IACtB,MAAM,IAAIjmB,MAAM,0BAEpB,MAAO,CAAC2L,EAAWyD,EACvB,CAEgB,SAAA+a,GACZ1iB,EACAhB,EACA6c,EACAlN,EACAiR,EACA1b,GAEA,GAAIlF,EAAS2F,GAAGsT,IAAQ,OAAOhhB,EAASA,UAAC+G,KAAK,GAE9C,MAAM2kB,EAAOlc,QAAQoV,GACf+G,EAAQnc,OAAOoV,GAEfgH,EAAYhH,EAAkB6E,GAAcK,GAE5C+B,EAAW9iB,EAAS2iB,GAAMl2B,IAAIuS,GAEpC2gB,GAAiBhR,EAAQiR,EAAS1b,EAAW4e,EAAUH,GACvD,MAAMI,EAAYF,EAAUC,EAAUnU,EAAQiR,EAAS1b,GACjDtE,EAAYI,EAAS4iB,GAAOjpB,IAAIopB,GACtC,GAAInjB,EAAU+E,GAAG,GAEb,MAAM,IAAIpM,MAAM,2BAGpB,OAAOqH,CACX,CAEgB,SAAAojB,GACZhjB,EACAJ,EACAic,EACAlN,EACAiR,EACA1b,GAEA,GAAItE,EAAU+E,GAAGsT,IAAQ,OAAOhhB,EAASA,UAAC+G,KAAK,GAE/C,MAAM2kB,EAAOlc,QAAQoV,GACf+G,EAAQnc,OAAOoV,GAEfgH,EAAYhH,EAAkBkF,GAAcL,GAElD,GAAI9gB,EAAUkJ,GAAG9I,EAAS4iB,IACtB,MAAM,IAAIrqB,MAAM,2BACpB,MAEMuqB,EAAWD,EAFC7iB,EAAS4iB,GAAOjpB,IAAIiG,GAEA+O,EAAQiR,EAAS1b,GACvDyb,GAAiBhR,EAAQiR,EAAS1b,EAAW4e,EAAUH,GACvD,MAAM3jB,EAAW8jB,EAASnpB,IAAIqG,EAAS2iB,IAEvC,GAAI3jB,EAAS2F,GAAG,GAEZ,MAAM,IAAIpM,MAAM,2BACpB,OAAOyG,CACX,CAEgB,SAAAikB,GACZjjB,EACAhB,EACA6c,EACAlN,EACAiR,EACA1b,EACAtD,GAEA,MAAM+hB,EAAOlc,QAAQoV,GACfjZ,EAAIpL,EAAAA,YAAImC,IAAIiH,GAOZsiB,GALqBrH,EACrB2F,GACAE,IAEW1hB,EAAS2iB,GAAMl2B,IAAIuS,GAGhC2P,EACAiR,EACA1b,GAEJ,OAAOjL,GAAQzB,EAAAA,YAAK4gB,GAAQ8K,EAAoBtgB,GACpD,CAEgB,SAAAugB,GACZnjB,EACAJ,EACAic,EACAlN,EACAiR,EACA1b,EACAtD,GAEA,MAAMgiB,EAAQnc,OAAOoV,GACfjZ,EAAIpL,EAAAA,YAAImC,IAAIiH,GAalB,OAAO3H,IAXoB4iB,EACrB6F,GACAF,IAEYxhB,EAAS4iB,GAAOjpB,IAAIiG,GAGlC+O,EACAiR,EACA1b,GAE+BtB,EACvC,CAEgB,SAAAwgB,GACZpjB,EACA6b,EACAlN,EACAiR,EACA1b,EACAtD,GAEA,MAEMyiB,EAFO5c,QAAQoV,GD8EnB,SACF7b,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAME,GAAEA,EAAEhpB,EAAEA,EAACkmB,EAAEA,EAACI,OAAEA,EAAM/mB,EAAEA,EAAC0pB,GAAEA,EAAEC,EAAEA,GAAML,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GA6BJ,OA1BoB3oB,GAChBmf,GACI5gB,EAAGmP,YAAChN,IAAIye,GAAQ2J,EAAI3J,GAAQtf,EAAGA,KAC/BG,GAAQzB,EAAGmP,YAAEyR,GAAQA,GAAQgH,EAAQA,GAAS4C,IAAIv1B,IAC9CwM,GACImf,GAAQ0J,EAAGnoB,IAAItB,GAAIypB,EAAGnoB,IAAItB,IAC1B+f,GACIA,GACIA,GAAQgH,EAAQA,GAChBhH,GAAQgH,EAAQA,IAEpBhH,GAAQ4J,EAAG5J,GAAQ4J,EAAGA,QAKtC5J,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GAAGa,IACvBV,GAAQ6oB,EAAGnoB,IAAItB,GAAI+f,GAAQA,GAAQgH,EAAQA,GAAS4C,KAExD5J,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GAAGa,IACvBV,GAAQ6oB,EAAGnoB,IAAItB,GAAI+f,GAAQA,GAAQgH,EAAQA,GAAS4C,MAMpE,CCtHUsB,CAAQtjB,EAAU2O,EAAQiR,EAAShf,EAASsD,GD8BhD,SACFlE,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAMlnB,GAAEA,EAAE5B,EAAEA,EAACkmB,EAAEA,EAACI,OAAEA,EAAMvmB,EAAEA,EAACkpB,GAAEA,EAAEC,EAAEA,GAAML,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GA6BJ,OA1BoB3oB,GAChBmf,GACI5gB,EAAGmP,YAAChN,IAAIye,GAAQ2J,EAAI3J,GAAQ4G,EAAGA,KAC/B/lB,GAAQzB,EAAGmP,YAAEyR,GAAQA,GAAQgH,EAAQA,GAAS4C,IAAIv1B,IAC9CwM,GACImf,GAAQ1d,EAAGf,IAAId,GAAI6B,EAAGf,IAAId,IAC1Buf,GACIA,GACIA,GAAQgH,EAAQA,GAChBhH,GAAQgH,EAAQA,IAEpBhH,GAAQ4J,EAAG5J,GAAQ4J,EAAGA,QAKtC5J,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GAAGa,IACvBV,GAAQyB,EAAGf,IAAId,GAAIuf,GAAQA,GAAQgH,EAAQA,GAAS4C,KAExD5J,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GAAGa,IACvBV,GAAQyB,EAAGf,IAAId,GAAIuf,GAAQA,GAAQgH,EAAQA,GAAS4C,MAMpE,CCxEUuB,CAAQvjB,EAAU2O,EAAQiR,EAAShf,EAASsD,GAElD,OAAOmf,CACX,CAEgB,SAAAG,GACZxjB,EACA6b,EACAlN,EACAiR,EACA1b,EACAtD,GAEA,MAEMyiB,EAFO5c,QAAQoV,GD0GnB,SACF7b,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAMlnB,GAAEA,EAAEskB,EAAEA,EAACI,OAAEA,EAAMvmB,EAAEA,EAACkpB,GAAEA,EAAEC,EAAEA,EAACpf,EAAEA,GAAM+e,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GAgBJ,OAboBxJ,GAChBnf,GAAQzB,EAAGmP,YAAEyR,GAAQxV,EAAGpL,EAAAA,YAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQ4G,EAAGA,OACvD/lB,GAAQzB,EAAGmP,YAAEyR,GAAQA,GAAQgH,EAAQA,GAAS4C,IAAIv1B,IAC9CwM,GACImf,GAAQ1d,EAAGf,IAAId,GAAI6B,EAAGf,IAAId,IAC1Buf,GACIA,GAAQA,GAAQgH,EAAQA,GAAShH,GAAQgH,EAAQA,IACjDhH,GAAQA,GAAQ4J,EAAGA,GAAIA,MAO3C,CCrIUyB,CAASzjB,EAAU2O,EAAQiR,EAAShf,EAASsD,GDuIjD,SACFlE,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAME,GAAEA,EAAEhpB,EAAEA,EAACsmB,OAAEA,EAAM/mB,EAAEA,EAAC0pB,GAAEA,EAAEC,EAAEA,EAACpf,EAAEA,GAAM+e,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GAgBJ,OAboBxJ,GAChBnf,GAAQzB,EAAGmP,YAAEyR,GAAQxV,EAAGpL,EAAAA,YAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQtf,EAAGA,OACvDG,GAAQzB,EAAGmP,YAAEyR,GAAQA,GAAQgH,EAAQA,GAAS4C,IAAIv1B,IAC9CwM,GACImf,GAAQ0J,EAAGnoB,IAAItB,GAAIypB,EAAGnoB,IAAItB,IAC1B+f,GACIA,GAAQA,GAAQgH,EAAQA,GAAShH,GAAQgH,EAAQA,IACjDhH,GAAQA,GAAQ4J,EAAGA,GAAIA,MAO3C,CCpKU0B,CAAS1jB,EAAU2O,EAAQiR,EAAShf,EAASsD,GAEnD,OAAOmf,CACX,sSArNgB,SACZrjB,EACA2O,EACAiR,EACAI,EACA/gB,EACA4c,GAEA,OAAIA,EDuKF,SACF7b,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAMlnB,GAAEA,EAAE5B,EAAEA,EAACkmB,EAAEA,EAACI,OAAEA,EAAMvmB,EAAEA,EAACkpB,GAAEA,EAAEC,EAAEA,GAAML,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GA+BJ,OA5BoB3oB,GAChBmf,GACInf,GAAQzB,cAAKA,EAAAA,YAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQ4G,EAAGA,MAC5C5G,GACI4J,EACA5J,GACIA,GACIA,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GACxBsf,GAAQgH,EAAQA,IAEpB4C,GACFroB,IAAIe,EAAGf,IAAId,IACbuf,GACIA,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GACxBsf,GAAQgH,EAAQA,IAEpB4C,GACFroB,IAAIe,EAAGf,IAAId,OAIzBuf,GAAQA,GAAQgH,EAAQA,GAAShH,GAAQ4J,EAAGA,IAAIv1B,IAC5C2rB,GAAQ1d,EAAGf,IAAId,GAAI6B,EAAGf,IAAId,KAKtC,CCnNe8qB,CAAuB3jB,EAAU2O,EAAQiR,EAAS3gB,EAAK+gB,GDuHhE,SACFhgB,EACA2O,EACAiR,EACA3gB,EACA2iB,GAEA,MAAME,GAAEA,EAAEhpB,EAAEA,EAACkmB,EAAEA,EAACI,OAAEA,EAAM/mB,EAAEA,EAAC0pB,GAAEA,EAAEC,EAAEA,GAAML,GACnC3hB,EACA2O,EACAiR,EACA3gB,EACA2iB,EACA,GA+BJ,OA5BoB3oB,GAChBmf,GACInf,GAAQzB,cAAKA,EAAAA,YAAImC,IAAIye,GAAQ2J,EAAI3J,GAAQtf,EAAGA,MAC5Csf,GACI4J,EACA5J,GACIA,GACIA,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GACxBsf,GAAQgH,EAAQA,IAEpB4C,GACFroB,IAAImoB,EAAGnoB,IAAItB,IACb+f,GACIA,GACIA,GAAQA,GAAQ2J,EAAI/C,GAAIlmB,GACxBsf,GAAQgH,EAAQA,IAEpB4C,GACFroB,IAAImoB,EAAGnoB,IAAItB,OAIzB+f,GAAQA,GAAQgH,EAAQA,GAAShH,GAAQ4J,EAAGA,IAAIv1B,IAC5C2rB,GAAQ0J,EAAGnoB,IAAItB,GAAIypB,EAAGnoB,IAAItB,KAKtC,CClKeurB,CAAuB5jB,EAAU2O,EAAQiR,EAAS3gB,EAAK+gB,EAEtE,UCiBa6D,GAWTjrB,gBAAgBkM,GACZ,MAAMuG,MACFA,EAAKC,KACLA,EAAIxS,EACJA,EAACkmB,EACDA,EAACI,OACDA,EAAM0E,UACNA,EAASC,UACTA,EAASC,SACTA,EAAQC,SACRA,EAAQ/E,EACRA,EAACC,EACDA,EAACK,EACDA,EAACvjB,EACDA,EAACojB,IACDA,GACAva,EAEEof,EAAc,CAChB7Y,QACAC,OACAxS,IACAkmB,IACAI,UAGE+E,EAAqB,CACvBL,YACAC,YACAC,WACAC,WACA/E,IACAC,IACAK,IACAvjB,IACAojB,OAGJ,IACK5zB,OAAO6J,OAAO4uB,GAAaE,OAAOC,GAAOA,MACzC54B,OAAO6J,OAAO6uB,GAAoBC,OAAOC,GAAOA,IAEjD,MAAM,IAAI9rB,MACN,yDAGR,OAAO,IAAIsrB,GACP/e,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACL4e,EACAC,EAEP,CAEDrxB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACA4e,EACAC,GA5EJrzB,KAAAyU,SAAsB/G,QAASA,UAAC8lB,MA8E5BxzB,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAU9D,EAAe8D,EAAS,IACvC9P,KAAKsU,YAActI,EAAesI,EAAa,IAC/CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAElBxU,KAAKozB,YAAc,CACf7Y,MAAOvO,EAAeonB,EAAY7Y,MAAO,IACzCC,KAAMxO,EAAeonB,EAAY5Y,KAAM,IACvCxS,EAAGgE,EAAeonB,EAAYprB,EAAG,IACjCkmB,EAAGliB,EAAeonB,EAAYlF,EAAG,IACjCI,OAAQtiB,EAAeonB,EAAY9E,OAAQ,KAG/CtuB,KAAKqzB,mBAAqB,CACtBhE,SAAU,CACN/mB,EAAG0D,EAAeqnB,EAAmBL,UAAW,IAChDzqB,EAAGyD,EAAeqnB,EAAmBJ,UAAW,KAEpD7D,QAAS,CACL9mB,EAAG0D,EAAeqnB,EAAmBH,SAAU,IAC/C3qB,EAAGyD,EAAeqnB,EAAmBF,SAAU,KAEnD/E,EAAGpiB,EAAeqnB,EAAmBjF,EAAG,IACxCC,EAAGriB,EAAeqnB,EAAmBhF,EAAG,IACxCK,EAAG1iB,EAAeqnB,EAAmB3E,EAAG,IACxCvjB,EAAGa,EAAeqnB,EAAmBloB,EAAG,IACxCojB,IAAKviB,EAAeqnB,EAAmB9E,IAAK,IAEnD,CAED1Z,kBAAkBC,EAAiBC,GAC/B,MAAM8V,EAAe7qB,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAI+V,EAAe,EAAG,KAAM,gCAC5B,MAAM1V,EAAKnV,KAAKuU,OAAOsW,GACjB/c,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhB6e,EAAgB9qB,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAI+V,EAAgB,EAAG,KAAM,iCAC7B,MAAMxV,EAAKtV,KAAKuU,OAAOuW,GACjB9c,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAEjB8e,EAAmC,IAAjBF,EAgBxB,MAdwC,CACpCzW,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAW9B,EAAe8B,EAAWyD,GACrCvD,WAAYhC,EAAegC,EAAYyD,GACvC3B,QAAS9P,KAAK8P,QACdib,kBAIP,CAEDjV,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,GAAIA,IAAavI,QAASA,UAACwI,YAAa,CACpC,MAAM+U,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAED4gB,EAAoBxiB,EAAa4Z,gBACjC+E,GACAC,GAgBA7E,EAA2B/iB,GAfFwrB,EAC3B3zB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GACFvK,IACE8qB,EACI3zB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GACA,IAGqCvK,IACzCmiB,EAAmB,IAInBtkB,EAAAA,YAAImC,IAAIsI,EAAarB,UAEzB,OAAOrJ,EACH6K,EAAAA,YACIgW,GAAQ4D,EAA0B9D,IAClC,IAGX,CACG,OAAO3gB,EACH6K,cACIgW,GAAQnW,EAAanD,WAAYoZ,IACjCjW,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,MAAMge,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAGHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAIDkX,EAAY2H,GACd6B,EAFoB9F,GADP3hB,EAAegB,EAAO5Q,WAAY,IACP+U,EAAarB,SAIrDqB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GAEJ,OAAO3M,EAAK6K,EAAWA,YAAC2Y,EAAW,IACtC,CAEDnT,yBACI3F,EACAnE,GAEA,MAAMge,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAYDiX,EAAWhb,GAROkjB,GACpBuB,EAHcznB,EAAegB,EAAO5Q,WAAY,IAKhD+U,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GAEqCjC,EAAarB,SACtD,OAAOrJ,EAAK6K,EAAWA,YAAC0Y,EAAU,IACrC,CAGD/Z,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDlG,2CACIC,EACAnE,GAEA,MAAMge,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAIDqY,EAAe+G,GACjBsB,EAFoB9F,GADP3hB,EAAegB,EAAO5Q,WAAY,IACP+U,EAAarB,SAIrDqB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAEDrZ,2CACIZ,EACAnE,GAEA,MAAMge,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAGDqY,EAAeiH,GACjBoB,EAFcznB,EAAegB,EAAO5Q,WAAY,IAIhD+U,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAED7Y,qDACIpB,EACAnE,GAEA,MAAMgd,EAAWhe,EAAegB,EAAO5Q,WAAY,IAC7C4uB,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAGDsY,EAAaiH,GACf,CACImB,EAA0B,GAAG93B,IACzBgyB,GAAU3D,EAAU7Y,EAAarB,UAErC2jB,EAA0B,IAE9BtiB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAED7Y,qDACIrB,EACAnE,GAEA,MAAMge,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,cAErCgiB,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAEDkX,EAAYje,EAAegB,EAAO5Q,WAAY,IAC9CivB,EAAaqH,GACf,CACIe,EAA0B,GAC1BA,EAA0B,GAAG5qB,IAAIohB,IAErC9Y,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEjB,OAAOrJ,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,WC9gBWuC,GACZ1e,EACAjD,EACA2nB,GAEA,MAAMtJ,EAAiBre,EAAS1Q,KAAKgvB,GAAMle,aAAW,IAAKke,KAE3D,OAAOrb,EAAS3T,KAAI,CAACivB,EAAKvuB,IACtBqrB,GAAQkD,EAAI9d,IAAIhG,EAAGmP,aAAEhJ,IAAIyd,EAAeruB,IAAS23B,EAAW33B,KAEpE,CC0BA,MAAM43B,GAAoBhG,SA8BbiG,GAYThsB,gBAAgBkM,GACZ,MAAMuG,MACFA,EAAKC,KACLA,EAAIxS,EACJA,EAACkmB,EACDA,EAACI,OACDA,EAAM0E,UACNA,EAASC,UACTA,EAASC,SACTA,EAAQC,SACRA,EAAQ/E,EACRA,EAACC,EACDA,EAACK,EACDA,EAACvjB,EACDA,EAACojB,IACDA,EAAGqF,WACHA,GACA5f,EAEEof,EAAc,CAChB7Y,QACAC,OACAxS,IACAkmB,IACAI,UAGE+E,EAAqB,CACvBL,YACAC,YACAC,WACAC,WACA/E,IACAC,IACAK,IACAvjB,IACAojB,OAGJ,IACK5zB,OAAO6J,OAAO4uB,GAAaE,OAAOC,GAAOA,MACzC54B,OAAO6J,OAAO6uB,GAAoBC,OAAOC,GAAOA,IAEjD,MAAM,IAAI9rB,MACN,yDAGR,IAAKmsB,EAAY,MAAM,IAAInsB,MAAM,mCAEjC,OAAO,IAAIqsB,GACP9f,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACL4e,EACAC,EACAO,EAEP,CAED5xB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACA4e,EACAC,EACAO,GAlFJ5zB,KAAAyU,SAAsB/G,QAASA,UAAC8lB,MAoF5BxzB,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAU9D,EAAe8D,EAAS,IACvC9P,KAAKsU,YAActI,EAAesI,EAAa,IAC/CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAK4zB,WAAa,CACd5nB,EAAe4nB,EAAW,GAAI,IAC9B5nB,EAAe4nB,EAAW,GAAI,KAGlC5zB,KAAKozB,YAAc,CACf7Y,MAAOvO,EAAeonB,EAAY7Y,MAAO,IACzCC,KAAMxO,EAAeonB,EAAY5Y,KAAM,IACvCxS,EAAGgE,EAAeonB,EAAYprB,EAAG,IACjCkmB,EAAGliB,EAAeonB,EAAYlF,EAAG,IACjCI,OAAQtiB,EAAeonB,EAAY9E,OAAQ,KAG/CtuB,KAAKqzB,mBAAqB,CACtBhE,SAAU,CACN/mB,EAAG0D,EAAeqnB,EAAmBL,UAAW,IAChDzqB,EAAGyD,EAAeqnB,EAAmBJ,UAAW,KAEpD7D,QAAS,CACL9mB,EAAG0D,EAAeqnB,EAAmBH,SAAU,IAC/C3qB,EAAGyD,EAAeqnB,EAAmBF,SAAU,KAEnD/E,EAAGpiB,EAAeqnB,EAAmBjF,EAAG,IACxCC,EAAGriB,EAAeqnB,EAAmBhF,EAAG,IACxCK,EAAG1iB,EAAeqnB,EAAmB3E,EAAG,IACxCvjB,EAAGa,EAAeqnB,EAAmBloB,EAAG,IACxCojB,IAAKviB,EAAeqnB,EAAmB9E,IAAK,IAEnD,CAED1Z,kBAAkBC,EAAiBC,GAC/B,MAAM8V,EAAe7qB,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAI+V,EAAe,EAAG,KAAM,gCAC5B,MAAM1V,EAAKnV,KAAKuU,OAAOsW,GACjB/c,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhB6e,EAAgB9qB,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAEhD,GAAI+V,EAAgB,EAAG,KAAM,iCAC7B,MAAMxV,EAAKtV,KAAKuU,OAAOuW,GACjB9c,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAEjB8e,EAAmC,IAAjBF,EAgBxB,MAdwC,CACpCzW,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAW9B,EAAe8B,EAAWyD,GACrCvD,WAAYhC,EAAegC,EAAYyD,GACvC3B,QAAS9P,KAAK8P,QACdib,kBAIP,CAEDjV,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAEDuP,mBACI5E,EACA6E,GAEA,GAAIA,IAAavI,QAASA,UAACwI,YAAa,CACpC,MAAM8d,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAED4gB,EAAoBxiB,EAAa4Z,gBACjC+E,GACAC,GAaAiE,EAAgB7rB,GAZSwrB,EAC3B3zB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GACFvK,IACE8qB,EACI3zB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GACA,IAImBvK,IAAImiB,EAAmB,IAC9C+I,EAAe,IAEb7I,EAA2B/iB,GAC7B6rB,EACAttB,EAAAA,YAAImC,IAAIsI,EAAarB,UAEzB,OAAOrJ,EACH6K,EAAAA,YACIgW,GAAQ4D,EAA0B9D,IAClC,IAGX,CACG,OAAO3gB,EACH6K,cACIgW,GAAQnW,EAAanD,WAAYoZ,IACjCjW,EAAaM,aAI5B,CAGDyE,0BAA0B1J,EAAe2J,GAErC,GAAIvK,EAAc5L,KAAKqU,QAAS7H,GAC5BxM,KAAKoW,kBAAkBD,OACpB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDmK,kBAAkBG,GACdvW,KAAKsU,YAAciC,CACtB,CAEDC,yBACIrF,EACAnE,GAEA,IACI,MAAM+mB,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAGHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAEDiX,EAAWhe,EAAegB,EAAO5Q,WAAY,IAE7C63B,EAAwB3M,GADNqG,GAAU3D,EAAU7Y,EAAarB,SAGrDikB,EAAe,IAUb9J,EAAY9hB,GARMypB,GACpB6B,EACAQ,EACA9iB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GAEuC2gB,EAAe,IAC1D,OAAOttB,EAAK6K,EAAWA,YAAC2Y,EAAW,IACtC,CAAC,MAAOpT,GACL,OAAOrQ,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IACI,MAAM+mB,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAEDkX,EAAYje,EAAegB,EAAO5Q,WAAY,IAG9C83B,EAAwBhC,GAC1BuB,EAHoBnM,GAAQ2C,EAAW8J,EAAe,IAKtD5iB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,GAME4W,EAAWhb,GAJO7G,GACpB+rB,EACAH,EAAe,IAEsB5iB,EAAarB,SACtD,OAAOrJ,EAAK6K,EAAWA,YAAC0Y,EAAU,IACrC,CAAC,MAAOnT,GACL,OAAOrQ,CACV,CACJ,CAGDyJ,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDlG,2CACIC,EACAnE,GAEA,IACI,MAAM+mB,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAEDiX,EAAWhe,EAAegB,EAAO5Q,WAAY,IAE7C63B,EAAwB3M,GADNqG,GAAU3D,EAAU7Y,EAAarB,SAGrDikB,EAAe,IAWb3I,EAAejjB,GACjBmf,GAVuB6K,GACvBsB,EACAQ,EACA9iB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAGeikB,EAAe,IAC3CA,EAAe,IAEnB,OAAOttB,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvU,GACL,OAAOrQ,CACV,CACJ,CAEDuL,2CACIZ,EACAnE,GAEA,IACI,MAAM+mB,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAGDohB,EAAkB7M,GADNtb,EAAegB,EAAO5Q,WAAY,IACT23B,EAAe,IAUpD3I,EAAejjB,GACjBmf,GAVuB+K,GACvBoB,EACAU,EACAhjB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAGeikB,EAAe,IAC3CA,EAAe,IAEnB,OAAOttB,EAAK6K,EAAWA,YAAC8Z,EAAc,IACzC,CAAC,MAAOvU,GACL,OAAOrQ,CACV,CACJ,CAED+L,qDACIpB,EACAnE,GAEA,IACI,MAAMgd,EAAWhe,EAAegB,EAAO5Q,WAAY,IAC7C23B,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAGDqhB,EAAmB9B,GACrB,CACImB,EAA0B,GAAG93B,IACzBgyB,GACIrG,GAAQ0C,EAAU+J,EAAe,IACjC5iB,EAAarB,UAGrB2jB,EAA0B,IAE9BtiB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEXub,EAAa/D,GAAQ8M,EAAkBL,EAAe,IAC5D,OAAOttB,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxU,GACL,OAAOrQ,CACV,CACJ,CAEDgM,qDACIrB,EACAnE,GAEA,IACI,MAAM+mB,EAAiBF,GACnB7zB,KAAK4zB,WAAW,GAChB5zB,KAAK4zB,WAAW,GAChBziB,EAAa4Z,iBAEXC,EAAqB4C,GACvB,CAACzc,EAAarD,UAAWqD,EAAanD,YACtC,CAACmD,EAAaI,WAAYJ,EAAaM,aACvCsiB,GAEEN,EAA4B5F,GAC9B7C,EAAmB,GACnBA,EAAmB,GACnB7Z,EAAa4Z,kBAEVhY,EAAkB2gB,GAAUvC,GAC/BsC,EACAzzB,KAAKozB,YACLpzB,KAAKqzB,oBAEHjgB,EAAqB,CACvB9K,EAAGyK,EAAiBpX,IAAI+3B,EAAOhnB,IAAI,IACnCnE,EAAGwK,GAEDkX,EAAYje,EAAegB,EAAO5Q,WAAY,IAC9Cg4B,EAAmB1B,GACrB,CACIe,EAA0B,GAC1BA,EAA0B,GAAG5qB,IACzBye,GAAQ2C,EAAW8J,EAAe,MAG1C5iB,EAAa4Z,gBACb/qB,KAAKozB,YACLpzB,KAAKqzB,mBACLjgB,EACAjC,EAAarB,SAEXukB,EAAgBlsB,GAClBmf,GAAQyM,EAAe,GAAIA,EAAe,IAC1CA,EAAe,IAEb1I,EAAa/D,GAAQ8M,EAAkBC,GAC7C,OAAO5tB,EAAK6K,EAAWA,YAAC+Z,EAAY,IACvC,CAAC,MAAOxU,GACL,OAAOrQ,CACV,CACJ,EC/nBuBC,EAAK,MACdA,EAAK,KAESW,OAAO,OAERA,OAAO,aAChC,MAAMktB,GAAqB,IACJltB,OAAO,WAC9B,MAAMmtB,GAA0B,KACJntB,OAAO,kBACnC,MAAMotB,GAAY5tB,EAAMH,EAAK,KAAM,IAEpCguB,GAAgB,IAEtB,IAAYC,IAAZ,SAAYA,GACRA,EAAA,UAAA,uBACAA,EAAA,UAAA,uBACAA,EAAA,uBAAA,qCACAA,EAAA,sBAAA,oCACAA,EAAA,WAAA,YACH,CAND,CAAYA,KAAAA,GAMX,CAAA,IAsBD,MAAMC,GAAUtgB,GAEG,8CAAXA,GACW,8CAAXA,EAiCKugB,GAAkB,CAC3B5nB,EACA6nB,IAE2B,iBAAhBA,EACAlf,OAAOlP,EAAKuG,GAAQH,IAAIpG,EAAK+tB,MAE7BxnB,EAAS6nB,EAiDlBC,GAAsB,CACxB9nB,EACAmE,EACA4jB,KAGA,MAAMC,EAAeL,GAAOxjB,EAAa2D,SACnC8f,GACIK,GACItf,OAAOxE,EAAanD,YACpBmD,EAAa+jB,sBAAsBrjB,YAEvCsjB,GAAgBhkB,EAAaM,cAEjCmjB,GACIK,GACItf,OAAOxE,EAAarD,WACpBqD,EAAaikB,qBAAqBvjB,YAEtCsjB,GAAgBhkB,EAAaI,aAIjC8jB,EAAeV,GAAOxjB,EAAa2D,SACnC8f,GACIK,GACItf,OAAOxE,EAAarD,WACpBqD,EAAaikB,qBAAqBvjB,YAEtCsjB,GAAgBhkB,EAAaI,aAEjCqjB,GACIK,GACItf,OAAOxE,EAAanD,YACpBmD,EAAa+jB,sBAAsBrjB,YAEvCsjB,GAAgBhkB,EAAaM,cAIjC6jB,EAAgBX,GAAOxjB,EAAa2D,SACpC3D,EAAa+jB,sBAAsBrjB,WACnCV,EAAaikB,qBAAqBvjB,WAGlC0jB,EA9H8B,EACpCR,EACA5jB,EACAnE,KAEA,IAAIwoB,EAgBJ,OAZIA,EAA4BP,GACxBjoB,EAHJ+nB,EAII5jB,EAAaikB,qBAAqBvjB,WAMlCV,EAAa+jB,sBAAsBrjB,YAIpC2jB,CAAyB,EAyGDC,CAC3BV,EACA5jB,EACAwE,OAAO3I,EAAO5Q,aAGlB,MAAO,CACHme,MAAO5E,OAAOrE,EAAWA,YAACH,EAAaoJ,MAAO,KAC9CC,KAAM7E,OAAOrE,EAAWA,YAACH,EAAaqJ,KAAM,KAC5Ckb,MAAO/f,OAAOrE,EAAWA,YAACH,EAAaukB,MAAO,KAC9CC,QAAShgB,OAAOrE,EAAWA,YAACH,EAAawkB,QAAS,KAClDrH,OAAQ3Y,OAAOrE,EAAWA,YAACH,EAAamd,OAAQ,KAChDgH,cAAeA,EACfM,OAAQZ,EAAeK,EACvBQ,OAAQb,EAAeK,EACvBS,OAAQ,CAACT,EAAcL,GACvBe,OAAQpB,GAAOxjB,EAAa2D,SACtB,CACIugB,EAAeE,EACfP,EAAeO,GAEnB,CACIF,EAAeE,EACfP,EAAeO,GAGzBA,uBAAwBA,EAC3B,EAKQJ,GAAmBlpB,IAC5B,OAAQA,GACJ,KAAK,EACD,OAAOqoB,GAGX,KAAK,EACD,OAxNyB,IA+N7B,QACI,OAAOE,GAAUp4B,WAExB,EAKQ45B,GAAgB,CAACC,EAAiBxX,IACpChY,EAAKwvB,EAAUxX,GAGpBwW,GAAsB,CAACgB,EAAiBxX,IACnCwX,EAAUxX,EAKfyX,GAAoB,CACtBC,EACAC,EACAC,EACAC,KAEA,IAAIC,EAAYC,EACZC,EAAO,EAmCX,OAjCIN,EAAOC,GACPG,EAAaH,GAAU,EAAIC,GAEvBF,EAAOI,GACPC,EAAaD,EAAaJ,EAC1BM,EAAOD,EAAaJ,EACpBK,GAAcH,EAEVG,EAAOhC,KACPgC,EAAOhC,IAGXgC,GAAcD,GAEdC,EAAO,IAGXF,EAAaH,GAAU,EAAIC,GAEvBF,EAAOI,GACPC,EAAaL,EAAOI,EAEpBE,EAAOD,EAAaJ,EACpBK,GAAcH,EAEVG,EAAOhC,KAAegC,EAAOhC,IAEjCgC,GAAcD,GAEdC,EAAO,GAIRA,CAAI,EAGTC,GAAe,CACjBC,EACAC,EACAP,EACAC,EACAO,KAEA,MAAMC,EAAUF,EAAM16B,OACtB,IAAI66B,EAAO,EAEX,IAAK,IAAItnB,EAAI,EAAGA,EAAIqnB,EAASrnB,IAAK,CAC9B,MAAM2mB,EAASO,EAAQE,EAASpnB,GAGhCsnB,GAAcb,GAAkBU,EAAMnnB,GAAI2mB,EAAQC,EAAOC,EAC5D,CAED,OAAOS,CAAI,EAITC,GAAiB,CACnBpB,EACAC,EACAC,EACAC,EACAkB,EACAC,EACA/lB,KAEA,IAAIgmB,EACJ,MAAMN,EAAqB,CAAC,GAAK,IAE3Btc,EAAQpJ,EAAaoJ,MACrBC,EAAOrJ,EAAaqJ,KACpBkb,EAAQvkB,EAAaukB,MACrBpH,EAASnd,EAAamd,OAE5B6I,GAAcF,EAEd,MAAMG,EAASV,GAAad,EAAQE,EAAQtb,EAAMkb,EAAOmB,GAEzD,IAAIQ,EAEJ,IAAK,IAAI5nB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB4nB,EAAOX,GAAab,EAAQE,EAAQvb,EAAMkb,EAAOmB,GAEjD,MAAMS,EAAaH,EAOnB,GALAA,EACIC,EAASC,IACDJ,GAAaG,EAASC,MACtBJ,EAAY3I,GAAU8I,EAASC,IAGvCF,EAAa5C,IACb+C,EAAa/C,GAUb,OARAsB,EAASD,EAASqB,EAAYE,EAE9BpB,EAAOmB,GAAgBpB,EAAOoB,GAAgBC,EAG9CI,GAAqB3B,EAAQwB,EAAQvB,EAAQwB,GAC7CG,GAAa5B,EAAQC,EAAQC,EAAQC,EAAQc,EAAUtc,GAEhD,CAAC4c,EAAYtB,GAEpBA,EAASD,EAASqB,EAAYE,EAE9BpB,EAAOmB,GAAgBpB,EAAOoB,GAAgBC,CAErD,CAED,MAAM,IAAI1vB,MAAMitB,GAAgB+C,sBAAsB,EAIpDD,GAAe,CACjB5B,EACAC,EACAC,EACAC,EACAc,EACAtc,KAEA,MAAMuc,EAAUf,EAAO75B,OACjBw7B,EAASnd,EAEf,IAAK,IAAI9K,EAAI,EAAGA,EAAIqnB,EAASrnB,IAAK,CAC9B,MAAMkoB,EAAU9B,EAASgB,EAASpnB,GAElC,GAAIsmB,EAAOtmB,GAAKkoB,EAAS,CACrB,MAAMC,EAAc,EAAIF,EAElBG,EAASF,EAAUC,EAEzB,GAAI7B,EAAOtmB,GAAKooB,EAAQ,CACpB,MAAMC,EAASlC,EAASiB,EAASpnB,GAAKmoB,EAEtC,GAAI9B,EAAOrmB,GAAKqoB,EACZ,MAAM,IAAIrwB,MAAMitB,GAAgBqD,WAEpC,GAAIhC,EAAOtmB,GAAKooB,EAAS/B,EAAOrmB,GAAKqoB,EACjC,MAAM,IAAIrwB,MAAMitB,GAAgBqD,UAEvC,CACJ,KAAM,CACH,MAAMC,EAAc,EAAIN,EAElBG,EAASF,EAAUK,EAEzB,GAAIjC,EAAOtmB,GAAKooB,EAAQ,CACpB,IAAIC,EAASlC,EAASiB,EAASpnB,GAG/B,GAFAqoB,GAAkBE,EAEdlC,EAAOrmB,GAAKqoB,EACZ,MAAM,IAAIrwB,MAAMitB,GAAgBuD,WAEpC,GAAIJ,EAAS9B,EAAOtmB,GAAKqoB,EAAShC,EAAOrmB,GACrC,MAAM,IAAIhI,MAAMitB,GAAgBuD,UAEvC,CACJ,CACJ,CACD,OAAO,CAAI,EAGTV,GAAuB,CACzB3B,EACAwB,EACAvB,EACAwB,KAEA,MAIMa,EAJYrC,EAASwB,GAETzB,EAASwB,GAK3B,GAAI,EAAIc,GAASA,IA9aa,qBA+a1B,OAAO,EAEP,MAAM,IAAIzwB,MAAMitB,GAAgByD,uBACnC,EA+FE,MAAMC,GAAsB,CAC/BprB,EACAmE,KAGA,MACMknB,EAAmBvD,GAAoB9nB,EAAQmE,GAAc,GAE7DykB,EAASyC,EAAiBzC,OAC1BC,EAASwC,EAAiBxC,OAC1BC,EAASuC,EAAiBvC,OAC1BC,EAASsC,EAAiBtC,OAE1BuC,EAA0BtB,GAC5BpB,EACAC,EACAC,EACAC,EACA,EACA,EACAsC,GAGJ,OAAO5xB,EACD2d,KAAKC,IAAIiU,EAAwB,KAC9B,EAAID,EAAiB1C,SACtBvR,KAAKC,IArBkB,GAsBvBgU,EAAiB/C,cACxB,EAIQpkB,GAA6C,CACtDC,EACAnE,KAEA,MAAMqrB,EAAmBvD,GAAoB9nB,EAAQmE,GAAc,GAE7DonB,EAA0BF,EAAiB9C,uBAE3CK,EAASyC,EAAiBzC,OAC1BG,EAASsC,EAAiBtC,OAC1ByC,EAAcH,EAAiB/C,cAC/B9a,EAAO6d,EAAiB7d,KACxBmb,EAAU0C,EAAiB1C,QAC3BE,EAASwC,EAAiBxC,OAC1BC,EAASuC,EAAiBvC,OAY1B2C,EAVmBzB,GACrBpB,EACAC,EACAC,EACAC,EACAwC,EACA5D,GAAOxjB,EAAa2D,SAAW,EAAI,EACnCujB,GAGkC,GAEhCK,EAAoC,IAAZ,EAAIle,GAAcob,EAE1C+C,EAAoC,IAAZ,EAAIne,GAAcob,EAEhD,GAAIjB,GAAOxjB,EAAa2D,SAAU,CAE9B,MAAM8jB,EAAc7C,EAAO,GAI3B,OAFoBA,EAAO,GAET4C,GAAgBC,EAAcF,EAKrC1rB,EAAOyK,SACR2gB,GAAoBprB,EAAQmE,GAC5B1K,EACK2d,KAAKC,IAAIoU,GAAgB,EAAI9C,IAC1BvR,KAAKC,IAAIkU,GACTC,GAGP/xB,EAAK+xB,GAAe,EAAI7C,GAEtC,CAAM,CAGH,MAAMiD,EAAc7C,EAAO,GAI3B,GAFoBA,EAAO,GAET4C,GAAgBC,EAAcF,EAAc,CAC1D,GAAI1rB,EAAOyK,SACP,OAAO2gB,GAAoBprB,EAAQmE,GAMvC,OAAO1K,EAHH2d,KAAKC,IAAIoU,GAAgB,EAAI9C,IAC7BvR,KAAKC,IAAIkU,GAEuBC,EACvC,CACG,OAAO/xB,EAAK+xB,GAAe,EAAI7C,GAEtC,GAMQ5jB,GAA6C,CACtDZ,EACAnE,KAEA,MAAMqrB,EAAmBvD,GAAoB9nB,EAAQmE,GAAc,GAE7DonB,GAA2BF,EAAiB9C,uBAE5CK,EAASyC,EAAiBzC,OAC1BG,EAASsC,EAAiBtC,OAC1ByC,EAAcH,EAAiB/C,cAE/B9a,EAAO6d,EAAiB7d,KACxBmb,EAAU0C,EAAiB1C,QAE3BE,EAASwC,EAAiBxC,OAC1BC,EAASuC,EAAiBvC,OAY1B2C,EAVmBzB,GACrBpB,EACAC,EACAC,EACAC,EACAwC,EACA5D,GAAOxjB,EAAa2D,SAAW,EAAI,EACnCujB,GAGkC,GAEhCK,EAAoC,IAAZ,EAAIle,GAAcob,EAE1C+C,EAAoC,IAAZ,EAAIne,GAAcob,EAEhD,GAAIjB,GAAOxjB,EAAa2D,SAAU,CAE9B,MAAM8jB,EAAc7C,EAAO,GAG3B,OACWtvB,EAHSsvB,EAAO,GAET4C,GAAgBC,EAAcF,EAEvCtU,KAAKC,IAAIkU,GACNnU,KAAKC,IAAIoU,GAAgB,EAAI9C,IAC7B6C,EAGIA,GAAe,EAAI7C,GAEtC,CAAM,CAEH,MAAMiD,EAAc7C,EAAO,GACrB8C,EAAc9C,EAAO,GAK3B,OACWtvB,EAJamyB,EAAcD,GACdE,EAAcH,EAI7BtU,KAAKC,IAAIkU,GACNnU,KAAKC,IAAIoU,GAAgB,EAAI9C,IAC7B6C,EAGIA,GAAe,EAAI7C,GAEtC,SC7pBQmD,GAcThxB,gBAAgBkM,GACZ,KACKA,EAAKuG,OACLvG,EAAKwG,MACLxG,EAAKsa,QACLta,EAAK0hB,OACL1hB,EAAK2hB,SAEN,MAAM,IAAIluB,MAAM,kCACpB,OAAO,IAAIqxB,GACP9kB,EAAKI,GACLJ,EAAKK,QACLL,EAAKlE,QACLkE,EAAKM,YACLN,EAAKO,OACLP,EAAKQ,WACLR,EAAKuG,MACLvG,EAAKwG,KACLxG,EAAKsa,OACLta,EAAK0hB,MACL1hB,EAAK2hB,QAEZ,CAED3zB,YACIoS,EACAC,EACAvE,EACAwE,EACAC,EACAC,EACA+F,EACAC,EACA8T,EACAoH,EACAC,GAhDJ31B,KAAAyU,SAAsB/G,QAASA,UAACqrB,GAkD5B/4B,KAAKoU,GAAKA,EACVpU,KAAKqU,QAAUA,EACfrU,KAAK8P,QAAUzD,EAAAA,WAAWyD,EAAS,IACnC9P,KAAKsU,YAAcjI,EAAAA,WAAWiI,EAAa,IAC3CtU,KAAKuU,OAASA,EACdvU,KAAKwU,WAAaA,EAClBxU,KAAKua,MAAQlO,EAAAA,WAAWkO,EAAO,IAC/Bva,KAAKwa,KAAOnO,EAAAA,WAAWmO,EAAM,IAC7Bxa,KAAKsuB,OAASjiB,EAAAA,WAAWiiB,EAAQ,IACjCtuB,KAAK01B,MAAQrpB,EAAAA,WAAWqpB,EAAO,IAC/B11B,KAAK21B,QAAUtpB,EAAAA,WAAWspB,EAAS,GACtC,CAMD1lB,8BAA8BC,GAE1B,OAAO,IAAI5T,MAAM0D,KAAKuU,OAAOrY,QAAQgb,KAAKE,EAAAA,KAC7C,CAGDnI,8BAA8BG,GAE1B,OAAOgI,MACV,CAEDvC,kBAAkBC,EAAiBC,WAC/B,MAAMC,EAAehV,KAAKuU,OAAOU,WAC5BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAW+I,KAEhD,GAAIE,EAAe,EAAG,KAAM,gCAC5B,MAAMG,EAAKnV,KAAKuU,OAAOS,GACjBlH,EAAYqH,EAAG1I,QACf8E,EAAa4D,EAAGlJ,SAEhBoJ,EAAgBrV,KAAKuU,OAAOU,WAC7BC,GAAMnJ,aAAWmJ,EAAEb,WAAatI,aAAWgJ,KAGhD,GAAIM,EAAgB,EAAG,KAAM,iCAC7B,MAAMC,EAAKtV,KAAKuU,OAAOc,GACjBrH,EAAasH,EAAG7I,QAChBgF,EAAc6D,EAAGrJ,SAEvB,aAAKU,EAAA2I,EAAG9I,4BAAOwsB,kBAA0B,QAARC,EAAA9jB,EAAG3I,aAAK,IAAAysB,OAAA,EAAAA,EAAED,eACvC,KAAM,gCAsBV,MApBqC,CACjC5kB,GAAIpU,KAAKoU,GACTC,QAASrU,KAAKqU,QACdI,SAAUzU,KAAKyU,SACfK,QAASA,EACTC,SAAUA,EACVxD,WAAYoE,OAAOpE,GACnBE,YAAakE,OAAOlE,GACpB3D,UAAWzB,EAAAA,WAAWyB,EAAWyD,GACjCvD,WAAY3B,EAAAA,WAAW2B,EAAYyD,GACnC3B,QAAS9P,KAAK8P,QACdyK,MAAOva,KAAKua,MACZC,KAAMxa,KAAKwa,KACX8T,OAAQtuB,KAAKsuB,OACboH,MAAO11B,KAAK01B,MACZC,QAAS31B,KAAK21B,QACdP,qBAAsB3uB,EAAK0O,EAAG3I,MAAMwsB,eACpC9D,sBAAuBzuB,EAAK6O,EAAG9I,MAAMwsB,eAI5C,CAMDljB,uBAAuB3E,GACnB,OAAOsC,EACHzT,KAAKuS,qDACDpB,EACA3K,GAGX,CAMDuP,mBACI5E,EACA6E,GAEA,IACI,MAAMkjB,ED1FqB,CACnC/nB,IAEA,IAAIgoB,EAAkBC,EAmCtB,OAjCIzE,GAAOxjB,EAAa2D,UACpBqkB,EAAmBvE,GACfK,GACItf,OAAOxE,EAAarD,WACpBqD,EAAaikB,qBAAqBvjB,YAEtCsjB,GAAgBhkB,EAAaI,aAEjC6nB,EAAoBxE,GAChBK,GACItf,OAAOxE,EAAanD,YACpBmD,EAAa+jB,sBAAsBrjB,YAEvCsjB,GAAgBhkB,EAAaM,gBAGjC0nB,EAAmBvE,GACfK,GACItf,OAAOxE,EAAanD,YACpBmD,EAAa+jB,sBAAsBrjB,YAEvCsjB,GAAgBhkB,EAAaM,cAGjC2nB,EAAoBxE,GAChBK,GACItf,OAAOxE,EAAarD,WACpBqD,EAAaikB,qBAAqBvjB,YAEtCsjB,GAAgBhkB,EAAaI,cAI9B,CACH8nB,2BAA4BF,EAC5BG,4BAA6BF,EAC7BxD,OAAQuD,EAAmBC,EAC9B,ECgD8BG,CAAwBpoB,GAIzCqoB,GAAY,EAFC7jB,OAAOrE,EAAWA,YAACH,EAAaoJ,MAAO,MAEtB2e,EAAetD,OAAS,GAE5D,GAAI5f,IAAavI,QAASA,UAACwI,YAAa,CACpC,MAAMwjB,EACFD,EAAWN,EAAeG,2BAE9B,OAAO5yB,EACHuvB,GACIyD,EACAtoB,EAAaikB,qBAAqBvjB,YACpCzV,WAET,CAAM,CACH,MAAMq9B,EACFD,EAAWN,EAAeI,4BAE9B,OAAO7yB,EACHuvB,GACIyD,EACAtoB,EAAa+jB,sBAAsBrjB,YACrCzV,WAET,CACJ,CAAC,MAAMuQ,GACJ,OAAOnG,CACV,CACJ,CAGD0P,0BAA0B1J,EAAe2J,GAErC,GAAInW,KAAKqU,SAAW7H,EAChBxM,KAAKsU,YAAc6B,MAChB,CAEH,MAAME,EAAIrW,KAAKuU,OAAO+B,MAAMpB,GAAMtJ,EAAcsJ,EAAEb,QAAS7H,KAC3D,IAAK6J,EAAG,MAAM5O,MAAM,oCACpB4O,EAAE5J,QAAU6E,EAAWA,YAAC6E,EAAYE,EAAEpK,SACzC,CACJ,CAEDuK,yBACIrF,EACAnE,GAEA,IACI,ODkNI,SACZA,EACAmE,GAEA,MAAMknB,EAAmBvD,GAAoB9nB,EAAQmE,GAAc,GAE7DonB,EAA0BF,EAAiB9C,uBAEjD,GAAIpkB,EAAa2D,UAAY3D,EAAa4D,SACtC,OAAOihB,GACHuC,EACApnB,EAAaikB,qBAAqBvjB,YAI1C,MAAM+jB,EAASyC,EAAiBzC,OAC1BC,EAASwC,EAAiBxC,OAC1BC,EAASuC,EAAiBvC,OAC1BC,EAASsC,EAAiBtC,OAE1B2D,EAAO1C,GACTpB,EACAC,EACAC,EACAC,EACAwC,EACA5D,GAAOxjB,EAAa2D,SAAW,EAAI,EACnCujB,GAGJ,QAAap6B,IAATy7B,EACA,MAAM,IAAIjyB,MAAMitB,GAAgBiF,YAC7B,CACH,MAAMhE,EAAU0C,EAAiB1C,QAC3BiE,EAAcF,EAAK,IAAM,EAAI/D,GAEnC,OAAOK,GACH5R,KAAKC,IAAIuV,GACTzoB,EAAa+jB,sBAAsBrjB,WAE1C,CACL,CC3PmB2E,CAAyBxJ,EAAQmE,EAC3C,CAAC,MAAMxE,GACJ,OAAOnG,CACV,CACJ,CAEDsQ,yBACI3F,EACAnE,GAEA,IACI,ODmPI,SACZA,EACAmE,GAGA,MAAMknB,EAAmBvD,GAAoB9nB,EAAQmE,GAAc,GAC7DonB,GAA2BF,EAAiB9C,uBAE9CpkB,EAAa2D,UAAY3D,EAAa4D,UACtCihB,GAEIuC,EACApnB,EAAa+jB,sBAAsBrjB,YAI3C,MAAM+jB,EAASyC,EAAiBzC,OAC1BC,EAASwC,EAAiBxC,OAC1BC,EAASuC,EAAiBvC,OAC1BC,EAASsC,EAAiBtC,OAE1B2D,EAAO1C,GACTpB,EACAC,EACAC,EACAC,EACAwC,EACA5D,GAAOxjB,EAAa2D,SAAW,EAAI,EACnCujB,GAGJ,QAAap6B,IAATy7B,EACA,MAAM,IAAIjyB,MAAMitB,GAAgBiF,YAC7B,CACH,MAAMhE,EAAUhgB,OAAOrE,EAAWA,YAACH,EAAawkB,QAAS,KAEnDiE,EAAcF,EAAK,IAAM,EAAI/D,GAEnC,OAAOK,GACH5R,KAAKC,IAAIuV,GACTzoB,EAAaikB,qBAAqBvjB,WAEzC,CACL,CC9RmBiF,CAAyB9J,EAAQmE,EAC3C,CAAC,MAAMxE,GACJ,OAAOnG,CACV,CACJ,CAED0K,2CACIC,EACAnE,GAEA,IACI,OAAOkE,GACHC,EACAnE,EAEP,CAAC,MAAML,GACJ,OAAOnG,CACV,CACJ,CAEDuL,2CACIZ,EACAnE,GAEA,IACI,OAAO+E,GACHZ,EACAnE,EAEP,CAAC,MAAML,GACJ,OAAOnG,CACV,CACJ,CAED+L,qDACIpB,EACAnE,GAEA,IACI,MD4awD,EAChEA,EACAmE,KAEA,MAAM7I,EAAI8vB,GAAoB3xB,EAAK,KAAM0K,GAGnCwC,EAFIzC,GAA2CC,EAAcnE,GACjD+K,MAAMzP,GACJuE,IAAIvE,GACxB,OAAOqL,EAAI8D,SAAWhR,EAhsBC,OAgsBmBkN,EAAI0Q,KAAK,ECpbpC9R,CACHvF,EACAmE,EAEP,CAAC,MAAMxE,GACJ,OAAOnG,CACV,CACJ,CAEDgM,qDACIrB,EACAnE,GAEA,IACI,MD0awD,EAChEA,EACAmE,KAEA,MAAM7I,EAAI8vB,GAAoB3xB,EAAK,KAAM0K,GAIzC,OAHUY,GAA2CZ,EAAcnE,GACjD+K,MAAMzP,GACJuE,IAAIvE,GACb+b,KAAK,EClbD7R,CACHxF,EACAmE,EAEP,CAAC,MAAMxE,GACJ,OAAOnG,CACV,CACJ,WCvRWqzB,GACZ7lB,EACA0P,EAAwB,GAgBxB,IAAK1P,EAAK8lB,YAAa,OAEvB,IAAIC,EAcJ,IACI,MAAMC,EAAWhmB,EAAKS,SAASrY,WAAW69B,SAAS,UACnD,IAAKD,KAAchmB,EAAKS,YAAY9G,QAAUA,YAE1C,YADAiP,QAAQC,MAAM,0BAA0B7I,EAAKS,YAAYT,EAAKI,MAGlE,GAAsB,aAAlBJ,EAAKS,UAA6C,eAAlBT,EAAKS,SACrCslB,EAAUhmB,EAAammB,SAASlmB,GAAM,QACnC,GAAsB,2BAAlBA,EAAKS,SACZslB,EAAUhmB,EAAammB,SAASlmB,GAAM,QACnC,GAAsB,WAAlBA,EAAKS,SACZslB,EAAU5d,GAAW+d,SAASlmB,QAC3B,GAAsB,eAAlBA,EAAKS,SACZslB,EAAUjd,GAAeod,SAASlmB,QAC/B,GAAsB,YAAlBA,EAAKS,SACZslB,EAAUnW,GAAYsW,SAASlmB,GAC/B+lB,EAAQ/V,yBAAyBN,QAC9B,GAAIsW,EAAUD,EAAU1Y,GAAW6Y,SAASlmB,QAC9C,GAAsB,kBAAlBA,EAAKS,SACVslB,EAAU9U,GAAkBiV,SAASlmB,QACpC,GAAsB,qBAAlBA,EAAKS,SACVslB,EAAUzT,GAAqB4T,SAASlmB,QACvC,GAAsB,UAAlBA,EAAKS,SAAsBslB,EAAUpP,GAAUuP,SAASlmB,QAC5D,GAAsB,UAAlBA,EAAKS,SAAsBslB,EAAU9M,GAAUiN,SAASlmB,QAC5D,GAAsB,UAAlBA,EAAKS,SAENslB,EADyB,IAAzB/lB,EAAKmmB,gBACKrG,GAAYoG,SAASlmB,GAErB+e,GAAUmH,SAASlmB,OAE9B,IAAsB,OAAlBA,EAAKS,SAKZ,YAHAmI,QAAQC,MACJ,4CAA4C7I,EAAKS,YAAYT,EAAKI,MAHvC2lB,EAAUjB,GAAOoB,SAASlmB,EAM5D,CACJ,CAAC,MAAO6C,GAEL,YADA+F,QAAQC,MAAM,iBAAiBhG,EAAIrP,UAEtC,CACD,OAAOuyB,CACX,CAGM,SAAUK,GACZpmB,EACA7C,EACA6E,EACAhJ,GAGA,OAAIgJ,IAAavI,QAASA,UAACwI,YAEnB9E,EAAasD,WAAa/G,QAAAA,UAAU8T,QACpCrQ,EAAarD,UAAU2J,SAEhBjR,EAEAwN,EAAKwC,yBAAyBrF,EAAcnE,GAGnDmE,EAAanD,WAAWyJ,SACjBjR,EAEPI,EAAMoG,EAAQmE,EAAaM,aAAamT,IACpCzT,EAAanD,WAAW5R,YAGrBuK,EAEAqN,EAAK8C,yBAAyB3F,EAAcnE,EAI/D,CCpIA,IAAIqtB,GAAsB,UAC1B,IACIA,GAAsBC,QAAQC,IAAIC,uBAAyB,SAC9D,CAAC,MAAO3jB,GACD+F,SACAA,QAAQ6d,IAAI5jB,EAEnB,CAEM,MAAM2jB,GAAsC,IAAIE,YACnDL,IAOSM,GAAgB,IAAID,EAAYv0B,UADvB,QCFhBy0B,GAAgBn0B,EAAK,wBAiDrB,SAAUo0B,GACZC,EACA9kB,EACAhJ,EACA+tB,GAIA,GAAI/tB,EAAOgL,GAAGvR,EAAK6K,EAAAA,YAAYwpB,EAAKE,YAAaD,KAC7C,OAAI/kB,IAAavI,QAASA,UAACwI,YAChBzP,EAEAG,EAIf,MAAMs0B,EAAUC,GAAWJ,EAAM9kB,EAAUhJ,GAC3C,OAAIgJ,IAAavI,QAASA,UAACwI,YAChBglB,EAAQA,EAAQ/+B,OAAS,GAEzB++B,EAAQ,EAEvB,CAEA,SAASC,GACLJ,EACA9kB,EACAhJ,GAEA,MAAMmuB,EAAQL,EAAKK,MACbhqB,EAAe2pB,EAAK3pB,aACpBwC,EAAM,CAAC3G,GAEb,GAAIgJ,IAAavI,QAASA,UAACwI,YACvB,IAAK,IAAIxG,EAAI,EAAGA,EAAI0rB,EAAMj/B,OAAQuT,IAC9BkE,EAAIxS,KACAi5B,GACIe,EAAM1rB,GACN0B,EAAa1B,GACbuG,EACArC,EAAIA,EAAIzX,OAAS,SAI1B,CACH,MAAM4E,EAAIq6B,EAAMj/B,OAChB,IAAK,IAAIuT,EAAI,EAAGA,EAAI0rB,EAAMj/B,OAAQuT,IAC9BkE,EAAIynB,QACAhB,GACIe,EAAMr6B,EAAI,EAAI2O,GACd0B,EAAarQ,EAAI,EAAI2O,GACrBuG,EACArC,EAAI,IAInB,CACD,OAAOA,CACX,CAEA,SAAS0nB,GACLP,EACA9kB,EACAilB,GAEA,MAAME,EAAQL,EAAKK,MACbhqB,EAAe2pB,EAAK3pB,aACpBwC,EAAM,CAAClN,EAAK,IACZ3F,EAAIq6B,EAAMj/B,OAChB,IAAIo/B,EAAgB,EAChBtlB,IAAavI,QAAAA,UAAU8tB,eAAcD,EAAgB,GACzD,IAAK,IAAI7rB,EAAI,EAAGA,EAAI0rB,EAAMj/B,OAAQuT,IAC9BkE,EAAIynB,QACAI,GACIL,EAAMr6B,EAAI,EAAI2O,GACd0B,EAAarQ,EAAI,EAAI2O,GACrBuG,EACAilB,EAAQn6B,EAAI,EAAI2O,EAAI6rB,IACtBr0B,MAAM0M,EAAI,KAGpB,OAAOA,CACX,UA2BgB8nB,GACZX,EACA9kB,EACAhJ,GAIA,OADwBquB,GAAmBP,EAAM9kB,EADjCklB,GAAWJ,EAAM9kB,EAAUhJ,IAEpB,EAC3B,CAGM,SAAUwuB,GACZxnB,EACA7C,EACA6E,EACAhJ,GAGA,GAAIgJ,IAAavI,QAASA,UAACwI,aACvB,GAAI9E,EAAarD,UAAU2J,SACvB,OAAOjR,MAER,CACH,GAAI2K,EAAanD,WAAWyJ,SACxB,OAAOjR,EAEX,GACII,EAAMoG,EAAQmE,EAAaM,aAAamT,IACpCzT,EAAanD,WAAW5R,YAG5B,OAAOuK,CACd,CACD,OAAIqP,IAAavI,QAASA,UAACwI,YAChBjC,EAAK9C,2CACRC,EACAnE,GAGGgH,EAAKjC,2CACRZ,EACAnE,EAIZ,UAEgB0uB,GACZZ,EACA9kB,EACAhJ,GAEA,MAAMmE,EAAe2pB,EAAK3pB,aACpBgqB,EAAQL,EAAKK,MACbr6B,EAAIq6B,EAAMj/B,OAEV++B,EAAUC,GAAWJ,EAAM9kB,EAAUhJ,GACrC2uB,EAAkBN,GAAmBP,EAAM9kB,EAAUilB,GAC3D,IAAItnB,EAAMlN,EAAK,GACf,GAAIuP,IAAavI,QAASA,UAACwI,YACvB,IAAK,IAAIxG,EAAI,EAAGA,EAAI3O,EAAG2O,IAAK,CACxB,MAAMmsB,EAAUC,GACZV,EAAM1rB,GACN0B,EAAa1B,GACbuG,EACAilB,EAAQxrB,IACVxI,MAAM00B,EAAgBlsB,EAAI,IAC5BkE,EAAMA,EAAI6D,KAAKokB,EAClB,KACE,CACH,MAAME,EA/Fd,SACIhB,EACA9kB,EACAilB,GAEA,GAAIjlB,IAAavI,QAAAA,UAAU8tB,aAEvB,MAAO,CAAC90B,EAAK,IAEjB,MAAM00B,EAAQL,EAAKK,MACbhqB,EAAe2pB,EAAK3pB,aACpBwC,EAAM,CAAClN,EAAK,IAClB,IAAK,IAAIgJ,EAAI,EAAGA,EAAI0rB,EAAMj/B,OAAQuT,IAC9BkE,EAAIxS,KACAq6B,GACIL,EAAM1rB,GACN0B,EAAa1B,GACbuG,EACAilB,EAAQxrB,EAAI,IACdxI,MAAM0M,EAAIA,EAAIzX,OAAS,KAGjC,OAAOyX,CACX,CAwEqCooB,CACzBjB,EACA9kB,EACAilB,GAEJ,IAAK,IAAIxrB,EAAI,EAAGA,EAAI3O,EAAG2O,IAAK,CACxB,IAAImsB,EAAUC,GACVV,EAAM1rB,GACN0B,EAAa1B,GACbuG,EACAilB,EAAQxrB,EAAI,IACdxI,MAAM00B,EAAgBlsB,EAAI,IAC5BmsB,EAAUA,EACL30B,MAAM00B,EAAgBlsB,EAAI,IAC1BxI,MAAM60B,EAAqBrsB,IAIhCkE,EAAMA,EAAI6D,KAAKokB,EAClB,CACJ,CAED,OADIjoB,EAAIpS,GAAGkF,EAAK,MAAKkN,EAAMinB,IACpBjnB,CACX,CAGM,SAAUkoB,GACZ7nB,EACA7C,EACA6E,EACAhJ,GAGA,GAAIgJ,IAAavI,QAASA,UAACwI,aACvB,GAAI9E,EAAarD,UAAU2J,SACvB,OAAOjR,MAER,CACH,GAAI2K,EAAanD,WAAWyJ,SACxB,OAAOjR,EAEX,GACII,EAAMoG,EAAQmE,EAAaM,aAAamT,IACpCzT,EAAanD,WAAW5R,YAG5B,OAAOuK,CACd,CACD,OAAIqP,IAAavI,QAASA,UAACwI,YAChBjC,EAAKzB,qDACRpB,EACAnE,GAGGgH,EAAKxB,qDACRrB,EACAnE,EAIZ,CAIM,SAAUgvB,GACZhoB,EACA7C,EACA6E,EACAhJ,GAGAmE,EAAe6C,EAAKa,kBAChB1D,EAAa2D,QACb3D,EAAa4D,UAGjB,MAAMjH,UAAEA,EAASE,WAAEA,EAAU8G,QAAEA,EAAOC,SAAEA,GAAa5D,EAErD,IAAI8qB,EAEJ,GAAIjmB,IAAavI,QAASA,UAACwI,aACvB,GACI9E,EAAasD,WAAa/G,QAAAA,UAAU8T,QACpCrQ,EAAarD,UAAU2J,SAEvB,OAAOjR,MAER,CACH,GAAI2K,EAAanD,WAAWyJ,SACxB,OAAOjR,EAEX,GACII,EAAMoG,EAAQmE,EAAaM,aAAamT,IACpCzT,EAAanD,WAAW5R,YAG5B,OAAOuK,CACd,CACD,GAAIqP,IAAavI,QAASA,UAACwI,YACvB,GAAIjC,EAAKS,WAAa/G,QAASA,UAACqW,QAE5BkY,EAAe7B,GACXpmB,EACA7C,EACA6E,EACAhJ,OAED,MAAIgH,EAAKS,YAAY/G,mBAIxB,MAAMjG,MAAM,oBAFZw0B,EAAejoB,EAAKwC,yBAAyBrF,EAAcnE,EAG9D,MAED,GAAIgH,EAAKS,WAAa/G,QAASA,UAACqW,QAE5BkY,EAAe7B,GACXpmB,EACA7C,EACA6E,EACAhJ,OAED,MAAIgH,EAAKS,YAAY/G,mBAIxB,MAAMjG,MAAM,oBAFZw0B,EAAejoB,EAAK8C,yBAAyB3F,EAAcnE,EAG9D,CAGL,MAAMkB,EAAW8H,IAAavI,QAAAA,UAAUwI,YAAcjJ,EAASivB,EACzDntB,EACFkH,IAAavI,QAAAA,UAAUwI,YAAcgmB,EAAejvB,EAsBxD,OAnBAgH,EAAKkC,0BACDpB,EACAhH,EAAUnS,IACN0Q,EAAUA,WACN6B,EAASuI,GAAGtF,EAAaI,YAAYnV,WACrC+U,EAAaI,cAIzByC,EAAKkC,0BACDnB,EACA/G,EAAWnF,IACPwD,EAAUA,WACNyC,EAAU2H,GAAGtF,EAAaM,aAAarV,WACvC+U,EAAaM,eAKlBwqB,CACX,CC9XO,MA4HDC,GAA2B,CAC7BC,EACAnmB,EACAomB,EACAC,EACAtB,EACAuB,EACAC,KAEA,IAAKC,EAAeC,GAAoBC,GACpCP,EACAnmB,EACAqmB,EACAtB,EACAuB,EACAC,GAGAI,EAAcN,EAGlB,GAAkC,IAA9BA,EAAmBngC,OACnB,MAAO,CACHygC,cACAC,MAAOJ,GAIf,MAAMK,EAAuBp2B,EACzB6K,EAAAA,YAAY8qB,EAAiBrB,IAIjC,IAAI+B,EAAmBN,EAGvB,MAAMO,EAAmC,GACzC,IAAIC,EAAoBC,KAAKC,UACzBJ,EAAiBvhC,KAAI,EAAG6Y,QAASA,IAAI+oB,QAGzC,MAAQJ,EAAuB9C,SAAS+C,KAGpCD,EAAuB57B,KAAK67B,GAC5BR,EAAgBM,GAEfH,EAAaF,GAAoBW,GAC9BZ,EACAxmB,EACA6mB,EACAF,EACAF,IAEHK,EAAkBL,GAAoBC,GACnCP,EACAnmB,EACA2mB,EACA5B,EACAuB,EACAC,GAG4B,IAA5BO,EAAiB5gC,SAtBmC,CAwBxD,MAAMmhC,EAAUP,EAAiBvhC,KAAI,EAAG6Y,QAASA,IAAI+oB,OACrDH,EAAoBC,KAAKC,UAAUG,EACtC,CAED,MAAO,CACHV,cACAC,MAAOJ,EACV,EA+HL,SAASE,GACLY,EACAtnB,EACA2mB,EACA5B,EACAuB,EACAC,GAEA,MAAMC,EAA2B,GAC3Be,EAA+C,GAC/CX,EAAQzX,EAAUmY,GA0ExB,MAvE0B,IAAIX,GAAaQ,MAAK,CAACp1B,EAAGR,IACzCA,EAAEwQ,MAAMhQ,GAAG8J,aAGJrV,SAASghC,IAEvB,IAAIC,GAAiB,EACjBC,EAAqB/2B,EAsCzB,GArCAi2B,EAAMpgC,SAAQ,CAACs+B,EAAMrrB,KAEjB,GACIhJ,EAAK6K,EAAWA,YAACwpB,EAAKE,YAAaD,IAAgBnW,IAC/C4Y,GAEN,CAKE,IAAIG,EAMAA,EAJAl3B,EAAK6K,EAAWA,YAACwpB,EAAKE,YAAaD,IAAgBx5B,GAC/Ci8B,GAGa72B,EDzVrB,SACZm0B,EACA9kB,EACAhJ,EACA+tB,EACAuB,EACAC,GAEA,GAAIvvB,EAAO6G,GAAG8mB,IAGV,OAAOc,GAA6BX,EAAM9kB,EAAUhJ,GAGxD,IAAI4wB,EAAmB/C,GACnBC,EACA9kB,EACAhJ,EACA+tB,GAEJ,MAAM8C,EAAUp3B,EAAK6K,EAAWA,YAACirB,EAAiBD,IAAiBr1B,MAC/D6zB,EAAKK,MAAMj/B,QAEf,OAAI8Z,IAAavI,QAASA,UAACwI,aACvB2nB,EAAmBA,EAAiB7lB,MAAM8lB,GACnC7wB,EAAOH,IAAI+wB,KAElB5wB,EAASA,EAAOwK,KAAKqmB,GACdD,EAAiB/wB,IAAIG,GAEpC,CC+TqC8wB,CACbhD,EACA9kB,EACAwnB,EACAzC,EACAuB,EACAC,GAGJoB,EAAetV,IAAIqV,KACnBA,EAAqBC,EACrBF,EAAgBhuB,EAEvB,MAGkB,IAAnBguB,EASA,OARAjB,EAAcr7B,KAAK,CACfiT,GAAI,GACJ2pB,MAAO,GACP5sB,aAAc,GACd6pB,YAAa70B,EAAAA,UAAU+G,KAAK,KAC5BiuB,MAAO,UAEXoC,EAA6Bp8B,KAAKqF,GAGlCg2B,EAAcr7B,KAAKy7B,EAAMa,IACzBF,EAA6Bp8B,KACzBq8B,EAAWzlB,MACPtR,EACI6K,EAAWA,YACPsrB,EAAMa,GAAezC,YACrBD,MAKhB6B,EAAMn+B,OAAOg/B,EAAe,EAC/B,IAGE,CAACjB,EAAee,EAC3B,CAKA,SAASH,GACLZ,EACAxmB,EACAomB,EACAO,EACAF,GAEA,IAAIuB,EAAat3B,EACbu3B,EAAyB,GAwBzBC,EAAiB,EACrB,KAAOF,EAAWG,cAAc3D,KAAwB,EACnDyD,EAAQtB,EAAaF,GAClB2B,GACI5B,EACAxmB,EACAomB,EACAO,EACAF,EACAyB,GAER,MAAMG,EAAW3D,EAAAA,UAAa4D,IAAI9lC,MAAM,KAAMylC,GACxCM,EAAW7D,EAAAA,UAAa8D,IAAIhmC,MAAM,KAAMylC,GAG9C,GAFAD,EAAaK,EAAStmB,MAAMwmB,GAAU1xB,IAAI0xB,GAC1CL,IACIA,EAAiB,IAAK,KAC7B,CACD,MAAO,CAACvB,EAAaF,EACzB,CAEA,SAAS2B,GACL5B,EACAxmB,EACAomB,EACAO,EACAF,EACAyB,GAEA,IAAIO,EAA4Bj4B,EAC5Bk4B,EAAkCl4B,EACtC,MAAMm4B,EAAwB,GACxBC,EAAkC,GAMxCjC,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAE7B,GACuB,GAAlByuB,GACGV,EAAW5Y,IAAIpe,IACfi2B,EAAiBhtB,GAAG4Y,IAAI7hB,IACT,GAAlB03B,GACGV,EAAWxlB,GAAGxR,IACdi2B,EAAiBhtB,GAAGoE,GAAGrN,GAC7B,CACE,MAAMs0B,EAAO0B,EAAc/sB,GACrBovB,EAAOpD,GACTX,EACA9kB,EACAwnB,GAEJmB,EAAMx9B,KAAK09B,GACX,MAAMC,EAAkBpD,GACpBZ,EACA9kB,EACAwnB,GAEJoB,EAAgBz9B,KAAK29B,GACrBL,EAA4BA,EAA0BjnB,KAClD9Q,EAAImG,IAAIiyB,IAEZJ,EACIA,EAAgClnB,KAAKqnB,EAAKhyB,IAAIiyB,GACrD,MAEGF,EAAgBz9B,KAAKsF,EAAK,QAC1Bk4B,EAAMx9B,KAAKsF,EAAK,OACnB,IASL,MAAMs4B,EAAwBt4B,EAC1Bi4B,EAAgC7sB,WAC5B4sB,EAA0B5sB,YAqBlC,IAlBA8qB,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7B,GACuB,GAAlByuB,GACGV,EAAW5Y,IAAIpe,IACfi2B,EAAiBhtB,GAAG4Y,IAAI7hB,IACT,GAAlB03B,GACGV,EAAWxlB,GAAGxR,IACdi2B,EAAiBhtB,GAAGoE,GAAGrN,GAC7B,CACE,MAAMw4B,EAAkBD,EACnBhnB,MAAM4mB,EAAMlvB,IACZ5C,IAAI+xB,EAAgBnvB,IACzBktB,EAAYltB,GAAKktB,EAAYltB,GAAG+H,KAAKwnB,GACrCvC,EAAiBhtB,GAAKgtB,EAAiBhtB,GAAG+H,KAAKwnB,EAClD,KAKDtE,EAAAA,UAAa8D,IAAIhmC,MAAM,KAAMmkC,GAAa9oB,GAAGrN,IAC7Ck0B,EAAYv0B,UAACm4B,IAAI9lC,MAAM,KAAMikC,GAAkBzkB,GAAGxR,KAEjDm2B,EAAaF,GAAoBwC,GAC9BtC,EACAF,EACAmC,GAIR,MAAMM,EAAyC,GAC/C,IAAIC,EAAmC34B,EACvCm2B,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7B0vB,EACIA,EAAiC3nB,KAAKgmB,IAEnB,GAAlBU,GACGV,EAAW5Y,IAAIpe,IACfi2B,EAAiBhtB,GAAG4Y,IAAI7hB,IACT,GAAlB03B,GACGV,EAAWxlB,GAAGxR,IACdi2B,EAAiBhtB,GAAGoE,GAAGrN,KAE3B04B,EAAuB/9B,KACnBs6B,GACIe,EAAc/sB,GACduG,EACAwnB,GAEP,IAGT,MAAM4B,EAAgBhD,EAAgBrkB,MAClConB,GAaJ,IAAK,IAAI1vB,EAAI,EAAGA,EAAIktB,EAAYzgC,SAAUuT,EACtC,GAAIktB,EAAYltB,GAAGuI,GAAGxR,IAASi2B,EAAiBhtB,GAAGoE,GAAGrN,IAE9Cm2B,EAAYltB,GAAG+H,KAAK4nB,GAAepnB,GAAGxR,IACtCi2B,EAAiBhtB,GAAG+H,KAAK4nB,GAAevrB,GAAGrN,GAC7C,CACEm2B,EAAYltB,GAAKktB,EAAYltB,GAAG+H,KAAK4nB,GACrC3C,EAAiBhtB,GAAKgtB,EAAiBhtB,GAAG+H,KAAK4nB,GAC/C,KACH,CAIT,MAAO,CAACF,EAAwBvC,EAAaF,EACjD,CAEA,SAASwC,GACLtC,EACAF,EACAmC,GAEA,IAAIS,EAA4C74B,EAC5C84B,EAA8C94B,EAC9C+4B,EAA+C/4B,EAC/Cg5B,EAAoCh5B,EA+ExC,OA9EAm2B,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAEzB+tB,EAAWnV,IAAI7hB,IACfg5B,EACIA,EAAkChoB,KAAKgmB,GAC3C8B,EACIA,EAA4C9nB,KACxC9Q,EAAImG,IAAI+xB,EAAgBnvB,MAI3BgtB,EAAiBhtB,GAAGmV,IAAIpe,IAC7Bg5B,EACIA,EAAkChoB,KAAKilB,EAAiBhtB,IAC5D8vB,EACIA,EAA6C/nB,KACzC9Q,EAAImG,IAAI+xB,EAAgBnvB,MAMhC4vB,EACIA,EAA0C7nB,KACtC9Q,EAAImG,IAAI+xB,EAAgBnvB,IAC3B,IAMbktB,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7B,GAAI+tB,EAAWnV,IAAI7hB,GACfm2B,EAAYltB,GAAKjJ,EACjBi2B,EAAiBhtB,GAAKgtB,EAAiBhtB,GAAGsI,MAAMylB,QAC7C,GAAIf,EAAiBhtB,GAAGmV,IAAIpe,GAC/Bm2B,EAAYltB,GAAKktB,EAAYltB,GAAGsI,MAAM0kB,EAAiBhtB,IACvDgtB,EAAiBhtB,GAAKjJ,MACnB,CACH,MAAMw4B,EAAkBQ,EACnBv4B,MAAMP,EAAImG,IAAI+xB,EAAgBnvB,KAC9B5C,IAAIwyB,GACT1C,EAAYltB,GAAKktB,EAAYltB,GAAG+H,KAAKwnB,GACrCvC,EAAiBhtB,GAAKgtB,EAAiBhtB,GAAG+H,KAAKwnB,EAClD,KAKDK,EAA0C5nB,WACtC+nB,EAAkC3rB,GAAGrN,GAGrCm2B,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7B,GAAIgtB,EAAiBhtB,GAAGgI,SAAU,CAC9B,MAAMunB,EAAkBQ,EACnBv4B,MAAMP,EAAImG,IAAI+xB,EAAgBnvB,KAC9B5C,IAAI0yB,GACT5C,EAAYltB,GAAKktB,EAAYltB,GAAG+H,KAAKwnB,GACrCvC,EAAiBhtB,GACbgtB,EAAiBhtB,GAAG+H,KAAKwnB,EAChC,KAKLrC,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7B,GAAIktB,EAAYltB,GAAGgI,SAAU,CACzB,MAAMunB,EAAkBQ,EACnBv4B,MAAMP,EAAImG,IAAI+xB,EAAgBnvB,KAC9B5C,IAAIyyB,GACT3C,EAAYltB,GAAKktB,EAAYltB,GAAG+H,KAAKwnB,GACrCvC,EAAiBhtB,GACbgtB,EAAiBhtB,GAAG+H,KAAKwnB,EAChC,MAIN,CAACrC,EAAaF,EACzB,CAGO,MAAMgD,GAAkB,CAC3B7C,EACA5mB,EACA2mB,EACA5B,KAEA,IAAI2E,EAAc,IAAIhF,YAAa,GAYnC,OAVAkC,EAAMpgC,SAAQ,CAACs+B,EAAMrrB,KACjBiwB,EAAcA,EAAYloB,KACtBqjB,GACIC,EACA9kB,EACA2mB,EAAYltB,GACZsrB,GAEP,IAEE2E,CAAW,EC1tBTC,GAAe,CACxB/C,EACA5mB,EACAomB,EACArB,EACAuB,EACAsD,EACArD,KAGA,GAAoB,GAAhBK,EAAM1gC,QAAekgC,EAAgB3kB,SACrC,MAAO,CAAC,GAAIjR,EAAMA,EAAMA,GAI5B,MAAMq5B,EFFM,SACZjD,EACAgD,GAEA,GAAqB,IAAjBhD,EAAM1gC,OAAc,MAAO,GAC/B,MAAM4jC,EAA4B,GAClC,IAAK,IAAIrwB,EAAI,EAAGA,EAAImwB,EAAUnwB,IAC1B,GAAIA,EAAImtB,EAAM1gC,OAAQ,CAClB,MAAM8+B,EAAc4B,EAAMntB,GAAGurB,YAC7B8E,EAAa3+B,KAAK65B,EACrB,CAEL,OAAO8E,CACX,CEXgCC,CAA+BnD,EAAOgD,GAC5DI,EAAkBH,EAAoBI,QACxC,CAAC/Q,EAAgBgR,KACbhR,EAAE/tB,KAAK++B,EAAUvkC,IAAIuzB,EAAEA,EAAEhzB,OAAS,IAAMkb,EAAIA,OACrC8X,IAEX,IAIJ,GAAIkN,EAAgBpkB,GAAGgoB,EAAgBA,EAAgB9jC,OAAS,IAC5D,MAAO,CAAC,GAAIsK,EAAMA,EAAMA,GAI5B,MAAM25B,EACFH,EAAgB/qB,WAAWmrB,GAEvBhE,EAAgB/T,IAAI+X,KACpB,EAEF/D,EAAqBwD,EAAoBp9B,MAAM,EAAG09B,GAIlDE,EACFL,EAAgBG,EAAkB,GAAGt3B,IAAIuzB,GAC7CC,EAAmBA,EAAmBngC,OAAS,GAC3CmgC,EAAmBA,EAAmBngC,OAAS,GAAG2M,IAAIw3B,GAE1D,MAAOC,EAAWC,EAAiBC,GDjCJ,EAC/B5D,EACA5mB,EACAomB,EACAC,EACAwD,EACA9E,EACAuB,EACA6D,EACAP,EACArD,KAKA,IAAIiE,EACAxqB,IAAavI,QAAAA,UAAUwI,YAActP,EAASM,OAAO,GAAKN,EAC1D45B,EAAkC,GAClCD,EAAuB,GACvB3D,EAAcN,EAAmB9gC,KAAKyR,GACtCvG,EAAK6K,EAAAA,YAAYtE,EAAQ+tB,MAE7B,IAAK,IAAIxzB,EAAI44B,EAAiB54B,GAAKq1B,EAAM1gC,OAAQqL,IAAK,CAClD,GAAIA,GAAK44B,EAAiB,CAUtB,MAAMtD,EAAuBvrB,EAAAA,YACzB8qB,EACArB,GAEE0F,EAAgB/F,EAAYv0B,UAACq4B,IAAIhmC,MAAM,KAAM,CAC/CiO,EAAKo2B,GAAsB51B,MAAMR,EAAK,EAAIc,IAC1C+J,EAAAA,YAAYuuB,EAAoBt4B,EAAI,GAAIwzB,KAI5C4B,EAAYngC,SAAQ,CAACghC,EAAY/tB,KAC7BktB,EAAYltB,GAAK+tB,EAAWv2B,MACxBP,EAAIqR,MAAM0oB,EAAc5zB,IAAIgwB,IAC/B,IAGA4D,EAAchpB,UAAUklB,EAAYx7B,KAAKs/B,EACjD,CAED,MAAQ7D,MAAOJ,EAAeG,YAAa+D,GACvCxE,GACIU,EACA5mB,EACAomB,EACAO,EACA5B,EACAuB,EACAC,GAERI,EAAc+D,EAEd,MAAMhB,EAAcD,GAChBjD,EACAxmB,EACA2mB,EACA5B,GAIE4F,EAAqBnE,EAAcyD,QACrC,CAACW,EAAK9F,IAAS8F,EAAM9F,EAAKiD,MAAM7hC,QAChC,GAQE2kC,EAAuBvvB,EAAAA,YACzBirB,EACAD,GAEJ,IAAIwE,GAAuB,EACvBC,EAA6Bv6B,EACjC,MAAMw6B,EAAUv6B,EAAKk6B,GAAoB15B,MAAM45B,GAc/C,GAbI7qB,IAAavI,QAASA,UAACwI,aACvB8qB,EAA6BrB,EAAY3nB,MAAMipB,GAC/CF,EAAuBC,EAA2B5C,cAC9CqC,KAGJO,EAA6BrB,EAAYloB,KAAKwpB,GAC9CF,EAAuBC,EAA2BE,WAC9CT,KAKHM,EAAsB,MAO3B,GALAP,EAAkB,IAAI5D,GACtB2D,EAAY,IAAI9D,GAChBgE,EAAiCO,EAG7BJ,GAAsBf,EAAU,KACvC,CAQD,OALAU,EAAYA,EAAUtpB,QAAO,CAACkqB,EAAGzxB,KAAO8wB,EAAgB9wB,GAAGgI,WAC3D8oB,EAAkBA,EAAgBvpB,QAC7BwmB,IAAgBA,EAAW/lB,WAGzB,CAAC6oB,EAAWC,EAAiBC,EAA+B,ECpF/DW,CACIvE,EACA5mB,EACAomB,EACAC,EACAwD,EACA9E,EACAuB,EACA6D,EACAP,EACArD,IAGDwB,EAAOqD,EAAiBC,GDwJR,EACvBf,EACAtqB,EACAomB,EACAmE,KAGA,MAAMxC,EAAkB,GACxB,IAAIuD,EAAiBf,EAAgB,GACjCgB,EAA2BjB,EAAU,GACrCc,EAAkB56B,EA8EtB,GA1EA85B,EAAU9jC,SAAQ,CAACs+B,EAAMrrB,KACrB,MAAM+tB,EAAa+C,EAAgB9wB,GAE/B+tB,EAAWxlB,GAAGspB,KACdA,EAAiB9D,EACjB+D,EAAkBzG,GAWtB,MAAM3pB,EAAe2pB,EAAK3pB,aACpBqwB,EAAoB,GACpBvG,EAA0B,GAChC,IAAIgB,EACJ,MAAMn7B,EAAIqQ,EAAajV,OAEvB,GADA++B,EAAQ95B,KAAKq8B,GACTxnB,IAAavI,QAASA,UAACwI,YAAa,CACpC,IAAK,IAAIxG,EAAI,EAAGA,EAAI3O,EAAG2O,IAAK,CACxBwrB,EAAQ95B,KACJ66B,GACIlB,EAAKK,MAAM1rB,GACX0B,EAAa1B,GACbhC,QAASA,UAACwI,YACVglB,EAAQA,EAAQ/+B,OAAS,KAGjC,MAAMulC,EAAa,CACfztB,KAAM8mB,EAAKiD,MAAMtuB,GAAGuE,KACpBc,QAASgmB,EAAKiD,MAAMtuB,GAAGqF,QACvBC,SAAU+lB,EAAKiD,MAAMtuB,GAAGsF,SACxByoB,WAAYvC,EAAQxrB,GAAGrT,WACvBslC,gBAAiB5G,EAAK3pB,aAAa1B,GAAG8B,WACtCowB,iBAAkB7G,EAAK3pB,aAAa1B,GAAGgC,YACvCwqB,aAAchB,EAAQA,EAAQ/+B,OAAS,GAAGE,YAE9ColC,EAAUrgC,KAAKsgC,EAClB,CACDxF,EAAehB,EAAQn6B,EAC1B,KAAM,CACH,IAAK,IAAI2O,EAAI,EAAGA,EAAI3O,EAAG2O,IAAK,CACxBwrB,EAAQG,QACJY,GACIlB,EAAKK,MAAMr6B,EAAI,EAAI2O,GACnB0B,EAAarQ,EAAI,EAAI2O,GACrBhC,QAASA,UAAC8tB,aACVN,EAAQ,KAGhB,MAAMwG,EAAa,CACfztB,KAAM8mB,EAAKiD,MAAMj9B,EAAI,EAAI2O,GAAGuE,KAC5Bc,QAASgmB,EAAKiD,MAAMj9B,EAAI,EAAI2O,GAAGqF,QAC/BC,SAAU+lB,EAAKiD,MAAMj9B,EAAI,EAAI2O,GAAGsF,SAChCyoB,WAAYvC,EAAQ,GAAG7+B,WACvBslC,gBAAiB5G,EAAK3pB,aAAarQ,EAAI,EAAI2O,GAAG8B,WAC9CowB,iBAAkB7G,EAAK3pB,aAAarQ,EAAI,EAAI2O,GAAGgC,YAC/CwqB,aAAchB,EAAQ,GAAG7+B,YAE7BolC,EAAUpG,QAAQqG,EACrB,CACDxF,EAAehB,EAAQ,EAC1B,CACD8C,EAAM58B,KAAKqgC,GACXJ,EAAkBA,EAAgB5pB,KAAKykB,EAAa,IAMpD8B,EAAM7hC,OAAS,EAAG,CAClB,MAAM0lC,EAAoCrB,EAAgBN,QACtD,CAACl4B,EAAGR,IAAMQ,EAAEyP,KAAKjQ,IACjBf,GAEEq7B,EAAOzF,EAAgBrkB,MAAM6pB,GACnC,GAAI5rB,IAAavI,QAASA,UAACwI,YAEvB8nB,EAAM,GAAG,GAAGP,WAAa/2B,EAAKs3B,EAAM,GAAG,GAAGP,YACrChmB,KAAKqqB,GACLzlC,eACF,CAEH,MAAM0lC,EAAyBxB,EAAU,GAAGvC,MAAM7hC,OAAS,EAC3D6hC,EAAM,GAAG+D,GAAwBtE,WAAa/2B,EAC1Cs3B,EAAM,GAAG+D,GAAwBtE,YAEhChmB,KAAKqqB,GACLzlC,UACR,CACJ,CAED,GAAIglC,EAAgB7/B,GAAG,GAAI,MAAO,CAAC,GAAIiF,EAAMA,GAE7C,MAAM66B,EAAW5F,GACb8F,EACAvrB,EACAxP,GAGJ,MAAO,CAACu3B,EAAOqD,EAAiBC,EAAS,EC9QEU,CACvCzB,EACAtqB,EACAvP,EAAK6K,EAAWA,YAAC8qB,EAAiBrB,IAClCwF,GAGJ,OAAIa,EAAgB7/B,GAAG,GAAW,CAAC,GAAIiF,EAAMA,EAAMA,GAE5C,CAACu3B,EAAOqD,EAAiBC,EAAUb,EAA+B,w7ZCxEtE,MAAMwB,GAA2B,CACpCC,eAAgB,GAChBlE,MAAO,GACPP,WAAYpmB,EAAIA,KAChB8qB,mBAAoB9qB,EAAIA,KACxBtC,QAAS,GACTqtB,gBAAiB,GACjBptB,SAAU,GACVqtB,kBAAmB,GACnBnG,aAAc7kB,EAAIA,KAClBirB,4BAA6BjrB,EAAIA,KACjCkrB,sBAAuBlrB,EAAIA,KAC3BiqB,SAAUjqB,EAAIA,KAAChb,YCJNmmC,GAAO,CAChBC,SAAU,CAAC,EAAG,IACdC,MAAO,CACH,EAAG,6CACH,GAAI,8CAERC,OAAQ,CACJ,EAAG,6CACH,GAAI,8CAERC,KAAM,CACF,EAAG,6CACH,GAAI,8CAERC,IAAK,CACD,EAAG,6CACH,GAAI,8CAERC,KAAM,CACF,EAAG,6CACH,GAAI,8CAERC,KAAM,CACF,EAAG,6CACH,GAAI,8CAERC,YAAa,CAETC,OAAQ,CACJ,EAAG,qEACH,GAAI,sEAGRC,QAAS,CACL,EAAG,qEACH,GAAI,sEAGRC,WAAY,CACR,EAAG,qEACH,GAAI,wEAiBHC,GAA0C,CACnD,EAAG,CAAE,EACL,GAAI,CAAE,GAy0BY,SAAAC,GAClBC,EACAC,4CAGA,MAAMC,EAAiB,IAAIC,EAAQA,SAC/BjB,GAAKG,OAAOY,GACZ,CAAC,6DACDD,GAGJ,aADmBE,EAAeE,mBAErC,CAMqB,SAAAC,GAClBvI,EACAmI,EACAxuB,EACAC,EACAiB,EACAwnB,EACA6F,4CAGA,IAAIM,EACAC,GAAgB,EAChB9uB,IAAYytB,GAAKE,MAAMa,KACvBxuB,EAAUytB,GAAKG,OAAOY,GACtBK,GAAe,GAEf5uB,IAAawtB,GAAKE,MAAMa,KACxBvuB,EAAWwtB,GAAKG,OAAOY,GACvBM,GAAgB,GAGpB,MAAMC,EAAqB1e,EAAU6c,IAC/B8B,EAAcX,GAAOG,GAAS,GAAGxuB,IAAUC,IAAWiB,KAC5D,OAAK8tB,GAELD,EAAS5B,eAAiB6B,EAAY7B,eACtC4B,EAAS9F,MAAQ+F,EAAY/F,MAC7B8F,EAASrG,WAAaA,EAWtBqG,EAAS9F,MAAM,GAAG/wB,OAAS62B,EAASrG,WAAWphC,WAC7BynC,EAAS/uB,QAAvB6uB,EAAiCpB,GAAKE,MAAMa,GACxBxuB,EAEL+uB,EAAS9uB,SAAxB6uB,EAAmCrB,GAAKE,MAAMa,GACzBvuB,EAGzB8uB,EAASxC,SA/Gb,SACIrrB,EACA+nB,EACAgG,EACA5I,GAEA,MAAM6I,EAA6B,GACnC,IAAK,IAAIv0B,EAAI,EAAGA,EAAIsuB,EAAM7hC,OAAQuT,IAAK,CACnC,MAAMgyB,EAAO1D,EAAMtuB,GAGbuE,EAAOmnB,EAAMnkB,QAAQqB,GAAMA,EAAEjE,KAAOqtB,EAAKwC,SAC/C,GAAoB,IAAhBjwB,EAAK9X,OAAc,OAAOuK,EAAK,GAGnC,MAAMszB,EAAUF,GAAa7lB,EAAK,IAClC,IAAK+lB,EAAS,OAAOtzB,EAAK,GAI1B,MAAM0K,EAAoB4oB,EAAQllB,kBAC9BkvB,EAAOtC,EAAKyC,cACZH,EAAOtC,EAAK0C,gBAIhB,IAAIC,EAEAA,EADApuB,IAAavI,QAAAA,UAAUwI,YACX8jB,EAAQ7oB,2CAChBC,EACA3K,GAIQuzB,EAAQhoB,2CAChBZ,EACA3K,GAIRw9B,EAAW7iC,KAAKijC,EACnB,CAGD,OAAOJ,EAAW/D,QAAO,CAACl4B,EAAGR,IAAMQ,EAAEd,MAAMM,IAC/C,CAkEwB88B,CAChBruB,EACA6tB,EAAS9F,MACT8F,EAAS5B,eACT9G,GACF/+B,WAGFynC,EAAS5H,mBA9Jb,SACIjmB,EACA+nB,EACAgG,EACAV,4CAEA,MACMiB,EAAgB,IAAId,EAAQA,SADhB,6CAC4Be,GAAUlB,GAClDmB,EAAQ,CACVC,OAAQC,EAAWA,YACnBC,UAAWD,EAAWA,YACtBE,qBAAqB,EACrBC,mBAAmB,GAGvB,IACI,MAAMC,QACIR,EAAcS,WAAWC,eAC3BhvB,EACA+nB,EACAgG,EACAS,GAGR,OAAIxuB,IAAavI,QAAAA,UAAUwI,YAChB6uB,EAAOf,EAAO7nC,OAAS,GAAGwQ,KAAK,GAC9Bo4B,EAAO,EACtB,CAAC,MAAOjuB,GAIL,OAHA+F,QAAQC,MACJ,2DAEGzF,MACV,IACJ,CA6HiC4tB,CAC1BhvB,EACA6tB,EAAS9F,MACT8F,EAAS5B,eACToB,GAGAQ,EAAS5H,aAAaxkB,SACf0N,EAAU6c,KAIrB6B,EAASxB,4BAA8BwB,EAAS5H,aACzC4H,IA5CkBA,IA6C5B,CA15BDV,GAAO,GAAG,GAAGZ,GAAKK,IAAI,KAAKL,GAAKG,OAAO,OAAS,CAC5CuC,KAAM,yBACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACxD3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKK,IAAI,OAAS,CAC5CqC,KAAM,yBACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,IACxD7E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKK,IAAI,KAAKL,GAAKG,OAAO,OAAS,CAC5CuC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACxD3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKK,IAAI,OAAS,CAC5CqC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,IACxD7E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKM,KAAK,KAAKN,GAAKG,OAAO,OAAS,CAC7CuC,KAAM,0BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKM,KAAK,GAAIN,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACtE3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,GAAG,GAAGZ,GAAKM,KAAK,KAAKN,GAAKG,OAAO,OAAS,CAC7CuC,KAAM,2BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKM,KAAK,GAAIN,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACtE3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKM,KAAK,OAAS,CAC7CoC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,GAAIL,GAAKM,KAAK,IACtE9E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKM,KAAK,OAAS,CAC7CoC,KAAM,2BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,GAAIL,GAAKM,KAAK,IACtE9E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKO,KAAK,KAAKP,GAAKG,OAAO,OAAS,CAC7CuC,KAAM,0BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKO,KAAK,GAAIP,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACtE3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,GAAG,GAAGZ,GAAKO,KAAK,KAAKP,GAAKG,OAAO,OAAS,CAC7CuC,KAAM,2BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKO,KAAK,GAAIP,GAAKK,IAAI,GAAIL,GAAKI,KAAK,GAAIJ,GAAKG,OAAO,IACtE3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKO,KAAK,OAAS,CAC7CmC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,GAAIL,GAAKO,KAAK,IACtE/E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,GAAG,GAAGZ,GAAKG,OAAO,KAAKH,GAAKO,KAAK,OAAS,CAC7CmC,KAAM,2BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,GAAIH,GAAKI,KAAK,GAAIJ,GAAKK,IAAI,GAAIL,GAAKO,KAAK,IACtE/E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,GAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,GACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,GACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAOtB/B,GAAO,IAAI,GAAGZ,GAAKM,KAAK,MAAMN,GAAKG,OAAO,QAAU,CAChDuC,KAAM,0BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKM,KAAK,IAAKN,GAAKI,KAAK,IAAKJ,GAAKG,OAAO,KAC3D3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKM,KAAK,QAAU,CAChDoC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,IAAKH,GAAKI,KAAK,IAAKJ,GAAKM,KAAK,KAC3D9E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKM,KAAK,MAAMN,GAAKG,OAAO,QAAU,CAChDuC,KAAM,2BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CAACM,GAAKM,KAAK,IAAKN,GAAKI,KAAK,IAAKJ,GAAKG,OAAO,KAC3D3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKM,KAAK,QAAU,CAChDoC,KAAM,2BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CAACM,GAAKG,OAAO,IAAKH,GAAKI,KAAK,IAAKJ,GAAKM,KAAK,KAC3D9E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKK,IAAI,MAAML,GAAKG,OAAO,QAAU,CAC/CuC,KAAM,yBACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKK,IAAI,IACTL,GAAKM,KAAK,IACVN,GAAKI,KAAK,IACVJ,GAAKG,OAAO,KAEhB3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,IAAI,GAAGZ,GAAKK,IAAI,MAAML,GAAKG,OAAO,QAAU,CAC/CuC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKK,IAAI,IACTL,GAAKM,KAAK,IACVN,GAAKI,KAAK,IACVJ,GAAKG,OAAO,KAEhB3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKK,IAAI,QAAU,CAC/CqC,KAAM,yBACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKG,OAAO,IACZH,GAAKI,KAAK,IACVJ,GAAKM,KAAK,IACVN,GAAKK,IAAI,KAEb7E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKK,IAAI,QAAU,CAC/CqC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKG,OAAO,IACZH,GAAKI,KAAK,IACVJ,GAAKM,KAAK,IACVN,GAAKK,IAAI,KAEb7E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKO,KAAK,MAAMP,GAAKG,OAAO,QAAU,CAChDuC,KAAM,0BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKO,KAAK,IACVP,GAAKM,KAAK,IACVN,GAAKI,KAAK,IACVJ,GAAKG,OAAO,KAEhB3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,IAAI,GAAGZ,GAAKO,KAAK,MAAMP,GAAKG,OAAO,QAAU,CAChDuC,KAAM,2BACNvD,gBAAiB,EACjBC,iBAAkB,GAClBM,eAAgB,CACZM,GAAKO,KAAK,IACVP,GAAKM,KAAK,IACVN,GAAKI,KAAK,IACVJ,GAAKG,OAAO,KAEhB3E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAMtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKO,KAAK,QAAU,CAChDmC,KAAM,0BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CACZM,GAAKG,OAAO,IACZH,GAAKI,KAAK,IACVJ,GAAKM,KAAK,IACVN,GAAKO,KAAK,KAEd/E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QAKtB/B,GAAO,IAAI,GAAGZ,GAAKG,OAAO,MAAMH,GAAKO,KAAK,QAAU,CAChDmC,KAAM,2BACNvD,gBAAiB,GACjBC,iBAAkB,EAClBM,eAAgB,CACZM,GAAKG,OAAO,IACZH,GAAKI,KAAK,IACVJ,GAAKM,KAAK,IACVN,GAAKO,KAAK,KAEd/E,MAAO,CACH,CACIkG,OAAQ1B,GAAKQ,YAAYC,OAAO,IAChCh2B,OAAQ,GACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYE,QAAQ,IACjCj2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,MAEd,CACIjB,OAAQ1B,GAAKQ,YAAYG,WAAW,IACpCl2B,OAAQ,IACRk3B,aAAc,EACdC,cAAe,EACfe,SAAU,QC7wBf,MAAMC,GAA6B,CACtC3C,SAAU,CAAC,GACX,EAAG,CAIC,6CACI,6CAGJ,6CACI,+CAMU,SAAA4C,GAClB/B,EACAgC,4CASA,OAPkB,IAAI7B,EAAQA,SAC1B6B,EACA,CACI,gFAEJhC,GAEaiC,oBAAoB5+B,EAAAA,eACxC,CCbD,IAAY6+B,IAAZ,SAAYA,GACRA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,SAAA,GAAA,UACH,CALD,CAAYA,KAAAA,GAKX,CAAA,ICpBD,MAAMC,GAAqBzH,GAUhB,IATgC,IAAI7+B,IACvC6+B,EAAM0H,SAASC,GACXA,EAASD,SAAShE,GAA2B,CACzCA,EAAK3sB,QACL2sB,EAAK1sB,gBAuBf4wB,GAAsB5H,GACjBA,EAAMkC,QAAO,CAACW,GAAO5zB,YAAa4zB,EAAIjlC,IAAIqR,IAASoK,EAAIA,MAYrDwuB,GAAiB,CAC1BC,EACAH,EACAzD,KAEI4D,IAAap4B,QAASA,UAAC8tB,eAGvBmK,EAAWA,EAASI,WAGjBJ,EAASnqC,KAAI,CAACkmC,EAAMhyB,WAIvB,IAAIs2B,EAAe,IAGnB,GAAU,IAANt2B,EAAS,CAGT,MAAMxC,EACF44B,IAAap4B,QAAAA,UAAUwI,YACjBwrB,EAAKC,gBACLD,EAAKE,iBAEfoE,EAAen/B,EAAMH,EAAKg7B,EAAKjE,YAAuBvwB,GACjDpG,cAAc,EAAG,GACjBzK,UACR,CACD,MAAM4pC,EACFH,IAAap4B,QAAAA,UAAUwI,YACjBwrB,EAAKE,iBACLF,EAAKC,gBAETuE,EAAer/B,EACjBH,EAA0B,QAArBkG,EAAA80B,EAAKxF,oBAAgB,IAAAtvB,EAAAA,EAAA,KAC1Bq5B,GAECn/B,cAAc,EAAG,GACjBzK,WAEC8nC,EAAejC,EAAergB,QAAQ6f,EAAK3sB,SAC3CqvB,EAAgBlC,EAAergB,QAAQ6f,EAAK1sB,UAClD,MAAO,CACHkvB,OAAQxC,EAAKztB,KACbkwB,eACAC,gBACAn3B,OAAQ+4B,EACRb,SAAU,KACVjJ,aAAcgK,EACjB,WC9FIC,GAITlkC,YAA6BmkC,GAAAnmC,KAAemmC,gBAAfA,EAHrBnmC,KAAKm7B,MAAuB,GAC5Bn7B,KAAiBomC,mBAAG,CAEqC,CAEtDC,uBACP,OAAOrmC,KAAKomC,iBACf,CAEME,SAASC,GACZ,MAAMpL,EAAQhW,EAAUnlB,KAAKm7B,OAE7B,GAAIoL,EACA,IAAK,MAAMvyB,KAAQmnB,EACf,GACsB,aAAlBnnB,EAAKS,UACa,eAAlBT,EAAKS,SACP,CACE,MAAM+xB,EAA4B,CAC9BnyB,QAASL,EAAKK,QACd5H,QAASuH,EAAKM,YACdrI,SAAU,GACVW,UAAW,IACXwI,OAAQ,KAEZpB,EAAKO,OAAOpT,KAAKqlC,GACjBxyB,EAAKQ,WAAWrT,KAAK6S,EAAKK,QAC7B,CAGT,OAAO8mB,CACV,CAQYsL,WAAWC,4CACpB,IAGI,OAFA1mC,KAAKm7B,YAAcn7B,KAAKmmC,gBAAgBG,SAASI,GACjD1mC,KAAKomC,mBAAoB,GAClB,CACV,CAAC,MAAOvvB,GAKL,OAHA7W,KAAKomC,mBAAoB,EACzBpmC,KAAKm7B,MAAQ,GACbve,QAAQC,MAAM,wBAAwBhG,MAC/B,CACV,IACJ,EC3CL,MAAM8vB,GAA2B,EAwB3B,SAAUC,GACZC,EACA/xB,EACAC,EACA6qB,GAEA,MAAMkH,EAA8B,CAAA,EAC9BC,EAAwB,CAAA,EACxBC,EAAyB,CAAA,EA4B/B,OA1BArsC,OAAO4C,KAAKspC,GAAUrqC,SAAS4X,IAC3B,MAAMJ,EAAO6yB,EAASzyB,GAChB6yB,EAAe,IAAI/nC,IAAI8U,EAAKQ,YAC5B0yB,EAAkBD,EAAazhC,IAAIsP,EAAQqyB,eAC3CC,EAAmBH,EAAazhC,IAAIuP,EAASoyB,eAGnD,GAAID,GAAmBE,EACnBN,EAAY9yB,EAAKI,IAAMJ,OAI3B,GAAI4rB,EAAW,EACX,GAAIsH,IAAoBE,EACpB,IAAK,MAAMC,KAAYJ,EACdF,EAAOM,KAAWN,EAAOM,GAAY,IAAInoC,IAAI,KAClD6nC,EAAOM,GAAU1rC,IAAIqY,EAAKI,SAE3B,IAAK8yB,GAAmBE,EAC3B,IAAK,MAAMC,IAAY,IAAIJ,GAClBD,EAAQK,KAAWL,EAAQK,GAAY,IAAInoC,IAAI,KACpD8nC,EAAQK,GAAU1rC,IAAIqY,EAAKI,GAGtC,IAEE,CAAC0yB,EAAaC,EAAQC,EACjC,CAEgB,SAAAM,GACZxyB,EACAC,EACA+xB,EACAC,EACAC,EACA7L,GAEA,MAAMyB,EAAmB,GAGzB,IAAK,MAAMxoB,KAAM0yB,EAAa,CAC1B,MAAMhM,EAAOyM,GAAW,CAACzyB,EAASC,GAAW,CAAComB,EAAM/mB,KACpDwoB,EAAMz7B,KAAK25B,EACd,CAED,IAAK,MAAMuM,KAAYN,EACnB,GAAIC,EAAQK,GAAW,CACnB,IACIG,EAEAC,EAHAC,EAAkClhC,EAElCmhC,EAAmCnhC,EAEvC,IAAK,MAAMohC,IAAY,IAAIb,EAAOM,IAAY,CAC1C,MAAMQ,EAAS1M,EAAMyM,GACfz2B,EAAe02B,EAAOhzB,kBACxBC,EACAuyB,GAEES,EACFD,EAAO/xB,uBAAuB3E,GAG9B22B,EAAoBC,uBAChBL,KAGJA,EAAkCI,EAClCN,EAAwCK,EAAOzzB,GAEtD,CACD,IAAK,MAAM4zB,IAAa,IAAIhB,EAAQK,IAAY,CAC5C,MAAMY,EAAU9M,EAAM6M,GAChB72B,EAAe82B,EAAQpzB,kBACzBwyB,EACAtyB,GAEE+yB,EACFG,EAAQnyB,uBAAuB3E,GAG/B22B,EAAoBC,uBAChBJ,KAGJA,EAAmCG,EACnCL,EAAyCQ,EAAQ7zB,GAExD,CACD,GACIozB,GACAC,EACF,CACE,MAAM3M,EAAOyM,GACT,CAACzyB,EAASuyB,EAAUtyB,GACpB,CACIomB,EAAMqM,GACNrM,EAAMsM,KAGd7K,EAAMz7B,KAAK25B,EACd,CACJ,CAEL,OAAO8B,CACX,CA0IM,SAAUsL,GACZpzB,EACAC,EACAozB,EACA/hC,GAEA,MAAMgiC,EAzHJ,SACFtzB,EACAC,EACAozB,EACA/hC,GAGA,MAAMiiC,EAA+B,IAAInpC,IACnCopC,EAAmC,GACnCC,EAAuC,GACvCC,EAAmBpiC,EAAOoiC,iBAC1BpiC,EAAOoiC,iBAAiBjtC,KACnBktC,GAAoBA,EAAgBp0B,UAEzC,GAIN,IAAK,MAAMD,KAAM+zB,EAAc,CAC3B,MAAMn0B,EAAOm0B,EAAa/zB,GAC1B,GAAIJ,EAAKS,UAAY/G,QAASA,UAAC8T,OAC3B8mB,EAAuBnnC,KAAK6S,EAAKK,SACjCg0B,EAAc1sC,IAAIqY,OACf,CACH,MAAMQ,EAAaR,EAAKQ,WAAWjZ,KAAK8Y,GACpCA,EAAQ8yB,iBAER3yB,EAAWylB,SAASjmB,EAAKK,UAIlBL,EAAKS,WAAa/G,QAASA,UAACgH,WADnC6zB,EAAyBpnC,KAAK6S,GAK9B5N,EAAOsiC,kBAAoB10B,EAAKC,OAChC00B,GACIN,EACAjiC,EAAOsiC,iBACP10B,EACAc,EACAC,EACAyzB,EACAL,EAGX,CACJ,CACD,GAAqC,GAAjCG,EAAuBpsC,OAAa,MAAO,GAI/C,IAAK,MAAMusC,KAAmBD,EAC1BI,GACI9zB,EACA2zB,EACAN,EACAE,GAEJO,GACIH,EACA1zB,EACAozB,EACAE,GAIR,MAAMQ,EAAqC,IAAI3pC,IAC/C,IAAK,MAAM8U,KAAQu0B,EAEXv0B,EAAKQ,WAAWs0B,MAAMt8B,GAClB87B,EAAuBrO,SAASztB,OAGpC67B,EAAc1sC,IAAIqY,GAClB60B,EAAsBltC,IAAIqY,EAAKK,UAIvC,IAAK,MAAMD,KAAM+zB,EAAc,CAC3B,MAAMn0B,EAAOm0B,EAAa/zB,GACtBJ,EAAKQ,WAAWs0B,MAAMt8B,GAAUq8B,EAAsBrjC,IAAIgH,MAC1D67B,EAAc1sC,IAAIqY,EAEzB,CAOD,OALI5N,EAAO2iC,YAAcZ,EAAa/hC,EAAO2iC,WAAW30B,KACpDi0B,EAAc1sC,IAAIwsC,EAAa/hC,EAAO2iC,WAAW30B,KAOzD,SAA0B+mB,GACtB,MAAMiN,EAA0B,CAAA,EAChC,IAAK,MAAMp0B,KAAQmnB,EAAO,CACtB,MAAMr6B,EAAIkT,EAAKQ,WAAWtY,OAC1B,IAAK,IAAIuT,EAAI,EAAGA,EAAI3O,EAAG2O,IAAK,CACnB24B,EAAcp0B,EAAKQ,WAAW/E,MAC/B24B,EAAcp0B,EAAKQ,WAAW/E,IAAM,IACxC,IAAK,IAAIqI,EAAI,EAAGA,EAAIhX,EAAGgX,IAAK,CACxB,GAAIrI,GAAKqI,EAAG,SACZ,MAAMkxB,EAAiC,CACnCh1B,EAAKI,GACLJ,EAAKQ,WAAW/E,GAChBuE,EAAKQ,WAAWsD,IAEpBswB,EAAcp0B,EAAKQ,WAAW/E,IAAItO,KAAK6nC,EAC1C,CACJ,CACJ,CACD,OAAOZ,CACX,CAvBqBa,CADc,IAAIZ,GAGvC,CA6B0Ba,CAClBp0B,EACAC,EACAozB,EACA/hC,GAEE+iC,EAAoC,GAMpCC,EAA0B,CAAC,CALF,CAC3BJ,KAAM,CAAC,GAAI,GAAIl0B,GACfu0B,cAAe,EAAE,GAAI,GACrBC,aAAc,MAGlB,IAAIC,GAAU,EACd,KAAOA,GAAS,CACZ,MAAMzoC,EAAIsoC,EAAUltC,OACdstC,EAA2B,GAEjC,IAAK,IAAI/5B,EAAI,EAAGA,EAAI25B,EAAUtoC,EAAI,GAAG5E,OAAQuT,IAAK,CAC9C,MAAMg6B,EAAWL,EAAUtoC,EAAI,GAAG2O,GAE5Bi6B,EAAiBtB,EADTqB,EAAST,KAAK,IAE5B,GAAKU,EACL,IAAK,MAAMV,KAAQU,EAAgB,CAG/B,GACID,EAASH,aAAarP,SAAS+O,EAAK,KACpCS,EAAST,KAAK,IAAMA,EAAK,GAEzB,SAEAA,EAAK,IAAMj0B,GACXo0B,EAAUhoC,KAAKwoC,GAAYX,EAAMS,EAAUL,IAE/C,MAAMQ,EAAwB,CAC1BZ,KAAMA,EACNK,cAAe,CAACvoC,EAAI,EAAG2O,GACvB65B,aAAcG,EAASH,aAAaO,OAAOb,EAAK,KAEpDQ,EAAaroC,KAAKyoC,EACrB,CACJ,CAC0B,GAAvBJ,EAAattC,OACbqtC,GAAU,EACPH,EAAUjoC,KAAKqoC,GAClB1oC,GAAK6lC,KAA0B4C,GAAU,EAChD,CACD,OAqBJ,SACIO,EACA3B,GAEA,MAAMvL,EAAmB,GACzB,IAAK,MAAMmN,KAAmBD,EAAsB,CAChD,MAAM3O,EAAQ4O,EAAgB,GAAGxuC,KAAK6Y,GAAO+zB,EAAa/zB,KAEtD+mB,EAAMj/B,OAAS,GACf0gC,EAAMz7B,KAAKomC,GAAWwC,EAAgB,GAAI5O,GAEjD,CACD,OAAOyB,CACX,CAlCWoN,CAAiBb,EAAWhB,EACvC,CAEA,SAASwB,GACLX,EACAS,EACAL,GAEA,MAAMa,EAAwC,CAACjB,GAC/CiB,EAAU7O,QAAQqO,EAAST,MAC3B,IAAIkB,EAAUT,EAASJ,cACvB,MAAuB,IAAhBa,EAAQ,IACXD,EAAU7O,QAAQgO,EAAUc,EAAQ,IAAIA,EAAQ,IAAIlB,MACpDkB,EAAUd,EAAUc,EAAQ,IAAIA,EAAQ,IAAIb,cAEhD,MAAMlO,EAAQ8O,EAAU1uC,KAAK4uC,GAAaA,EAAS,KACnDhP,EAAM18B,OAAO,EAAG,GAEhB,MAAO,CADQwrC,EAAU1uC,KAAK4uC,GAAaA,EAAS,KACpChP,EACpB,CAmBgB,SAAAoM,GAAWhzB,EAAkB4mB,GACzC,IAAIhmB,EAAYG,EAChB,MAAMyoB,EAAgB,GAChB5sB,EAA+B,GACrC,IAAIiD,EAAK,GAET,IAAK,IAAI3E,EAAI,EAAGA,EAAI0rB,EAAMj/B,OAAQuT,IAAK,CACnC0F,EAAKZ,EAAO9E,GACZ6F,EAAKf,EAAO9E,EAAI,GAChB,MAAM26B,EAAWjP,EAAM1rB,GAAGoF,kBAAkBM,EAAIG,GAChDnE,EAAahQ,KAAKipC,GAClBh2B,GAAUg2B,EAASh2B,GAEnB,MAAMqtB,EAAa,CACfztB,KAAMmnB,EAAM1rB,GAAG2E,GACfU,QAASK,EACTJ,SAAUO,EACVosB,gBAAiB0I,EAAS74B,WAC1BowB,iBAAkByI,EAAS34B,aAG/BssB,EAAM58B,KAAKsgC,EACd,CAUD,MARsB,CAClBrtB,KACA2pB,QACA/C,YAAa5jB,EAAIA,KACjBjG,eACAgqB,QAIR,UAEgBkP,GACZv1B,EACAC,EACAu1B,GAEA,IAAIC,EAA6B/jC,EAC7BgkC,EAAkD,KACtD,IAAK,MAAMp2B,KAAMk2B,EAAiB,CAC9B,MAAMt2B,EAAOs2B,EAAgBl2B,GACvB6yB,EAAe,IAAI/nC,IAAI8U,EAAKQ,YAIlC,IACKyyB,EAAazhC,IAAIsP,EAAQqyB,iBACzBF,EAAazhC,IAAIuP,EAASoyB,eAE3B,SACJ,MAAMh2B,EAAe6C,EAAKa,kBAAkBC,EAASC,GAC/C+yB,EAAsB9zB,EAAK8B,uBAAuB3E,GAGpD22B,EAAoBC,uBAChBwC,KAGJA,EAA6BzC,EAC7B0C,EAAmCp2B,EAE1C,CACD,OAAOo2B,CACX,CAIA,SAASC,GAAa7N,GAClB,IAAIxoB,EAAK,GACL2pB,EAAgB,GAChB5sB,EAA+B,GAC/BgqB,EAAoB,GACxB,IAAK,MAAML,KAAQ8B,EACfxoB,GAAM0mB,EAAK1mB,GACX2pB,EAAQA,EAAM8L,OAAO/O,EAAKiD,OAC1B5sB,EAAeA,EAAa04B,OAAO/O,EAAK3pB,cACxCgqB,EAAQA,EAAM0O,OAAO/O,EAAKK,OAS9B,MAPsB,CAClB/mB,GAAIA,EACJ2pB,MAAOA,EACP5sB,aAAcA,EACd6pB,YAAa5jB,EAAIA,KACjB+jB,MAAOA,EAGf,CA4GgB,SAAAuP,GACZvP,EACAlX,GAEA,OAAOtpB,OAAOgwC,YACVxlB,EAAUgW,GACLnkB,QACIhD,GACGA,EAAKQ,WAAWtY,OAAS,GAAgC,MAA3B8X,EAAKO,OAAO,GAAG9H,UAEpDlR,KAAKyY,GAAS,CAACA,EAAKI,GAAIylB,GAAa7lB,EAAMiQ,MAC3CjN,QAAO,EAAC,CAAGhD,UAAmB/V,IAAT+V,IAElC,CAEA,SAAS42B,GACL52B,EACA00B,EACAl8B,GAEA,IAAIq+B,EACJ,MAAMr2B,EAAaR,EAAKQ,WACxB,GAAIA,EAAWylB,SAASztB,KAAWk8B,EAAiBzO,SAASztB,GACzD,IAAK,IAAIiD,EAAI,EAAGA,EAAI,EAAGA,IACf+E,EAAW/E,IAAMjD,IACjBq+B,EAAgBr2B,EAAW,EAAI/E,IAI3C,OAAOo7B,CACX,CAEA,SAASlC,GACLN,EACAK,EACAoC,EACAh2B,EACAC,EACAyzB,EACAL,GAGA,MAAM4C,EAAgBrC,EAAiBntC,KAAK8Y,GACxCA,EAAQ8yB,gBAGZ,GAA6B,IAAzB4D,EAAc7uC,OAAc,OAGhC,MAAM8uC,EAAqCJ,GACvCE,EACAC,EACAj2B,GAEEm2B,EAAsCL,GACxCE,EACAC,EACAh2B,GAEJ,GAAKi2B,GAAmBC,EAAxB,CAGA5C,EAAc1sC,IAAImvC,GAGlB,IAAK,MAAMrC,KAAmBD,EACtBwC,GAAkBA,IAAmBvC,GAErCG,GACIoC,EACAvC,EACAN,EACAE,GAGJ4C,GAAmBA,IAAoBxC,GAEvCG,GACIH,EACAwC,EACA9C,EACAE,EAtBoC,CA0BpD,CAEA,SAASO,GACL9zB,EACAC,EACAomB,EACA+P,GAEA,MAAMl3B,EAAOq2B,GAAwBv1B,EAASC,EAAUomB,GACpDnnB,GAAMk3B,EAAWvvC,IAAIw/B,EAAMnnB,GACnC,CC9pBgB,SAAAm3B,GACZvO,EACA5mB,GAEA,IAAIo1B,EAAwBh0B,EAAAA,KAC5BwlB,EAAMpgC,SAASs+B,IAEXA,EAAKE,YAUG,SACZF,EACA9kB,GAEA,MAAM7E,EAAe2pB,EAAK3pB,aAC1B,IAAIk6B,EACJ,GAAIr1B,IAAavI,QAASA,UAACwI,YAAa,CACpCo1B,EAAQvQ,EAAKK,MAAMhqB,EAAajV,OAAS,GAAG6Z,mBACxC5E,EAAaA,EAAajV,OAAS,GACnCuR,QAASA,UAACwI,aAGd,IAAK,IAAIxG,EAAI0B,EAAajV,OAAS,EAAGuT,GAAK,EAAGA,IAAK,CAC/C,MAAM67B,EAAmBxQ,EAAKK,MAAM1rB,GAAGsG,mBACnC5E,EAAa1B,GACbhC,QAASA,UAACwI,aAMd,GAJ0B6kB,EAAKK,MAAM1rB,GAAGsG,mBACpC5E,EAAa1B,GACbhC,QAASA,UAAC8tB,cAEQlT,IAAIgjB,GACtBA,EAAQC,MACL,CACH,MAAMC,EAAcnR,GAChBU,EAAKK,MAAM1rB,GACXqrB,EAAK3pB,aAAa1B,GAClBhC,QAASA,UAAC8tB,aACV8P,GAEJA,EAAQ3Q,EAAAA,UAAa8D,IAAI+M,EAAaD,EACzC,CACJ,CACD,GAAID,EAAM5zB,SAAU,OAAOL,OAK3B,OAJe/K,EAAUA,WACrBg/B,EAAM50B,GAAGtF,EAAa,GAAGI,YAAYnV,WACrC+U,EAAa,GAAGI,WAGvB,CACG85B,EAAQvQ,EAAKK,MAAM,GAAGplB,mBAClB5E,EAAa,GACb1D,kBAAU8tB,cAEd,IAAK,IAAI9rB,EAAI,EAAGA,EAAI0B,EAAajV,OAAQuT,IAAK,CAC1C,MAAM67B,EAAmBxQ,EAAKK,MAAM1rB,GAAGsG,mBACnC5E,EAAa1B,GACbhC,QAASA,UAACwI,aAERu1B,EAAoB1Q,EAAKK,MAAM1rB,GAAGsG,mBACpC5E,EAAa1B,GACbhC,QAASA,UAAC8tB,cAEd,GAAI+P,EAAiBjjB,IAAIgjB,GACrBA,EAAQG,MACL,CACH,MAAMC,EAAcrR,GAChBU,EAAKK,MAAM1rB,GACXqrB,EAAK3pB,aAAa1B,GAClBhC,QAASA,UAACwI,YACVo1B,GAEJA,EAAQ3Q,EAAAA,UAAa8D,IAAIiN,EAAaD,EACzC,CACJ,CACD,OAAIH,EAAM5zB,SAAiBL,OACpB/K,EAAUA,WACbg/B,EACK50B,GAAGtF,EAAaA,EAAajV,OAAS,GAAGuV,aACzCrV,WACL+U,EAAaA,EAAajV,OAAS,GAAGuV,YAGlD,CAnF2Bi6B,CAA0B5Q,EAAM9kB,GAEnDo1B,EAAwBA,EAAsBzvC,IAAIm/B,EAAKE,YAAY,IAKvE,MAAO,CAHa4B,EAAMO,MAAK,CAACp1B,EAAGR,IACxBA,EAAEyzB,YAAYhjB,GAAGjQ,EAAEizB,aAAe,GAAK,IAE7BoQ,EACzB,OCJaO,GAGT3pC,YAA6BoE,GAAApG,KAAMoG,OAANA,EAF7BpG,KAAK4F,MAAyC,EAEI,CAKlDgmC,kBACI92B,EACAC,EACAiB,EACAmlB,EACA0Q,GAIA,GAFA/2B,EAAUA,EAAQqyB,cAClBpyB,EAAWA,EAASoyB,cACC,IAAjBhM,EAAMj/B,OAAc,MAAO,GAI/B,MAAM0J,EACF5F,KAAK4F,MACD,GAAGkP,IAAUC,IAAWiB,IAAW61B,EAAY5nB,aAGvD,IAAK4nB,EAAYC,cAAkBlmC,EAE/B,OAAOA,EAAMg3B,MAGjB,MAAMuL,EAAeuC,GAAiBvP,EAAO0Q,EAAY5nB,YAElD6iB,EAAaC,EAAQC,GAAWJ,GACnCuB,EACArzB,EACAC,EACA82B,EAAYjM,UAGVmM,EAAWzE,GACbxyB,EACAC,EACA+xB,EACAC,EACAC,EACAmB,GAGE6D,EAAe9D,GACjBpzB,EACAC,EACAozB,EACAnoC,KAAKoG,QAGH6lC,EFyZR,SACFn3B,EACAC,EACAm3B,EACAC,EACA/lC,SAGA,MAAMgmC,EAAyBhmC,EAAOimC,mBACtC,IAAKD,EAAwB,MAAO,GAEpC,MAAMC,EAAqBH,EAASE,EAAuBh4B,IAErDk4B,EAAmC,QAAlB3/B,EAAAvG,EAAOmmC,mBAAW,IAAA5/B,OAAA,EAAAA,EAAE0H,QAE3C,IAAKg4B,IAAuBC,EAAgB,MAAO,GAGnD,MAAME,EAAqBnC,GACvBv1B,EACAw3B,EACAH,GAGEM,EAAsBpC,GACxBiC,EACAv3B,EACAo3B,GAGJ,GAAIK,IAAuBC,EAAqB,CAK5C,MAAMC,EAAmBP,EAAcK,GAGjCG,EAAapF,GACf,CAACzyB,EAASw3B,EAAgBF,EAAuBQ,MACjD,CAACF,EAAkBL,IAIjBQ,EAAqBxC,GACvB+B,EAAuBQ,KACvB73B,EACAo3B,GAGJ,GAA2B,OAAvBU,EAA6B,MAAO,GAExC,MAAMC,EAAWX,EAAcU,GAM/B,MAAO,CAACpC,GAAa,CAACkC,EALNpF,GACZ,CAAC6E,EAAuBQ,KAAM73B,GAC9B,CAAC+3B,MAIR,CAED,IAAKN,GAAsBC,EAAqB,CAM5C,MAAMM,EAAsB1C,GACxBv1B,EACAs3B,EAAuBQ,KACvBT,GAGJ,GAA4B,OAAxBY,EAA8B,MAAO,GAEzC,MAAML,EAAmBP,EAAcM,GACjCO,EAAYb,EAAcY,GAG1BJ,EAAapF,GACf,CAAC6E,EAAuBQ,KAAMN,EAAgBv3B,GAC9C,CAACs3B,EAAoBK,IAOzB,MAAO,CAACjC,GAAa,CALHlD,GACd,CAACzyB,EAASs3B,EAAuBQ,MACjC,CAACI,IAG4BL,IACpC,CAOD,MAAO,EACX,CE1fiCM,CACrBn4B,EACAC,EACAozB,EACAA,EACAnoC,KAAKoG,QAGH8mC,EAAmBnB,EACpBlC,UAAUmC,GACVnC,UAAUoC,IACRrP,GAASuO,GAAoB+B,EAAkBl3B,GAMtD,OAJAhW,KAAK4F,MAAM,GAAGkP,IAAUC,IAAWiB,IAAW61B,EAAY5nB,aACtD,CACI2Y,MAAOA,GAERA,CACV,CAWDuQ,0BACIr4B,EACAC,EACAiB,EACAmyB,EACAvI,GAIA,GAFA9qB,EAAUA,EAAQqyB,cAClBpyB,EAAWA,EAASoyB,cACqB,IAArCxsC,OAAO4C,KAAK4qC,GAAcjsC,OAAc,MAAO,GAEnD,MAAO4qC,EAAaC,EAAQC,GAAWJ,GACnCuB,EACArzB,EACAC,EACA6qB,GAGEmM,EAAWzE,GACbxyB,EACAC,EACA+xB,EACAC,EACAC,EACAmB,GAGE6D,EAAe9D,GACjBpzB,EACAC,EACAozB,EACAnoC,KAAKoG,QAGH8mC,EAAmBnB,EAASlC,UAAUmC,IACrCpP,GAASuO,GAAoB+B,EAAkBl3B,GACtD,OAAO4mB,CACV,QCtIQwQ,GAGTprC,YACIoE,EACiBinC,GAAArtC,KAAiBqtC,kBAAjBA,EAEjBrtC,KAAKstC,gBAAkB,CACnB5I,YAAa,IACb,CAACt+B,EAAOmnC,KAAKpG,eAAgB,IAEpC,CAOYqG,sBACTrgB,EACAxlB,EACA8lC,EACAC,EAAqBvnC,YAAU+G,KAAK,mDAEpC,GAAIugC,EAAYh2B,UAAYi2B,EAAQj2B,SAAU,OAAOL,OACrD,MAAMu2B,QAAmB3tC,KAAK4tC,2BAA2BzgB,GACnD0gB,EAAgB1nC,EAASA,UAAC+G,KAC5BtG,EAAMH,EAAKknC,GAAahmC,GAAe8O,GAAG,GAAGra,YAGjD,OAAOqxC,EAAY/gC,IAAIghC,GAAShhC,IAAImhC,GAAehhC,IAAInG,EAAAA,eAC1D,CAMMonC,2BACH3gB,EACAwgB,GAEA3tC,KAAKstC,gBAAgBngB,EAAaga,eAAiBwG,CACtD,CAKaC,2BACVzgB,4CAGA,MAAM4gB,EACF/tC,KAAKstC,gBAAgBngB,EAAaga,eACtC,GAAI4G,EAAkB,OAAOA,EAE7B,IACI,MAAMC,QACIhuC,KAAKqtC,kBAAkBO,2BACzBzgB,GAMR,OAFAntB,KAAK8tC,2BAA2B3gB,EAAc6gB,GAEvCA,CACV,CAAC,MAAOn3B,GAGL,OAFA+F,QAAQ6d,IAAI,+CACZ7d,QAAQ6d,IAAI5jB,GACL,GACV,IACJ,4NC/CyB,0JCqB1B7U,YACWqhC,EACUj9B,EACjB+/B,EACAkH,GAHOrtC,KAAQqjC,SAARA,EACUrjC,KAAMoG,OAANA,EAjBJpG,KAAAiuC,mBAAkC,CAC/CC,SAAU7hC,EAAAA,WAAW,KAAM,GAC3BqhC,QAASvnC,EAAAA,UAAU+G,KAAK,SACxBihC,eAAgBxgC,QAAUA,WAACygC,IAC3BxO,SAAU,EACV3b,UAAWG,KAAKiqB,MAAMC,KAAKC,MAAQ,KACnCzC,cAAc,GAed9rC,KAAKwuC,WAAa,IAAItI,GAAWC,GACjCnmC,KAAKyuC,cAAgB,IAAI9C,GAAcvlC,GACvCpG,KAAK0uC,mBAAqB,IAAItB,GAC1BhnC,EACAinC,EAEP,CAED/G,SAASC,GACL,OAAOvmC,KAAKwuC,WAAWlI,SAASC,EACnC,CAMKE,sDACF,OAAOzmC,KAAKwuC,WAAW/H,eAC1B,CAYKkI,SACF75B,EACAC,EACAiB,EACAwnB,EACAqO,EACAtF,GAAU,4CAEV,IAAKvmC,KAAKwuC,WAAWnI,iBAAkB,OAAOlhB,EAAU6c,IAGxD,MAAM4M,iCACC5uC,KAAKiuC,oBACLpC,GAEH7rC,KAAK6uC,SAAWtI,IAChBqI,EAAQ9C,cAAe,EACvB9rC,KAAK6uC,OAAStI,GAElB,MACMuI,EL5EmB,EAC7B3T,EACAgT,IAEIA,IAAmBxgC,QAAAA,WAAWygC,IAAYjT,EACvCA,EAAMnkB,QAAQqB,GAAMA,EAAE5D,WAAa05B,IKuEhBY,CADY/uC,KAAKwuC,WAAWlI,SAASC,GACZqI,EAAQT,gBAEjDa,QR3EQ,SAClB3L,EACArtB,EACAlB,EACAC,EACA3O,EACAo3B,4CAGA1oB,EAAUA,EAAQqyB,cAClBpyB,EAAWA,EAASoyB,cAEpB,IAAIjF,EAAqB1E,EACrB2E,EAAkBrtB,EAClBm6B,EAAkB1J,GAAU2J,KAC5BC,EAAmBp6B,EACnBq6B,EAAmB7J,GAAU2J,KAC7BG,EAAc3oC,EAAAA,YACd4oC,EAAe5oC,EAAAA,YAqBnB,GAfIoO,IAAY4vB,EAAAA,cACZvC,EAAkB/7B,EAAOmnC,KAAKpG,cAC9B8H,EAAkB1J,GAAUgK,KAI5Bx6B,IAAa2vB,EAAAA,cACbyK,EAAmB/oC,EAAOmnC,KAAKpG,cAC/BiI,EAAmB7J,GAAUgK,KAO7Bz6B,IAAYytB,GAAKE,MAAMr8B,EAAOk9B,SAAU,CACxCnB,EAAkBI,GAAKG,OAAOt8B,EAAOk9B,SACrC2L,EAAkB1J,GAAU9C,MAC5B,MAAMhkB,QAAa2kB,GAAaC,EAAUj9B,EAAOk9B,SACjD+L,EAAc5wB,EACVzI,IAAavI,QAAAA,UAAUwI,cACvBisB,EAAqB1E,EAAW9wB,IAAI+R,GAAM5R,IAAInG,EAAAA,aACrD,CAGD,GAAIqO,IAAawtB,GAAKE,MAAMr8B,EAAOk9B,SAAU,CACzC6L,EAAmB5M,GAAKG,OAAOt8B,EAAOk9B,SACtC8L,EAAmB7J,GAAU9C,MAC7B,MAAMhkB,QAAa2kB,GAAaC,EAAUj9B,EAAOk9B,SACjDgM,EAAe7wB,EACXzI,IAAavI,QAAAA,UAAU8tB,eACvB2G,EAAqB1E,EAAW9wB,IAAI+R,GAAM5R,IAAInG,EAAAA,aACrD,CAMD,MAAM8oC,EACFrK,GAA2B/+B,EAAOk9B,UAAY,CAAA,EAsBlD,OAnBIkM,EAAqB16B,KACrBqtB,EAAkBqN,EAAqB16B,GACvCm6B,EAAkB1J,GAAUkK,SAC5BJ,QAAoBK,GAAuBrM,EAAUlB,GACjDnsB,IAAavI,QAAAA,UAAUwI,cACvBisB,EAAqB1E,EAAW9wB,IAAI2iC,GAAaxiC,IAAInG,EAAAA,eAIzD8oC,EAAqBz6B,KACrBo6B,EAAmBK,EAAqBz6B,GACxCq6B,EAAmB7J,GAAUkK,SAC7BH,QAAqBI,GAAuBrM,EAAU8L,GAClDn5B,IAAavI,QAAAA,UAAU8tB,eACvB2G,EAAqB1E,EAAW9wB,IAAI4iC,GAAcziC,IAAInG,EAAAA,eAKvD,CACHipC,mBAAoBnS,EACpB0E,mBAAoBA,EACpBptB,QAAS,CACL86B,gBAAiB96B,EACjB+6B,gBAAiB1N,EACjB2N,SAAUb,EACVxwB,KAAM4wB,GAEVt6B,SAAU,CACN66B,gBAAiB76B,EACjB86B,gBAAiBV,EACjBW,SAAUV,EACV3wB,KAAM6wB,MAGjB,CQ1BiCS,CACtB/vC,KAAKqjC,SACLrtB,EACAlB,EACAC,EACA/U,KAAKoG,OACLD,EAAAA,UAAU+G,KAAKswB,IAGnB,IAAIqG,EAsBJ,OAVIA,WV6pBRP,EACAxuB,EACAC,GAEA,QAAKwtB,GAAKC,SAASvI,SAASqJ,KAE5BxuB,EAAUA,EAAQqyB,cAClBpyB,EAAWA,EAASoyB,cAGfryB,IAAYytB,GAAKG,OAAOY,IAAYvuB,IAAawtB,GAAKK,IAAIU,IAC1DxuB,IAAYytB,GAAKG,OAAOY,IAAYvuB,IAAawtB,GAAKM,KAAKS,IAC3DxuB,IAAYytB,GAAKG,OAAOY,IAAYvuB,IAAawtB,GAAKO,KAAKQ,IAC3DxuB,IAAYytB,GAAKK,IAAIU,IAAYvuB,IAAawtB,GAAKG,OAAOY,IAC1DxuB,IAAYytB,GAAKM,KAAKS,IAAYvuB,IAAawtB,GAAKG,OAAOY,IAC3DxuB,IAAYytB,GAAKO,KAAKQ,IAAYvuB,IAAawtB,GAAKG,OAAOY,IAC3DxuB,IAAYytB,GAAKE,MAAMa,IAAYvuB,IAAawtB,GAAKK,IAAIU,IACzDxuB,IAAYytB,GAAKE,MAAMa,IAAYvuB,IAAawtB,GAAKM,KAAKS,IAC1DxuB,IAAYytB,GAAKE,MAAMa,IAAYvuB,IAAawtB,GAAKO,KAAKQ,IAC1DxuB,IAAYytB,GAAKK,IAAIU,IAAYvuB,IAAawtB,GAAKE,MAAMa,IACzDxuB,IAAYytB,GAAKM,KAAKS,IAAYvuB,IAAawtB,GAAKE,MAAMa,IAC1DxuB,IAAYytB,GAAKO,KAAKQ,IAAYvuB,IAAawtB,GAAKE,MAAMa,GAInE,CUjsBY0M,CAAiBhwC,KAAKoG,OAAOk9B,QAASxuB,EAASC,SAC9B2uB,GACboL,EACA9uC,KAAKoG,OAAOk9B,QACZ0L,EAAYl6B,QAAQ+6B,gBACpBb,EAAYj6B,SAAS86B,gBACrB75B,EACAg5B,EAAY9M,mBACZliC,KAAKqjC,gBAGQrjC,KAAKiwC,aAClBjB,EAAYl6B,QAAQ+6B,gBACpBb,EAAYj6B,SAAS86B,gBACrB75B,EACAg5B,EAAY9M,mBACZ4M,EACAF,GAIJ/K,EAAS5H,aAAaxkB,WAE1BosB,ERLF,SACFA,EACA7tB,EACAg5B,EACA5oC,GAEA,GAA8B,IAA1By9B,EAAS9F,MAAM7hC,OAAc,OAAO2nC,EAYxC,GAVAA,EAAS/uB,QAAUk6B,EAAYl6B,QAAQ86B,gBACvC/L,EAAS9uB,SAAWi6B,EAAYj6B,SAAS66B,gBAEzC/L,EAAS3B,mBAAqB2B,EAASrG,WACvCqG,EAASvB,sBAAwBuB,EAAS5H,aAE1C4H,EAAS1B,gBAAkB6M,EAAYl6B,QAAQ+6B,gBAC/ChM,EAASzB,kBAAoB4M,EAAYj6B,SAAS86B,gBAI9Cb,EAAYl6B,QAAQg7B,WAAavK,GAAU2J,MAC3CF,EAAYj6B,SAAS+6B,WAAavK,GAAU2J,KAE5C,OAAOrL,EAOPmL,EAAYl6B,QAAQg7B,WAAavK,GAAUgK,KAC3CP,EAAYj6B,SAAS+6B,WAAavK,GAAUgK,MAE5C1L,EAAS5B,eAAiB4B,EAAS5B,eAAe1mC,KAAK20C,GACnDtkC,EAAcskC,EAAM9pC,EAAOmnC,MAAQ7I,EAAWA,YAAGwL,KAQzD,MAAMC,EAAmBL,GACrBA,IAAavK,GAAU9C,OAASqN,IAAavK,GAAUkK,SA+C3D,OAxCKU,EAAgBnB,EAAYl6B,QAAQg7B,WACjC95B,IAAavI,QAASA,UAACwI,aAC1Bk6B,EAAgBnB,EAAYj6B,SAAS+6B,WAClC95B,IAAavI,QAAAA,UAAU8tB,gBAE3BsI,EAASrG,WAAawR,EAAYW,mBAClC9L,EAAS3B,mBAAqB8M,EAAY9M,oBAM1ClsB,IAAavI,QAAAA,UAAUwI,aACvBk6B,EAAgBnB,EAAYj6B,SAAS+6B,YAErCjM,EAAS5H,aAAe4H,EAAS5H,aAC5BvvB,IAAIhG,EAAAA,aACJmG,IAAImiC,EAAYj6B,SAAS0J,MAE9BolB,EAASxB,4BACLwB,EAASxB,4BACJ31B,IAAIhG,EAAAA,aACJmG,IAAImiC,EAAYj6B,SAAS0J,OAKlCzI,IAAavI,QAAAA,UAAU8tB,cACvB4U,EAAgBnB,EAAYl6B,QAAQg7B,YAEpCjM,EAAS5H,aAAe4H,EAAS5H,aAC5BvvB,IAAIhG,EAAAA,aACJmG,IAAImiC,EAAYl6B,QAAQ2J,MAE7BolB,EAASxB,4BACLwB,EAASxB,4BACJ31B,IAAIhG,EAAAA,aACJmG,IAAImiC,EAAYl6B,QAAQ2J,OAG9BolB,CACX,CQrFmBuM,CAAevM,EAAU7tB,EAAUg5B,EAAahvC,KAAKoG,SAFrBy9B,IAK9C,CASKwM,qBACFC,EACAC,EACArC,EACAR,4CAEA,OAAIQ,EAASz2B,SAAiBL,OACvBpX,KAAK0uC,mBAAmBlB,sBAC3B8C,EACAC,EACArC,EACAR,KAEP,CAGauC,aACVn7B,EACAC,EACAiB,EACAwnB,EACArC,EACA0Q,4CAEA,GAAqB,IAAjB1Q,EAAMj/B,OAAc,OAAOipB,EAAU6c,IAEzC,MAAMpF,EAAQ58B,KAAKyuC,cAAc7C,kBAC7B92B,EACAC,EACAiB,EACAmlB,EACA0Q,GAGJ,GAAoB,GAAhBjP,EAAM1gC,OAAa,OAAOipB,EAAU6c,IAGxC,IAAIN,EACAC,EACJ/E,EAAM,GAAGmB,MAAMvhC,SAASilC,IAEhB71B,EAAc61B,EAAK3sB,QAASA,KAC5B4sB,EAAkBD,EAAKC,iBAEvB91B,EAAc61B,EAAK1sB,SAAUA,KAC7B4sB,EAAmBF,EAAKE,iBAC3B,IAGL,MAAM6O,QAAwBxwC,KAAKqwC,qBAC/Br6B,IAAavI,QAAAA,UAAUwI,YAAclB,EAAWD,EAChDkB,IAAavI,QAASA,UAACwI,YACjB0rB,EACAD,EACNmK,EAAYqC,SACZrC,EAAY6B,UAIT3P,EAAO0S,EAAOpP,EAAUqP,GAC3B1wC,KAAK2/B,aACD/C,EACAY,EACAxnB,EACA0rB,EACAC,EACA6O,EACA3E,EAAYjM,UAGdiE,WPnHV8M,EACA36B,EACAwnB,EACA1oB,EACAC,EACAknB,EACAoG,EACAhB,GAEA,GAA6B,IAAzBsP,EAAcz0C,OACd,OAAOipB,EAAU6c,IAGrB,MAAM4O,EAAazrB,EAAUwrB,GACvB1O,EAAiBuD,GAAkBoL,GACnC7S,EAAkB6S,EAAWnL,SAASC,GACxCE,GAAe5vB,EAAU0vB,EAAUzD,KAIjCJ,EAAOrE,EAAW30B,IAAI88B,GAAmB5H,IAkB/C,OAjBI8D,EAAK7pB,GAAG,KACR+lB,EAAM,GAAG/wB,OAAS7G,EAASA,UAAC+G,KAAK6wB,EAAM,GAAG/wB,QAAQrR,IAAIkmC,GAAMzlC,YAGrC,CACvBohC,aACA0E,mBAAoB1E,EACpBvB,eACAqG,sBAAuBrG,EACvBoG,8BACAtE,QACAkE,iBACAntB,UACAC,WACAssB,WAIR,CO4EyBU,CACbhE,EACA/nB,EACAwnB,EACA1oB,EACAC,EACA07B,EACAC,EACArP,GAGJ,OAAOwC,IACV,CAKOlE,aACJ/C,EACAY,EACAxnB,EACA0rB,EACAC,EACA6O,EACA5Q,GAKA,MAAO7E,EAAeuB,GAClBtmB,IAAavI,QAASA,UAACwI,YACjB,CAACyrB,EAAiBC,GAClB,CAACA,EAAkBD,IAEtB3D,EAAO0S,EAAOpP,EAAUqP,GAAwB/Q,GACnD/C,EACA5mB,EACAwnB,EACAzC,EACAuB,EACAsD,EACA4Q,GAGJ,MAAO,CACHzS,EACA1xB,aACIokC,EAAMh6B,GAAG6lB,EAAgB5B,EAAYv0B,UAAC0qC,aAAaz0C,WACnDkgC,GAEJ+E,EAASjlC,WACTiQ,EAAAA,WACIqkC,EACKj6B,GAAG6lB,EAAgB5B,EAAYv0B,UAAC0qC,aAChCz0C,WACLkgC,GAGX,8RP9PoCyB,GAK9B,IAJgC,IAAI7+B,IACvC6+B,EAAM0H,SAAShE,GAA2B,CAACA,EAAK3sB,QAAS2sB,EAAK1sB,oFQThE,SACFmD,EACAjM,EACAgvB,EACA5rB,EACA4I,GAEA,GAAIC,EAAYhc,QAAU++B,EAAQ/+B,OAC9B,KAAM,mDAKV,MAAM40C,EAAwC54B,EAAY3c,KACtD,CAACkR,EAASgD,IAAMhJ,EAAK6K,EAAAA,YAAY7E,EAASR,EAASwD,OAGjDshC,EAAe9V,EAAQgF,QAAO,CAAC+Q,EAAa9iC,EAAUuB,KAExD,MAAM0B,EAAmC,CACrC8G,IAAK9R,EAAAA,UAAU+G,KAAK+K,GACpBC,YAAa44B,EACb97B,aAAcvF,EACdzB,WAAYqB,EACZoC,YAAa,GACb3B,QAASsH,EAAIA,MAEX65B,EAAWC,GACb1qC,EACA2K,GAKEggC,EAAmB1qC,EADE6K,EAAAA,YAAYpD,EAAUjC,EAASwD,KAErD5C,IAAIokC,GACJ70C,WACL,OAAO+J,EAASA,UAAC+G,KAAK8jC,GAAar1C,IAC/B0Q,aAAW8kC,EAAkB,IAChC,GACF/5B,EAAIA,MAEP,OAAOjR,EAASA,UAAC+G,KAAK6jC,EAC1B,8CC3CM,SACF7hC,EACAjD,EACAkD,EACA8rB,EACA5rB,GAEA,MAAM0hC,EAAe9V,EAAQgF,QAAO,CAAC+Q,EAAa9iC,EAAUuB,KAExD,MAAM0B,EAAqC,CACvCrD,UAAWoB,EAASO,GACpB8B,WAAYtF,EAASwD,GACrBzB,WAAYqB,EACZtB,SAAUoB,EAAkBM,GAC5BK,QAASsH,EAAIA,MAEX65B,EAAWG,EACb5qC,EACA2K,GAKEggC,EAAmB1qC,EADE6K,EAAAA,YAAYpD,EAAUjC,EAASwD,KAErD5C,IAAIokC,GACJ70C,WACL,OAAO+J,EAASA,UAAC+G,KAAK8jC,GAAar1C,IAC/B0Q,aAAW8kC,EAAkB,IAChC,GACF/5B,EAAIA,MAEP,OAAOjR,EAASA,UAAC+G,KAAK6jC,EAC1B","x_google_ignoreList":[0,1]}