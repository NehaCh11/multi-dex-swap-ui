import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
import { Provider } from '@ethersproject/providers';
import { RouteProposer } from './routeProposal';
import { SwapCostCalculator } from './swapCostCalculator';
import { SwapInfo, SwapTypes, SubgraphPoolBase, SwapOptions, TokenPriceService, PoolDataService, SorConfig } from './types';
export declare class SOR {
    provider: Provider;
    private readonly config;
    private readonly poolCacher;
    readonly routeProposer: RouteProposer;
    readonly swapCostCalculator: SwapCostCalculator;
    private useBpt;
    private readonly defaultSwapOptions;
    /**
     * @param {Provider} provider - Provider.
     * @param {SorConfig} config - Chain specific configuration for the SOR.
     * @param {PoolDataService} poolDataService - Generic service that fetches pool data from an external data source.
     * @param {TokenPriceService} tokenPriceService - Generic service that fetches token prices from an external price feed. Used in calculating swap cost.
     */
    constructor(provider: Provider, config: SorConfig, poolDataService: PoolDataService, tokenPriceService: TokenPriceService);
    getPools(useBpts?: boolean): SubgraphPoolBase[];
    /**
     * fetchPools Retrieves pools information and saves to internal pools cache.
     * @returns {boolean} True if pools fetched successfully, False if not.
     */
    fetchPools(): Promise<boolean>;
    /**
     * getSwaps Retrieve information for best swap tokenIn>tokenOut.
     * @param {string} tokenIn - Address of tokenIn.
     * @param {string} tokenOut - Address of tokenOut.
     * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.
     * @param {BigNumberish} swapAmount - Either amountIn or amountOut depending on the `swapType` value.
     * @param swapOptions
     * @param useBpts Set to true to consider join/exit weighted pool paths (these will need formatted and submitted via Relayer)
     * @returns Swap information including return amount and swaps structure to be submitted to Vault.
     */
    getSwaps(tokenIn: string, tokenOut: string, swapType: SwapTypes, swapAmount: BigNumberish, swapOptions?: Partial<SwapOptions>, useBpts?: boolean): Promise<SwapInfo>;
    /**
     * getCostOfSwapInToken Calculates and saves price of a swap in outputToken denomination. Used to determine if extra swaps are cost effective.
     * @param {string} outputToken - Address of outputToken.
     * @param {number} outputTokenDecimals - Decimals of outputToken.
     * @param {BigNumber} gasPrice - Gas price used to calculate cost.
     * @param {BigNumber} swapGas - Gas cost of a swap. Default=85000.
     * @returns {BigNumber} Price of a swap in outputToken denomination.
     */
    getCostOfSwapInToken(outputToken: string, outputTokenDecimals: number, gasPrice: BigNumber, swapGas?: BigNumber): Promise<BigNumber>;
    private processSwaps;
    /**
     * Find optimal routes for trade from given candidate paths
     */
    private getBestPaths;
}
