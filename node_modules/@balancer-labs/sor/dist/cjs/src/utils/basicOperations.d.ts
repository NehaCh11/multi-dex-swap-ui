export declare const BZERO: bigint;
export declare const BONE: bigint;
export declare const ONE: bigint;
/**
 * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if
 * it had 18 decimals.
 */
export declare function _computeScalingFactor(tokenDecimals: bigint): bigint;
/**
 * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed
 * scaling or not.
 */
export declare function _upscale(amount: bigint, scalingFactor: bigint): bigint;
/**
 * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*
 * the `amounts` array.
 */
export declare function _upscaleArray(amounts: bigint[], scalingFactors: bigint[]): bigint[];
/**
 * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on
 * whether it needed scaling or not. The result is rounded down.
 */
export declare function _downscaleDown(amount: bigint, scalingFactor: bigint): bigint;
/**
 * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead
 * *mutates* the `amounts` array.
 */
export declare function _downscaleDownArray(amounts: bigint[], scalingFactors: bigint[]): bigint[];
/**
 * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on
 * whether it needed scaling or not. The result is rounded up.
 */
export declare function _downscaleUp(amount: bigint, scalingFactor: bigint): bigint;
/**
 * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead
 * *mutates* the `amounts` array.
 */
export declare function _downscaleUpArray(amounts: bigint[], scalingFactors: bigint[]): bigint[];
export declare class MathSol {
    /**
     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.
     */
    /**
     * @dev Returns the addition of two signed integers, reverting on overflow.
     */
    static add(a: bigint, b: bigint): bigint;
    /**
     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.
     */
    static sub(a: bigint, b: bigint): bigint;
    /**
     * @dev Returns the subtraction of two signed integers, reverting on overflow.
     */
    /**
     * @dev Returns the largest of two numbers of 256 bits.
     */
    static max(a: bigint, b: bigint): bigint;
    /**
     * @dev Returns the smallest of two numbers of 256 bits.
     */
    static min(a: bigint, b: bigint): bigint;
    static mul(a: bigint, b: bigint): bigint;
    static div(a: bigint, b: bigint, roundUp: boolean): bigint;
    static divDown(a: bigint, b: bigint): bigint;
    static divUp(a: bigint, b: bigint): bigint;
    static ONE: bigint;
    static MAX_POW_RELATIVE_ERROR: bigint;
    static mulUpFixed(a: bigint, b: bigint): bigint;
    static divDownFixed(a: bigint, b: bigint): bigint;
    static divUpFixed(a: bigint, b: bigint): bigint;
    static powUpFixed(x: bigint, y: bigint): bigint;
    static powDown(x: bigint, y: bigint): bigint;
    static complementFixed(x: bigint): bigint;
    static mulDownFixed(a: bigint, b: bigint): bigint;
}
