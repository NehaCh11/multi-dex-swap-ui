{"version":3,"file":"basicOperations.js","sources":["../../../../../src/utils/basicOperations.ts"],"sourcesContent":["export const BZERO = BigInt(0);\nexport const BONE = BigInt(1);\nexport const ONE = BigInt('1000000000000000000'); // 18 decimal places\n\nconst _require = (b: boolean, message: string) => {\n    if (!b) throw new Error(message);\n};\n\n/**\n * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\n * it had 18 decimals.\n */\nexport function _computeScalingFactor(tokenDecimals: bigint): bigint {\n    // Tokens with more than 18 decimals are not supported.\n    const decimalsDifference = BigInt(18) - tokenDecimals;\n    return ONE * BigInt(10) ** decimalsDifference;\n}\n\n/**\n * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\n * scaling or not.\n */\nexport function _upscale(amount: bigint, scalingFactor: bigint): bigint {\n    // Upscale rounding wouldn't necessarily always go in the same direction: in a swap for example the balance of\n    // token in should be rounded up, and that of token out rounded down. This is the only place where we round in\n    // the same direction for all amounts, as the impact of this rounding is expected to be minimal (and there's no\n    // rounding error unless `_scalingFactor()` is overriden).\n    return MathSol.mulDownFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\n * the `amounts` array.\n */\nexport function _upscaleArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const upscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        upscaledAmounts[i] = MathSol.mulDownFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return upscaledAmounts;\n}\n\n/**\n * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n * whether it needed scaling or not. The result is rounded down.\n */\nexport function _downscaleDown(amount: bigint, scalingFactor: bigint): bigint {\n    return MathSol.divDownFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\n * *mutates* the `amounts` array.\n */\nexport function _downscaleDownArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const downscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        downscaledAmounts[i] = MathSol.divDownFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return downscaledAmounts;\n}\n\n/**\n * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\n * whether it needed scaling or not. The result is rounded up.\n */\nexport function _downscaleUp(amount: bigint, scalingFactor: bigint): bigint {\n    return MathSol.divUpFixed(amount, scalingFactor);\n}\n\n/**\n * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\n * *mutates* the `amounts` array.\n */\nexport function _downscaleUpArray(\n    amounts: bigint[],\n    scalingFactors: bigint[]\n): bigint[] {\n    const downscaledAmounts = new Array<bigint>(amounts.length);\n    for (let i = 0; i < amounts.length; ++i) {\n        downscaledAmounts[i] = MathSol.divUpFixed(\n            amounts[i],\n            scalingFactors[i]\n        );\n    }\n    return downscaledAmounts;\n}\n\nexport class MathSol {\n    /**\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    // add(a: bigint, b: bigint): bigint {\n    //     const c = a + b;\n    //     // _require(c >= a, Errors.ADD_OVERFLOW);\n    //     return c;\n    // }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on overflow.\n     */\n    static add(a: bigint, b: bigint): bigint {\n        const c = a + b;\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), 'Errors.ADD_OVERFLOW');\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\n     */\n    static sub(a: bigint, b: bigint): bigint {\n        _require(b <= a, 'Errors.SUB_OVERFLOW');\n        const c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\n     */\n    // sub(int256 a, int256 b) internal pure returns (int256) {\n    //     int256 c = a - b;\n    //     // _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\n    //     return c;\n    // }\n\n    /**\n     * @dev Returns the largest of two numbers of 256 bits.\n     */\n    static max(a: bigint, b: bigint): bigint {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers of 256 bits.\n     */\n    static min(a: bigint, b: bigint): bigint {\n        return a < b ? a : b;\n    }\n\n    static mul(a: bigint, b: bigint): bigint {\n        const c = a * b;\n        _require(a == BZERO || c / a == b, 'Errors.MUL_OVERFLOW');\n        return c;\n    }\n\n    static div(a: bigint, b: bigint, roundUp: boolean): bigint {\n        return roundUp ? this.divUp(a, b) : this.divDown(a, b);\n    }\n\n    static divDown(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n        return a / b;\n    }\n\n    static divUp(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            return BONE + (a - BONE) / b;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static ONE = BigInt('1000000000000000000'); // 18 decimal places\n    static MAX_POW_RELATIVE_ERROR = BigInt(10000);\n\n    static mulUpFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        _require(a == BZERO || product / a == b, 'Errors.MUL_OVERFLOW');\n\n        if (product == BZERO) {\n            return BZERO;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return (product - BONE) / this.ONE + BONE;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    // Same as divDown in Smart Contract FixedPoint.sol\n    static divDownFixed(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            const aInflated = a * this.ONE;\n            // _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static divUpFixed(a: bigint, b: bigint): bigint {\n        _require(b != BZERO, 'Errors.ZERO_DIVISION');\n\n        if (a == BZERO) {\n            return BZERO;\n        } else {\n            const aInflated = a * this.ONE;\n            _require(aInflated / a == this.ONE, 'Errors.DIV_INTERNAL'); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return (aInflated - BONE) / b + BONE;\n        }\n    }\n\n    // Modification: Taken from the fixed point class\n    static powUpFixed(x: bigint, y: bigint): bigint {\n        const raw = LogExpMath.pow(x, y);\n        const maxError = this.add(\n            this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR),\n            BONE\n        );\n\n        return this.add(raw, maxError);\n    }\n\n    static powDown(x: bigint, y: bigint): bigint {\n        const raw = LogExpMath.pow(x, y);\n        const maxError = this.add(\n            this.mulUpFixed(raw, this.MAX_POW_RELATIVE_ERROR),\n            BONE\n        );\n        return this.sub(raw, maxError);\n    }\n\n    // Modification: Taken from the fixed point class\n    static complementFixed(x: bigint): bigint {\n        return x < this.ONE ? this.ONE - x : BZERO;\n    }\n\n    // This is the same as mulDown in Smart Contracts FixedPoint.sol\n    static mulDownFixed(a: bigint, b: bigint): bigint {\n        const product = a * b;\n        _require(a == BZERO || product / a == b, 'Errors.MUL_OVERFLOW');\n\n        return product / this.ONE;\n    }\n}\n\nclass LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static ONE_18 = BigInt('1000000000000000000');\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    static ONE_20 = BigInt('100000000000000000000');\n    static ONE_36 = BigInt('1000000000000000000000000000000000000');\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    static MAX_NATURAL_EXPONENT = BigInt('130000000000000000000');\n    static MIN_NATURAL_EXPONENT = BigInt('-41000000000000000000');\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    static LN_36_LOWER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) - BigInt('100000000000000000');\n    static LN_36_UPPER_BOUND: bigint =\n        BigInt(LogExpMath.ONE_18) + BigInt('100000000000000000');\n\n    static MILD_EXPONENT_BOUND: bigint =\n        BigInt(2) ** BigInt(254) / LogExpMath.ONE_20;\n\n    // 18 decimal constants\n    static x0 = BigInt('128000000000000000000'); // 2ˆ7\n    static a0 = BigInt(\n        '38877084059945950922200000000000000000000000000000000000'\n    ); // eˆ(x0) (no decimals)\n    static x1 = BigInt('64000000000000000000'); // 2ˆ6\n    static a1 = BigInt('6235149080811616882910000000'); // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    static x2 = BigInt('3200000000000000000000'); // 2ˆ5\n    static a2 = BigInt('7896296018268069516100000000000000'); // eˆ(x2)\n    static x3 = BigInt('1600000000000000000000'); // 2ˆ4\n    static a3 = BigInt('888611052050787263676000000'); // eˆ(x3)\n    static x4 = BigInt('800000000000000000000'); // 2ˆ3\n    static a4 = BigInt('298095798704172827474000'); // eˆ(x4)\n    static x5 = BigInt('400000000000000000000'); // 2ˆ2\n    static a5 = BigInt('5459815003314423907810'); // eˆ(x5)\n    static x6 = BigInt('200000000000000000000'); // 2ˆ1\n    static a6 = BigInt('738905609893065022723'); // eˆ(x6)\n    static x7 = BigInt('100000000000000000000'); // 2ˆ0\n    static a7 = BigInt('271828182845904523536'); // eˆ(x7)\n    static x8 = BigInt('50000000000000000000'); // 2ˆ-1\n    static a8 = BigInt('164872127070012814685'); // eˆ(x8)\n    static x9 = BigInt('25000000000000000000'); // 2ˆ-2\n    static a9 = BigInt('128402541668774148407'); // eˆ(x9)\n    static x10 = BigInt('12500000000000000000'); // 2ˆ-3\n    static a10 = BigInt('113314845306682631683'); // eˆ(x10)\n    static x11 = BigInt('6250000000000000000'); // 2ˆ-4\n    static a11 = BigInt('106449445891785942956'); // eˆ(x11)\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    static pow(x: bigint, y: bigint): bigint {\n        if (y === BZERO) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return this.ONE_18;\n        }\n\n        if (x == BZERO) {\n            return BZERO;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(\n            x <\n                BigInt(\n                    '57896044618658097711785492504343953926634992332820282019728792003956564819968'\n                ),\n            'Errors.X_OUT_OF_BOUNDS'\n        );\n        const x_int256 = x;\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < this.MILD_EXPONENT_BOUND, 'Errors.Y_OUT_OF_BOUNDS');\n        const y_int256 = y;\n\n        let logx_times_y;\n        if (\n            this.LN_36_LOWER_BOUND < x_int256 &&\n            x_int256 < this.LN_36_UPPER_BOUND\n        ) {\n            const ln_36_x = this._ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y =\n                (ln_36_x / this.ONE_18) * y_int256 +\n                ((ln_36_x % this.ONE_18) * y_int256) / this.ONE_18;\n        } else {\n            logx_times_y = this._ln(x_int256) * y_int256;\n        }\n        logx_times_y /= this.ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            this.MIN_NATURAL_EXPONENT <= logx_times_y &&\n                logx_times_y <= this.MAX_NATURAL_EXPONENT,\n            'Errors.PRODUCT_OUT_OF_BOUNDS'\n        );\n\n        // return uint256(exp(logx_times_y));\n        return this.exp(logx_times_y);\n    }\n\n    static exp(x: bigint): bigint {\n        _require(\n            x >= this.MIN_NATURAL_EXPONENT && x <= this.MAX_NATURAL_EXPONENT,\n            'Errors.INVALID_EXPONENT'\n        );\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return (this.ONE_18 * this.ONE_18) / this.exp(BigInt(-1) * x);\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        let firstAN;\n        if (x >= this.x0) {\n            x -= this.x0;\n            firstAN = this.a0;\n        } else if (x >= this.x1) {\n            x -= this.x1;\n            firstAN = this.a1;\n        } else {\n            firstAN = BigInt(1); // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= BigInt(100);\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        let product = this.ONE_20;\n\n        if (x >= this.x2) {\n            x -= this.x2;\n            product = (product * this.a2) / this.ONE_20;\n        }\n        if (x >= this.x3) {\n            x -= this.x3;\n            product = (product * this.a3) / this.ONE_20;\n        }\n        if (x >= this.x4) {\n            x -= this.x4;\n            product = (product * this.a4) / this.ONE_20;\n        }\n        if (x >= this.x5) {\n            x -= this.x5;\n            product = (product * this.a5) / this.ONE_20;\n        }\n        if (x >= this.x6) {\n            x -= this.x6;\n            product = (product * this.a6) / this.ONE_20;\n        }\n        if (x >= this.x7) {\n            x -= this.x7;\n            product = (product * this.a7) / this.ONE_20;\n        }\n        if (x >= this.x8) {\n            x -= this.x8;\n            product = (product * this.a8) / this.ONE_20;\n        }\n        if (x >= this.x9) {\n            x -= this.x9;\n            product = (product * this.a9) / this.ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        let seriesSum = this.ONE_20; // The initial one in the sum, with 20 decimal places.\n        let term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by this.ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = (term * x) / this.ONE_20 / BigInt(2);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(3);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(4);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(5);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(6);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(7);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(8);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(9);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(10);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(11);\n        seriesSum += term;\n\n        term = (term * x) / this.ONE_20 / BigInt(12);\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by this.ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / this.ONE_20) * firstAN) / BigInt(100);\n    }\n\n    static _ln_36(x: bigint): bigint {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= this.ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        const z = ((x - this.ONE_36) * this.ONE_36) / (x + this.ONE_36);\n        const z_squared = (z * z) / this.ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(11);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(13);\n\n        num = (num * z_squared) / this.ONE_36;\n        seriesSum += num / BigInt(15);\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * BigInt(2);\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    static _ln(a: bigint): bigint {\n        if (a < this.ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by this.ONE_18.\n            return BigInt(-1) * this._ln((this.ONE_18 * this.ONE_18) / a);\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // this.ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        let sum = BZERO;\n        if (a >= this.a0 * this.ONE_18) {\n            a /= this.a0; // Integer, not fixed point division\n            sum += this.x0;\n        }\n\n        if (a >= this.a1 * this.ONE_18) {\n            a /= this.a1; // Integer, not fixed point division\n            sum += this.x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= BigInt(100);\n        a *= BigInt(100);\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= this.a2) {\n            a = (a * this.ONE_20) / this.a2;\n            sum += this.x2;\n        }\n\n        if (a >= this.a3) {\n            a = (a * this.ONE_20) / this.a3;\n            sum += this.x3;\n        }\n\n        if (a >= this.a4) {\n            a = (a * this.ONE_20) / this.a4;\n            sum += this.x4;\n        }\n\n        if (a >= this.a5) {\n            a = (a * this.ONE_20) / this.a5;\n            sum += this.x5;\n        }\n\n        if (a >= this.a6) {\n            a = (a * this.ONE_20) / this.a6;\n            sum += this.x6;\n        }\n\n        if (a >= this.a7) {\n            a = (a * this.ONE_20) / this.a7;\n            sum += this.x7;\n        }\n\n        if (a >= this.a8) {\n            a = (a * this.ONE_20) / this.a8;\n            sum += this.x8;\n        }\n\n        if (a >= this.a9) {\n            a = (a * this.ONE_20) / this.a9;\n            sum += this.x9;\n        }\n\n        if (a >= this.a10) {\n            a = (a * this.ONE_20) / this.a10;\n            sum += this.x10;\n        }\n\n        if (a >= this.a11) {\n            a = (a * this.ONE_20) / this.a11;\n            sum += this.x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        const z = ((a - this.ONE_20) * this.ONE_20) / (a + this.ONE_20);\n        const z_squared = (z * z) / this.ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        let num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        let seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(3);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(5);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(7);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(9);\n\n        num = (num * z_squared) / this.ONE_20;\n        seriesSum += num / BigInt(11);\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= BigInt(2);\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / BigInt(100);\n    }\n}\n"],"names":["BZERO","BigInt","BONE","ONE","_require","b","message","Error","_computeScalingFactor","tokenDecimals","decimalsDifference","_upscale","amount","scalingFactor","MathSol","mulDownFixed","_downscaleDown","divDownFixed","static","a","c","roundUp","this","divUp","divDown","product","aInflated","x","y","raw","LogExpMath","pow","maxError","add","mulUpFixed","MAX_POW_RELATIVE_ERROR","sub","ONE_18","x_int256","MILD_EXPONENT_BOUND","y_int256","logx_times_y","LN_36_LOWER_BOUND","LN_36_UPPER_BOUND","ln_36_x","_ln_36","_ln","MIN_NATURAL_EXPONENT","MAX_NATURAL_EXPONENT","exp","firstAN","x0","a0","x1","a1","ONE_20","x2","a2","x3","a3","x4","a4","x5","a5","x6","a6","x7","a7","x8","a8","x9","a9","term","seriesSum","z","ONE_36","z_squared","num","sum","a10","x10","a11","x11"],"mappings":"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"}