{"version":3,"file":"index.js","sources":["../../../../../src/utils/index.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address';\nimport { parseFixed, BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    _computeScalingFactor,\n    _downscaleDown,\n    ONE as ONE_BigInt,\n    _upscale,\n} from './basicOperations';\nimport { SubgraphToken } from '../types';\n\nexport const isSameAddress = (address1: string, address2: string): boolean =>\n    getAddress(address1) === getAddress(address2);\n\n/// Parses a fixed-point decimal string into a BigNumber\n/// If we do not have enough decimals to express the number, we truncate it\nexport function safeParseFixed(value: string, decimals = 0): BigNumber {\n    const [integer, fraction] = value.split('.');\n    if (!fraction) {\n        return parseFixed(value, decimals);\n    }\n    const safeValue = integer + '.' + fraction.slice(0, decimals);\n    return parseFixed(safeValue, decimals);\n}\n\n// normalizes its balance as if it had 18 decimals taking price rate into consideration.\nexport const normaliseBalance = (\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'balance'>\n): bigint => {\n    return parseFixed(token.balance, 18)\n        .mul(parseFixed(token.priceRate ?? '1', 18))\n        .div(ONE)\n        .toBigInt();\n};\n\n// normalizes amount as if it had 18 decimals taking price rate into consideration.\nexport const normaliseAmount = (\n    amount: bigint,\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'decimals'>\n): bigint => {\n    const scalingFactor = _computeScalingFactor(BigInt(token.decimals));\n    return BigNumber.from(_upscale(amount, scalingFactor).toString())\n        .mul(parseFixed(token.priceRate ?? '1', 18))\n        .div(ONE)\n        .toBigInt();\n};\n\n// denormalises amount from 18 decimals to token decimals taking price rate into consideration.\nexport const denormaliseAmount = (\n    amount: bigint,\n    token: Partial<Pick<SubgraphToken, 'priceRate'>> &\n        Pick<SubgraphToken, 'decimals'>\n): bigint => {\n    const amountAfterRate =\n        (amount * ONE_BigInt) /\n        BigInt(parseFixed(token.priceRate ?? '1', 18).toString());\n    const scalingFactor = _computeScalingFactor(BigInt(token.decimals));\n    return _downscaleDown(amountAfterRate, scalingFactor);\n};\n"],"names":["isSameAddress","address1","address2","getAddress","safeParseFixed","value","decimals","integer","fraction","split","parseFixed","safeValue","slice","normaliseBalance","token","balance","mul","_a","priceRate","div","ONE","toBigInt","normaliseAmount","amount","scalingFactor","_computeScalingFactor","BigInt","BigNumber","from","_upscale","toString","denormaliseAmount","amountAfterRate","ONE_BigInt","_downscaleDown"],"mappings":"8RAWaA,EAAgB,CAACC,EAAkBC,IAC5CC,EAAWF,KAAcE,EAAWD,YAIxBE,EAAeC,EAAeC,EAAW,GACrD,MAAOC,EAASC,GAAYH,EAAMI,MAAM,KACxC,IAAKD,EACD,OAAOE,EAAWL,EAAOC,GAE7B,MAAMK,EAAYJ,EAAU,IAAMC,EAASI,MAAM,EAAGN,GACpD,OAAOI,EAAWC,EAAWL,EACjC,CAGa,MAAAO,EACTC,UAGA,OAAOJ,EAAWI,EAAMC,QAAS,IAC5BC,IAAIN,EAA0B,QAAfO,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,KACvCE,IAAIC,GACJC,UAAU,EAINC,EAAkB,CAC3BC,EACAT,WAGA,MAAMU,EAAgBC,EAAsBC,OAAOZ,EAAMR,WACzD,OAAOqB,EAAUC,KAAKC,EAASN,EAAQC,GAAeM,YACjDd,IAAIN,EAA0B,QAAfO,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,KACvCE,IAAIC,GACJC,UAAU,EAINU,EAAoB,CAC7BR,EACAT,WAGA,MAAMkB,EACDT,EAASU,EACVP,OAAOhB,EAA0B,QAAfO,EAAAH,EAAMI,iBAAS,IAAAD,EAAAA,EAAI,IAAK,IAAIa,YAC5CN,EAAgBC,EAAsBC,OAAOZ,EAAMR,WACzD,OAAO4B,EAAeF,EAAiBR,EAAc"}