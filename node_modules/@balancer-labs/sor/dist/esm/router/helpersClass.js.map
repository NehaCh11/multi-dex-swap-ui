{"version":3,"file":"helpersClass.js","sources":["../../../../../src/router/helpersClass.ts"],"sourcesContent":["import {\n    BigNumber as OldBigNumber,\n    ZERO,\n    INFINITY,\n    scale,\n    bnum,\n} from '../utils/bignumber';\nimport { getOutputAmountSwap } from '../pools';\nimport { INFINITESIMAL } from '../config';\nimport {\n    NewPath,\n    SwapTypes,\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n} from '../types';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\n\nconst MINIMUM_VALUE = bnum('0.000000000000000001');\n\nexport function getHighestLimitAmountsForPaths(\n    paths: NewPath[],\n    maxPools: number\n): BigNumber[] {\n    if (paths.length === 0) return [];\n    const limitAmounts: BigNumber[] = [];\n    for (let i = 0; i < maxPools; i++) {\n        if (i < paths.length) {\n            const limitAmount = paths[i].limitAmount;\n            limitAmounts.push(limitAmount);\n        }\n    }\n    return limitAmounts;\n}\n\nexport function getEffectivePriceSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber,\n    inputDecimals: number,\n    outputDecimals: number,\n    costReturnToken: BigNumber\n): OldBigNumber {\n    if (amount.lt(INFINITESIMAL)) {\n        // Return spot price as code below would be 0/0 = undefined\n        // or small_amount/0 or 0/small_amount which would cause bugs\n        return getSpotPriceAfterSwapForPath(path, swapType, amount);\n    }\n\n    let outputAmountSwap = getOutputAmountSwapForPath(\n        path,\n        swapType,\n        amount,\n        inputDecimals\n    );\n    const gasCost = bnum(formatFixed(costReturnToken, outputDecimals)).times(\n        path.pools.length\n    );\n    if (swapType === SwapTypes.SwapExactIn) {\n        outputAmountSwap = outputAmountSwap.minus(gasCost);\n        return amount.div(outputAmountSwap); // amountIn/AmountOut\n    } else {\n        amount = amount.plus(gasCost);\n        return outputAmountSwap.div(amount); // amountIn/AmountOut\n    }\n}\n\nexport function getOutputAmountSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber,\n    inputDecimals: number\n): OldBigNumber {\n    // First of all check if the amount is above limit, if so, return 0 for\n    // 'swapExactIn' or Inf for swapExactOut\n    if (amount.gt(bnum(formatFixed(path.limitAmount, inputDecimals)))) {\n        if (swapType === SwapTypes.SwapExactIn) {\n            return ZERO;\n        } else {\n            return INFINITY;\n        }\n    }\n\n    const amounts = getAmounts(path, swapType, amount);\n    if (swapType === SwapTypes.SwapExactIn) {\n        return amounts[amounts.length - 1];\n    } else {\n        return amounts[0];\n    }\n}\n\nfunction getAmounts(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber[] {\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [amount];\n\n    if (swapType === SwapTypes.SwapExactIn) {\n        for (let i = 0; i < pools.length; i++) {\n            ans.push(\n                getOutputAmountSwap(\n                    pools[i],\n                    poolPairData[i],\n                    swapType,\n                    ans[ans.length - 1]\n                )\n            );\n        }\n    } else {\n        const n = pools.length;\n        for (let i = 0; i < pools.length; i++) {\n            ans.unshift(\n                getOutputAmountSwap(\n                    pools[n - 1 - i],\n                    poolPairData[n - 1 - i],\n                    swapType,\n                    ans[0]\n                )\n            );\n        }\n    }\n    return ans;\n}\n\nfunction getProdsSpotPrices(\n    path: NewPath,\n    swapType: SwapTypes,\n    amounts: OldBigNumber[]\n): OldBigNumber[] {\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [bnum(1)];\n    const n = pools.length;\n    let oneIfExactOut = 0;\n    if (swapType === SwapTypes.SwapExactOut) oneIfExactOut = 1;\n    for (let i = 0; i < pools.length; i++) {\n        ans.unshift(\n            getSpotPriceAfterSwap(\n                pools[n - 1 - i],\n                poolPairData[n - 1 - i],\n                swapType,\n                amounts[n - 1 - i + oneIfExactOut]\n            ).times(ans[0])\n        );\n    }\n    return ans;\n}\n\nfunction getProdsFirstSpotPrices(\n    path: NewPath,\n    swapType: SwapTypes,\n    amounts: OldBigNumber[]\n): OldBigNumber[] {\n    if (swapType !== SwapTypes.SwapExactOut)\n        // Throw error?\n        return [bnum(0)];\n\n    const pools = path.pools;\n    const poolPairData = path.poolPairData;\n    const ans = [bnum(1)];\n    for (let i = 0; i < pools.length; i++) {\n        ans.push(\n            getSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i + 1]\n            ).times(ans[ans.length - 1])\n        );\n    }\n    return ans;\n}\n\nexport function getSpotPriceAfterSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    const amounts = getAmounts(path, swapType, amount);\n    const prodsSpotPrices = getProdsSpotPrices(path, swapType, amounts);\n    return prodsSpotPrices[0];\n}\n\n// TODO: Add cases for pairType = [BTP->token, token->BTP] and poolType = [weighted, stable]\nexport function getSpotPriceAfterSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    // TODO: check if necessary to check if amount > limitAmount\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (poolPairData.balanceIn.isZero()) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        return pool._spotPriceAfterSwapExactTokenInForTokenOut(\n            poolPairData,\n            amount\n        );\n    } else {\n        return pool._spotPriceAfterSwapTokenInForExactTokenOut(\n            poolPairData,\n            amount\n        );\n    }\n    throw Error('Unsupported swap');\n}\n\nexport function getDerivativeSpotPriceAfterSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    const poolPairData = path.poolPairData;\n    const pools = path.pools;\n    const n = pools.length;\n\n    const amounts = getAmounts(path, swapType, amount);\n    const prodsSpotPrices = getProdsSpotPrices(path, swapType, amounts);\n    let ans = bnum(0);\n    if (swapType === SwapTypes.SwapExactIn) {\n        for (let i = 0; i < n; i++) {\n            const newTerm = getDerivativeSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i]\n            ).times(prodsSpotPrices[i + 1]);\n            ans = ans.plus(newTerm);\n        }\n    } else {\n        const prodsFirstSpotPrices = getProdsFirstSpotPrices(\n            path,\n            swapType,\n            amounts\n        );\n        for (let i = 0; i < n; i++) {\n            let newTerm = getDerivativeSpotPriceAfterSwap(\n                pools[i],\n                poolPairData[i],\n                swapType,\n                amounts[i + 1]\n            ).times(prodsSpotPrices[i + 1]);\n            newTerm = newTerm\n                .times(prodsSpotPrices[i + 1])\n                .times(prodsFirstSpotPrices[i]);\n            // The following option is more efficient but returns less precision due to the division\n            /*          let thisSpotPrice = getSpotPriceAfterSwap(pools[i], poolPairData[i], swapType, amounts[i + 1]);\n            newTerm = newTerm.div(thisSpotPrice).times(prodsSpotPrices[0]);*/\n            ans = ans.plus(newTerm);\n        }\n    }\n    if (ans.eq(bnum(0))) ans = MINIMUM_VALUE;\n    return ans;\n}\n\n// TODO: Add cases for pairType = [BPT->token, token->BPT] and poolType = [weighted, stable]\nexport function getDerivativeSpotPriceAfterSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    // TODO: check if necessary to check if amount > limitAmount\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (poolPairData.balanceIn.isZero()) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        return pool._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            poolPairData,\n            amount\n        );\n    } else {\n        return pool._derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            poolPairData,\n            amount\n        );\n    }\n    throw Error('Unsupported swap');\n}\n\n// We need do pass 'pools' here because this function has to update the pools state\n// in case a pool is used twice in two different paths\nexport function EVMgetOutputAmountSwap(\n    pool: PoolBase,\n    poolPairData: PoolPairBase,\n    swapType: SwapTypes,\n    amount: OldBigNumber\n): OldBigNumber {\n    //we recalculate the pool pair data since balance updates are not reflected immediately in cached poolPairData\n    poolPairData = pool.parsePoolPairData(\n        poolPairData.tokenIn,\n        poolPairData.tokenOut\n    );\n\n    const { balanceIn, balanceOut, tokenIn, tokenOut } = poolPairData;\n\n    let returnAmount: OldBigNumber;\n\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (\n            poolPairData.poolType !== PoolTypes.Linear &&\n            poolPairData.balanceIn.isZero()\n        ) {\n            return ZERO;\n        }\n    } else {\n        if (poolPairData.balanceOut.isZero()) {\n            return ZERO;\n        }\n        if (\n            scale(amount, poolPairData.decimalsOut).gte(\n                poolPairData.balanceOut.toString()\n            )\n        )\n            return INFINITY;\n    }\n    if (swapType === SwapTypes.SwapExactIn) {\n        if (pool.poolType === PoolTypes.Element) {\n            // TODO this will just be part of below once maths available\n            returnAmount = getOutputAmountSwap(\n                pool,\n                poolPairData,\n                swapType,\n                amount\n            );\n        } else if (pool.poolType in PoolTypes) {\n            // Will accept/return normalised values\n            returnAmount = pool._exactTokenInForTokenOut(poolPairData, amount);\n        } else {\n            throw Error('Unsupported swap');\n        }\n    } else {\n        if (pool.poolType === PoolTypes.Element) {\n            // TODO this will just be part of below once maths available\n            returnAmount = getOutputAmountSwap(\n                pool,\n                poolPairData,\n                swapType,\n                amount\n            );\n        } else if (pool.poolType in PoolTypes) {\n            // Will accept/return normalised values\n            returnAmount = pool._tokenInForExactTokenOut(poolPairData, amount);\n        } else {\n            throw Error('Unsupported swap');\n        }\n    }\n\n    const amountIn = swapType === SwapTypes.SwapExactIn ? amount : returnAmount;\n    const amountOut =\n        swapType === SwapTypes.SwapExactIn ? returnAmount : amount;\n\n    // Update balances of tokenIn and tokenOut\n    pool.updateTokenBalanceForPool(\n        tokenIn,\n        balanceIn.add(\n            parseFixed(\n                amountIn.dp(poolPairData.decimalsIn).toString(),\n                poolPairData.decimalsIn\n            )\n        )\n    );\n    pool.updateTokenBalanceForPool(\n        tokenOut,\n        balanceOut.sub(\n            parseFixed(\n                amountOut.dp(poolPairData.decimalsOut).toString(),\n                poolPairData.decimalsOut\n            )\n        )\n    );\n\n    return returnAmount;\n}\n"],"names":["MINIMUM_VALUE","bnum","getHighestLimitAmountsForPaths","paths","maxPools","length","limitAmounts","i","limitAmount","push","getEffectivePriceSwapForPath","path","swapType","amount","inputDecimals","outputDecimals","costReturnToken","lt","INFINITESIMAL","getSpotPriceAfterSwapForPath","outputAmountSwap","getOutputAmountSwapForPath","gasCost","formatFixed","times","pools","SwapTypes","SwapExactIn","minus","div","plus","gt","ZERO","INFINITY","amounts","getAmounts","poolPairData","ans","getOutputAmountSwap","n","unshift","getProdsSpotPrices","oneIfExactOut","SwapExactOut","getSpotPriceAfterSwap","pool","balanceIn","isZero","balanceOut","scale","decimalsOut","gte","toString","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","getDerivativeSpotPriceAfterSwapForPath","prodsSpotPrices","newTerm","getDerivativeSpotPriceAfterSwap","prodsFirstSpotPrices","getProdsFirstSpotPrices","eq","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","EVMgetOutputAmountSwap","parsePoolPairData","tokenIn","tokenOut","returnAmount","poolType","PoolTypes","Linear","Element","Error","_exactTokenInForTokenOut","_tokenInForExactTokenOut","amountIn","amountOut","updateTokenBalanceForPool","add","parseFixed","dp","decimalsIn","sub"],"mappings":"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"}