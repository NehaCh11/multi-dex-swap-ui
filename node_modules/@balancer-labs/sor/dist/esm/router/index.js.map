{"version":3,"file":"index.js","sources":["../../../../../src/router/index.ts"],"sourcesContent":["import { BigNumber as OldBigNumber, bnum, ZERO } from '../utils/bignumber';\nimport { getHighestLimitAmountsForPaths } from './helpersClass';\nimport { formatSwaps, optimizeSwapAmounts } from './sorClass';\nimport { NewPath, Swap, SwapTypes } from '../types';\nimport { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\n\nexport const getBestPaths = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    inputDecimals: number,\n    outputDecimals: number,\n    maxPools: number,\n    costReturnToken: BigNumber\n): [Swap[][], OldBigNumber, OldBigNumber, OldBigNumber] => {\n    // No paths available or totalSwapAmount == 0, return empty solution\n    if (paths.length == 0 || totalSwapAmount.isZero()) {\n        return [[], ZERO, ZERO, ZERO];\n    }\n\n    // Before we start the main loop, we first check if there is enough liquidity for this totalSwapAmount\n    const highestLimitAmounts = getHighestLimitAmountsForPaths(paths, maxPools);\n    const sumLimitAmounts = highestLimitAmounts.reduce(\n        (r: BigNumber[], pathLimit: BigNumber) => {\n            r.push(pathLimit.add(r[r.length - 1] || Zero));\n            return r;\n        },\n        []\n    );\n\n    // If the cumulative limit across all paths is lower than totalSwapAmount then no solution is possible\n    if (totalSwapAmount.gt(sumLimitAmounts[sumLimitAmounts.length - 1])) {\n        return [[], ZERO, ZERO, ZERO]; // Not enough liquidity, return empty\n    }\n\n    // We use the highest limits to define the initial number of pools considered and the initial guess for swapAmounts.\n    const initialNumPaths =\n        sumLimitAmounts.findIndex((cumulativeLimit) =>\n            // If below is true, it means we have enough liquidity\n            totalSwapAmount.lte(cumulativeLimit)\n        ) + 1;\n\n    const initialSwapAmounts = highestLimitAmounts.slice(0, initialNumPaths);\n\n    //  Since the sum of the first i highest limits will be less than totalSwapAmount, we remove the difference to the last swapAmount\n    //  so we are sure that the sum of swapAmounts will be equal to totalSwapAmount\n    const difference =\n        sumLimitAmounts[initialNumPaths - 1].sub(totalSwapAmount);\n    initialSwapAmounts[initialSwapAmounts.length - 1] =\n        initialSwapAmounts[initialSwapAmounts.length - 1].sub(difference);\n\n    const [bestPaths, bestSwapAmounts, bestTotalReturnConsideringFees] =\n        optimizeSwapAmounts(\n            paths,\n            swapType,\n            totalSwapAmount,\n            initialSwapAmounts,\n            highestLimitAmounts,\n            inputDecimals,\n            outputDecimals,\n            initialNumPaths,\n            maxPools,\n            costReturnToken\n        );\n\n    const [swaps, bestTotalReturn, marketSp] = formatSwaps(\n        bestPaths,\n        swapType,\n        bnum(formatFixed(totalSwapAmount, inputDecimals)),\n        bestSwapAmounts\n    );\n\n    if (bestTotalReturn.eq(0)) return [[], ZERO, ZERO, ZERO];\n\n    return [swaps, bestTotalReturn, marketSp, bestTotalReturnConsideringFees];\n};\n"],"names":["getBestPaths","paths","swapType","totalSwapAmount","inputDecimals","outputDecimals","maxPools","costReturnToken","length","isZero","ZERO","highestLimitAmounts","getHighestLimitAmountsForPaths","sumLimitAmounts","reduce","r","pathLimit","push","add","Zero","gt","initialNumPaths","findIndex","cumulativeLimit","lte","initialSwapAmounts","slice","difference","sub","bestPaths","bestSwapAmounts","bestTotalReturnConsideringFees","optimizeSwapAmounts","swaps","bestTotalReturn","marketSp","formatSwaps","bnum","formatFixed","eq"],"mappings":"sSAOa,MAAAA,EAAe,CACxBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,KAGA,GAAoB,GAAhBN,EAAMO,QAAeL,EAAgBM,SACrC,MAAO,CAAC,GAAIC,EAAMA,EAAMA,GAI5B,MAAMC,EAAsBC,EAA+BX,EAAOK,GAC5DO,EAAkBF,EAAoBG,QACxC,CAACC,EAAgBC,KACbD,EAAEE,KAAKD,EAAUE,IAAIH,EAAEA,EAAEP,OAAS,IAAMW,IACjCJ,IAEX,IAIJ,GAAIZ,EAAgBiB,GAAGP,EAAgBA,EAAgBL,OAAS,IAC5D,MAAO,CAAC,GAAIE,EAAMA,EAAMA,GAI5B,MAAMW,EACFR,EAAgBS,WAAWC,GAEvBpB,EAAgBqB,IAAID,KACpB,EAEFE,EAAqBd,EAAoBe,MAAM,EAAGL,GAIlDM,EACFd,EAAgBQ,EAAkB,GAAGO,IAAIzB,GAC7CsB,EAAmBA,EAAmBjB,OAAS,GAC3CiB,EAAmBA,EAAmBjB,OAAS,GAAGoB,IAAID,GAE1D,MAAOE,EAAWC,EAAiBC,GAC/BC,EACI/B,EACAC,EACAC,EACAsB,EACAd,EACAP,EACAC,EACAgB,EACAf,EACAC,IAGD0B,EAAOC,EAAiBC,GAAYC,EACvCP,EACA3B,EACAmC,EAAKC,EAAYnC,EAAiBC,IAClC0B,GAGJ,OAAII,EAAgBK,GAAG,GAAW,CAAC,GAAI7B,EAAMA,EAAMA,GAE5C,CAACuB,EAAOC,EAAiBC,EAAUJ,EAA+B"}