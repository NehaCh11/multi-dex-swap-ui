import"../external/lodash.clonedeep/index.js";import{PRICE_ERROR_TOLERANCE as t}from"../config.js";import{INFINITY as s,bnum as o,ONE as n,ZERO as e}from"../utils/bignumber.js";import{SwapTypes as i}from"../types.js";import{EVMgetOutputAmountSwap as l,getSpotPriceAfterSwapForPath as u,getEffectivePriceSwapForPath as r,getDerivativeSpotPriceAfterSwapForPath as p,getOutputAmountSwapForPath as a}from"./helpersClass.js";import{formatFixed as m,BigNumber as c}from"@ethersproject/bignumber";import{BigNumber as f}from"bignumber.js";import{exports as h}from"../_virtual/index.js";const g=(t,l,u,r,p,a,c,h,g,w)=>{let E=l===i.SwapExactIn?s.times(-1):s,k=[],v=[],A=r.map((t=>o(m(t,a))));for(let s=h;s<=t.length;s++){if(s!=h){const t=m(u,a),e=f.min.apply(null,[o(t).times(o(1/s)),m(p[s-1],a)]);A.forEach(((s,o)=>{A[o]=s.times(n.minus(e.div(t)))})),e.isZero()||A.push(e)}const{paths:r,swapAmounts:S}=d(t,l,u,A,a,c,w);A=S;const x=b(r,l,A,a),I=r.reduce(((t,s)=>t+s.swaps.length),0),O=m(w,c);let D=!1,N=e;const j=o(I).times(O);if(l===i.SwapExactIn?(N=x.minus(j),D=N.isGreaterThan(E)):(N=x.plus(j),D=N.isLessThan(E)),!D)break;if(k=[...A],v=[...r],E=N,I>=g)break}return v=v.filter(((t,s)=>!k[s].isZero())),k=k.filter((t=>!t.isZero())),[v,k,E]},d=(t,s,n,e,i,l,u)=>{let[r,p]=E(t,s,e,i,l,u),a=e;if(1===e.length)return{swapAmounts:a,paths:r};const c=o(m(n,i));let f=r;const h=[];let g=JSON.stringify(f.map((({id:t})=>t)).sort());for(;!h.includes(g)&&(h.push(g),r=f,[a,p]=k(r,s,c,a,p),[f,p]=E(t,s,a,i,l,u),0!==f.length);){const t=f.map((({id:t})=>t)).sort();g=JSON.stringify(t)}return{swapAmounts:a,paths:r}},w=(t,s,n,r)=>{const p=[];let a=r[0],m=t[0],c=e;if(t.forEach(((t,o)=>{const n=r[o];n.gt(a)&&(a=n,m=t);const e=t.poolPairData,u=[],f=[];let h;const g=e.length;if(f.push(n),s===i.SwapExactIn){for(let s=0;s<g;s++){f.push(l(t.pools[s],e[s],i.SwapExactIn,f[f.length-1]));const o={pool:t.swaps[s].pool,tokenIn:t.swaps[s].tokenIn,tokenOut:t.swaps[s].tokenOut,swapAmount:f[s].toString(),tokenInDecimals:t.poolPairData[s].decimalsIn,tokenOutDecimals:t.poolPairData[s].decimalsOut,returnAmount:f[f.length-1].toString()};u.push(o)}h=f[g]}else{for(let s=0;s<g;s++){f.unshift(l(t.pools[g-1-s],e[g-1-s],i.SwapExactOut,f[0]));const o={pool:t.swaps[g-1-s].pool,tokenIn:t.swaps[g-1-s].tokenIn,tokenOut:t.swaps[g-1-s].tokenOut,swapAmount:f[1].toString(),tokenInDecimals:t.poolPairData[g-1-s].decimalsIn,tokenOutDecimals:t.poolPairData[g-1-s].decimalsOut,returnAmount:f[0].toString()};u.unshift(o)}h=f[0]}p.push(u),c=c.plus(h)})),p.length>0){const l=r.reduce(((t,s)=>t.plus(s)),e),u=n.minus(l);if(s===i.SwapExactIn)p[0][0].swapAmount=o(p[0][0].swapAmount).plus(u).toString();else{const s=t[0].swaps.length-1;p[0][s].swapAmount=o(p[0][s].swapAmount).plus(u).toString()}}if(c.eq(0))return[[],e,e];const f=u(m,s,e);return[p,c,f]};function E(t,n,i,l,u,p){const a=[],f=[],g=h(t);return[...i].sort(((t,s)=>s.minus(t).toNumber())).forEach((t=>{let i=-1,h=s;if(g.forEach(((e,a)=>{if(o(m(e.limitAmount,l)).gte(t)){let c;c=o(m(e.limitAmount,l)).eq(t)?s:r(e,n,t,l,u,p),c.lte(h)&&(h=c,i=a)}})),-1===i)return a.push({id:"",swaps:[],poolPairData:[],limitAmount:c.from("0"),pools:[]}),void f.push(e);a.push(g[i]),f.push(t.minus(o(m(g[i].limitAmount,l)))),g.splice(i,1)})),[a,f]}function k(s,o,e,i,l){let u=n,r=[],p=0;for(;u.isGreaterThan(t);){[r,i,l]=v(s,o,e,i,l,p);const t=f.max.apply(null,r),n=f.min.apply(null,r);if(u=t.minus(n).div(n),p++,p>100)break}return[i,l]}function v(t,s,i,l,r,a){let m=e,c=e;const h=[],g=[];l.forEach(((i,l)=>{if(0==a&&i.gte(e)&&r[l].lte(e)||0!=a&&i.gt(e)&&r[l].lt(e)){const o=t[l],e=u(o,s,i);h.push(e);const r=p(o,s,i);g.push(r),m=m.plus(n.div(r)),c=c.plus(e.div(r))}else g.push(o("NaN")),h.push(o("NaN"))}));const d=o(c.toNumber()/m.toNumber());for(l.forEach(((t,s)=>{if(0==a&&t.gte(e)&&r[s].lte(e)||0!=a&&t.gt(e)&&r[s].lt(e)){const t=d.minus(h[s]).div(g[s]);l[s]=l[s].plus(t),r[s]=r[s].plus(t)}}));f.min.apply(null,l).lt(e)||f.max.apply(null,r).gt(e);)[l,r]=A(l,r,g);const w=[];let E=e;l.forEach(((o,n)=>{E=E.plus(o),(0==a&&o.gte(e)&&r[n].lte(e)||0!=a&&o.gt(e)&&r[n].lt(e))&&w.push(u(t[n],s,o))}));const k=i.minus(E);for(let t=0;t<l.length;++t)if(l[t].gt(e)&&r[t].lt(e)&&l[t].plus(k).gt(e)&&r[t].plus(k).lt(e)){l[t]=l[t].plus(k),r[t]=r[t].plus(k);break}return[w,l,r]}function A(t,s,o){let i=e,l=e,u=e,r=e;return t.forEach(((t,p)=>{t.lte(e)?(r=r.plus(t),l=l.plus(n.div(o[p]))):s[p].gte(e)?(r=r.plus(s[p]),u=u.plus(n.div(o[p]))):i=i.plus(n.div(o[p]))})),t.forEach(((l,u)=>{if(l.lte(e))t[u]=e,s[u]=s[u].minus(l);else if(s[u].gte(e))t[u]=t[u].minus(s[u]),s[u]=e;else{const e=r.times(n.div(o[u])).div(i);t[u]=t[u].plus(e),s[u]=s[u].plus(e)}})),i.isZero()&&(r.lt(e)?t.forEach(((e,i)=>{if(s[i].isZero()){const e=r.times(n.div(o[i])).div(u);t[i]=t[i].plus(e),s[i]=s[i].plus(e)}})):t.forEach(((e,i)=>{if(t[i].isZero()){const e=r.times(n.div(o[i])).div(l);t[i]=t[i].plus(e),s[i]=s[i].plus(e)}}))),[t,s]}const b=(t,s,o,n)=>{let e=new f(0);return t.forEach(((t,i)=>{e=e.plus(a(t,s,o[i],n))})),e};export{b as calcTotalReturn,w as formatSwaps,g as optimizeSwapAmounts};
//# sourceMappingURL=sorClass.js.map
