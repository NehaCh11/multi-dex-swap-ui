import{bnum as t,ZERO as e,scale as n,INFINITY as o}from"../utils/bignumber.js";import{getOutputAmountSwap as r}from"../pools/index.js";import{INFINITESIMAL as a}from"../config.js";import{SwapTypes as i,PoolTypes as l}from"../types.js";import{formatFixed as u,parseFixed as c}from"@ethersproject/bignumber";const s=t("0.000000000000000001");function p(t,e){if(0===t.length)return[];const n=[];for(let o=0;o<e;o++)if(o<t.length){const e=t[o].limitAmount;n.push(e)}return n}function f(e,n,o,r,l,c){if(o.lt(a))return g(e,n,o);let s=m(e,n,o,r);const p=t(u(c,l)).times(e.pools.length);return n===i.SwapExactIn?(s=s.minus(p),o.div(s)):(o=o.plus(p),s.div(o))}function m(n,r,a,l){if(a.gt(t(u(n.limitAmount,l))))return r===i.SwapExactIn?e:o;const c=I(n,r,a);return r===i.SwapExactIn?c[c.length-1]:c[0]}function I(t,e,n){const o=t.pools,a=t.poolPairData,l=[n];if(e===i.SwapExactIn)for(let t=0;t<o.length;t++)l.push(r(o[t],a[t],e,l[l.length-1]));else{const t=o.length;for(let n=0;n<o.length;n++)l.unshift(r(o[t-1-n],a[t-1-n],e,l[0]))}return l}function S(e,n,o){const r=e.pools,a=e.poolPairData,l=[t(1)],u=r.length;let c=0;n===i.SwapExactOut&&(c=1);for(let t=0;t<r.length;t++)l.unshift(E(r[u-1-t],a[u-1-t],n,o[u-1-t+c]).times(l[0]));return l}function g(t,e,n){return S(t,e,I(t,e,n))[0]}function E(t,r,a,l){if(a===i.SwapExactIn){if(r.balanceIn.isZero())return e}else{if(r.balanceOut.isZero())return e;if(n(l,r.decimalsOut).gte(r.balanceOut.toString()))return o}return a===i.SwapExactIn?t._spotPriceAfterSwapExactTokenInForTokenOut(r,l):t._spotPriceAfterSwapTokenInForExactTokenOut(r,l)}function w(e,n,o){const r=e.poolPairData,a=e.pools,l=a.length,u=I(e,n,o),c=S(e,n,u);let p=t(0);if(n===i.SwapExactIn)for(let t=0;t<l;t++){const e=x(a[t],r[t],n,u[t]).times(c[t+1]);p=p.plus(e)}else{const o=function(e,n,o){if(n!==i.SwapExactOut)return[t(0)];const r=e.pools,a=e.poolPairData,l=[t(1)];for(let t=0;t<r.length;t++)l.push(E(r[t],a[t],n,o[t+1]).times(l[l.length-1]));return l}(e,n,u);for(let t=0;t<l;t++){let e=x(a[t],r[t],n,u[t+1]).times(c[t+1]);e=e.times(c[t+1]).times(o[t]),p=p.plus(e)}}return p.eq(t(0))&&(p=s),p}function x(t,r,a,l){if(a===i.SwapExactIn){if(r.balanceIn.isZero())return e}else{if(r.balanceOut.isZero())return e;if(n(l,r.decimalsOut).gte(r.balanceOut.toString()))return o}return a===i.SwapExactIn?t._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(r,l):t._derivativeSpotPriceAfterSwapTokenInForExactTokenOut(r,l)}function O(t,a,u,s){a=t.parsePoolPairData(a.tokenIn,a.tokenOut);const{balanceIn:p,balanceOut:f,tokenIn:m,tokenOut:I}=a;let S;if(u===i.SwapExactIn){if(a.poolType!==l.Linear&&a.balanceIn.isZero())return e}else{if(a.balanceOut.isZero())return e;if(n(s,a.decimalsOut).gte(a.balanceOut.toString()))return o}if(u===i.SwapExactIn)if(t.poolType===l.Element)S=r(t,a,u,s);else{if(!(t.poolType in l))throw Error("Unsupported swap");S=t._exactTokenInForTokenOut(a,s)}else if(t.poolType===l.Element)S=r(t,a,u,s);else{if(!(t.poolType in l))throw Error("Unsupported swap");S=t._tokenInForExactTokenOut(a,s)}const g=u===i.SwapExactIn?s:S,E=u===i.SwapExactIn?S:s;return t.updateTokenBalanceForPool(m,p.add(c(g.dp(a.decimalsIn).toString(),a.decimalsIn))),t.updateTokenBalanceForPool(I,f.sub(c(E.dp(a.decimalsOut).toString(),a.decimalsOut))),S}export{O as EVMgetOutputAmountSwap,x as getDerivativeSpotPriceAfterSwap,w as getDerivativeSpotPriceAfterSwapForPath,f as getEffectivePriceSwapForPath,p as getHighestLimitAmountsForPaths,m as getOutputAmountSwapForPath,E as getSpotPriceAfterSwap,g as getSpotPriceAfterSwapForPath};
//# sourceMappingURL=helpersClass.js.map
