{"version":3,"file":"sorClass.js","sources":["../../../../../src/router/sorClass.ts"],"sourcesContent":["import cloneDeep from 'lodash.clonedeep';\nimport { PRICE_ERROR_TOLERANCE } from '../config';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n    INFINITY,\n} from '../utils/bignumber';\nimport { SwapTypes, NewPath, Swap } from '../types';\nimport {\n    getEffectivePriceSwapForPath,\n    getSpotPriceAfterSwapForPath,\n    getDerivativeSpotPriceAfterSwapForPath,\n    getOutputAmountSwapForPath,\n    EVMgetOutputAmountSwap,\n} from './helpersClass';\nimport { BigNumber, formatFixed } from '@ethersproject/bignumber';\n\nexport const optimizeSwapAmounts = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    initialSwapAmounts: BigNumber[],\n    highestLimitAmounts: BigNumber[],\n    inputDecimals: number,\n    outputDecimals: number,\n    initialNumPaths: number,\n    maxPools: number,\n    costReturnToken: BigNumber\n): [NewPath[], OldBigNumber[], OldBigNumber] => {\n    // First get the optimal totalReturn to trade 'totalSwapAmount' with\n    // one path only (b=1). Then increase the number of pools as long as\n    // improvementCondition is true (see more information below)\n    let bestTotalReturnConsideringFees =\n        swapType === SwapTypes.SwapExactIn ? INFINITY.times(-1) : INFINITY;\n    let bestSwapAmounts: OldBigNumber[] = [];\n    let bestPaths: NewPath[] = [];\n    let swapAmounts = initialSwapAmounts.map((amount) =>\n        bnum(formatFixed(amount, inputDecimals))\n    );\n    for (let b = initialNumPaths; b <= paths.length; b++) {\n        if (b != initialNumPaths) {\n            // We already had a previous iteration and are adding another pool this new iteration\n            // swapAmounts.push(ONE); // Initialize new swapAmount with 1 wei to\n            // make sure that it won't be considered as a non viable amount (which would\n            // be the case if it started at 0)\n\n            // Start new path at 1/b of totalSwapAmount (i.e. if this is the 5th pool, we start with\n            // 20% of the totalSwapAmount for this new swapAmount added). However, we need to make sure\n            // that this value is not higher then the bth limit of the paths available otherwise there\n            // won't be any possible path to process this swapAmount:\n            const humanTotalSwapAmount = formatFixed(\n                totalSwapAmount,\n                inputDecimals\n            );\n            const newSwapAmount = OldBigNumber.min.apply(null, [\n                bnum(humanTotalSwapAmount).times(bnum(1 / b)),\n                formatFixed(highestLimitAmounts[b - 1], inputDecimals),\n            ]);\n            // We need then to multiply all current\n            // swapAmounts by 1-newSwapAmount/totalSwapAmount.\n            swapAmounts.forEach((swapAmount, i) => {\n                swapAmounts[i] = swapAmount.times(\n                    ONE.minus(newSwapAmount.div(humanTotalSwapAmount))\n                );\n            });\n\n            if (!newSwapAmount.isZero()) swapAmounts.push(newSwapAmount);\n        }\n\n        const { paths: selectedPaths, swapAmounts: bestAmounts } =\n            optimizePathDistribution(\n                paths,\n                swapType,\n                totalSwapAmount,\n                swapAmounts,\n                inputDecimals,\n                outputDecimals,\n                costReturnToken\n            );\n        swapAmounts = bestAmounts;\n\n        const totalReturn = calcTotalReturn(\n            selectedPaths,\n            swapType,\n            swapAmounts,\n            inputDecimals\n        );\n\n        // Calculates the number of pools in all the paths to include the gas costs\n        const totalNumberOfPools = selectedPaths.reduce(\n            (acc, path) => acc + path.swaps.length,\n            0\n        );\n\n        // improvementCondition is true if we are improving the totalReturn\n        // Notice that totalReturn has to be maximized for 'swapExactIn'\n        // and MINIMIZED for 'swapExactOut'\n        // This is because for the case of 'swapExactOut', totalReturn means the\n        // amount of tokenIn needed to buy totalSwapAmount of tokenOut\n        const costReturnTokenHuman = formatFixed(\n            costReturnToken,\n            outputDecimals\n        );\n        let improvementCondition = false;\n        let totalReturnConsideringFees = ZERO;\n        const gasFees = bnum(totalNumberOfPools).times(costReturnTokenHuman);\n        if (swapType === SwapTypes.SwapExactIn) {\n            totalReturnConsideringFees = totalReturn.minus(gasFees);\n            improvementCondition = totalReturnConsideringFees.isGreaterThan(\n                bestTotalReturnConsideringFees\n            );\n        } else {\n            totalReturnConsideringFees = totalReturn.plus(gasFees);\n            improvementCondition = totalReturnConsideringFees.isLessThan(\n                bestTotalReturnConsideringFees\n            );\n        }\n\n        // Stop if improvement has stopped\n        if (!improvementCondition) break;\n\n        bestSwapAmounts = [...swapAmounts]; // Copy to avoid linking variables\n        bestPaths = [...selectedPaths];\n        bestTotalReturnConsideringFees = totalReturnConsideringFees;\n\n        // Stop if max number of pools has been reached\n        if (totalNumberOfPools >= maxPools) break;\n    }\n\n    // 0 swap amounts can occur due to rounding errors but we don't want to pass those on so filter out\n    bestPaths = bestPaths.filter((_, i) => !bestSwapAmounts[i].isZero());\n    bestSwapAmounts = bestSwapAmounts.filter(\n        (swapAmount) => !swapAmount.isZero()\n    );\n\n    return [bestPaths, bestSwapAmounts, bestTotalReturnConsideringFees];\n};\n\n/**\n * For a fixed number of possible paths, finds the optimal distribution of swap amounts to maximise output\n */\nconst optimizePathDistribution = (\n    allPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: BigNumber,\n    initialSwapAmounts: OldBigNumber[],\n    inputDecimals: number,\n    outputDecimals,\n    costReturnToken: BigNumber\n): { paths: NewPath[]; swapAmounts: OldBigNumber[] } => {\n    let [selectedPaths, exceedingAmounts] = getBestPathIds(\n        allPaths,\n        swapType,\n        initialSwapAmounts,\n        inputDecimals,\n        outputDecimals,\n        costReturnToken\n    );\n\n    let swapAmounts = initialSwapAmounts;\n\n    // Trivial case of only allowing a single path\n    if (initialSwapAmounts.length === 1) {\n        return {\n            swapAmounts,\n            paths: selectedPaths,\n        };\n    }\n\n    const humanTotalSwapAmount = bnum(\n        formatFixed(totalSwapAmount, inputDecimals)\n    );\n\n    // We store the next set of paths to consider separately so that can always retrieve the previous paths\n    let newSelectedPaths = selectedPaths;\n\n    // We now loop to iterateSwapAmounts until we converge.\n    const historyOfSortedPathIds: string[] = [];\n    let sortedPathIdsJSON = JSON.stringify(\n        newSelectedPaths.map(({ id }) => id).sort()\n    );\n\n    while (!historyOfSortedPathIds.includes(sortedPathIdsJSON)) {\n        // Local minima can result in infinite loops\n        // We then maintain a log of the sorted paths ids which we have already considered to prevent getting stuck\n        historyOfSortedPathIds.push(sortedPathIdsJSON);\n        selectedPaths = newSelectedPaths;\n\n        [swapAmounts, exceedingAmounts] = iterateSwapAmounts(\n            selectedPaths,\n            swapType,\n            humanTotalSwapAmount,\n            swapAmounts,\n            exceedingAmounts\n        );\n        [newSelectedPaths, exceedingAmounts] = getBestPathIds(\n            allPaths,\n            swapType,\n            swapAmounts,\n            inputDecimals,\n            outputDecimals,\n            costReturnToken\n        );\n\n        if (newSelectedPaths.length === 0) break;\n\n        const pathIds = newSelectedPaths.map(({ id }) => id).sort();\n        sortedPathIdsJSON = JSON.stringify(pathIds);\n    }\n\n    return {\n        swapAmounts,\n        paths: selectedPaths,\n    };\n};\n\nexport const formatSwaps = (\n    bestPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    bestSwapAmounts: OldBigNumber[]\n): [Swap[][], OldBigNumber, OldBigNumber] => {\n    //// Prepare swap data from paths\n    const swaps: Swap[][] = [];\n    let highestSwapAmt = bestSwapAmounts[0];\n    let largestSwapPath: NewPath = bestPaths[0];\n    let bestTotalReturn = ZERO; // Reset totalReturn as this time it will be\n    // calculated with the EVM maths so the return is exactly what the user will get\n    // after executing the transaction (given there are no front-runners)\n\n    bestPaths.forEach((path, i) => {\n        const swapAmount = bestSwapAmounts[i];\n\n        if (swapAmount.gt(highestSwapAmt)) {\n            highestSwapAmt = swapAmount;\n            largestSwapPath = path;\n        }\n        // // TODO: remove. To debug only!\n        /*\n        console.log(\n            'Prices should be all very close (unless one of the paths is on the limit!'\n        );\n        console.log(\n            getSpotPriceAfterSwapForPath(path, swapType, swapAmount).toNumber()\n        );\n        */\n        const poolPairData = path.poolPairData;\n        const pathSwaps: Swap[] = [];\n        const amounts: OldBigNumber[] = [];\n        let returnAmount: OldBigNumber;\n        const n = poolPairData.length;\n        amounts.push(swapAmount);\n        if (swapType === SwapTypes.SwapExactIn) {\n            for (let i = 0; i < n; i++) {\n                amounts.push(\n                    EVMgetOutputAmountSwap(\n                        path.pools[i],\n                        poolPairData[i],\n                        SwapTypes.SwapExactIn,\n                        amounts[amounts.length - 1]\n                    )\n                );\n                const swap: Swap = {\n                    pool: path.swaps[i].pool,\n                    tokenIn: path.swaps[i].tokenIn,\n                    tokenOut: path.swaps[i].tokenOut,\n                    swapAmount: amounts[i].toString(),\n                    tokenInDecimals: path.poolPairData[i].decimalsIn,\n                    tokenOutDecimals: path.poolPairData[i].decimalsOut,\n                    returnAmount: amounts[amounts.length - 1].toString(),\n                };\n                pathSwaps.push(swap);\n            }\n            returnAmount = amounts[n];\n        } else {\n            for (let i = 0; i < n; i++) {\n                amounts.unshift(\n                    EVMgetOutputAmountSwap(\n                        path.pools[n - 1 - i],\n                        poolPairData[n - 1 - i],\n                        SwapTypes.SwapExactOut,\n                        amounts[0]\n                    )\n                );\n                const swap: Swap = {\n                    pool: path.swaps[n - 1 - i].pool,\n                    tokenIn: path.swaps[n - 1 - i].tokenIn,\n                    tokenOut: path.swaps[n - 1 - i].tokenOut,\n                    swapAmount: amounts[1].toString(),\n                    tokenInDecimals: path.poolPairData[n - 1 - i].decimalsIn,\n                    tokenOutDecimals: path.poolPairData[n - 1 - i].decimalsOut,\n                    returnAmount: amounts[0].toString(),\n                };\n                pathSwaps.unshift(swap);\n            }\n            returnAmount = amounts[0];\n        }\n        swaps.push(pathSwaps);\n        bestTotalReturn = bestTotalReturn.plus(returnAmount);\n    });\n\n    // Since the individual swapAmounts for each path are integers, the sum of all swapAmounts\n    // might not be exactly equal to the totalSwapAmount the user requested. We need to correct that rounding error\n    // and we do that by adding the rounding error to the first path.\n    if (swaps.length > 0) {\n        const totalSwapAmountWithRoundingErrors = bestSwapAmounts.reduce(\n            (a, b) => a.plus(b),\n            ZERO\n        );\n        const dust = totalSwapAmount.minus(totalSwapAmountWithRoundingErrors);\n        if (swapType === SwapTypes.SwapExactIn) {\n            // As swap is ExactIn, add dust to input pool\n            swaps[0][0].swapAmount = bnum(swaps[0][0].swapAmount as string)\n                .plus(dust)\n                .toString();\n        } else {\n            // As swap is ExactOut, add dust to output pool\n            const firstPathLastPoolIndex = bestPaths[0].swaps.length - 1;\n            swaps[0][firstPathLastPoolIndex].swapAmount = bnum(\n                swaps[0][firstPathLastPoolIndex].swapAmount as string\n            )\n                .plus(dust)\n                .toString();\n        }\n    }\n\n    if (bestTotalReturn.eq(0)) return [[], ZERO, ZERO];\n\n    const marketSp = getSpotPriceAfterSwapForPath(\n        largestSwapPath,\n        swapType,\n        ZERO\n    );\n\n    return [swaps, bestTotalReturn, marketSp];\n};\n\n//  For a given list of swapAmounts, gets list of pools with best effective price for these amounts\n//  Always choose best pool for highest swapAmount first, then 2nd swapAmount and so on. This is\n//  because it's best to use the best effective price for the highest amount to be traded\nfunction getBestPathIds(\n    originalPaths: NewPath[],\n    swapType: SwapTypes,\n    swapAmounts: OldBigNumber[],\n    inputDecimals: number,\n    outputDecimals: number,\n    costReturnToken: BigNumber\n): [NewPath[], OldBigNumber[]] {\n    const selectedPaths: NewPath[] = [];\n    const selectedPathExceedingAmounts: OldBigNumber[] = [];\n    const paths = cloneDeep(originalPaths); // Deep copy to avoid changing the original path data\n\n    // Sort swapAmounts in descending order without changing original: https://stackoverflow.com/a/42442909\n    const sortedSwapAmounts = [...swapAmounts].sort((a, b) => {\n        return b.minus(a).toNumber();\n    });\n\n    sortedSwapAmounts.forEach((swapAmount) => {\n        // Find path that has best effective price\n        let bestPathIndex = -1;\n        let bestEffectivePrice = INFINITY; // Start with worst price possible\n        paths.forEach((path, i) => {\n            // Do not consider this path if its limit is below swapAmount\n            if (\n                bnum(formatFixed(path.limitAmount, inputDecimals)).gte(\n                    swapAmount\n                )\n            ) {\n                // Calculate effective price of this path for this swapAmount\n                // If path.limitAmount = swapAmount we set effectivePrice as\n                // Infinity because we know this path is maxed out and we want\n                // to select other paths that can still be improved on\n                let effectivePrice: OldBigNumber;\n                if (\n                    bnum(formatFixed(path.limitAmount, inputDecimals)).eq(\n                        swapAmount\n                    )\n                ) {\n                    effectivePrice = INFINITY;\n                } else {\n                    // TODO for optimization: pass already calculated limitAmount as input\n                    // to getEffectivePriceSwapForPath()\n                    effectivePrice = getEffectivePriceSwapForPath(\n                        path,\n                        swapType,\n                        swapAmount,\n                        inputDecimals,\n                        outputDecimals,\n                        costReturnToken\n                    );\n                }\n                if (effectivePrice.lte(bestEffectivePrice)) {\n                    bestEffectivePrice = effectivePrice;\n                    bestPathIndex = i;\n                }\n            }\n        });\n\n        if (bestPathIndex === -1) {\n            selectedPaths.push({\n                id: '',\n                swaps: [],\n                poolPairData: [],\n                limitAmount: BigNumber.from('0'),\n                pools: [],\n            });\n            selectedPathExceedingAmounts.push(ZERO);\n            return;\n        } else {\n            selectedPaths.push(paths[bestPathIndex]);\n            selectedPathExceedingAmounts.push(\n                swapAmount.minus(\n                    bnum(\n                        formatFixed(\n                            paths[bestPathIndex].limitAmount,\n                            inputDecimals\n                        )\n                    )\n                )\n            );\n            paths.splice(bestPathIndex, 1); // Remove path from list\n        }\n    });\n\n    return [selectedPaths, selectedPathExceedingAmounts];\n}\n\n// This functions finds the swapAmounts such that all the paths that have viable swapAmounts (i.e.\n// that are not negative or equal to limitAmount) bring their respective prices after swap to the\n// same price (which means that this is the optimal solution for the paths analyzed)\nfunction iterateSwapAmounts(\n    selectedPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[]\n): [OldBigNumber[], OldBigNumber[]] {\n    let priceError = ONE; // Initialize priceError just so that while starts\n    let prices: OldBigNumber[] = [];\n    // // Since this is the beginning of an iteration with a new set of paths, we\n    // // set any swapAmounts that were 0 previously to 1 wei or at the limit\n    // // to limit minus 1 wei just so that they\n    // // are considered as viable for iterateSwapAmountsApproximation(). If they were\n    // // left at 0 iterateSwapAmountsApproximation() would consider them already outside\n    // // the viable range and would not iterate on them. This is useful when\n    // // iterateSwapAmountsApproximation() is being repeatedly called within the while loop\n    // // below, but not when a new execution of iterateSwapAmounts() happens with new\n    // // paths.\n    // for (let i = 0; i < swapAmounts.length; ++i) {\n    //     if (swapAmounts[i].isZero()) {\n    //         // Very small amount: TODO put in config file\n    //         const epsilon = totalSwapAmount.times(INFINITESIMAL);\n    //         swapAmounts[i] = epsilon;\n    //         exceedingAmounts[i] = exceedingAmounts[i].plus(epsilon);\n    //     }\n    //     if (exceedingAmounts[i].isZero()) {\n    //         // Very small amount: TODO put in config file\n    //         const epsilon = totalSwapAmount.times(INFINITESIMAL);\n    //         swapAmounts[i] = swapAmounts[i].minus(epsilon); // Very small amount\n    //         exceedingAmounts[i] = exceedingAmounts[i].minus(epsilon);\n    //     }\n    // }\n    let iterationCount = 0;\n    while (priceError.isGreaterThan(PRICE_ERROR_TOLERANCE)) {\n        [prices, swapAmounts, exceedingAmounts] =\n            iterateSwapAmountsApproximation(\n                selectedPaths,\n                swapType,\n                totalSwapAmount,\n                swapAmounts,\n                exceedingAmounts,\n                iterationCount\n            );\n        const maxPrice = OldBigNumber.max.apply(null, prices);\n        const minPrice = OldBigNumber.min.apply(null, prices);\n        priceError = maxPrice.minus(minPrice).div(minPrice);\n        iterationCount++;\n        if (iterationCount > 100) break;\n    }\n    return [swapAmounts, exceedingAmounts];\n}\n\nfunction iterateSwapAmountsApproximation(\n    selectedPaths: NewPath[],\n    swapType: SwapTypes,\n    totalSwapAmount: OldBigNumber,\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[], // This is the amount by which swapAmount exceeds the pool limit_amount\n    iterationCount: number\n): [OldBigNumber[], OldBigNumber[], OldBigNumber[]] {\n    let sumInverseDerivativeSPaSs = ZERO;\n    let sumSPaSDividedByDerivativeSPaSs = ZERO;\n    const SPaSs: OldBigNumber[] = [];\n    const derivativeSPaSs: OldBigNumber[] = [];\n\n    // We only iterate on the swapAmounts that are viable (i.e. no negative or > than path limit)\n    // OR if this is the first time \"iterateSwapAmountsApproximation\" is called\n    // within \"iterateSwapAmounts()\". In this case swapAmounts should be considered viable\n    // also if they are on the limit.\n    swapAmounts.forEach((swapAmount, i) => {\n        // if (swapAmount.gt(ZERO) && exceedingAmounts[i].lt(ZERO)) {\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        ) {\n            const path = selectedPaths[i];\n            const SPaS = getSpotPriceAfterSwapForPath(\n                path,\n                swapType,\n                swapAmount\n            );\n            SPaSs.push(SPaS);\n            const derivative_SPaS = getDerivativeSpotPriceAfterSwapForPath(\n                path,\n                swapType,\n                swapAmount\n            );\n            derivativeSPaSs.push(derivative_SPaS);\n            sumInverseDerivativeSPaSs = sumInverseDerivativeSPaSs.plus(\n                ONE.div(derivative_SPaS)\n            );\n            sumSPaSDividedByDerivativeSPaSs =\n                sumSPaSDividedByDerivativeSPaSs.plus(SPaS.div(derivative_SPaS));\n        } else {\n            // This swapAmount is not viable but we push to keep list length consistent\n            derivativeSPaSs.push(bnum('NaN'));\n            SPaSs.push(bnum('NaN'));\n        }\n    });\n    // // This division using BigNumber below lost precision. Its result was for example\n    // 1.042818e-12 while using normal js math operations it was\n    // 1.0428184989387553e-12. This loss of precision caused an important bug\n\n    // let weighted_average_SPaS = sumSPaSDividedByDerivativeSPaSs.div(\n    //     sumInverseDerivativeSPaSs\n    // );\n    const weighted_average_SPaS = bnum(\n        sumSPaSDividedByDerivativeSPaSs.toNumber() /\n            sumInverseDerivativeSPaSs.toNumber()\n    );\n\n    swapAmounts.forEach((swapAmount, i) => {\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        ) {\n            const deltaSwapAmount = weighted_average_SPaS\n                .minus(SPaSs[i])\n                .div(derivativeSPaSs[i]);\n            swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n            exceedingAmounts[i] = exceedingAmounts[i].plus(deltaSwapAmount);\n        }\n    });\n\n    // Make sure no input amount is negative or above the path limit\n    while (\n        OldBigNumber.min.apply(null, swapAmounts).lt(ZERO) ||\n        OldBigNumber.max.apply(null, exceedingAmounts).gt(ZERO)\n    ) {\n        [swapAmounts, exceedingAmounts] = redistributeInputAmounts(\n            swapAmounts,\n            exceedingAmounts,\n            derivativeSPaSs\n        );\n    }\n\n    const pricesForViableAmounts: OldBigNumber[] = []; // Get prices for all non-negative AND below-limit input amounts\n    let swapAmountsSumWithRoundingErrors = ZERO;\n    swapAmounts.forEach((swapAmount, i) => {\n        swapAmountsSumWithRoundingErrors =\n            swapAmountsSumWithRoundingErrors.plus(swapAmount);\n        if (\n            (iterationCount == 0 &&\n                swapAmount.gte(ZERO) &&\n                exceedingAmounts[i].lte(ZERO)) ||\n            (iterationCount != 0 &&\n                swapAmount.gt(ZERO) &&\n                exceedingAmounts[i].lt(ZERO))\n        )\n            pricesForViableAmounts.push(\n                getSpotPriceAfterSwapForPath(\n                    selectedPaths[i],\n                    swapType,\n                    swapAmount\n                )\n            );\n    });\n\n    const roundingError = totalSwapAmount.minus(\n        swapAmountsSumWithRoundingErrors\n    );\n    // console.log(\"Rounding error\")\n    // console.log(roundingError.div(totalSwapAmount).toNumber())\n    // // let errorLimit = totalSwapAmount.times(bnum(0.001))\n    // // if(roundingError>errorLimit)\n    // //     throw \"Rounding error in iterateSwapAmountsApproximation() too large\";\n\n    // Add rounding error to make sum be exactly equal to totalSwapAmount to avoid error compounding\n    // Add to the first swapAmount that is already not zero or at the limit\n    // AND only if swapAmount would not leave the viable range (i.e. swapAmoung\n    // would still be >0 and <limit) after adding the error\n    // I.d. we need: (swapAmount+error)>0 AND (exceedingAmount+error)<0\n    for (let i = 0; i < swapAmounts.length; ++i) {\n        if (swapAmounts[i].gt(ZERO) && exceedingAmounts[i].lt(ZERO)) {\n            if (\n                swapAmounts[i].plus(roundingError).gt(ZERO) &&\n                exceedingAmounts[i].plus(roundingError).lt(ZERO)\n            ) {\n                swapAmounts[i] = swapAmounts[i].plus(roundingError);\n                exceedingAmounts[i] = exceedingAmounts[i].plus(roundingError);\n                break;\n            }\n        }\n    }\n\n    return [pricesForViableAmounts, swapAmounts, exceedingAmounts];\n}\n\nfunction redistributeInputAmounts(\n    swapAmounts: OldBigNumber[],\n    exceedingAmounts: OldBigNumber[],\n    derivativeSPaSs: OldBigNumber[]\n): [OldBigNumber[], OldBigNumber[]] {\n    let sumInverseDerivativeSPaSsForViableAmounts = ZERO;\n    let sumInverseDerivativeSPaSsForNegativeAmounts = ZERO;\n    let sumInverseDerivativeSPaSsForExceedingAmounts = ZERO;\n    let sumNegativeOrExceedingSwapAmounts = ZERO;\n    swapAmounts.forEach((swapAmount, i) => {\n        // Amount is negative\n        if (swapAmount.lte(ZERO)) {\n            sumNegativeOrExceedingSwapAmounts =\n                sumNegativeOrExceedingSwapAmounts.plus(swapAmount);\n            sumInverseDerivativeSPaSsForNegativeAmounts =\n                sumInverseDerivativeSPaSsForNegativeAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n        }\n        // Amount is above limit (exceeding > 0)\n        else if (exceedingAmounts[i].gte(ZERO)) {\n            sumNegativeOrExceedingSwapAmounts =\n                sumNegativeOrExceedingSwapAmounts.plus(exceedingAmounts[i]);\n            sumInverseDerivativeSPaSsForExceedingAmounts =\n                sumInverseDerivativeSPaSsForExceedingAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n        }\n        // Sum the inverse of the derivative if the swapAmount is viable,\n        // i.e. if swapAmount > 0 or swapAmount < limit\n        else\n            sumInverseDerivativeSPaSsForViableAmounts =\n                sumInverseDerivativeSPaSsForViableAmounts.plus(\n                    ONE.div(derivativeSPaSs[i])\n                );\n    });\n\n    // Now redestribute sumNegativeOrExceedingSwapAmounts\n    // to non-exceeding pools if sumNegativeOrExceedingSwapAmounts > 0\n    // or to non zero swapAmount pools if sumNegativeOrExceedingSwapAmounts < 0\n    swapAmounts.forEach((swapAmount, i) => {\n        if (swapAmount.lte(ZERO)) {\n            swapAmounts[i] = ZERO;\n            exceedingAmounts[i] = exceedingAmounts[i].minus(swapAmount);\n        } else if (exceedingAmounts[i].gte(ZERO)) {\n            swapAmounts[i] = swapAmounts[i].minus(exceedingAmounts[i]); // This is the same as swapAmounts[i] = pathLimitAmounts[i]\n            exceedingAmounts[i] = ZERO;\n        } else {\n            const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                .times(ONE.div(derivativeSPaSs[i]))\n                .div(sumInverseDerivativeSPaSsForViableAmounts);\n            swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n            exceedingAmounts[i] = exceedingAmounts[i].plus(deltaSwapAmount);\n        }\n    });\n\n    // If there were no viable amounts (i.e all amounts were either negative or above limit)\n    // We run this extra loop to redistribute the excess\n    if (sumInverseDerivativeSPaSsForViableAmounts.isZero()) {\n        if (sumNegativeOrExceedingSwapAmounts.lt(ZERO)) {\n            // This means we need to redistribute to the exceeding amounts that\n            // were now set to the limit\n            swapAmounts.forEach((swapAmount, i) => {\n                if (exceedingAmounts[i].isZero()) {\n                    const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                        .times(ONE.div(derivativeSPaSs[i]))\n                        .div(sumInverseDerivativeSPaSsForExceedingAmounts);\n                    swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n                    exceedingAmounts[i] =\n                        exceedingAmounts[i].plus(deltaSwapAmount);\n                }\n            });\n        } else {\n            // This means we need to redistribute to the negative amounts that\n            // were now set to zero\n            swapAmounts.forEach((swapAmount, i) => {\n                if (swapAmounts[i].isZero()) {\n                    const deltaSwapAmount = sumNegativeOrExceedingSwapAmounts\n                        .times(ONE.div(derivativeSPaSs[i]))\n                        .div(sumInverseDerivativeSPaSsForNegativeAmounts);\n                    swapAmounts[i] = swapAmounts[i].plus(deltaSwapAmount);\n                    exceedingAmounts[i] =\n                        exceedingAmounts[i].plus(deltaSwapAmount);\n                }\n            });\n        }\n    }\n    return [swapAmounts, exceedingAmounts];\n}\n\n// TODO: calculate EVM return (use bmath) and update pool balances like current SOR\nexport const calcTotalReturn = (\n    paths: NewPath[],\n    swapType: SwapTypes,\n    swapAmounts: OldBigNumber[],\n    inputDecimals: number\n): OldBigNumber => {\n    let totalReturn = new OldBigNumber(0);\n    // changing the contents of pools (parameter passed as reference)\n    paths.forEach((path, i) => {\n        totalReturn = totalReturn.plus(\n            getOutputAmountSwapForPath(\n                path,\n                swapType,\n                swapAmounts[i],\n                inputDecimals\n            )\n        );\n    });\n    return totalReturn;\n};\n"],"names":["optimizeSwapAmounts","paths","swapType","totalSwapAmount","initialSwapAmounts","highestLimitAmounts","inputDecimals","outputDecimals","initialNumPaths","maxPools","costReturnToken","bestTotalReturnConsideringFees","SwapTypes","SwapExactIn","INFINITY","times","bestSwapAmounts","bestPaths","swapAmounts","map","amount","bnum","formatFixed","b","length","humanTotalSwapAmount","newSwapAmount","OldBigNumber","min","apply","forEach","swapAmount","i","ONE","minus","div","isZero","push","selectedPaths","bestAmounts","optimizePathDistribution","totalReturn","calcTotalReturn","totalNumberOfPools","reduce","acc","path","swaps","costReturnTokenHuman","improvementCondition","totalReturnConsideringFees","ZERO","gasFees","isGreaterThan","plus","isLessThan","filter","_","allPaths","exceedingAmounts","getBestPathIds","newSelectedPaths","historyOfSortedPathIds","sortedPathIdsJSON","JSON","stringify","id","sort","includes","iterateSwapAmounts","pathIds","formatSwaps","highestSwapAmt","largestSwapPath","bestTotalReturn","gt","poolPairData","pathSwaps","amounts","returnAmount","n","EVMgetOutputAmountSwap","pools","swap","pool","tokenIn","tokenOut","toString","tokenInDecimals","decimalsIn","tokenOutDecimals","decimalsOut","unshift","SwapExactOut","totalSwapAmountWithRoundingErrors","a","dust","firstPathLastPoolIndex","eq","marketSp","getSpotPriceAfterSwapForPath","originalPaths","selectedPathExceedingAmounts","cloneDeep","toNumber","bestPathIndex","bestEffectivePrice","limitAmount","gte","effectivePrice","getEffectivePriceSwapForPath","lte","BigNumber","from","splice","priceError","prices","iterationCount","PRICE_ERROR_TOLERANCE","iterateSwapAmountsApproximation","maxPrice","max","minPrice","sumInverseDerivativeSPaSs","sumSPaSDividedByDerivativeSPaSs","SPaSs","derivativeSPaSs","lt","SPaS","derivative_SPaS","getDerivativeSpotPriceAfterSwapForPath","weighted_average_SPaS","deltaSwapAmount","redistributeInputAmounts","pricesForViableAmounts","swapAmountsSumWithRoundingErrors","roundingError","sumInverseDerivativeSPaSsForViableAmounts","sumInverseDerivativeSPaSsForNegativeAmounts","sumInverseDerivativeSPaSsForExceedingAmounts","sumNegativeOrExceedingSwapAmounts","getOutputAmountSwapForPath"],"mappings":"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"}