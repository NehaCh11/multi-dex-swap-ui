{"version":3,"file":"wrapper.js","sources":["../../../../src/wrapper.ts"],"sourcesContent":["import { BigNumber, BigNumberish, parseFixed } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport cloneDeep from 'lodash.clonedeep';\nimport { BigNumber as OldBigNumber } from './utils/bignumber';\nimport { getBestPaths } from './router';\nimport { getWrappedInfo, setWrappedInfo } from './wrapInfo';\nimport { formatSwaps } from './formatSwaps';\nimport { PoolCacher } from './poolCacher';\nimport { RouteProposer } from './routeProposal';\nimport { filterPoolsByType } from './routeProposal/filtering';\nimport { SwapCostCalculator } from './swapCostCalculator';\nimport { getLidoStaticSwaps, isLidoStableSwap } from './pools/lido';\nimport { isSameAddress } from './utils';\nimport { EMPTY_SWAPINFO } from './constants';\nimport {\n    SwapInfo,\n    SwapTypes,\n    NewPath,\n    PoolFilter,\n    Swap,\n    SubgraphPoolBase,\n    SwapOptions,\n    TokenPriceService,\n    PoolDataService,\n    SorConfig,\n} from './types';\nimport { Zero } from '@ethersproject/constants';\n\nexport class SOR {\n    private readonly poolCacher: PoolCacher;\n    public readonly routeProposer: RouteProposer;\n    readonly swapCostCalculator: SwapCostCalculator;\n    private useBpt: boolean;\n\n    private readonly defaultSwapOptions: SwapOptions = {\n        gasPrice: parseFixed('50', 9),\n        swapGas: BigNumber.from('85000'),\n        poolTypeFilter: PoolFilter.All,\n        maxPools: 4,\n        timestamp: Math.floor(Date.now() / 1000),\n        forceRefresh: false,\n    };\n\n    /**\n     * @param {Provider} provider - Provider.\n     * @param {SorConfig} config - Chain specific configuration for the SOR.\n     * @param {PoolDataService} poolDataService - Generic service that fetches pool data from an external data source.\n     * @param {TokenPriceService} tokenPriceService - Generic service that fetches token prices from an external price feed. Used in calculating swap cost.\n     */\n    constructor(\n        public provider: Provider,\n        private readonly config: SorConfig,\n        poolDataService: PoolDataService,\n        tokenPriceService: TokenPriceService\n    ) {\n        this.poolCacher = new PoolCacher(poolDataService);\n        this.routeProposer = new RouteProposer(config);\n        this.swapCostCalculator = new SwapCostCalculator(\n            config,\n            tokenPriceService\n        );\n    }\n\n    getPools(useBpts?: boolean): SubgraphPoolBase[] {\n        return this.poolCacher.getPools(useBpts);\n    }\n\n    /**\n     * fetchPools Retrieves pools information and saves to internal pools cache.\n     * @returns {boolean} True if pools fetched successfully, False if not.\n     */\n    async fetchPools(): Promise<boolean> {\n        return this.poolCacher.fetchPools();\n    }\n\n    /**\n     * getSwaps Retrieve information for best swap tokenIn>tokenOut.\n     * @param {string} tokenIn - Address of tokenIn.\n     * @param {string} tokenOut - Address of tokenOut.\n     * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n     * @param {BigNumberish} swapAmount - Either amountIn or amountOut depending on the `swapType` value.\n     * @param swapOptions\n     * @param useBpts Set to true to consider join/exit weighted pool paths (these will need formatted and submitted via Relayer)\n     * @returns Swap information including return amount and swaps structure to be submitted to Vault.\n     */\n    async getSwaps(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        swapAmount: BigNumberish,\n        swapOptions?: Partial<SwapOptions>,\n        useBpts = false\n    ): Promise<SwapInfo> {\n        if (!this.poolCacher.finishedFetching) return cloneDeep(EMPTY_SWAPINFO);\n\n        // Set any unset options to their defaults\n        const options: SwapOptions = {\n            ...this.defaultSwapOptions,\n            ...swapOptions,\n        };\n        if (this.useBpt !== useBpts) {\n            options.forceRefresh = true;\n            this.useBpt = useBpts;\n        }\n        const pools: SubgraphPoolBase[] = this.poolCacher.getPools(useBpts);\n        const filteredPools = filterPoolsByType(pools, options.poolTypeFilter);\n\n        const wrappedInfo = await getWrappedInfo(\n            this.provider,\n            swapType,\n            tokenIn,\n            tokenOut,\n            this.config,\n            BigNumber.from(swapAmount)\n        );\n\n        let swapInfo: SwapInfo;\n        if (isLidoStableSwap(this.config.chainId, tokenIn, tokenOut)) {\n            swapInfo = await getLidoStaticSwaps(\n                filteredPools,\n                this.config.chainId,\n                wrappedInfo.tokenIn.addressForSwaps,\n                wrappedInfo.tokenOut.addressForSwaps,\n                swapType,\n                wrappedInfo.swapAmountForSwaps,\n                this.provider\n            );\n        } else {\n            swapInfo = await this.processSwaps(\n                wrappedInfo.tokenIn.addressForSwaps,\n                wrappedInfo.tokenOut.addressForSwaps,\n                swapType,\n                wrappedInfo.swapAmountForSwaps,\n                filteredPools,\n                options\n            );\n        }\n\n        if (swapInfo.returnAmount.isZero()) return swapInfo;\n\n        swapInfo = setWrappedInfo(swapInfo, swapType, wrappedInfo, this.config);\n\n        return swapInfo;\n    }\n    /**\n     * getCostOfSwapInToken Calculates and saves price of a swap in outputToken denomination. Used to determine if extra swaps are cost effective.\n     * @param {string} outputToken - Address of outputToken.\n     * @param {number} outputTokenDecimals - Decimals of outputToken.\n     * @param {BigNumber} gasPrice - Gas price used to calculate cost.\n     * @param {BigNumber} swapGas - Gas cost of a swap. Default=85000.\n     * @returns {BigNumber} Price of a swap in outputToken denomination.\n     */\n    async getCostOfSwapInToken(\n        outputToken: string,\n        outputTokenDecimals: number,\n        gasPrice: BigNumber,\n        swapGas?: BigNumber\n    ): Promise<BigNumber> {\n        if (gasPrice.isZero()) return Zero;\n        return this.swapCostCalculator.convertGasCostToToken(\n            outputToken,\n            outputTokenDecimals,\n            gasPrice,\n            swapGas\n        );\n    }\n\n    // Will process swap/pools data and return best swaps\n    private async processSwaps(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        swapAmount: BigNumber,\n        pools: SubgraphPoolBase[],\n        swapOptions: SwapOptions\n    ): Promise<SwapInfo> {\n        if (pools.length === 0) return cloneDeep(EMPTY_SWAPINFO);\n\n        const paths = this.routeProposer.getCandidatePaths(\n            tokenIn,\n            tokenOut,\n            swapType,\n            pools,\n            swapOptions\n        );\n\n        if (paths.length == 0) return cloneDeep(EMPTY_SWAPINFO);\n\n        // Path is guaranteed to contain both tokenIn and tokenOut\n        let tokenInDecimals;\n        let tokenOutDecimals;\n        paths[0].swaps.forEach((swap) => {\n            // Inject token decimals to avoid having to query onchain\n            if (isSameAddress(swap.tokenIn, tokenIn)) {\n                tokenInDecimals = swap.tokenInDecimals;\n            }\n            if (isSameAddress(swap.tokenOut, tokenOut)) {\n                tokenOutDecimals = swap.tokenOutDecimals;\n            }\n        });\n\n        const costOutputToken = await this.getCostOfSwapInToken(\n            swapType === SwapTypes.SwapExactIn ? tokenOut : tokenIn,\n            swapType === SwapTypes.SwapExactIn\n                ? tokenOutDecimals\n                : tokenInDecimals,\n            swapOptions.gasPrice,\n            swapOptions.swapGas\n        );\n\n        // Returns list of swaps\n        const [swaps, total, marketSp, totalConsideringFees] =\n            this.getBestPaths(\n                paths,\n                swapAmount,\n                swapType,\n                tokenInDecimals,\n                tokenOutDecimals,\n                costOutputToken,\n                swapOptions.maxPools\n            );\n\n        const swapInfo = formatSwaps(\n            swaps,\n            swapType,\n            swapAmount,\n            tokenIn,\n            tokenOut,\n            total,\n            totalConsideringFees,\n            marketSp\n        );\n\n        return swapInfo;\n    }\n\n    /**\n     * Find optimal routes for trade from given candidate paths\n     */\n    private getBestPaths(\n        paths: NewPath[],\n        swapAmount: BigNumber,\n        swapType: SwapTypes,\n        tokenInDecimals: number,\n        tokenOutDecimals: number,\n        costOutputToken: BigNumber,\n        maxPools: number\n    ): [Swap[][], BigNumber, string, BigNumber] {\n        // swapExactIn - total = total amount swap will return of tokenOut\n        // swapExactOut - total = total amount of tokenIn required for swap\n\n        const [inputDecimals, outputDecimals] =\n            swapType === SwapTypes.SwapExactIn\n                ? [tokenInDecimals, tokenOutDecimals]\n                : [tokenOutDecimals, tokenInDecimals];\n\n        const [swaps, total, marketSp, totalConsideringFees] = getBestPaths(\n            paths,\n            swapType,\n            swapAmount,\n            inputDecimals,\n            outputDecimals,\n            maxPools,\n            costOutputToken\n        );\n\n        return [\n            swaps,\n            parseFixed(\n                total.dp(outputDecimals, OldBigNumber.ROUND_FLOOR).toString(),\n                outputDecimals\n            ),\n            marketSp.toString(),\n            parseFixed(\n                totalConsideringFees\n                    .dp(outputDecimals, OldBigNumber.ROUND_FLOOR)\n                    .toString(),\n                outputDecimals\n            ),\n        ];\n    }\n}\n"],"names":["SOR","constructor","provider","config","poolDataService","tokenPriceService","this","defaultSwapOptions","gasPrice","parseFixed","swapGas","BigNumber","from","poolTypeFilter","PoolFilter","All","maxPools","timestamp","Math","floor","Date","now","forceRefresh","poolCacher","PoolCacher","routeProposer","RouteProposer","swapCostCalculator","SwapCostCalculator","getPools","useBpts","fetchPools","getSwaps","tokenIn","tokenOut","swapType","swapAmount","swapOptions","finishedFetching","cloneDeep","EMPTY_SWAPINFO","options","useBpt","pools","filteredPools","filterPoolsByType","wrappedInfo","getWrappedInfo","swapInfo","isLidoStableSwap","chainId","getLidoStaticSwaps","addressForSwaps","swapAmountForSwaps","processSwaps","returnAmount","isZero","setWrappedInfo","getCostOfSwapInToken","outputToken","outputTokenDecimals","Zero","convertGasCostToToken","length","paths","getCandidatePaths","tokenInDecimals","tokenOutDecimals","swaps","forEach","swap","isSameAddress","costOutputToken","SwapTypes","SwapExactIn","total","marketSp","totalConsideringFees","getBestPaths","formatSwaps","inputDecimals","outputDecimals","dp","OldBigNumber","ROUND_FLOOR","toString"],"mappings":"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"}