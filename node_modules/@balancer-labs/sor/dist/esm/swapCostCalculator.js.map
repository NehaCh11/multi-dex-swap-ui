{"version":3,"file":"swapCostCalculator.js","sources":["../../../../src/swapCostCalculator.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { bnum, scale } from './utils/bignumber';\nimport { SorConfig, TokenPriceService } from './types';\n\nexport class SwapCostCalculator {\n    private readonly tokenPriceCache: Record<string, string>;\n\n    constructor(\n        config: SorConfig,\n        private readonly tokenPriceService: TokenPriceService\n    ) {\n        this.tokenPriceCache = {\n            AddressZero: '1',\n            [config.weth.toLowerCase()]: '1',\n        };\n    }\n\n    /**\n     * Calculate the cost of spending a certain amount of gas in terms of a token.\n     * This allows us to determine whether an increased amount of tokens gained\n     * is worth spending this extra gas (e.g. by including an extra pool in a swap)\n     */\n    public async convertGasCostToToken(\n        tokenAddress: string,\n        tokenDecimals: number,\n        gasPriceWei: BigNumber,\n        swapGas: BigNumber = BigNumber.from('85000')\n    ): Promise<BigNumber> {\n        if (gasPriceWei.isZero() || swapGas.isZero()) return Zero;\n        const tokenPrice = await this.getNativeAssetPriceInToken(tokenAddress);\n        const tokenPriceWei = BigNumber.from(\n            scale(bnum(tokenPrice), tokenDecimals).dp(0).toString()\n        );\n\n        return gasPriceWei.mul(swapGas).mul(tokenPriceWei).div(ONE);\n    }\n\n    /**\n     * @param tokenAddress - the address of the token for which to express the native asset in terms of\n     * @param tokenPrice - the price of the native asset in terms of the provided token\n     */\n    public setNativeAssetPriceInToken(\n        tokenAddress: string,\n        tokenPrice: string\n    ): void {\n        this.tokenPriceCache[tokenAddress.toLowerCase()] = tokenPrice;\n    }\n\n    /**\n     * @param tokenAddress - the address of the token for which to express the native asset in terms of\n     */\n    private async getNativeAssetPriceInToken(\n        tokenAddress: string\n    ): Promise<string> {\n        // Check if we have token price cached\n        const cachedTokenPrice =\n            this.tokenPriceCache[tokenAddress.toLowerCase()];\n        if (cachedTokenPrice) return cachedTokenPrice;\n\n        try {\n            const ethPriceInToken =\n                await this.tokenPriceService.getNativeAssetPriceInToken(\n                    tokenAddress\n                );\n\n            //cache the price so we don't need to refetch it\n            this.setNativeAssetPriceInToken(tokenAddress, ethPriceInToken);\n\n            return ethPriceInToken;\n        } catch (err) {\n            console.log('Error Getting Token Price. Defaulting to 0.');\n            console.log(err);\n            return '0';\n        }\n    }\n}\n"],"names":["SwapCostCalculator","constructor","config","tokenPriceService","this","tokenPriceCache","AddressZero","weth","toLowerCase","convertGasCostToToken","tokenAddress","tokenDecimals","gasPriceWei","swapGas","BigNumber","from","isZero","Zero","tokenPrice","getNativeAssetPriceInToken","tokenPriceWei","scale","bnum","dp","toString","mul","div","ONE","setNativeAssetPriceInToken","cachedTokenPrice","ethPriceInToken","err","console","log"],"mappings":"6OAKaA,EAGTC,YACIC,EACiBC,GAAAC,KAAiBD,kBAAjBA,EAEjBC,KAAKC,gBAAkB,CACnBC,YAAa,IACb,CAACJ,EAAOK,KAAKC,eAAgB,IAEpC,CAOYC,sBACTC,EACAC,EACAC,EACAC,EAAqBC,EAAUC,KAAK,mDAEpC,GAAIH,EAAYI,UAAYH,EAAQG,SAAU,OAAOC,EACrD,MAAMC,QAAmBd,KAAKe,2BAA2BT,GACnDU,EAAgBN,EAAUC,KAC5BM,EAAMC,EAAKJ,GAAaP,GAAeY,GAAG,GAAGC,YAGjD,OAAOZ,EAAYa,IAAIZ,GAASY,IAAIL,GAAeM,IAAIC,KAC1D,CAMMC,2BACHlB,EACAQ,GAEAd,KAAKC,gBAAgBK,EAAaF,eAAiBU,CACtD,CAKaC,2BACVT,4CAGA,MAAMmB,EACFzB,KAAKC,gBAAgBK,EAAaF,eACtC,GAAIqB,EAAkB,OAAOA,EAE7B,IACI,MAAMC,QACI1B,KAAKD,kBAAkBgB,2BACzBT,GAMR,OAFAN,KAAKwB,2BAA2BlB,EAAcoB,GAEvCA,CACV,CAAC,MAAOC,GAGL,OAFAC,QAAQC,IAAI,+CACZD,QAAQC,IAAIF,GACL,GACV,IACJ"}