{"version":3,"file":"formatSwaps.js","sources":["../../../../src/formatSwaps.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport cloneDeep from 'lodash.clonedeep';\nimport { bnum, scale } from './utils/bignumber';\nimport { EMPTY_SWAPINFO } from './constants';\nimport { SwapTypes, SwapV2, Swap, SwapInfo } from './types';\nimport { Zero } from '@ethersproject/constants';\n\n/**\n * @returns an array of deduplicated token addresses used in the provided swaps\n */\nconst getTokenAddresses = (swaps: Swap[][]): string[] => {\n    const tokenAddressesSet: Set<string> = new Set(\n        swaps.flatMap((sequence) =>\n            sequence.flatMap((swap): [string, string] => [\n                swap.tokenIn,\n                swap.tokenOut,\n            ])\n        )\n    );\n\n    return [...tokenAddressesSet];\n};\n\n/**\n * @returns an array of deduplicated token addresses used in the provided swaps\n */\nexport const getTokenAddressesForSwap = (swaps: Swap[]): string[] => {\n    const tokenAddressesSet: Set<string> = new Set(\n        swaps.flatMap((swap): [string, string] => [swap.tokenIn, swap.tokenOut])\n    );\n\n    return [...tokenAddressesSet];\n};\n\n/**\n * @dev Assumes that intermediate swaps have been properly formatted using the zero sentinel value\n * @returns the total amount of tokens used in the described batchSwap\n */\nconst getTotalSwapAmount = (swaps: SwapV2[]) => {\n    return swaps.reduce((acc, { amount }) => acc.add(amount), Zero);\n};\n\n/**\n * Formats a sequence of swaps to the format expected by the Balance Vault.\n * @dev Intermediate swaps' amounts are replaced with the sentinel value of zero\n *      and exact output sequences are reversed.\n * @param swapKind - a SwapTypes enum for whether the swap has an exact input or exact output\n * @param sequence - a sequence of swaps which form a path from the input token to the output token\n * @param tokenAddresses - an array of all the token address which are involved in the batchSwap\n * @returns\n */\nexport const formatSequence = (\n    swapKind: SwapTypes,\n    sequence: Swap[],\n    tokenAddresses: string[]\n): SwapV2[] => {\n    if (swapKind === SwapTypes.SwapExactOut) {\n        // GIVEN_OUT sequences must be passed to the vault in reverse order.\n        // After reversing the sequence we can treat them almost equivalently to GIVEN_IN sequences\n        sequence = sequence.reverse();\n    }\n\n    return sequence.map((swap, i) => {\n        // Multihop swaps can be executed by passing an `amountIn` value of zero for a swap. This will cause the amount out\n        // of the previous swap to be used as the amount in of the current one. In such a scenario, `tokenIn` must equal the\n        // previous swap's `tokenOut`.\n        let amountScaled = '0';\n\n        // First swap needs to be given a value so we inject this from SOR solution\n        if (i === 0) {\n            // If it's a GIVEN_IN swap then swapAmount is in terms of tokenIn\n            // and vice versa for GIVEN_OUT\n            const scalingFactor =\n                swapKind === SwapTypes.SwapExactIn\n                    ? swap.tokenInDecimals\n                    : swap.tokenOutDecimals;\n\n            amountScaled = scale(bnum(swap.swapAmount as string), scalingFactor)\n                .decimalPlaces(0, 1)\n                .toString();\n        }\n        const scalingFactorReturn =\n            swapKind === SwapTypes.SwapExactIn\n                ? swap.tokenOutDecimals\n                : swap.tokenInDecimals;\n\n        const returnScaled = scale(\n            bnum(swap.returnAmount ?? '0'),\n            scalingFactorReturn\n        )\n            .decimalPlaces(0, 1)\n            .toString();\n\n        const assetInIndex = tokenAddresses.indexOf(swap.tokenIn);\n        const assetOutIndex = tokenAddresses.indexOf(swap.tokenOut);\n        return {\n            poolId: swap.pool,\n            assetInIndex,\n            assetOutIndex,\n            amount: amountScaled,\n            userData: '0x',\n            returnAmount: returnScaled,\n        };\n    });\n};\n\nexport function formatSwaps(\n    swapsOriginal: Swap[][],\n    swapType: SwapTypes,\n    swapAmount: BigNumber,\n    tokenIn: string,\n    tokenOut: string,\n    returnAmount: BigNumber,\n    returnAmountConsideringFees: BigNumber,\n    marketSp: string\n): SwapInfo {\n    if (swapsOriginal.length === 0) {\n        return cloneDeep(EMPTY_SWAPINFO);\n    }\n\n    const swapsClone = cloneDeep(swapsOriginal);\n    const tokenAddresses = getTokenAddresses(swapsClone);\n    const swaps: SwapV2[] = swapsClone.flatMap((sequence) =>\n        formatSequence(swapType, sequence, tokenAddresses)\n    );\n\n    // We need to account for any rounding losses by adding dust to first path\n    const dust = swapAmount.sub(getTotalSwapAmount(swaps));\n    if (dust.gt(0)) {\n        swaps[0].amount = BigNumber.from(swaps[0].amount).add(dust).toString();\n    }\n\n    const swapInfo: SwapInfo = {\n        swapAmount,\n        swapAmountForSwaps: swapAmount,\n        returnAmount,\n        returnAmountFromSwaps: returnAmount,\n        returnAmountConsideringFees,\n        swaps,\n        tokenAddresses,\n        tokenIn,\n        tokenOut,\n        marketSp,\n    };\n\n    return swapInfo;\n}\n"],"names":["getTokenAddresses","swaps","Set","flatMap","sequence","swap","tokenIn","tokenOut","getTokenAddressesForSwap","getTotalSwapAmount","reduce","acc","amount","add","Zero","formatSequence","swapKind","tokenAddresses","SwapTypes","SwapExactOut","reverse","map","i","amountScaled","scalingFactor","SwapExactIn","tokenInDecimals","tokenOutDecimals","scale","bnum","swapAmount","decimalPlaces","toString","scalingFactorReturn","returnScaled","_a","returnAmount","assetInIndex","indexOf","assetOutIndex","poolId","pool","userData","formatSwaps","swapsOriginal","swapType","returnAmountConsideringFees","marketSp","length","cloneDeep","EMPTY_SWAPINFO","swapsClone","dust","sub","gt","BigNumber","from","swapAmountForSwaps","returnAmountFromSwaps"],"mappings":"8UAUA,MAAMA,EAAqBC,GAUhB,IATgC,IAAIC,IACvCD,EAAME,SAASC,GACXA,EAASD,SAASE,GAA2B,CACzCA,EAAKC,QACLD,EAAKE,gBAWRC,EAA4BP,GAK9B,IAJgC,IAAIC,IACvCD,EAAME,SAASE,GAA2B,CAACA,EAAKC,QAASD,EAAKE,cAUhEE,EAAsBR,GACjBA,EAAMS,QAAO,CAACC,GAAOC,YAAaD,EAAIE,IAAID,IAASE,GAYjDC,EAAiB,CAC1BC,EACAZ,EACAa,KAEID,IAAaE,EAAUC,eAGvBf,EAAWA,EAASgB,WAGjBhB,EAASiB,KAAI,CAAChB,EAAMiB,WAIvB,IAAIC,EAAe,IAGnB,GAAU,IAAND,EAAS,CAGT,MAAME,EACFR,IAAaE,EAAUO,YACjBpB,EAAKqB,gBACLrB,EAAKsB,iBAEfJ,EAAeK,EAAMC,EAAKxB,EAAKyB,YAAuBN,GACjDO,cAAc,EAAG,GACjBC,UACR,CACD,MAAMC,EACFjB,IAAaE,EAAUO,YACjBpB,EAAKsB,iBACLtB,EAAKqB,gBAETQ,EAAeN,EACjBC,EAA0B,QAArBM,EAAA9B,EAAK+B,oBAAgB,IAAAD,EAAAA,EAAA,KAC1BF,GAECF,cAAc,EAAG,GACjBC,WAECK,EAAepB,EAAeqB,QAAQjC,EAAKC,SAC3CiC,EAAgBtB,EAAeqB,QAAQjC,EAAKE,UAClD,MAAO,CACHiC,OAAQnC,EAAKoC,KACbJ,eACAE,gBACA3B,OAAQW,EACRmB,SAAU,KACVN,aAAcF,EACjB,cAIOS,EACZC,EACAC,EACAf,EACAxB,EACAC,EACA6B,EACAU,EACAC,GAEA,GAA6B,IAAzBH,EAAcI,OACd,OAAOC,EAAUC,GAGrB,MAAMC,EAAaF,EAAUL,GACvB3B,EAAiBjB,EAAkBmD,GACnClD,EAAkBkD,EAAWhD,SAASC,GACxCW,EAAe8B,EAAUzC,EAAUa,KAIjCmC,EAAOtB,EAAWuB,IAAI5C,EAAmBR,IAC3CmD,EAAKE,GAAG,KACRrD,EAAM,GAAGW,OAAS2C,EAAUC,KAAKvD,EAAM,GAAGW,QAAQC,IAAIuC,GAAMpB,YAgBhE,MAb2B,CACvBF,aACA2B,mBAAoB3B,EACpBM,eACAsB,sBAAuBtB,EACvBU,8BACA7C,QACAgB,iBACAX,UACAC,WACAwC,WAIR"}