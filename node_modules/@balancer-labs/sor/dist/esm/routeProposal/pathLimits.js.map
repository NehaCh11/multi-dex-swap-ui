{"version":3,"file":"pathLimits.js","sources":["../../../../../src/routeProposal/pathLimits.ts"],"sourcesContent":["import { BigNumber, parseFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { SwapTypes, NewPath } from '../types';\nimport { getOutputAmountSwap } from '../pools';\nimport { BigNumber as OldBigNumber } from '../utils/bignumber';\n\nexport function calculatePathLimits(\n    paths: NewPath[],\n    swapType: SwapTypes\n): [NewPath[], BigNumber] {\n    let maxLiquidityAvailable = Zero;\n    paths.forEach((path) => {\n        // Original parsedPoolPairForPath here but this has already been done.\n        path.limitAmount = getLimitAmountSwapForPath(path, swapType);\n        // if (path.limitAmount.isNaN()) throw 'path.limitAmount.isNaN';\n        maxLiquidityAvailable = maxLiquidityAvailable.add(path.limitAmount);\n    });\n    const sortedPaths = paths.sort((a, b) => {\n        return b.limitAmount.gt(a.limitAmount) ? 1 : -1;\n    });\n    return [sortedPaths, maxLiquidityAvailable];\n}\n\nexport function getLimitAmountSwapForPath(\n    path: NewPath,\n    swapType: SwapTypes\n): BigNumber {\n    const poolPairData = path.poolPairData;\n    let limit: OldBigNumber;\n    if (swapType === SwapTypes.SwapExactIn) {\n        limit = path.pools[poolPairData.length - 1].getLimitAmountSwap(\n            poolPairData[poolPairData.length - 1],\n            SwapTypes.SwapExactIn\n        );\n\n        for (let i = poolPairData.length - 2; i >= 0; i--) {\n            const poolLimitExactIn = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactIn\n            );\n            const poolLimitExactOut = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactOut\n            );\n            if (poolLimitExactOut.lte(limit)) {\n                limit = poolLimitExactIn;\n            } else {\n                const pulledLimit = getOutputAmountSwap(\n                    path.pools[i],\n                    path.poolPairData[i],\n                    SwapTypes.SwapExactOut,\n                    limit\n                );\n                limit = OldBigNumber.min(pulledLimit, poolLimitExactIn);\n            }\n        }\n        if (limit.isZero()) return Zero;\n        const result = parseFixed(\n            limit.dp(poolPairData[0].decimalsIn).toString(),\n            poolPairData[0].decimalsIn\n        );\n        return result;\n    } else {\n        limit = path.pools[0].getLimitAmountSwap(\n            poolPairData[0],\n            SwapTypes.SwapExactOut\n        );\n        for (let i = 1; i < poolPairData.length; i++) {\n            const poolLimitExactIn = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactIn\n            );\n            const poolLimitExactOut = path.pools[i].getLimitAmountSwap(\n                poolPairData[i],\n                SwapTypes.SwapExactOut\n            );\n            if (poolLimitExactIn.lte(limit)) {\n                limit = poolLimitExactOut;\n            } else {\n                const pushedLimit = getOutputAmountSwap(\n                    path.pools[i],\n                    path.poolPairData[i],\n                    SwapTypes.SwapExactIn,\n                    limit\n                );\n                limit = OldBigNumber.min(pushedLimit, poolLimitExactOut);\n            }\n        }\n        if (limit.isZero()) return Zero;\n        return parseFixed(\n            limit\n                .dp(poolPairData[poolPairData.length - 1].decimalsOut)\n                .toString(),\n            poolPairData[poolPairData.length - 1].decimalsOut\n        );\n    }\n}\n"],"names":["calculatePathLimits","paths","swapType","maxLiquidityAvailable","Zero","forEach","path","limitAmount","getLimitAmountSwapForPath","add","sort","a","b","gt","poolPairData","limit","SwapTypes","SwapExactIn","pools","length","getLimitAmountSwap","i","poolLimitExactIn","SwapExactOut","lte","pulledLimit","getOutputAmountSwap","OldBigNumber","min","isZero","parseFixed","dp","decimalsIn","toString","poolLimitExactOut","pushedLimit","decimalsOut"],"mappings":"6QAMgB,SAAAA,EACZC,EACAC,GAEA,IAAIC,EAAwBC,EAC5BH,EAAMI,SAASC,IAEXA,EAAKC,YAAcC,EAA0BF,EAAMJ,GAEnDC,EAAwBA,EAAsBM,IAAIH,EAAKC,YAAY,IAKvE,MAAO,CAHaN,EAAMS,MAAK,CAACC,EAAGC,IACxBA,EAAEL,YAAYM,GAAGF,EAAEJ,aAAe,GAAK,IAE7BJ,EACzB,CAEgB,SAAAK,EACZF,EACAJ,GAEA,MAAMY,EAAeR,EAAKQ,aAC1B,IAAIC,EACJ,GAAIb,IAAac,EAAUC,YAAa,CACpCF,EAAQT,EAAKY,MAAMJ,EAAaK,OAAS,GAAGC,mBACxCN,EAAaA,EAAaK,OAAS,GACnCH,EAAUC,aAGd,IAAK,IAAII,EAAIP,EAAaK,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAC/C,MAAMC,EAAmBhB,EAAKY,MAAMG,GAAGD,mBACnCN,EAAaO,GACbL,EAAUC,aAMd,GAJ0BX,EAAKY,MAAMG,GAAGD,mBACpCN,EAAaO,GACbL,EAAUO,cAEQC,IAAIT,GACtBA,EAAQO,MACL,CACH,MAAMG,EAAcC,EAChBpB,EAAKY,MAAMG,GACXf,EAAKQ,aAAaO,GAClBL,EAAUO,aACVR,GAEJA,EAAQY,EAAaC,IAAIH,EAAaH,EACzC,CACJ,CACD,GAAIP,EAAMc,SAAU,OAAOzB,EAK3B,OAJe0B,EACXf,EAAMgB,GAAGjB,EAAa,GAAGkB,YAAYC,WACrCnB,EAAa,GAAGkB,WAGvB,CACGjB,EAAQT,EAAKY,MAAM,GAAGE,mBAClBN,EAAa,GACbE,EAAUO,cAEd,IAAK,IAAIF,EAAI,EAAGA,EAAIP,EAAaK,OAAQE,IAAK,CAC1C,MAAMC,EAAmBhB,EAAKY,MAAMG,GAAGD,mBACnCN,EAAaO,GACbL,EAAUC,aAERiB,EAAoB5B,EAAKY,MAAMG,GAAGD,mBACpCN,EAAaO,GACbL,EAAUO,cAEd,GAAID,EAAiBE,IAAIT,GACrBA,EAAQmB,MACL,CACH,MAAMC,EAAcT,EAChBpB,EAAKY,MAAMG,GACXf,EAAKQ,aAAaO,GAClBL,EAAUC,YACVF,GAEJA,EAAQY,EAAaC,IAAIO,EAAaD,EACzC,CACJ,CACD,OAAInB,EAAMc,SAAiBzB,EACpB0B,EACHf,EACKgB,GAAGjB,EAAaA,EAAaK,OAAS,GAAGiB,aACzCH,WACLnB,EAAaA,EAAaK,OAAS,GAAGiB,YAGlD"}