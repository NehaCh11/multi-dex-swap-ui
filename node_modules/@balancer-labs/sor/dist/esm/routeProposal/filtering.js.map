{"version":3,"file":"filtering.js","sources":["../../../../../src/routeProposal/filtering.ts"],"sourcesContent":["import cloneDeep from 'lodash.clonedeep';\nimport {\n    SubgraphPoolBase,\n    PoolDictionary,\n    NewPath,\n    Swap,\n    PoolBase,\n    PoolFilter,\n    PoolTypes,\n    PoolPairBase,\n    SorConfig,\n    hopDictionary,\n} from '../types';\nimport { ZERO } from '../utils/bignumber';\nimport { parseNewPool } from '../pools';\nimport { Zero } from '@ethersproject/constants';\n\nconst BOOSTED_PATHS_MAX_LENGTH = 7;\n\ninterface edgeDict {\n    [node: string]: [string, string, string][];\n}\n\ninterface treeEdge {\n    edge: [string, string, string];\n    parentIndices: [number, number];\n    visitedNodes: string[];\n}\n\nexport const filterPoolsByType = (\n    pools: SubgraphPoolBase[],\n    poolTypeFilter: PoolFilter\n): SubgraphPoolBase[] => {\n    if (poolTypeFilter === PoolFilter.All) return pools;\n    return pools.filter((p) => p.poolType === poolTypeFilter);\n};\n\n/*\nThe purpose of this function is to build dictionaries of direct pools \nand plausible hop pools.\n*/\nexport function filterPoolsOfInterest(\n    allPools: PoolDictionary,\n    tokenIn: string,\n    tokenOut: string,\n    maxPools: number\n): [PoolDictionary, hopDictionary, hopDictionary] {\n    const directPools: PoolDictionary = {};\n    const hopsIn: hopDictionary = {};\n    const hopsOut: hopDictionary = {};\n\n    Object.keys(allPools).forEach((id) => {\n        const pool = allPools[id];\n        const tokenListSet = new Set(pool.tokensList);\n        const containsTokenIn = tokenListSet.has(tokenIn.toLowerCase());\n        const containsTokenOut = tokenListSet.has(tokenOut.toLowerCase());\n\n        // This is a direct pool as has both tokenIn and tokenOut\n        if (containsTokenIn && containsTokenOut) {\n            directPools[pool.id] = pool;\n            return;\n        }\n\n        if (maxPools > 1) {\n            if (containsTokenIn && !containsTokenOut) {\n                for (const hopToken of tokenListSet) {\n                    if (!hopsIn[hopToken]) hopsIn[hopToken] = new Set([]);\n                    hopsIn[hopToken].add(pool.id);\n                }\n            } else if (!containsTokenIn && containsTokenOut) {\n                for (const hopToken of [...tokenListSet]) {\n                    if (!hopsOut[hopToken]) hopsOut[hopToken] = new Set([]);\n                    hopsOut[hopToken].add(pool.id);\n                }\n            }\n        }\n    });\n    return [directPools, hopsIn, hopsOut];\n}\n\nexport function producePaths(\n    tokenIn: string,\n    tokenOut: string,\n    directPools: PoolDictionary,\n    hopsIn: hopDictionary,\n    hopsOut: hopDictionary,\n    pools: PoolDictionary\n): NewPath[] {\n    const paths: NewPath[] = [];\n\n    // Create direct paths\n    for (const id in directPools) {\n        const path = createPath([tokenIn, tokenOut], [pools[id]]);\n        paths.push(path);\n    }\n\n    for (const hopToken in hopsIn) {\n        if (hopsOut[hopToken]) {\n            let highestNormalizedLiquidityFirst = ZERO; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n            let highestNormalizedLiquidityFirstPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (tokenIn -> hopToken)\n            let highestNormalizedLiquiditySecond = ZERO; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n            let highestNormalizedLiquiditySecondPoolId: string | undefined; // Aux variable to find pool with most liquidity for pair (hopToken -> tokenOut)\n            for (const poolInId of [...hopsIn[hopToken]]) {\n                const poolIn = pools[poolInId];\n                const poolPairData = poolIn.parsePoolPairData(\n                    tokenIn,\n                    hopToken\n                );\n                const normalizedLiquidity =\n                    poolIn.getNormalizedLiquidity(poolPairData);\n                // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n                if (\n                    normalizedLiquidity.isGreaterThanOrEqualTo(\n                        highestNormalizedLiquidityFirst\n                    )\n                ) {\n                    highestNormalizedLiquidityFirst = normalizedLiquidity;\n                    highestNormalizedLiquidityFirstPoolId = poolIn.id;\n                }\n            }\n            for (const poolOutId of [...hopsOut[hopToken]]) {\n                const poolOut = pools[poolOutId];\n                const poolPairData = poolOut.parsePoolPairData(\n                    hopToken,\n                    tokenOut\n                );\n                const normalizedLiquidity =\n                    poolOut.getNormalizedLiquidity(poolPairData);\n                // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n                if (\n                    normalizedLiquidity.isGreaterThanOrEqualTo(\n                        highestNormalizedLiquiditySecond\n                    )\n                ) {\n                    highestNormalizedLiquiditySecond = normalizedLiquidity;\n                    highestNormalizedLiquiditySecondPoolId = poolOut.id;\n                }\n            }\n            if (\n                highestNormalizedLiquidityFirstPoolId &&\n                highestNormalizedLiquiditySecondPoolId\n            ) {\n                const path = createPath(\n                    [tokenIn, hopToken, tokenOut],\n                    [\n                        pools[highestNormalizedLiquidityFirstPoolId],\n                        pools[highestNormalizedLiquiditySecondPoolId],\n                    ]\n                );\n                paths.push(path);\n            }\n        }\n    }\n    return paths;\n}\n\n// We build a directed graph for the boosted pools.\n// Nodes are tokens and edges are triads: [pool.id, tokenIn, tokenOut].\n// The current criterion for including a pool into this graph is the following:\n// (a) We include every linear pool.\n// (b) Among preminted BPT pools and weighted pools, we include those that contain the pool token of a linear pool.\n// (c) Among every pool, we include those that contain the pool token of a pool from the previous step.\n// (d) We include connections of tokenIn and tokenOut to list of tokens from `connectingTokens` (only highest liquidity for each).\n// (e) When tokenIn or tokenOut are tokens offered at an LBP, we also include\n// the LBPs and the corresponding highest liquidity connections of the raising tokens with WETH.\n// (f) We include the pool weth/wsteth\n//\n// To build the paths using boosted pools we use the following algorithm.\n// Given a tokenIn and a tokenOut belonging to the graph, we want to find\n// all the connecting paths inside the graph, with the properties:\n// (a) They do not visit the same token twice\n// (b) They do not use the same pool twice in a row (since this\n// would never be optimal).\n// These paths can be organized as a directed tree having tokenIn as a root.\n// We build this tree by adding at each step all the possible continuations for\n// each branch. When a branch reaches tokenOut, we write down the corresponding path.\n// We only allow paths up to length BOOSTED_PATHS_MAX_LENGTH = 7\nexport function getBoostedGraph(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAllDict: PoolDictionary,\n    config: SorConfig\n): edgeDict {\n    // This should contain all pools in the Graph\n    const graphPoolsSet: Set<PoolBase> = new Set();\n    const allLinearPoolAddresses: string[] = [];\n    const poolsToCheckForLinearBpt: PoolBase[] = [];\n    const connectingTokens = config.connectingTokens\n        ? config.connectingTokens.map(\n              (connectingToken) => connectingToken.address\n          )\n        : [];\n    // Add all LinearPools (see step a)\n    // Create a list of pools that should be checked for Linear BPT (for step b)\n    // Add LBP pools with tokenIn or tokenOut and their corresponding highest liquidity connections\n    for (const id in poolsAllDict) {\n        const pool = poolsAllDict[id];\n        if (pool.poolType == PoolTypes.Linear) {\n            allLinearPoolAddresses.push(pool.address);\n            graphPoolsSet.add(pool);\n        } else {\n            const tokensList = pool.tokensList.map((address) =>\n                address.toLowerCase()\n            );\n            if (tokensList.includes(pool.address)) {\n                // Here we asssume that preminted pools are exactly those that\n                // are not linear and have their pool token in their tokensList.\n                poolsToCheckForLinearBpt.push(pool);\n            } else if (pool.poolType === PoolTypes.Weighted) {\n                // We want to consider Weighted Pools with Linear Bpt tokens\n                poolsToCheckForLinearBpt.push(pool);\n            }\n            if (config.lbpRaisingTokens && pool.isLBP) {\n                handleLBPCase(\n                    graphPoolsSet,\n                    config.lbpRaisingTokens,\n                    pool,\n                    tokenIn,\n                    tokenOut,\n                    connectingTokens,\n                    poolsAllDict\n                );\n            }\n        }\n    }\n    if (allLinearPoolAddresses.length == 0) return {};\n\n    // add best pools tokenIn -> connectingToken and connectingToken -> tokenOut\n    // these can be part of a longer path so do not rely on being directly connected\n    for (const connectingToken of connectingTokens) {\n        addMostLiquidPoolToSet(\n            tokenIn,\n            connectingToken,\n            poolsAllDict,\n            graphPoolsSet\n        );\n        addMostLiquidPoolToSet(\n            connectingToken,\n            tokenOut,\n            poolsAllDict,\n            graphPoolsSet\n        );\n    }\n    // As per step b - Among preminted BPT pools and weighted pools, we include those that contain the pool token of a linear pool.\n    const poolsWithLinearTokens: Set<string> = new Set();\n    for (const pool of poolsToCheckForLinearBpt) {\n        if (\n            pool.tokensList.some((token) =>\n                allLinearPoolAddresses.includes(token)\n            )\n        ) {\n            graphPoolsSet.add(pool);\n            poolsWithLinearTokens.add(pool.address);\n        }\n    }\n    // As per step c -  We include every pool that has a pool token from the previous step\n    for (const id in poolsAllDict) {\n        const pool = poolsAllDict[id];\n        if (pool.tokensList.some((token) => poolsWithLinearTokens.has(token))) {\n            graphPoolsSet.add(pool);\n        }\n    }\n    // Step f - add pool weth/wsteth when it exists\n    if (config.wETHwstETH && poolsAllDict[config.wETHwstETH.id]) {\n        graphPoolsSet.add(poolsAllDict[config.wETHwstETH.id]);\n    }\n    const graphPools: PoolBase[] = [...graphPoolsSet];\n    const edgeDict = getNodesAndEdges(graphPools);\n    return edgeDict;\n}\n\nfunction getNodesAndEdges(pools: PoolBase[]): edgeDict {\n    const edgesFromNode: edgeDict = {};\n    for (const pool of pools) {\n        const n = pool.tokensList.length;\n        for (let i = 0; i < n; i++) {\n            if (!edgesFromNode[pool.tokensList[i]])\n                edgesFromNode[pool.tokensList[i]] = [];\n            for (let j = 0; j < n; j++) {\n                if (i == j) continue;\n                const edge: [string, string, string] = [\n                    pool.id,\n                    pool.tokensList[i],\n                    pool.tokensList[j],\n                ];\n                edgesFromNode[pool.tokensList[i]].push(edge);\n            }\n        }\n    }\n    return edgesFromNode;\n}\n\nexport function getBoostedPaths(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAllDict: PoolDictionary,\n    config: SorConfig\n): NewPath[] {\n    const edgesFromNode = getBoostedGraph(\n        tokenIn,\n        tokenOut,\n        poolsAllDict,\n        config\n    );\n    const pathsInfo: [string[], string[]][] = [];\n    const rootTreeEdge: treeEdge = {\n        edge: ['', '', tokenIn],\n        parentIndices: [-1, -1],\n        visitedNodes: [],\n    };\n    const treeEdges: treeEdge[][] = [[rootTreeEdge]];\n    let iterate = true;\n    while (iterate) {\n        const n = treeEdges.length; // number of tree edge layers so far\n        const newTreeEdges: treeEdge[] = [];\n        // adds every possible treeEdge for each treeEdge of the previous layer\n        for (let i = 0; i < treeEdges[n - 1].length; i++) {\n            const treeEdge = treeEdges[n - 1][i];\n            const token = treeEdge.edge[2];\n            const edgesFromToken = edgesFromNode[token];\n            if (!edgesFromToken) continue;\n            for (const edge of edgesFromToken) {\n                // skip if the node was already visited or\n                // if the pool is the one from the previous edge\n                if (\n                    treeEdge.visitedNodes.includes(edge[2]) ||\n                    treeEdge.edge[0] == edge[0]\n                ) {\n                    continue;\n                }\n                if (edge[2] == tokenOut) {\n                    pathsInfo.push(getPathInfo(edge, treeEdge, treeEdges));\n                }\n                const newTreeEdge: treeEdge = {\n                    edge: edge,\n                    parentIndices: [n - 1, i],\n                    visitedNodes: treeEdge.visitedNodes.concat(edge[1]),\n                };\n                newTreeEdges.push(newTreeEdge);\n            }\n        }\n        if (newTreeEdges.length == 0) {\n            iterate = false;\n        } else treeEdges.push(newTreeEdges);\n        if (n == BOOSTED_PATHS_MAX_LENGTH) iterate = false;\n    }\n    return pathsInfoToPaths(pathsInfo, poolsAllDict);\n}\n\nfunction getPathInfo(\n    edge: [string, string, string],\n    treeEdge: treeEdge,\n    treeEdges: treeEdge[][]\n): [string[], string[]] {\n    const pathEdges: [string, string, string][] = [edge];\n    pathEdges.unshift(treeEdge.edge);\n    let indices = treeEdge.parentIndices;\n    while (indices[0] !== -1) {\n        pathEdges.unshift(treeEdges[indices[0]][indices[1]].edge);\n        indices = treeEdges[indices[0]][indices[1]].parentIndices;\n    }\n    const pools = pathEdges.map((pathEdge) => pathEdge[0]);\n    pools.splice(0, 1);\n    const tokens = pathEdges.map((pathEdge) => pathEdge[2]);\n    return [tokens, pools];\n}\n\nfunction pathsInfoToPaths(\n    flexBoostedPathsInfo: [string[], string[]][],\n    poolsAllDict: PoolDictionary\n): NewPath[] {\n    const paths: NewPath[] = [];\n    for (const boostedPathInfo of flexBoostedPathsInfo) {\n        const pools = boostedPathInfo[1].map((id) => poolsAllDict[id]);\n        // ignore paths of length 1 and 2\n        if (pools.length > 2) {\n            paths.push(createPath(boostedPathInfo[0], pools));\n        }\n    }\n    return paths;\n}\n\n// Creates a path with pools.length hops\n// i.e. tokens[0]>[Pool0]>tokens[1]>[Pool1]>tokens[2]>[Pool2]>tokens[3]\nexport function createPath(tokens: string[], pools: PoolBase[]): NewPath {\n    let tI: string, tO: string;\n    const swaps: Swap[] = [];\n    const poolPairData: PoolPairBase[] = [];\n    let id = '';\n\n    for (let i = 0; i < pools.length; i++) {\n        tI = tokens[i];\n        tO = tokens[i + 1];\n        const poolPair = pools[i].parsePoolPairData(tI, tO);\n        poolPairData.push(poolPair);\n        id = id + poolPair.id;\n\n        const swap: Swap = {\n            pool: pools[i].id,\n            tokenIn: tI,\n            tokenOut: tO,\n            tokenInDecimals: poolPair.decimalsIn,\n            tokenOutDecimals: poolPair.decimalsOut,\n        };\n\n        swaps.push(swap);\n    }\n\n    const path: NewPath = {\n        id,\n        swaps,\n        limitAmount: Zero,\n        poolPairData,\n        pools,\n    };\n\n    return path;\n}\n\nexport function getHighestLiquidityPool(\n    tokenIn: string,\n    tokenOut: string,\n    poolsOfInterest: PoolDictionary\n): string | null {\n    let highestNormalizedLiquidity = ZERO;\n    let highestNormalizedLiquidityPoolId: string | null = null;\n    for (const id in poolsOfInterest) {\n        const pool = poolsOfInterest[id];\n        const tokenListSet = new Set(pool.tokensList);\n\n        // If pool doesn't have tokenIn or tokenOut then ignore\n\n        if (\n            !tokenListSet.has(tokenIn.toLowerCase()) ||\n            !tokenListSet.has(tokenOut.toLowerCase())\n        )\n            continue;\n        const poolPairData = pool.parsePoolPairData(tokenIn, tokenOut);\n        const normalizedLiquidity = pool.getNormalizedLiquidity(poolPairData);\n        // Cannot be strictly greater otherwise highestNormalizedLiquidityPoolId = 0 if hopTokens[i] balance is 0 in this pool.\n        if (\n            normalizedLiquidity.isGreaterThanOrEqualTo(\n                highestNormalizedLiquidity\n            )\n        ) {\n            highestNormalizedLiquidity = normalizedLiquidity;\n            highestNormalizedLiquidityPoolId = id;\n        }\n    }\n    return highestNormalizedLiquidityPoolId;\n}\n\n// This function will only work correctly if the input is composable\n// i.e. each path's token out = next path's token in\nfunction composePaths(paths: NewPath[]): NewPath {\n    let id = '';\n    let swaps: Swap[] = [];\n    let poolPairData: PoolPairBase[] = [];\n    let pools: PoolBase[] = [];\n    for (const path of paths) {\n        id += path.id;\n        swaps = swaps.concat(path.swaps);\n        poolPairData = poolPairData.concat(path.poolPairData);\n        pools = pools.concat(path.pools);\n    }\n    const path: NewPath = {\n        id: id,\n        swaps: swaps,\n        poolPairData: poolPairData,\n        limitAmount: Zero,\n        pools: pools,\n    };\n    return path;\n}\n\n/*\nThe staBAL3 pool (STABALADDR) is the main stable pool that holds DAI/USDC/USDT and has the staBAL3 BPT.\nMetastable pools that contain a project token, i.e. TUSD, paired with staBAL3 BPT.\nUSDC connecting pool (USDCCONNECTINGPOOL) is a metastable pool containing USDC and staBAL3 BPT.\nThis setup should enable paths between the new project metastable pools and other liquidity. I.e. TUSD > BAL, which would look like:\nTUSD>[TUSDstaBALPool]>staBAL3>[ConnectingPool]>USDC>[BalWeightedPool]>BAL\n*/\nexport function getPathsUsingStaBalPool(\n    tokenIn: string,\n    tokenOut: string,\n    poolsAll: PoolDictionary,\n    poolsFiltered: PoolDictionary,\n    config: SorConfig\n): NewPath[] {\n    // This will be the USDC/staBAL Connecting pool used in Polygon\n    const usdcConnectingPoolInfo = config.usdcConnectingPool;\n    if (!usdcConnectingPoolInfo) return [];\n\n    const usdcConnectingPool = poolsAll[usdcConnectingPoolInfo.id];\n    // staBal BPT token is the hop token between token and USDC connecting pool\n    const hopTokenStaBal = config.staBal3Pool?.address;\n\n    if (!usdcConnectingPool || !hopTokenStaBal) return [];\n\n    // Finds the best metastable Pool with tokenIn/staBal3Bpt or returns null if doesn't exist\n    const metastablePoolIdIn = getHighestLiquidityPool(\n        tokenIn,\n        hopTokenStaBal,\n        poolsFiltered\n    );\n    // Finds the best metastable Pool with tokenOut/staBal3Bpt or returns null if doesn't exist\n    const metastablePoolIdOut = getHighestLiquidityPool(\n        hopTokenStaBal,\n        tokenOut,\n        poolsFiltered\n    );\n\n    if (metastablePoolIdIn && !metastablePoolIdOut) {\n        // First part of path is multihop through metaStablePool and USDC Connecting Pools\n        // Last part of path is single hop through USDC/tokenOut highest liquidity pool\n        // i.e. tokenIn>[metaStablePool]>staBAL>[usdcConnecting]>USDC>[HighLiqPool]>tokenOut\n\n        const metaStablePoolIn = poolsFiltered[metastablePoolIdIn];\n\n        // tokenIn > [metaStablePool] > staBal > [UsdcConnectingPool] > USDC\n        const staBalPath = createPath(\n            [tokenIn, hopTokenStaBal, usdcConnectingPoolInfo.usdc],\n            [metaStablePoolIn, usdcConnectingPool]\n        );\n\n        // Hop out as it is USDC > tokenOut\n        const mostLiquidLastPool = getHighestLiquidityPool(\n            usdcConnectingPoolInfo.usdc,\n            tokenOut,\n            poolsFiltered\n        );\n        // No USDC>tokenOut pool so return empty path\n        if (mostLiquidLastPool === null) return [];\n\n        const lastPool = poolsFiltered[mostLiquidLastPool];\n        const pathEnd = createPath(\n            [usdcConnectingPoolInfo.usdc, tokenOut],\n            [lastPool]\n        );\n\n        return [composePaths([staBalPath, pathEnd])];\n    }\n\n    if (!metastablePoolIdIn && metastablePoolIdOut) {\n        // First part of path is single hop through tokenIn/USDC highest liquidity pool\n        // Last part of path is multihop through USDC Connecting Pools and metaStablePool\n        // i.e. i.e. tokenIn>[HighLiqPool]>USDC>[usdcConnecting]>staBAL>[metaStablePool]>tokenOut\n\n        // Hop in as it is tokenIn > USDC\n        const mostLiquidFirstPool = getHighestLiquidityPool(\n            tokenIn,\n            usdcConnectingPoolInfo.usdc,\n            poolsFiltered\n        );\n        // No tokenIn>USDC pool so return empty path\n        if (mostLiquidFirstPool === null) return [];\n\n        const metaStablePoolIn = poolsFiltered[metastablePoolIdOut];\n        const firstPool = poolsFiltered[mostLiquidFirstPool];\n\n        // USDC > [UsdcConnectingPool] > staBal > [metaStablePool] > tokenOut\n        const staBalPath = createPath(\n            [usdcConnectingPoolInfo.usdc, hopTokenStaBal, tokenOut],\n            [usdcConnectingPool, metaStablePoolIn]\n        );\n        const pathStart = createPath(\n            [tokenIn, usdcConnectingPoolInfo.usdc],\n            [firstPool]\n        );\n\n        return [composePaths([pathStart, staBalPath])];\n    }\n\n    // If we're here either the path doesn't use metastable pools (and so will not be routed through StaBAL)\n    // or both input and output tokens are in metastable pools and so should be handled by existing multihop algorithm\n    // (because it is tokenIn>[metaStablePoolIn]>staBal>[metaStablePoolOut]>tokenOut)\n    //\n    // We then return an empty set of paths\n    return [];\n}\n\nexport function parseToPoolsDict(\n    pools: SubgraphPoolBase[],\n    timestamp: number\n): PoolDictionary {\n    return Object.fromEntries(\n        cloneDeep(pools)\n            .filter(\n                (pool) =>\n                    pool.tokensList.length > 0 && pool.tokens[0].balance !== '0'\n            )\n            .map((pool) => [pool.id, parseNewPool(pool, timestamp)])\n            .filter(([, pool]) => pool !== undefined)\n    );\n}\n\nfunction getRaisingToken(\n    pool: PoolBase,\n    lbpRaisingTokens: string[],\n    token: string\n): string | undefined {\n    let theOtherToken: string | undefined;\n    const tokensList = pool.tokensList;\n    if (tokensList.includes(token) && !lbpRaisingTokens.includes(token)) {\n        for (let i = 0; i < 2; i++) {\n            if (tokensList[i] == token) {\n                theOtherToken = tokensList[1 - i];\n            }\n        }\n    }\n    return theOtherToken;\n}\n\nfunction handleLBPCase(\n    graphPoolsSet: Set<PoolBase>,\n    lbpRaisingTokens: string[],\n    poolLbp: PoolBase,\n    tokenIn: string,\n    tokenOut: string,\n    connectingTokens: string[],\n    poolsAllDict: PoolDictionary\n) {\n    // Tokens that will be used as LBP Base Token, e.g. USDC/DAI/WETH\n    const raisingTokens = lbpRaisingTokens.map((address) =>\n        address.toLowerCase()\n    );\n\n    if (raisingTokens.length === 0) return;\n\n    // Assuming tokenIn is the lbpToken find the corresponding base token if it exists\n    const raisingTokenIn: string | undefined = getRaisingToken(\n        poolLbp,\n        raisingTokens,\n        tokenIn\n    );\n    const raisingTokenOut: string | undefined = getRaisingToken(\n        poolLbp,\n        raisingTokens,\n        tokenOut\n    );\n    if (!raisingTokenIn && !raisingTokenOut) return;\n\n    // Add the LBP pool to the graph\n    graphPoolsSet.add(poolLbp);\n\n    // For each connecting token add most liquid pools with raisingToken and raisingTokenOut\n    for (const connectingToken of connectingTokens) {\n        if (raisingTokenIn && raisingTokenIn !== connectingToken) {\n            // raisingToken>[Pool]>connectingToken\n            addMostLiquidPoolToSet(\n                raisingTokenIn,\n                connectingToken,\n                poolsAllDict,\n                graphPoolsSet\n            );\n        }\n        if (raisingTokenOut && raisingTokenOut !== connectingToken) {\n            // connectingToken>[Pool]>raisingToken\n            addMostLiquidPoolToSet(\n                connectingToken,\n                raisingTokenOut,\n                poolsAllDict,\n                graphPoolsSet\n            );\n        }\n    }\n}\n\nfunction addMostLiquidPoolToSet(\n    tokenIn: string,\n    tokenOut: string,\n    pools: PoolDictionary,\n    graphPools: Set<PoolBase>\n): void {\n    const pool = getHighestLiquidityPool(tokenIn, tokenOut, pools);\n    if (pool) graphPools.add(pools[pool]);\n}\n"],"names":["BOOSTED_PATHS_MAX_LENGTH","filterPoolsByType","pools","poolTypeFilter","PoolFilter","All","filter","p","poolType","filterPoolsOfInterest","allPools","tokenIn","tokenOut","maxPools","directPools","hopsIn","hopsOut","Object","keys","forEach","id","pool","tokenListSet","Set","tokensList","containsTokenIn","has","toLowerCase","containsTokenOut","hopToken","add","producePaths","paths","path","createPath","push","highestNormalizedLiquidityFirstPoolId","highestNormalizedLiquiditySecondPoolId","highestNormalizedLiquidityFirst","ZERO","highestNormalizedLiquiditySecond","poolInId","poolIn","poolPairData","parsePoolPairData","normalizedLiquidity","getNormalizedLiquidity","isGreaterThanOrEqualTo","poolOutId","poolOut","getBoostedGraph","poolsAllDict","config","graphPoolsSet","allLinearPoolAddresses","poolsToCheckForLinearBpt","connectingTokens","map","connectingToken","address","PoolTypes","Linear","includes","Weighted","lbpRaisingTokens","isLBP","handleLBPCase","length","addMostLiquidPoolToSet","poolsWithLinearTokens","some","token","wETHwstETH","edgesFromNode","n","i","j","edge","getNodesAndEdges","getBoostedPaths","pathsInfo","treeEdges","parentIndices","visitedNodes","iterate","newTreeEdges","treeEdge","edgesFromToken","getPathInfo","newTreeEdge","concat","flexBoostedPathsInfo","boostedPathInfo","pathsInfoToPaths","pathEdges","unshift","indices","pathEdge","splice","tokens","tI","tO","swaps","poolPair","swap","tokenInDecimals","decimalsIn","tokenOutDecimals","decimalsOut","limitAmount","Zero","getHighestLiquidityPool","poolsOfInterest","highestNormalizedLiquidity","highestNormalizedLiquidityPoolId","composePaths","getPathsUsingStaBalPool","poolsAll","poolsFiltered","usdcConnectingPoolInfo","usdcConnectingPool","hopTokenStaBal","_a","staBal3Pool","metastablePoolIdIn","metastablePoolIdOut","metaStablePoolIn","staBalPath","usdc","mostLiquidLastPool","lastPool","mostLiquidFirstPool","firstPool","parseToPoolsDict","timestamp","fromEntries","cloneDeep","balance","parseNewPool","undefined","getRaisingToken","theOtherToken","poolLbp","raisingTokens","raisingTokenIn","raisingTokenOut","graphPools"],"mappings":"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"}