import"../external/lodash.clonedeep/index.js";import{PoolFilter as t,PoolTypes as o}from"../types.js";import{ZERO as n}from"../utils/bignumber.js";import{parseNewPool as s}from"../pools/index.js";import{Zero as e}from"@ethersproject/constants";import{exports as i}from"../_virtual/index.js";const r=7,c=(o,n)=>n===t.All?o:o.filter((t=>t.poolType===n));function a(t,o,n,s){const e={},i={},r={};return Object.keys(t).forEach((c=>{const a=t[c],d=new Set(a.tokensList),f=d.has(o.toLowerCase()),l=d.has(n.toLowerCase());if(f&&l)e[a.id]=a;else if(s>1)if(f&&!l)for(const t of d)i[t]||(i[t]=new Set([])),i[t].add(a.id);else if(!f&&l)for(const t of[...d])r[t]||(r[t]=new Set([])),r[t].add(a.id)})),[e,i,r]}function d(t,o,s,e,i,r){const c=[];for(const n in s){const s=p([t,o],[r[n]]);c.push(s)}for(const s in e)if(i[s]){let a,d,f=n,l=n;for(const o of[...e[s]]){const n=r[o],e=n.parsePoolPairData(t,s),i=n.getNormalizedLiquidity(e);i.isGreaterThanOrEqualTo(f)&&(f=i,a=n.id)}for(const t of[...i[s]]){const n=r[t],e=n.parsePoolPairData(s,o),i=n.getNormalizedLiquidity(e);i.isGreaterThanOrEqualTo(l)&&(l=i,d=n.id)}if(a&&d){const n=p([t,s,o],[r[a],r[d]]);c.push(n)}}return c}function f(t,n,s,e){const i=new Set,r=[],c=[],a=e.connectingTokens?e.connectingTokens.map((t=>t.address)):[];for(const d in s){const f=s[d];if(f.poolType==o.Linear)r.push(f.address),i.add(f);else{(f.tokensList.map((t=>t.toLowerCase())).includes(f.address)||f.poolType===o.Weighted)&&c.push(f),e.lbpRaisingTokens&&f.isLBP&&w(i,e.lbpRaisingTokens,f,t,n,a,s)}}if(0==r.length)return{};for(const o of a)T(t,o,s,i),T(o,n,s,i);const d=new Set;for(const t of c)t.tokensList.some((t=>r.includes(t)))&&(i.add(t),d.add(t.address));for(const t in s){const o=s[t];o.tokensList.some((t=>d.has(t)))&&i.add(o)}e.wETHwstETH&&s[e.wETHwstETH.id]&&i.add(s[e.wETHwstETH.id]);return function(t){const o={};for(const n of t){const t=n.tokensList.length;for(let s=0;s<t;s++){o[n.tokensList[s]]||(o[n.tokensList[s]]=[]);for(let e=0;e<t;e++){if(s==e)continue;const t=[n.id,n.tokensList[s],n.tokensList[e]];o[n.tokensList[s]].push(t)}}}return o}([...i])}function l(t,o,n,s){const e=f(t,o,n,s),i=[],c=[[{edge:["","",t],parentIndices:[-1,-1],visitedNodes:[]}]];let a=!0;for(;a;){const t=c.length,n=[];for(let s=0;s<c[t-1].length;s++){const r=c[t-1][s],a=e[r.edge[2]];if(a)for(const e of a){if(r.visitedNodes.includes(e[2])||r.edge[0]==e[0])continue;e[2]==o&&i.push(u(e,r,c));const a={edge:e,parentIndices:[t-1,s],visitedNodes:r.visitedNodes.concat(e[1])};n.push(a)}}0==n.length?a=!1:c.push(n),t==r&&(a=!1)}return function(t,o){const n=[];for(const s of t){const t=s[1].map((t=>o[t]));t.length>2&&n.push(p(s[0],t))}return n}(i,n)}function u(t,o,n){const s=[t];s.unshift(o.edge);let e=o.parentIndices;for(;-1!==e[0];)s.unshift(n[e[0]][e[1]].edge),e=n[e[0]][e[1]].parentIndices;const i=s.map((t=>t[0]));i.splice(0,1);return[s.map((t=>t[2])),i]}function p(t,o){let n,s;const i=[],r=[];let c="";for(let e=0;e<o.length;e++){n=t[e],s=t[e+1];const a=o[e].parsePoolPairData(n,s);r.push(a),c+=a.id;const d={pool:o[e].id,tokenIn:n,tokenOut:s,tokenInDecimals:a.decimalsIn,tokenOutDecimals:a.decimalsOut};i.push(d)}return{id:c,swaps:i,limitAmount:e,poolPairData:r,pools:o}}function h(t,o,s){let e=n,i=null;for(const n in s){const r=s[n],c=new Set(r.tokensList);if(!c.has(t.toLowerCase())||!c.has(o.toLowerCase()))continue;const a=r.parsePoolPairData(t,o),d=r.getNormalizedLiquidity(a);d.isGreaterThanOrEqualTo(e)&&(e=d,i=n)}return i}function m(t){let o="",n=[],s=[],i=[];for(const e of t)o+=e.id,n=n.concat(e.swaps),s=s.concat(e.poolPairData),i=i.concat(e.pools);return{id:o,swaps:n,poolPairData:s,limitAmount:e,pools:i}}function g(t,o,n,s,e){var i;const r=e.usdcConnectingPool;if(!r)return[];const c=n[r.id],a=null===(i=e.staBal3Pool)||void 0===i?void 0:i.address;if(!c||!a)return[];const d=h(t,a,s),f=h(a,o,s);if(d&&!f){const n=s[d],e=p([t,a,r.usdc],[n,c]),i=h(r.usdc,o,s);if(null===i)return[];const f=s[i];return[m([e,p([r.usdc,o],[f])])]}if(!d&&f){const n=h(t,r.usdc,s);if(null===n)return[];const e=s[f],i=s[n],d=p([r.usdc,a,o],[c,e]);return[m([p([t,r.usdc],[i]),d])]}return[]}function L(t,o){return Object.fromEntries(i(t).filter((t=>t.tokensList.length>0&&"0"!==t.tokens[0].balance)).map((t=>[t.id,s(t,o)])).filter((([,t])=>void 0!==t)))}function k(t,o,n){let s;const e=t.tokensList;if(e.includes(n)&&!o.includes(n))for(let t=0;t<2;t++)e[t]==n&&(s=e[1-t]);return s}function w(t,o,n,s,e,i,r){const c=o.map((t=>t.toLowerCase()));if(0===c.length)return;const a=k(n,c,s),d=k(n,c,e);if(a||d){t.add(n);for(const o of i)a&&a!==o&&T(a,o,r,t),d&&d!==o&&T(o,d,r,t)}}function T(t,o,n,s){const e=h(t,o,n);e&&s.add(n[e])}export{p as createPath,c as filterPoolsByType,a as filterPoolsOfInterest,f as getBoostedGraph,l as getBoostedPaths,h as getHighestLiquidityPool,g as getPathsUsingStaBalPool,L as parseToPoolsDict,d as producePaths};
//# sourceMappingURL=filtering.js.map
