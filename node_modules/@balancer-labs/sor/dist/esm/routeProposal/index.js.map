{"version":3,"file":"index.js","sources":["../../../../../src/routeProposal/index.ts"],"sourcesContent":["import {\n    getPathsUsingStaBalPool,\n    parseToPoolsDict,\n    filterPoolsOfInterest,\n    producePaths,\n    getBoostedPaths,\n} from './filtering';\nimport { calculatePathLimits } from './pathLimits';\nimport {\n    SwapOptions,\n    SwapTypes,\n    NewPath,\n    SubgraphPoolBase,\n    SorConfig,\n    PoolDictionary,\n} from '../types';\n\nexport class RouteProposer {\n    cache: Record<string, { paths: NewPath[] }> = {};\n\n    constructor(private readonly config: SorConfig) {}\n\n    /**\n     * Given a list of pools and a desired input/output, returns a set of possible paths to route through\n     */\n    getCandidatePaths(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        pools: SubgraphPoolBase[],\n        swapOptions: SwapOptions\n    ): NewPath[] {\n        tokenIn = tokenIn.toLowerCase();\n        tokenOut = tokenOut.toLowerCase();\n        if (pools.length === 0) return [];\n\n        // If token pair has been processed before that info can be reused to speed up execution\n        // If timestamp has not been manually set in `getSwaps` then default (set on instantiation) is used which means cache will be used\n        const cache =\n            this.cache[\n                `${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`\n            ];\n        // forceRefresh can be set to force fresh processing of paths/prices\n        if (!swapOptions.forceRefresh && !!cache) {\n            // Using pre-processed data from cache\n            return cache.paths;\n        }\n\n        const poolsAllDict = parseToPoolsDict(pools, swapOptions.timestamp);\n\n        const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n            poolsAllDict,\n            tokenIn,\n            tokenOut,\n            swapOptions.maxPools\n        );\n\n        const pathData = producePaths(\n            tokenIn,\n            tokenOut,\n            directPools,\n            hopsIn,\n            hopsOut,\n            poolsAllDict\n        );\n\n        const boostedPaths = getBoostedPaths(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            this.config\n        );\n\n        const pathsUsingStaBal = getPathsUsingStaBalPool(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            poolsAllDict,\n            this.config\n        );\n\n        const combinedPathData = pathData\n            .concat(...boostedPaths)\n            .concat(...pathsUsingStaBal);\n        const [paths] = calculatePathLimits(combinedPathData, swapType);\n\n        this.cache[`${tokenIn}${tokenOut}${swapType}${swapOptions.timestamp}`] =\n            {\n                paths: paths,\n            };\n        return paths;\n    }\n\n    /**\n     * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.\n     * @param {string} tokenIn - Address of tokenIn\n     * @param {string} tokenOut - Address of tokenOut\n     * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.\n     * @param {PoolDictionary} poolsAllDict - Dictionary of pools.\n     * @param {number }maxPools - Maximum number of pools to hop through.\n     * @returns {NewPath[]} Array of possible paths sorted by liquidity.\n     */\n    getCandidatePathsFromDict(\n        tokenIn: string,\n        tokenOut: string,\n        swapType: SwapTypes,\n        poolsAllDict: PoolDictionary,\n        maxPools: number\n    ): NewPath[] {\n        tokenIn = tokenIn.toLowerCase();\n        tokenOut = tokenOut.toLowerCase();\n        if (Object.keys(poolsAllDict).length === 0) return [];\n\n        const [directPools, hopsIn, hopsOut] = filterPoolsOfInterest(\n            poolsAllDict,\n            tokenIn,\n            tokenOut,\n            maxPools\n        );\n\n        const pathData = producePaths(\n            tokenIn,\n            tokenOut,\n            directPools,\n            hopsIn,\n            hopsOut,\n            poolsAllDict\n        );\n\n        const boostedPaths = getBoostedPaths(\n            tokenIn,\n            tokenOut,\n            poolsAllDict,\n            this.config\n        );\n\n        const combinedPathData = pathData.concat(...boostedPaths);\n        const [paths] = calculatePathLimits(combinedPathData, swapType);\n        return paths;\n    }\n}\n"],"names":["RouteProposer","constructor","config","this","cache","getCandidatePaths","tokenIn","tokenOut","swapType","pools","swapOptions","toLowerCase","length","timestamp","forceRefresh","paths","poolsAllDict","parseToPoolsDict","directPools","hopsIn","hopsOut","filterPoolsOfInterest","maxPools","pathData","producePaths","boostedPaths","getBoostedPaths","pathsUsingStaBal","getPathsUsingStaBalPool","combinedPathData","concat","calculatePathLimits","getCandidatePathsFromDict","Object","keys"],"mappings":"6MAiBaA,EAGTC,YAA6BC,GAAAC,KAAMD,OAANA,EAF7BC,KAAKC,MAAyC,EAEI,CAKlDC,kBACIC,EACAC,EACAC,EACAC,EACAC,GAIA,GAFAJ,EAAUA,EAAQK,cAClBJ,EAAWA,EAASI,cACC,IAAjBF,EAAMG,OAAc,MAAO,GAI/B,MAAMR,EACFD,KAAKC,MACD,GAAGE,IAAUC,IAAWC,IAAWE,EAAYG,aAGvD,IAAKH,EAAYI,cAAkBV,EAE/B,OAAOA,EAAMW,MAGjB,MAAMC,EAAeC,EAAiBR,EAAOC,EAAYG,YAElDK,EAAaC,EAAQC,GAAWC,EACnCL,EACAV,EACAC,EACAG,EAAYY,UAGVC,EAAWC,EACblB,EACAC,EACAW,EACAC,EACAC,EACAJ,GAGES,EAAeC,EACjBpB,EACAC,EACAS,EACAb,KAAKD,QAGHyB,EAAmBC,EACrBtB,EACAC,EACAS,EACAA,EACAb,KAAKD,QAGH2B,EAAmBN,EACpBO,UAAUL,GACVK,UAAUH,IACRZ,GAASgB,EAAoBF,EAAkBrB,GAMtD,OAJAL,KAAKC,MAAM,GAAGE,IAAUC,IAAWC,IAAWE,EAAYG,aACtD,CACIE,MAAOA,GAERA,CACV,CAWDiB,0BACI1B,EACAC,EACAC,EACAQ,EACAM,GAIA,GAFAhB,EAAUA,EAAQK,cAClBJ,EAAWA,EAASI,cACqB,IAArCsB,OAAOC,KAAKlB,GAAcJ,OAAc,MAAO,GAEnD,MAAOM,EAAaC,EAAQC,GAAWC,EACnCL,EACAV,EACAC,EACAe,GAGEC,EAAWC,EACblB,EACAC,EACAW,EACAC,EACAC,EACAJ,GAGES,EAAeC,EACjBpB,EACAC,EACAS,EACAb,KAAKD,QAGH2B,EAAmBN,EAASO,UAAUL,IACrCV,GAASgB,EAAoBF,EAAkBrB,GACtD,OAAOO,CACV"}