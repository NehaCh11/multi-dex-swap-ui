import { BigNumber } from '@ethersproject/bignumber';
export declare function _calculateInvariant(balances: BigNumber[], root3Alpha: BigNumber): BigNumber;
/** @dev Prepares quadratic terms for input to _calculateCubic
 *  assumes a > 0, b < 0, c <= 0, and d <= 0 and returns a, -b, -c, -d
 *  terms come from cubic in Section 3.1.1
 *  argument root3Alpha = cube root of alpha
 */
export declare function _calculateCubicTerms(balances: BigNumber[], root3Alpha: BigNumber): [BigNumber, BigNumber, BigNumber, BigNumber];
/** @dev Calculate the maximal root of the polynomial a L^3 - mb L^2 - mc L - md.
 *   This root is always non-negative, and it is the unique positive root unless mb == mc == md == 0. */
export declare function _calculateCubic(a: BigNumber, mb: BigNumber, mc: BigNumber, md: BigNumber, root3Alpha: BigNumber): BigNumber;
/** @dev Starting point for Newton iteration. Safe with all cubic polynomials where the coefficients have the appropriate
 *   signs, but calibrated to the particular polynomial for computing the invariant. */
export declare function _calculateCubicStartingPoint(a: BigNumber, mb: BigNumber, mc: BigNumber): BigNumber;
/** @dev Find a root of the given polynomial with the given starting point l.
 *   Safe iff l > the local minimum.
 *   Note that f(l) may be negative for the first iteration and will then be positive (up to rounding errors).
 *   f'(l) is always positive for the range of values we consider.
 *   See write-up, Appendix A. */
export declare function _runNewtonIteration(a: BigNumber, mb: BigNumber, mc: BigNumber, md: BigNumber, root3Alpha: BigNumber, rootEst: BigNumber): BigNumber;
export declare function _calcNewtonDelta(a: BigNumber, mb: BigNumber, mc: BigNumber, md: BigNumber, root3Alpha: BigNumber, rootEst: BigNumber): [BigNumber, boolean];
/** @dev Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the
 * current balances and weights.
 * Changed signs compared to original algorithm to account for amountOut < 0.
 * See Proposition 12 in 3.1.4.*/
export declare function _calcOutGivenIn(balanceIn: BigNumber, balanceOut: BigNumber, amountIn: BigNumber, virtualOffset: BigNumber): BigNumber;
/** @dev Computes how many tokens must be sent to a pool in order to take `amountOut`, given the
 * currhent balances and weights.
 * Similar to the one before but adapting bc negative values (amountOut would be negative).*/
export declare function _calcInGivenOut(balanceIn: BigNumber, balanceOut: BigNumber, amountOut: BigNumber, virtualOffset: BigNumber): BigNumber;
export declare function _calculateNewSpotPrice(balances: BigNumber[], inAmount: BigNumber, outAmount: BigNumber, virtualOffsetInOut: BigNumber, swapFee: BigNumber): BigNumber;
export declare function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(balances: BigNumber[], outAmount: BigNumber, virtualOffsetInOut: BigNumber): BigNumber;
export declare function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(balances: BigNumber[], inAmount: BigNumber, outAmount: BigNumber, virtualOffsetInOut: BigNumber, swapFee: BigNumber): BigNumber;
export declare function _getNormalizedLiquidity(balances: BigNumber[], virtualParamOut: BigNumber): BigNumber;
