{"version":3,"file":"linearMath.js","sources":["../../../../../../src/pools/linearPool/linearMath.ts"],"sourcesContent":["import { MathSol, BZERO } from '../../utils/basicOperations';\n\ntype Params = {\n    fee: bigint;\n    rate: bigint;\n    lowerTarget: bigint;\n    upperTarget: bigint;\n};\n\nexport function _calcBptOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n\n    if (bptSupply == BigInt(0)) {\n        return _toNominal(mainIn, params);\n    }\n\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n    const deltaNominalMain = afterNominalMain - previousNominalMain;\n    const invariant = _calcInvariantUp(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divDown(MathSol.mul(bptSupply, deltaNominalMain), invariant);\n}\n\nexport function _calcBptInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n    const deltaNominalMain = previousNominalMain - afterNominalMain;\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUp(MathSol.mul(bptSupply, deltaNominalMain), invariant);\n}\n\nexport function _calcBptInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newWrappedBalance = wrappedBalance - wrappedOut;\n    const newInvariant = _calcInvariantDown(\n        nominalMain,\n        newWrappedBalance,\n        params\n    );\n    const newBptBalance = MathSol.divDown(\n        MathSol.mul(bptSupply, newInvariant),\n        previousInvariant\n    );\n    return bptSupply - newBptBalance;\n}\n\nexport function _calcWrappedOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance + mainIn, params);\n    const deltaNominalMain = afterNominalMain - previousNominalMain;\n    return MathSol.divDownFixed(deltaNominalMain, params.rate);\n}\n\nexport function _calcWrappedInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const afterNominalMain = _toNominal(mainBalance - mainOut, params);\n    const deltaNominalMain = previousNominalMain - afterNominalMain;\n    return MathSol.divUpFixed(deltaNominalMain, params.rate);\n}\n\nexport function _calcMainInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    if (bptSupply == BigInt(0)) {\n        return _fromNominal(bptOut, params);\n    }\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantUp(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const deltaNominalMain = MathSol.divUp(\n        MathSol.mul(invariant, bptOut),\n        bptSupply\n    );\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcMainOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const deltaNominalMain = MathSol.divDown(\n        MathSol.mul(invariant, bptIn),\n        bptSupply\n    );\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcMainOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulDownFixed(wrappedIn, params.rate);\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return mainBalance - newMainBalance;\n}\n\nexport function _calcMainInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulUpFixed(wrappedOut, params.rate);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    const newMainBalance = _fromNominal(afterNominalMain, params);\n    return newMainBalance - mainBalance;\n}\n\nexport function _calcBptOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    if (bptSupply == BigInt(0)) {\n        // Return nominal DAI\n        return MathSol.mulDownFixed(wrappedIn, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newWrappedBalance = wrappedBalance + wrappedIn;\n    const newInvariant = _calcInvariantDown(\n        nominalMain,\n        newWrappedBalance,\n        params\n    );\n    const newBptBalance = MathSol.divDown(\n        MathSol.mul(bptSupply, newInvariant),\n        previousInvariant\n    );\n    return newBptBalance - bptSupply;\n}\n\nexport function _calcWrappedInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount in, so we round up overall.\n    if (bptSupply == BigInt(0)) {\n        // Return nominal DAI\n        return MathSol.divUpFixed(bptOut, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newBptBalance = bptSupply + bptOut;\n    const newWrappedBalance = MathSol.divUpFixed(\n        MathSol.divUp(\n            MathSol.mul(newBptBalance, previousInvariant),\n            bptSupply\n        ) - nominalMain,\n        params.rate\n    );\n\n    return newWrappedBalance - wrappedBalance;\n}\n\nexport function _calcWrappedOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    // Amount out, so we round down overall.\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    const newBptBalance = bptSupply - bptIn;\n    const newWrappedBalance = MathSol.divUpFixed(\n        MathSol.divUp(\n            MathSol.mul(newBptBalance, previousInvariant),\n            bptSupply\n        ) - nominalMain,\n        params.rate\n    );\n\n    return wrappedBalance - newWrappedBalance;\n}\n\nfunction _calcInvariantUp(\n    nominalMainBalance: bigint,\n    wrappedBalance: bigint,\n    params: Params\n): bigint {\n    return nominalMainBalance + MathSol.mulUpFixed(wrappedBalance, params.rate);\n}\n\nfunction _calcInvariantDown(\n    nominalMainBalance: bigint,\n    wrappedBalance: bigint,\n    params: Params\n): bigint {\n    return (\n        nominalMainBalance + MathSol.mulDownFixed(wrappedBalance, params.rate)\n    );\n}\n\nfunction _toNominal(real: bigint, params: Params): bigint {\n    // Fees are always rounded down: either direction would work but we need to be consistent, and rounding down\n    // uses less gas.\n    if (real < params.lowerTarget) {\n        const fees = MathSol.mulDownFixed(\n            params.lowerTarget - real,\n            params.fee\n        );\n        return MathSol.sub(real, fees);\n    } else if (real <= params.upperTarget) {\n        return real;\n    } else {\n        const fees = MathSol.mulDownFixed(\n            real - params.upperTarget,\n            params.fee\n        );\n        return MathSol.sub(real, fees);\n    }\n}\n\nfunction _fromNominal(nominal: bigint, params: Params): bigint {\n    // Since real = nominal + fees, rounding down fees is equivalent to rounding down real.\n    if (nominal < params.lowerTarget) {\n        return MathSol.divDownFixed(\n            nominal + MathSol.mulDownFixed(params.fee, params.lowerTarget),\n            MathSol.ONE + params.fee\n        );\n    } else if (nominal <= params.upperTarget) {\n        return nominal;\n    } else {\n        return MathSol.divDownFixed(\n            nominal - MathSol.mulDownFixed(params.fee, params.upperTarget),\n            MathSol.ONE - params.fee\n        );\n    }\n}\n\nfunction leftDerivativeToNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount <= params.lowerTarget) {\n        return onePlusFee;\n    } else if (amount <= params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return oneMinusFee;\n    }\n}\n\nfunction rightDerivativeToNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount < params.lowerTarget) {\n        return onePlusFee;\n    } else if (amount < params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return oneMinusFee;\n    }\n}\n\nfunction leftDerivativeFromNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount <= params.lowerTarget) {\n        return MathSol.divUpFixed(MathSol.ONE, onePlusFee);\n    } else if (amount <= params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return MathSol.divUpFixed(MathSol.ONE, oneMinusFee);\n    }\n}\n\nfunction rightDerivativeFromNominal(amount: bigint, params: Params): bigint {\n    const oneMinusFee = MathSol.complementFixed(params.fee);\n    const onePlusFee = MathSol.ONE + params.fee;\n    if (amount < params.lowerTarget) {\n        return MathSol.divUpFixed(MathSol.ONE, onePlusFee);\n    } else if (amount < params.upperTarget) {\n        return MathSol.ONE;\n    } else {\n        return MathSol.divUpFixed(MathSol.ONE, oneMinusFee);\n    }\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    bptIndex: number\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = tokenAmountOut             /        bptIn         \\                                  //\n    // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n    // bpt = bptTotalSupply                                                                      //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, bptTotalSupply);\n    const amountsOut: bigint[] = new Array(balances.length).fill(BZERO);\n    for (let i = 0; i < balances.length; i++) {\n        // BPT is skipped as those tokens are not the LPs, but rather the preminted and undistributed amount.\n        if (i != bptIndex) {\n            amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n        }\n    }\n    return amountsOut;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'main->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const finalMainBalance = mainIn + mainBalance;\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    let poolFactor = MathSol.ONE;\n    if (bptSupply != BigInt(0)) {\n        poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    }\n    return MathSol.divUpFixed(\n        poolFactor,\n        rightDerivativeToNominal(finalMainBalance, params)\n    );\n}\n\n// PairType = 'main->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapMainInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    let poolFactor = MathSol.ONE;\n    if (bptSupply != BigInt(0)) {\n        poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    }\n    const deltaNominalMain = MathSol.mulUpFixed(bptOut, poolFactor);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    return MathSol.mulUpFixed(\n        poolFactor,\n        rightDerivativeFromNominal(afterNominalMain, params)\n    );\n}\n\n// PairType = 'BPT->main'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapMainOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const poolFactor = MathSol.divDownFixed(invariant, bptSupply);\n    const deltaNominalMain = MathSol.mulDownFixed(bptIn, poolFactor);\n    const afterNominalMain = MathSol.sub(previousNominalMain, deltaNominalMain);\n    return MathSol.divUpFixed(\n        MathSol.ONE,\n        MathSol.mulUpFixed(\n            poolFactor,\n            leftDerivativeFromNominal(afterNominalMain, params)\n        )\n    );\n}\n\n// PairType = 'BPT->main'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBptInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const finalMainBalance = MathSol.sub(mainBalance, mainOut);\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const invariant = _calcInvariantDown(\n        previousNominalMain,\n        wrappedBalance,\n        params\n    );\n    const poolFactor = MathSol.divUpFixed(invariant, bptSupply);\n    return MathSol.divUpFixed(\n        leftDerivativeToNominal(finalMainBalance, params),\n        poolFactor\n    );\n}\n\n// PairType = 'main->wrapped'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapMainInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulUpFixed(wrappedOut, params.rate);\n    const afterNominalMain = previousNominalMain + deltaNominalMain;\n    return MathSol.mulUpFixed(\n        rightDerivativeFromNominal(afterNominalMain, params),\n        params.rate\n    );\n}\n\n// PairType = 'wrapped->main'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapWrappedInPerMainOut(\n    mainOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const afterMain = mainBalance - mainOut;\n    return MathSol.divUpFixed(\n        leftDerivativeToNominal(afterMain, params),\n        params.rate\n    );\n}\n\n// PairType = 'main->wrapped'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapWrappedOutPerMainIn(\n    mainIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    return MathSol.divDownFixed(\n        params.rate,\n        rightDerivativeToNominal(mainBalance + mainIn, params)\n    );\n}\n\n// PairType = 'wrapped->main'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapMainOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const previousNominalMain = _toNominal(mainBalance, params);\n    const deltaNominalMain = MathSol.mulDownFixed(wrappedIn, params.rate);\n    const afterNominalMain = previousNominalMain - deltaNominalMain;\n    const inversePrice = MathSol.mulUpFixed(\n        leftDerivativeFromNominal(afterNominalMain, params),\n        params.rate\n    );\n    return MathSol.divUpFixed(MathSol.ONE, inversePrice);\n}\n\n// PairType = 'wrapped->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutPerWrappedIn(\n    wrappedIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    if (bptSupply == BigInt(0)) {\n        return params.rate;\n    }\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUpFixed(\n        previousInvariant,\n        MathSol.mulUpFixed(bptSupply, params.rate)\n    );\n}\n\n// PairType = 'BPT->wrapped'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapWrappedOutPerBptIn(\n    bptIn: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUp(\n        MathSol.mul(bptSupply, params.rate),\n        previousInvariant\n    );\n}\n\n// PairType = 'wrapped->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapWrappedInPerBptOut(\n    bptOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    if (bptSupply == BigInt(0)) {\n        return MathSol.divUpFixed(MathSol.ONE, params.rate);\n    }\n\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divUpFixed(\n        previousInvariant,\n        MathSol.mulUpFixed(bptSupply, params.rate)\n    );\n}\n\n// PairType = 'BPT->wrapped'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBptInPerWrappedOut(\n    wrappedOut: bigint,\n    mainBalance: bigint,\n    wrappedBalance: bigint,\n    bptSupply: bigint,\n    params: Params\n): bigint {\n    const nominalMain = _toNominal(mainBalance, params);\n    const previousInvariant = _calcInvariantUp(\n        nominalMain,\n        wrappedBalance,\n        params\n    );\n    return MathSol.divDown(\n        MathSol.mul(bptSupply, params.rate),\n        previousInvariant\n    );\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// Derivative of spot price is always zero, except at the target break points,\n// where it is infinity in some sense. But we ignore this pathology, return zero\n// and expect good behaviour at the optimization algorithm.\n"],"names":["_calcBptOutPerMainIn","mainIn","mainBalance","wrappedBalance","bptSupply","params","BigInt","_toNominal","previousNominalMain","deltaNominalMain","invariant","_calcInvariantUp","MathSol","divDown","mul","_calcBptInPerMainOut","mainOut","_calcInvariantDown","divUp","_calcBptInPerWrappedOut","wrappedOut","nominalMain","previousInvariant","newInvariant","_calcWrappedOutPerMainIn","divDownFixed","rate","_calcWrappedInPerMainOut","divUpFixed","_calcMainInPerBptOut","bptOut","_fromNominal","_calcMainOutPerBptIn","bptIn","_calcMainOutPerWrappedIn","wrappedIn","mulDownFixed","_calcMainInPerWrappedOut","mulUpFixed","_calcBptOutPerWrappedIn","_calcWrappedInPerBptOut","newBptBalance","_calcWrappedOutPerBptIn","nominalMainBalance","real","lowerTarget","fees","fee","sub","upperTarget","nominal","ONE","leftDerivativeToNominal","amount","oneMinusFee","complementFixed","onePlusFee","rightDerivativeToNominal","leftDerivativeFromNominal","rightDerivativeFromNominal","_calcTokensOutGivenExactBptIn","balances","bptAmountIn","bptTotalSupply","bptIndex","bptRatio","amountsOut","Array","length","fill","BZERO","i","_spotPriceAfterSwapBptOutPerMainIn","finalMainBalance","poolFactor","_spotPriceAfterSwapMainInPerBptOut","afterNominalMain","_spotPriceAfterSwapMainOutPerBptIn","_spotPriceAfterSwapBptInPerMainOut","_spotPriceAfterSwapMainInPerWrappedOut","_spotPriceAfterSwapWrappedInPerMainOut","afterMain","_spotPriceAfterSwapWrappedOutPerMainIn","_spotPriceAfterSwapMainOutPerWrappedIn","inversePrice","_spotPriceAfterSwapBptOutPerWrappedIn","_spotPriceAfterSwapWrappedOutPerBptIn","_spotPriceAfterSwapWrappedInPerBptOut","_spotPriceAfterSwapBptInPerWrappedOut"],"mappings":"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"}