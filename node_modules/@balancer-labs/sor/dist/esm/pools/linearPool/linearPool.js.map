{"version":3,"file":"linearPool.js","sources":["../../../../../../src/pools/linearPool/linearPool.ts"],"sourcesContent":["import { BigNumber, parseFixed, formatFixed } from '@ethersproject/bignumber';\nimport { bnum, INFINITY, scale, ZERO } from '../../utils/bignumber';\nimport { BigNumber as OldBigNumber } from '../../utils/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { isSameAddress } from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport {\n    _calcBptOutPerMainIn,\n    _calcBptInPerWrappedOut,\n    _calcBptInPerMainOut,\n    _calcWrappedOutPerMainIn,\n    _calcWrappedInPerMainOut,\n    _calcMainInPerBptOut,\n    _calcMainOutPerBptIn,\n    _calcMainOutPerWrappedIn,\n    _calcMainInPerWrappedOut,\n    _calcBptOutPerWrappedIn,\n    _calcWrappedInPerBptOut,\n    _calcWrappedOutPerBptIn,\n    _spotPriceAfterSwapBptOutPerMainIn,\n    _spotPriceAfterSwapMainOutPerBptIn,\n    _spotPriceAfterSwapBptOutPerWrappedIn,\n    _spotPriceAfterSwapWrappedOutPerBptIn,\n    _spotPriceAfterSwapWrappedOutPerMainIn,\n    _spotPriceAfterSwapMainOutPerWrappedIn,\n    _spotPriceAfterSwapMainInPerBptOut,\n    _spotPriceAfterSwapBptInPerMainOut,\n    _spotPriceAfterSwapWrappedInPerBptOut,\n    _spotPriceAfterSwapBptInPerWrappedOut,\n    _spotPriceAfterSwapMainInPerWrappedOut,\n    _spotPriceAfterSwapWrappedInPerMainOut,\n} from './linearMath';\n\nexport enum PairTypes {\n    BptToMainToken,\n    MainTokenToBpt,\n    MainTokenToWrappedToken,\n    WrappedTokenToMainToken,\n    BptToWrappedToken,\n    WrappedTokenToBpt,\n}\n\ntype LinearPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'priceRate'\n>;\n\nexport type LinearPoolPairData = PoolPairBase & {\n    pairType: PairTypes;\n    wrappedBalance: OldBigNumber; // If main token is USDC then wrapped token is aUSDC (or a wrapped version of it)\n    wrappedBalanceScaled: BigNumber; // If main token is USDC then wrapped token is aUSDC (or a wrapped version of it)\n    wrappedDecimals: number;\n    rate: BigNumber; // PriceRate of wrapped token\n    lowerTarget: BigNumber; // Target determine the range where there are positive, zero or negative fees\n    upperTarget: BigNumber; // when the \"main token\" has a balance below lowerTarget, there are negative fees when adding main token\n    mainBalanceScaled: BigNumber; // Scaled are used for EVM/SDK maths\n    bptBalanceScaled: BigNumber;\n    virtualBptSupply: BigNumber;\n};\n\nexport class LinearPool implements PoolBase<LinearPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Linear;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: LinearPoolToken[];\n    tokensList: string[];\n\n    wrappedIndex: number;\n    wrappedDecimals: number;\n    mainIndex: number;\n    bptIndex: number;\n    lowerTarget: BigNumber;\n    upperTarget: BigNumber;\n    MAX_RATIO = parseFixed('10', 18); // Specific for Linear pool types\n    ALMOST_ONE = parseFixed('0.99', 18);\n    // Used for VirutalBpt and can be removed if SG is updated with VirtualBpt value\n    MAX_TOKEN_BALANCE = BigNumber.from('2').pow('112').sub('1');\n\n    static fromPool(pool: SubgraphPoolBase): LinearPool {\n        if (pool.mainIndex === undefined)\n            throw new Error('LinearPool missing mainIndex');\n        if (pool.wrappedIndex === undefined)\n            throw new Error('LinearPool missing wrappedIndex');\n        if (!pool.lowerTarget)\n            throw new Error('LinearPool missing lowerTarget');\n        if (!pool.upperTarget)\n            throw new Error('LinearPool missing upperTarget');\n        return new LinearPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList,\n            pool.mainIndex,\n            pool.wrappedIndex,\n            pool.lowerTarget,\n            pool.upperTarget\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: LinearPoolToken[],\n        tokensList: string[],\n        mainIndex: number,\n        wrappedIndex: number,\n        lowerTarget: string,\n        upperTarget: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.mainIndex = mainIndex;\n        this.bptIndex = this.tokensList.indexOf(this.address);\n        this.wrappedIndex = wrappedIndex;\n        this.wrappedDecimals = this.tokens[this.wrappedIndex].decimals;\n        this.lowerTarget = parseFixed(lowerTarget, 18); // Wrapped token will have same decimals as underlying\n        this.upperTarget = parseFixed(upperTarget, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): LinearPoolPairData {\n        let pairType: PairTypes;\n\n        const tI = this.tokens.find((t) => isSameAddress(t.address, tokenIn));\n        if (!tI) throw Error(`Pool does not contain token in ${tokenIn}`);\n        const decimalsIn = tI.decimals;\n        const balanceIn = parseFixed(tI.balance, decimalsIn);\n\n        const tO = this.tokens.find((t) => isSameAddress(t.address, tokenOut));\n        if (!tO) throw Error(`Pool does not contain token out ${tokenOut}`);\n        const decimalsOut = tO.decimals;\n        const balanceOut = parseFixed(tO.balance, decimalsOut);\n\n        // Linear pools allow trading between token and pool BPT (phantom BPT)\n        if (isSameAddress(tokenIn, this.address)) {\n            if (isSameAddress(tokenOut, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.BptToWrappedToken;\n            else pairType = PairTypes.BptToMainToken;\n        } else if (isSameAddress(tokenOut, this.address)) {\n            if (isSameAddress(tokenIn, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.WrappedTokenToBpt;\n            else pairType = PairTypes.MainTokenToBpt;\n        } else {\n            if (isSameAddress(tokenIn, this.tokens[this.wrappedIndex].address))\n                pairType = PairTypes.WrappedTokenToMainToken;\n            else pairType = PairTypes.MainTokenToWrappedToken;\n        }\n\n        // Get all token balances scaled to 18\n        const allBalancesScaled = this.tokens.map(({ balance }) =>\n            parseFixed(balance, 18)\n        );\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/88a14eb623f6a22ef3f1afc5a8c49ebfa7eeceed/pkg/pool-linear/contracts/LinearPool.sol#L247\n        // VirtualBPTSupply must be used for the maths\n        // TO DO - SG should be updated to so that totalShares should return VirtualSupply\n        const bptBalanceScaled = allBalancesScaled[this.bptIndex];\n        const virtualBptSupply = this.MAX_TOKEN_BALANCE.sub(bptBalanceScaled);\n\n        const poolPairData: LinearPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            pairType: pairType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: balanceIn,\n            balanceOut: balanceOut,\n            swapFee: this.swapFee,\n            wrappedBalance: scale(\n                bnum(this.tokens[this.wrappedIndex].balance),\n                this.wrappedDecimals\n            ),\n            wrappedBalanceScaled: allBalancesScaled[this.wrappedIndex], // Note this is not multiplied by rate\n            wrappedDecimals: this.wrappedDecimals,\n            rate: parseFixed(this.tokens[this.wrappedIndex].priceRate, 18),\n            lowerTarget: this.lowerTarget,\n            upperTarget: this.upperTarget,\n            mainBalanceScaled: allBalancesScaled[this.mainIndex],\n            bptBalanceScaled,\n            virtualBptSupply,\n        };\n\n        return poolPairData;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getNormalizedLiquidity(poolPairData: LinearPoolPairData): OldBigNumber {\n        return INFINITY; // It is the inverse of zero\n        // This is correct since linear pools have no price impact,\n        // except for the swap fee that is expected to be small.\n    }\n\n    getLimitAmountSwap(\n        poolPairData: LinearPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // Needs to return human scaled numbers\n        const linearPoolPairData = poolPairData as LinearPoolPairData;\n        const balanceOutHuman = scale(\n            bnum(poolPairData.balanceOut.toString()),\n            -poolPairData.decimalsOut\n        );\n\n        if (swapType === SwapTypes.SwapExactIn) {\n            if (linearPoolPairData.pairType === PairTypes.MainTokenToBpt) {\n                return this._mainTokenInForExactBPTOut(\n                    poolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n            } else if (\n                linearPoolPairData.pairType === PairTypes.WrappedTokenToBpt\n            ) {\n                // Swapping to BPT allows for a very large amount so using pre-minted amount as estimation\n                return scale(bnum(this.MAX_TOKEN_BALANCE.toString()), -18);\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToMainToken\n            ) {\n                // Limit is amount of BPT in for pool balance of tokenOut\n                // Amount must be in human scale\n                return this._BPTInForExactMainTokenOut(\n                    linearPoolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToWrappedToken\n            ) {\n                const limit = this._BPTInForExactWrappedTokenOut(\n                    poolPairData,\n                    balanceOutHuman\n                        .times(this.ALMOST_ONE.toString())\n                        .div(ONE.toString())\n                );\n                // Returning Human scale\n                return limit;\n            } else if (\n                linearPoolPairData.pairType ===\n                    PairTypes.MainTokenToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.WrappedTokenToMainToken\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else return bnum(0);\n        } else {\n            if (\n                linearPoolPairData.pairType === PairTypes.MainTokenToBpt ||\n                linearPoolPairData.pairType === PairTypes.WrappedTokenToBpt\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.MAX_RATIO)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else if (\n                linearPoolPairData.pairType === PairTypes.BptToMainToken ||\n                linearPoolPairData.pairType === PairTypes.BptToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.MainTokenToWrappedToken ||\n                linearPoolPairData.pairType ===\n                    PairTypes.WrappedTokenToMainToken\n            ) {\n                const limit = bnum(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(ONE)\n                        .toString()\n                );\n                return scale(limit, -poolPairData.decimalsOut);\n            } else return bnum(0);\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n\n        // update total shares with BPT balance diff\n        if (isSameAddress(this.address, token)) {\n            const parsedTokenBalance = parseFixed(T.balance, T.decimals);\n            const diff = parsedTokenBalance.sub(newBalance);\n            const newTotalShares = this.totalShares.add(diff);\n            this.updateTotalShares(newTotalShares);\n        }\n        // update token balance with new balance\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n            return this._exactMainTokenInForBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n            return this._exactBPTInForMainTokenOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n            return this._exactWrappedTokenInForBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n            return this._exactBPTInForWrappedTokenOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n        ) {\n            return this._exactMainTokenInForWrappedOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n        ) {\n            return this._exactWrappedTokenInForMainOut(poolPairData, amount);\n        } else return bnum(0);\n    }\n\n    _exactWrappedTokenInForMainOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainOutPerWrappedIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactMainTokenInForWrappedOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedOutPerMainIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactMainTokenInForBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcBptOutPerMainIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactBPTInForMainTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainOutPerBptIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactWrappedTokenInForBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amt = _calcBptOutPerWrappedIn(\n                parseFixed(amount.toString(), 18).toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _exactBPTInForWrappedTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedOutPerBptIn(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n            return this._mainTokenInForExactBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n            return this._BPTInForExactMainTokenOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n            return this._wrappedTokenInForExactBPTOut(poolPairData, amount);\n        } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n            return this._BPTInForExactWrappedTokenOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n        ) {\n            return this._mainTokenInForExactWrappedOut(poolPairData, amount);\n        } else if (\n            poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n        ) {\n            return this._wrappedTokenInForExactMainOut(poolPairData, amount);\n        } else return bnum(0); // LinearPool does not support TokenToToken\n    }\n\n    _wrappedTokenInForExactMainOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedInPerMainOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _mainTokenInForExactWrappedOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcMainInPerWrappedOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _mainTokenInForExactBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n            // in = main\n            // out = BPT\n            const amt = _calcMainInPerBptOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _BPTInForExactMainTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcBptInPerMainOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _wrappedTokenInForExactBPTOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.toString(), 18);\n\n            const amt = _calcWrappedInPerBptOut(\n                amtScaled.toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _BPTInForExactWrappedTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amt = _calcBptInPerWrappedOut(\n                // amtNoRate.toBigInt(),\n                parseFixed(amount.toString(), 18).toBigInt(),\n                poolPairData.mainBalanceScaled.toBigInt(),\n                poolPairData.wrappedBalanceScaled.toBigInt(),\n                poolPairData.virtualBptSupply.toBigInt(),\n                {\n                    fee: poolPairData.swapFee.toBigInt(),\n                    lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                    upperTarget: poolPairData.upperTarget.toBigInt(),\n                    rate: poolPairData.rate.toBigInt(),\n                }\n            );\n            // return human readable number\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_UP mode (0)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsIn,\n                0\n            );\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Linear Pool doesn't have Exit Pool implementation\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Linear Pool doesn't have Join Pool implementation\n        return Zero;\n    }\n\n    // SPOT PRICES AFTER SWAP\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const bigintAmount = parseFixed(\n                amount.dp(18).toString(),\n                18\n            ).toBigInt();\n            const mainBalance = poolPairData.mainBalanceScaled.toBigInt();\n            const wrappedBalance = poolPairData.wrappedBalanceScaled.toBigInt();\n            const bptSupply = poolPairData.virtualBptSupply.toBigInt();\n            const params = {\n                fee: poolPairData.swapFee.toBigInt(),\n                lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                upperTarget: poolPairData.upperTarget.toBigInt(),\n                rate: poolPairData.rate.toBigInt(),\n            };\n            let result: bigint;\n            if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n                result = _spotPriceAfterSwapBptOutPerMainIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n                result = _spotPriceAfterSwapMainOutPerBptIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n                result = _spotPriceAfterSwapBptOutPerWrappedIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n                result = _spotPriceAfterSwapWrappedOutPerBptIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n            ) {\n                result = _spotPriceAfterSwapWrappedOutPerMainIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n            ) {\n                result = _spotPriceAfterSwapMainOutPerWrappedIn(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else return bnum(0);\n            return scale(bnum(result.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                0\n            );\n        } catch (err) {\n            return bnum(0);\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: LinearPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const bigintAmount = parseFixed(\n                amount.dp(18).toString(),\n                18\n            ).toBigInt();\n            const mainBalance = poolPairData.mainBalanceScaled.toBigInt();\n            const wrappedBalance = poolPairData.wrappedBalanceScaled.toBigInt();\n            const bptSupply = poolPairData.virtualBptSupply.toBigInt();\n            const params = {\n                fee: poolPairData.swapFee.toBigInt(),\n                lowerTarget: poolPairData.lowerTarget.toBigInt(),\n                upperTarget: poolPairData.upperTarget.toBigInt(),\n                rate: poolPairData.rate.toBigInt(),\n            };\n            let result: bigint;\n            if (poolPairData.pairType === PairTypes.MainTokenToBpt) {\n                result = _spotPriceAfterSwapMainInPerBptOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToMainToken) {\n                result = _spotPriceAfterSwapBptInPerMainOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.WrappedTokenToBpt) {\n                result = _spotPriceAfterSwapWrappedInPerBptOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToWrappedToken) {\n                result = _spotPriceAfterSwapBptInPerWrappedOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.MainTokenToWrappedToken\n            ) {\n                result = _spotPriceAfterSwapMainInPerWrappedOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else if (\n                poolPairData.pairType === PairTypes.WrappedTokenToMainToken\n            ) {\n                result = _spotPriceAfterSwapWrappedInPerMainOut(\n                    bigintAmount,\n                    mainBalance,\n                    wrappedBalance,\n                    bptSupply,\n                    params\n                );\n            } else return bnum(0);\n            return scale(bnum(result.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                0\n            );\n        } catch (err) {\n            return bnum(0);\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        poolPairData: LinearPoolPairData,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return bnum(0);\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        poolPairData: LinearPoolPairData,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return bnum(0);\n    }\n}\n"],"names":["PairTypes","LinearPool","static","pool","undefined","mainIndex","Error","wrappedIndex","lowerTarget","upperTarget","id","address","swapFee","totalShares","tokens","tokensList","constructor","this","poolType","PoolTypes","Linear","MAX_RATIO","parseFixed","ALMOST_ONE","MAX_TOKEN_BALANCE","BigNumber","from","pow","sub","bptIndex","indexOf","wrappedDecimals","decimals","parsePoolPairData","tokenIn","tokenOut","pairType","tI","find","t","isSameAddress","decimalsIn","balanceIn","balance","tO","decimalsOut","balanceOut","BptToWrappedToken","BptToMainToken","WrappedTokenToBpt","MainTokenToBpt","WrappedTokenToMainToken","MainTokenToWrappedToken","allBalancesScaled","map","bptBalanceScaled","virtualBptSupply","Number","wrappedBalance","scale","bnum","wrappedBalanceScaled","rate","priceRate","mainBalanceScaled","getNormalizedLiquidity","poolPairData","INFINITY","getLimitAmountSwap","swapType","linearPoolPairData","balanceOutHuman","toString","SwapTypes","SwapExactIn","_mainTokenInForExactBPTOut","times","div","ONE","_BPTInForExactMainTokenOut","_BPTInForExactWrappedTokenOut","limit","mul","updateTokenBalanceForPool","token","newBalance","T","diff","newTotalShares","add","updateTotalShares","formatFixed","_exactTokenInForTokenOut","amount","_exactMainTokenInForBPTOut","_exactBPTInForMainTokenOut","_exactWrappedTokenInForBPTOut","_exactBPTInForWrappedTokenOut","_exactMainTokenInForWrappedOut","_exactWrappedTokenInForMainOut","amtScaled","amt","_calcMainOutPerWrappedIn","toBigInt","fee","dp","err","ZERO","_calcWrappedOutPerMainIn","_calcBptOutPerMainIn","_calcMainOutPerBptIn","_calcBptOutPerWrappedIn","_calcWrappedOutPerBptIn","_tokenInForExactTokenOut","_wrappedTokenInForExactBPTOut","_mainTokenInForExactWrappedOut","_wrappedTokenInForExactMainOut","_calcWrappedInPerMainOut","_calcMainInPerWrappedOut","_calcMainInPerBptOut","_calcBptInPerMainOut","_calcWrappedInPerBptOut","_calcBptInPerWrappedOut","_calcTokensOutGivenExactBptIn","bptAmountIn","Array","length","fill","Zero","_calcBptOutGivenExactTokensIn","amountsIn","_spotPriceAfterSwapExactTokenInForTokenOut","bigintAmount","mainBalance","bptSupply","params","result","_spotPriceAfterSwapBptOutPerMainIn","_spotPriceAfterSwapMainOutPerBptIn","_spotPriceAfterSwapBptOutPerWrappedIn","_spotPriceAfterSwapWrappedOutPerBptIn","_spotPriceAfterSwapWrappedOutPerMainIn","_spotPriceAfterSwapMainOutPerWrappedIn","_spotPriceAfterSwapTokenInForExactTokenOut","_spotPriceAfterSwapMainInPerBptOut","_spotPriceAfterSwapBptInPerMainOut","_spotPriceAfterSwapWrappedInPerBptOut","_spotPriceAfterSwapBptInPerWrappedOut","_spotPriceAfterSwapMainInPerWrappedOut","_spotPriceAfterSwapWrappedInPerMainOut","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut"],"mappings":"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"}