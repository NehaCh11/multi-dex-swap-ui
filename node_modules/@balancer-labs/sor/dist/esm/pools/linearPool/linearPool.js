import{parseFixed as t,BigNumber as e,formatFixed as a}from"@ethersproject/bignumber";import{scale as n,bnum as r,INFINITY as o,ZERO as i}from"../../utils/bignumber.js";import{WeiPerEther as p,Zero as T}from"@ethersproject/constants";import{isSameAddress as s}from"../../utils/index.js";import{PoolTypes as d,SwapTypes as g}from"../../types.js";import{_calcMainOutPerWrappedIn as B,_calcWrappedOutPerMainIn as l,_calcBptOutPerMainIn as c,_calcMainOutPerBptIn as u,_calcBptOutPerWrappedIn as I,_calcWrappedOutPerBptIn as k,_calcWrappedInPerMainOut as h,_calcMainInPerWrappedOut as w,_calcMainInPerBptOut as S,_calcBptInPerMainOut as m,_calcWrappedInPerBptOut as O,_calcBptInPerWrappedOut as y,_spotPriceAfterSwapBptOutPerMainIn as M,_spotPriceAfterSwapMainOutPerBptIn as f,_spotPriceAfterSwapBptOutPerWrappedIn as x,_spotPriceAfterSwapWrappedOutPerBptIn as F,_spotPriceAfterSwapWrappedOutPerMainIn as W,_spotPriceAfterSwapMainOutPerWrappedIn as _,_spotPriceAfterSwapMainInPerBptOut as E,_spotPriceAfterSwapBptInPerMainOut as P,_spotPriceAfterSwapWrappedInPerBptOut as v,_spotPriceAfterSwapBptInPerWrappedOut as A,_spotPriceAfterSwapMainInPerWrappedOut as b,_spotPriceAfterSwapWrappedInPerMainOut as L}from"./linearMath.js";var N;!function(t){t[t.BptToMainToken=0]="BptToMainToken",t[t.MainTokenToBpt=1]="MainTokenToBpt",t[t.MainTokenToWrappedToken=2]="MainTokenToWrappedToken",t[t.WrappedTokenToMainToken=3]="WrappedTokenToMainToken",t[t.BptToWrappedToken=4]="BptToWrappedToken",t[t.WrappedTokenToBpt=5]="WrappedTokenToBpt"}(N||(N={}));class j{static fromPool(t){if(void 0===t.mainIndex)throw new Error("LinearPool missing mainIndex");if(void 0===t.wrappedIndex)throw new Error("LinearPool missing wrappedIndex");if(!t.lowerTarget)throw new Error("LinearPool missing lowerTarget");if(!t.upperTarget)throw new Error("LinearPool missing upperTarget");return new j(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,t.mainIndex,t.wrappedIndex,t.lowerTarget,t.upperTarget)}constructor(a,n,r,o,i,p,T,s,g,B){this.poolType=d.Linear,this.MAX_RATIO=t("10",18),this.ALMOST_ONE=t("0.99",18),this.MAX_TOKEN_BALANCE=e.from("2").pow("112").sub("1"),this.id=a,this.address=n,this.swapFee=t(r,18),this.totalShares=t(o,18),this.tokens=i,this.tokensList=p,this.mainIndex=T,this.bptIndex=this.tokensList.indexOf(this.address),this.wrappedIndex=s,this.wrappedDecimals=this.tokens[this.wrappedIndex].decimals,this.lowerTarget=t(g,18),this.upperTarget=t(B,18)}parsePoolPairData(e,a){let o;const i=this.tokens.find((t=>s(t.address,e)));if(!i)throw Error(`Pool does not contain token in ${e}`);const p=i.decimals,T=t(i.balance,p),d=this.tokens.find((t=>s(t.address,a)));if(!d)throw Error(`Pool does not contain token out ${a}`);const g=d.decimals,B=t(d.balance,g);o=s(e,this.address)?s(a,this.tokens[this.wrappedIndex].address)?N.BptToWrappedToken:N.BptToMainToken:s(a,this.address)?s(e,this.tokens[this.wrappedIndex].address)?N.WrappedTokenToBpt:N.MainTokenToBpt:s(e,this.tokens[this.wrappedIndex].address)?N.WrappedTokenToMainToken:N.MainTokenToWrappedToken;const l=this.tokens.map((({balance:e})=>t(e,18))),c=l[this.bptIndex],u=this.MAX_TOKEN_BALANCE.sub(c);return{id:this.id,address:this.address,poolType:this.poolType,pairType:o,tokenIn:e,tokenOut:a,decimalsIn:Number(p),decimalsOut:Number(g),balanceIn:T,balanceOut:B,swapFee:this.swapFee,wrappedBalance:n(r(this.tokens[this.wrappedIndex].balance),this.wrappedDecimals),wrappedBalanceScaled:l[this.wrappedIndex],wrappedDecimals:this.wrappedDecimals,rate:t(this.tokens[this.wrappedIndex].priceRate,18),lowerTarget:this.lowerTarget,upperTarget:this.upperTarget,mainBalanceScaled:l[this.mainIndex],bptBalanceScaled:c,virtualBptSupply:u}}getNormalizedLiquidity(t){return o}getLimitAmountSwap(t,e){const a=t,o=n(r(t.balanceOut.toString()),-t.decimalsOut);if(e===g.SwapExactIn){if(a.pairType===N.MainTokenToBpt)return this._mainTokenInForExactBPTOut(t,o.times(this.ALMOST_ONE.toString()).div(p.toString()));if(a.pairType===N.WrappedTokenToBpt)return n(r(this.MAX_TOKEN_BALANCE.toString()),-18);if(a.pairType===N.BptToMainToken)return this._BPTInForExactMainTokenOut(a,o.times(this.ALMOST_ONE.toString()).div(p.toString()));if(a.pairType===N.BptToWrappedToken){return this._BPTInForExactWrappedTokenOut(t,o.times(this.ALMOST_ONE.toString()).div(p.toString()))}if(a.pairType===N.MainTokenToWrappedToken||a.pairType===N.WrappedTokenToMainToken){const e=r(t.balanceOut.mul(this.ALMOST_ONE).div(p).toString());return n(e,-t.decimalsOut)}return r(0)}if(a.pairType===N.MainTokenToBpt||a.pairType===N.WrappedTokenToBpt){const e=r(t.balanceOut.mul(this.MAX_RATIO).div(p).toString());return n(e,-t.decimalsOut)}if(a.pairType===N.BptToMainToken||a.pairType===N.BptToWrappedToken||a.pairType===N.MainTokenToWrappedToken||a.pairType===N.WrappedTokenToMainToken){const e=r(t.balanceOut.mul(this.ALMOST_ONE).div(p).toString());return n(e,-t.decimalsOut)}return r(0)}updateTokenBalanceForPool(e,n){const r=this.tokens.find((t=>s(t.address,e)));if(!r)throw Error("Pool does not contain this token");if(s(this.address,e)){const e=t(r.balance,r.decimals).sub(n),a=this.totalShares.add(e);this.updateTotalShares(a)}r.balance=a(n,r.decimals)}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,e){return t.pairType===N.MainTokenToBpt?this._exactMainTokenInForBPTOut(t,e):t.pairType===N.BptToMainToken?this._exactBPTInForMainTokenOut(t,e):t.pairType===N.WrappedTokenToBpt?this._exactWrappedTokenInForBPTOut(t,e):t.pairType===N.BptToWrappedToken?this._exactBPTInForWrappedTokenOut(t,e):t.pairType===N.MainTokenToWrappedToken?this._exactMainTokenInForWrappedOut(t,e):t.pairType===N.WrappedTokenToMainToken?this._exactWrappedTokenInForMainOut(t,e):r(0)}_exactWrappedTokenInForMainOut(e,a){try{const o=t(a.toString(),18),i=B(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_exactMainTokenInForWrappedOut(e,a){try{const o=t(a.toString(),18),i=l(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_exactMainTokenInForBPTOut(e,a){try{const o=t(a.toString(),18),i=c(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_exactBPTInForMainTokenOut(e,a){try{const o=t(a.toString(),18),i=u(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_exactWrappedTokenInForBPTOut(e,a){try{const o=I(t(a.toString(),18).toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(o.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_exactBPTInForWrappedTokenOut(e,a){try{const o=t(a.toString(),18),i=k(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_tokenInForExactTokenOut(t,e){return t.pairType===N.MainTokenToBpt?this._mainTokenInForExactBPTOut(t,e):t.pairType===N.BptToMainToken?this._BPTInForExactMainTokenOut(t,e):t.pairType===N.WrappedTokenToBpt?this._wrappedTokenInForExactBPTOut(t,e):t.pairType===N.BptToWrappedToken?this._BPTInForExactWrappedTokenOut(t,e):t.pairType===N.MainTokenToWrappedToken?this._mainTokenInForExactWrappedOut(t,e):t.pairType===N.WrappedTokenToMainToken?this._wrappedTokenInForExactMainOut(t,e):r(0)}_wrappedTokenInForExactMainOut(e,a){try{const o=t(a.toString(),18),i=h(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_mainTokenInForExactWrappedOut(e,a){try{const o=t(a.toString(),18),i=w(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsOut,1)}catch(t){return i}}_mainTokenInForExactBPTOut(e,a){try{const o=t(a.toString(),18),i=S(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsIn,0)}catch(t){return i}}_BPTInForExactMainTokenOut(e,a){try{const o=t(a.toString(),18),i=m(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsIn,0)}catch(t){return i}}_wrappedTokenInForExactBPTOut(e,a){try{const o=t(a.toString(),18),i=O(o.toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(i.toString()),-18).dp(e.decimalsIn,0)}catch(t){return i}}_BPTInForExactWrappedTokenOut(e,a){try{const o=y(t(a.toString(),18).toBigInt(),e.mainBalanceScaled.toBigInt(),e.wrappedBalanceScaled.toBigInt(),e.virtualBptSupply.toBigInt(),{fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()});return n(r(o.toString()),-18).dp(e.decimalsIn,0)}catch(t){return i}}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(T)}_calcBptOutGivenExactTokensIn(t){return T}_spotPriceAfterSwapExactTokenInForTokenOut(e,a){try{const o=t(a.dp(18).toString(),18).toBigInt(),i=e.mainBalanceScaled.toBigInt(),p=e.wrappedBalanceScaled.toBigInt(),T=e.virtualBptSupply.toBigInt(),s={fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()};let d;if(e.pairType===N.MainTokenToBpt)d=M(o,i,p,T,s);else if(e.pairType===N.BptToMainToken)d=f(o,i,p,T,s);else if(e.pairType===N.WrappedTokenToBpt)d=x(o,i,p,T,s);else if(e.pairType===N.BptToWrappedToken)d=F(o,i,p,T,s);else if(e.pairType===N.MainTokenToWrappedToken)d=W(o,i,p,T,s);else{if(e.pairType!==N.WrappedTokenToMainToken)return r(0);d=_(o,i,p,T,s)}return n(r(d.toString()),-18).dp(e.decimalsOut,0)}catch(t){return r(0)}}_spotPriceAfterSwapTokenInForExactTokenOut(e,a){try{const o=t(a.dp(18).toString(),18).toBigInt(),i=e.mainBalanceScaled.toBigInt(),p=e.wrappedBalanceScaled.toBigInt(),T=e.virtualBptSupply.toBigInt(),s={fee:e.swapFee.toBigInt(),lowerTarget:e.lowerTarget.toBigInt(),upperTarget:e.upperTarget.toBigInt(),rate:e.rate.toBigInt()};let d;if(e.pairType===N.MainTokenToBpt)d=E(o,i,p,T,s);else if(e.pairType===N.BptToMainToken)d=P(o,i,p,T,s);else if(e.pairType===N.WrappedTokenToBpt)d=v(o,i,p,T,s);else if(e.pairType===N.BptToWrappedToken)d=A(o,i,p,T,s);else if(e.pairType===N.MainTokenToWrappedToken)d=b(o,i,p,T,s);else{if(e.pairType!==N.WrappedTokenToMainToken)return r(0);d=L(o,i,p,T,s)}return n(r(d.toString()),-18).dp(e.decimalsOut,0)}catch(t){return r(0)}}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){return r(0)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){return r(0)}}export{j as LinearPool,N as PairTypes};
//# sourceMappingURL=linearPool.js.map
