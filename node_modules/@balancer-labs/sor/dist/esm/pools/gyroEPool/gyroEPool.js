import{getAddress as e}from"@ethersproject/address";import{WeiPerEther as t,Zero as a}from"@ethersproject/constants";import{formatFixed as s}from"@ethersproject/bignumber";import{ZERO as r,bnum as o}from"../../utils/bignumber.js";import{PoolTypes as n,SwapTypes as i}from"../../types.js";import{normalizeBalances as d,balancesFromTokenInOut as m,virtualOffset0 as l,virtualOffset1 as c,reduceFee as u,addFee as h}from"./gyroEMath/gyroEMathHelpers.js";import{safeParseFixed as p,isSameAddress as k}from"../../utils/index.js";import{divDown as y,mulDown as I}from"../gyroHelpers/gyroSignedFixedPoint.js";import{calculateInvariantWithError as E,calcOutGivenIn as P,calcInGivenOut as b,calcSpotPriceAfterSwapOutGivenIn as g,calcSpotPriceAfterSwapInGivenOut as T,calcDerivativePriceAfterSwapOutGivenIn as v,calcDerivativeSpotPriceAfterSwapInGivenOut as w}from"./gyroEMath/gyroEMath.js";import{SWAP_LIMIT_FACTOR as O}from"../gyroHelpers/constants.js";import{universalNormalizedLiquidity as f}from"../liquidity.js";class S{static fromPool(e){const{alpha:t,beta:a,c:s,s:r,lambda:o,tauAlphaX:n,tauAlphaY:i,tauBetaX:d,tauBetaY:m,u:l,v:c,w:u,z:h,dSq:p}=e,k={alpha:t,beta:a,c:s,s:r,lambda:o},y={tauAlphaX:n,tauAlphaY:i,tauBetaX:d,tauBetaY:m,u:l,v:c,w:u,z:h,dSq:p};if(!Object.values(k).every((e=>e))||!Object.values(y).every((e=>e)))throw new Error("Pool missing GyroE params and/or GyroE derived params");return new S(e.id,e.address,e.swapFee,e.totalShares,e.tokens,e.tokensList,k,y)}constructor(e,t,a,s,r,o,i,d){this.poolType=n.GyroE,this.id=e,this.address=t,this.swapFee=p(a,18),this.totalShares=p(s,18),this.tokens=r,this.tokensList=o,this.gyroEParams={alpha:p(i.alpha,18),beta:p(i.beta,18),c:p(i.c,18),s:p(i.s,18),lambda:p(i.lambda,18)},this.derivedGyroEParams={tauAlpha:{x:p(d.tauAlphaX,38),y:p(d.tauAlphaY,38)},tauBeta:{x:p(d.tauBetaX,38),y:p(d.tauBetaY,38)},u:p(d.u,38),v:p(d.v,38),w:p(d.w,38),z:p(d.z,38),dSq:p(d.dSq,38)}}parsePoolPairData(t,a){const s=this.tokens.findIndex((a=>e(a.address)===e(t)));if(s<0)throw"Pool does not contain tokenIn";const r=this.tokens[s],o=r.balance,n=r.decimals,i=this.tokens.findIndex((t=>e(t.address)===e(a)));if(i<0)throw"Pool does not contain tokenOut";const d=this.tokens[i],m=d.balance,l=d.decimals,c=0===s;return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:t,tokenOut:a,decimalsIn:Number(n),decimalsOut:Number(l),balanceIn:p(o,n),balanceOut:p(m,l),swapFee:this.swapFee,tokenInIsToken0:c}}getNormalizedLiquidity(e){return f(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(e,r))}getLimitAmountSwap(e,a){if(a===i.SwapExactIn){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),u={x:n.add(i.mul(2)),y:n},h=e.tokenInIsToken0?l:c,p=h(this.gyroEParams,this.derivedGyroEParams,u).sub(h(this.gyroEParams,this.derivedGyroEParams,u,!0)).sub(a[0]),k=y(p,t.sub(e.swapFee));return o(s(I(k,O),18))}return o(s(I(e.balanceOut,O),e.decimalsOut))}updateTokenBalanceForPool(e,t){if(k(this.address,e))this.updateTotalShares(t);else{const a=this.tokens.find((t=>k(t.address,e)));if(!a)throw Error("Pool does not contain this token");a.balance=s(t,a.decimals)}}updateTotalShares(e){this.totalShares=e}_exactTokenInForTokenOut(e,t){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),l={x:n.add(i.mul(2)),y:n},c=p(t.toString(),18),h=u(c,e.swapFee),k=P(r,h,e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l);return o(s(k,18))}_tokenInForExactTokenOut(e,t){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),l={x:n.add(i.mul(2)),y:n},c=p(t.toString(),18),u=b(r,c,e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l),k=h(u,e.swapFee);return o(s(k,18))}_calcTokensOutGivenExactBptIn(e){return new Array(this.tokens.length).fill(a)}_calcBptOutGivenExactTokensIn(e){return a}_spotPriceAfterSwapExactTokenInForTokenOut(e,t){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),l={x:n.add(i.mul(2)),y:n},c=p(t.toString(),18),h=u(c,e.swapFee),k=g(r,h,e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l,e.swapFee);return o(s(k,18))}_spotPriceAfterSwapTokenInForExactTokenOut(e,t){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),l={x:n.add(i.mul(2)),y:n},c=p(t.toString(),18),u=T(r,c,e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l,e.swapFee);return o(s(u,18))}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(e,t){const a=p(t.toString(),18),r=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),n=m(r[0],r[1],e.tokenInIsToken0),[i,l]=E(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(l.mul(2)),y:i},h=v([n[0].add(u(a,e.swapFee)),n[1]],e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c,e.swapFee);return o(s(h,18))}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(e,t){const a=d([e.balanceIn,e.balanceOut],[e.decimalsIn,e.decimalsOut]),r=m(a[0],a[1],e.tokenInIsToken0),[n,i]=E(r,this.gyroEParams,this.derivedGyroEParams),l={x:n.add(i.mul(2)),y:n},c=p(t.toString(),18),u=w([r[0],r[1].sub(c)],e.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l,e.swapFee);return o(s(u,18))}}export{S as GyroEPool};
//# sourceMappingURL=gyroEPool.js.map
