{"version":3,"file":"stablePool.js","sources":["../../../../../../src/pools/stablePool/stablePool.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    scale,\n    ZERO,\n} from '../../utils/bignumber';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport {\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n} from './stableMath';\nimport {\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcTokensOutGivenExactBptIn,\n} from './stableMathBigInt';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\ntype StablePoolToken = Pick<SubgraphToken, 'address' | 'balance' | 'decimals'>;\n\nexport type StablePoolPairData = PoolPairBase & {\n    allBalances: OldBigNumber[];\n    allBalancesScaled: BigNumber[]; // EVM Maths uses everything in 1e18 upscaled format and this avoids repeated scaling\n    amp: BigNumber;\n    tokenIndexIn: number;\n    tokenIndexOut: number;\n};\n\nexport class StablePool implements PoolBase<StablePoolPairData> {\n    poolType: PoolTypes = PoolTypes.Stable;\n    id: string;\n    address: string;\n    amp: BigNumber;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: StablePoolToken[];\n    tokensList: string[];\n    MAX_IN_RATIO = parseFixed('0.3', 18);\n    MAX_OUT_RATIO = parseFixed('0.3', 18);\n\n    static AMP_DECIMALS = 3;\n\n    static fromPool(pool: SubgraphPoolBase): StablePool {\n        if (!pool.amp) throw new Error('StablePool missing amp factor');\n        return new StablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: StablePoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.amp = parseFixed(amp, StablePool.AMP_DECIMALS);\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): StablePoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        // Get all token balances\n        const allBalances = this.tokens.map(({ balance }) => bnum(balance));\n        const allBalancesScaled = this.tokens.map(({ balance }) =>\n            parseFixed(balance, 18)\n        );\n\n        const poolPairData: StablePoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            allBalances,\n            allBalancesScaled, // TO DO - Change to BigInt??\n            amp: this.amp,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: StablePoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PoolPairBase,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // We multiply ratios by 10**-18 because we are in normalized space\n        // so 0.5 should be 0.5 and not 500000000000000000\n        // TODO: update bmath to use everything normalized\n        if (swapType === SwapTypes.SwapExactIn) {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceIn.mul(this.MAX_IN_RATIO).div(ONE),\n                    poolPairData.decimalsIn\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut.mul(this.MAX_OUT_RATIO).div(ONE),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n\n            const amtWithFeeEvm = this.subtractSwapFeeAmount(\n                parseFixed(\n                    amount.dp(poolPairData.decimalsIn).toString(),\n                    poolPairData.decimalsIn\n                ),\n                poolPairData.swapFee\n            );\n\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = amtWithFeeEvm.mul(\n                10 ** (18 - poolPairData.decimalsIn)\n            );\n\n            const amt = _calcOutGivenIn(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amtScaled.toBigInt(),\n                BigInt(0)\n            );\n\n            // return normalised amount\n            // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n            // i.e. when using token with 2decimals 0.002 should be returned as 0\n            // Uses ROUND_DOWN mode (1)\n            return scale(bnum(amt.toString()), -18).dp(\n                poolPairData.decimalsOut,\n                1\n            );\n        } catch (err) {\n            // console.error(`_evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amtScaled = parseFixed(amount.dp(18).toString(), 18);\n\n            let amt = _calcInGivenOut(\n                this.amp.toBigInt(),\n                poolPairData.allBalancesScaled.map((balance) =>\n                    balance.toBigInt()\n                ),\n                poolPairData.tokenIndexIn,\n                poolPairData.tokenIndexOut,\n                amtScaled.toBigInt(),\n                BigInt(0)\n            );\n\n            // this is downscaleUp\n            const scaleFactor = BigInt(10 ** (18 - poolPairData.decimalsIn));\n            amt = (amt + scaleFactor - BigInt(1)) / scaleFactor;\n\n            const amtWithFee = this.addSwapFeeAmount(\n                BigNumber.from(amt),\n                poolPairData.swapFee\n            );\n            return bnum(amtWithFee.toString()).div(\n                10 ** poolPairData.decimalsIn\n            );\n        } catch (err) {\n            console.error(`_evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        // takes price rate into account\n        const balancesNormalised = this.tokens\n            .filter((t) => !isSameAddress(t.address, this.address))\n            .map((t) => normaliseBalance(t));\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, this.tokens[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                this.amp.toBigInt(),\n                balancesNormalised,\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            return Zero;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _spotPriceAfterSwapExactTokenInForTokenOut(amount, poolPairData);\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _spotPriceAfterSwapTokenInForExactTokenOut(amount, poolPairData);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: StablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n\n    subtractSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L466\n        const feeAmount = amount.mul(swapFee).add(ONE.sub(1)).div(ONE);\n        return amount.sub(feeAmount);\n    }\n\n    addSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L458\n        const feeAmount = ONE.sub(swapFee);\n        return amount.mul(ONE).add(feeAmount.sub(1)).div(feeAmount);\n    }\n}\n"],"names":["StablePool","static","pool","amp","Error","id","address","swapFee","totalShares","tokens","tokensList","constructor","this","poolType","PoolTypes","Stable","MAX_IN_RATIO","parseFixed","MAX_OUT_RATIO","AMP_DECIMALS","parsePoolPairData","tokenIn","tokenOut","tokenIndexIn","findIndex","t","getAddress","tI","balanceIn","balance","decimalsIn","decimals","tokenIndexOut","tO","balanceOut","decimalsOut","allBalances","map","bnum","allBalancesScaled","Number","getNormalizedLiquidity","poolPairData","universalNormalizedLiquidity","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","ZERO","getLimitAmountSwap","swapType","SwapTypes","SwapExactIn","formatFixed","mul","div","ONE","updateTokenBalanceForPool","token","newBalance","isSameAddress","updateTotalShares","T","find","newTotalShares","_exactTokenInForTokenOut","amount","isZero","amtScaled","subtractSwapFeeAmount","dp","toString","amt","_calcOutGivenIn","toBigInt","BigInt","scale","err","_tokenInForExactTokenOut","_calcInGivenOut","scaleFactor","amtWithFee","addSwapFeeAmount","BigNumber","from","console","error","message","_calcTokensOutGivenExactBptIn","bptAmountIn","balancesNormalised","filter","normaliseBalance","amountsOutNormalised","a","i","denormaliseAmount","Array","length","fill","_calcBptOutGivenExactTokensIn","amountsIn","amountsInNormalised","forEach","normaliseAmount","bptAmountOut","Zero","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","feeAmount","add","sub"],"mappings":"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"}