import{getAddress as t}from"@ethersproject/address";import{parseFixed as e,formatFixed as n,BigNumber as s}from"@ethersproject/bignumber";import{WeiPerEther as o,Zero as a}from"@ethersproject/constants";import{bnum as r,ZERO as i,scale as c}from"../../utils/bignumber.js";import{isSameAddress as d,normaliseBalance as l,denormaliseAmount as m,normaliseAmount as p}from"../../utils/index.js";import{PoolTypes as u,SwapTypes as h}from"../../types.js";import{_spotPriceAfterSwapExactTokenInForTokenOut as I,_spotPriceAfterSwapTokenInForExactTokenOut as k,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as f,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as g}from"./stableMath.js";import{_calcOutGivenIn as S,_calcInGivenOut as w,_calcTokensOutGivenExactBptIn as T,_calcBptOutGivenExactTokensIn as B}from"./stableMathBigInt.js";import{universalNormalizedLiquidity as O}from"../liquidity.js";class b{static fromPool(t){if(!t.amp)throw new Error("StablePool missing amp factor");return new b(t.id,t.address,t.amp,t.swapFee,t.totalShares,t.tokens,t.tokensList)}constructor(t,n,s,o,a,r,i){this.poolType=u.Stable,this.MAX_IN_RATIO=e("0.3",18),this.MAX_OUT_RATIO=e("0.3",18),this.id=t,this.address=n,this.amp=e(s,b.AMP_DECIMALS),this.swapFee=e(o,18),this.totalShares=e(a,18),this.tokens=r,this.tokensList=i}parsePoolPairData(n,s){const o=this.tokens.findIndex((e=>t(e.address)===t(n)));if(o<0)throw"Pool does not contain tokenIn";const a=this.tokens[o],i=a.balance,c=a.decimals,d=this.tokens.findIndex((e=>t(e.address)===t(s)));if(d<0)throw"Pool does not contain tokenOut";const l=this.tokens[d],m=l.balance,p=l.decimals,u=this.tokens.map((({balance:t})=>r(t))),h=this.tokens.map((({balance:t})=>e(t,18)));return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:n,tokenOut:s,balanceIn:e(i,c),balanceOut:e(m,p),swapFee:this.swapFee,allBalances:u,allBalancesScaled:h,amp:this.amp,tokenIndexIn:o,tokenIndexOut:d,decimalsIn:Number(c),decimalsOut:Number(p)}}getNormalizedLiquidity(t){return O(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,i))}getLimitAmountSwap(t,e){return e===h.SwapExactIn?r(n(t.balanceIn.mul(this.MAX_IN_RATIO).div(o),t.decimalsIn)):r(n(t.balanceOut.mul(this.MAX_OUT_RATIO).div(o),t.decimalsOut))}updateTokenBalanceForPool(t,e){if(d(this.address,t))this.updateTotalShares(e);else{const s=this.tokens.find((e=>d(e.address,t)));if(!s)throw Error("Pool does not contain this token");s.balance=n(e,s.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,n){try{if(n.isZero())return i;const s=this.subtractSwapFeeAmount(e(n.dp(t.decimalsIn).toString(),t.decimalsIn),t.swapFee).mul(10**(18-t.decimalsIn)),o=S(this.amp.toBigInt(),t.allBalancesScaled.map((t=>t.toBigInt())),t.tokenIndexIn,t.tokenIndexOut,s.toBigInt(),BigInt(0));return c(r(o.toString()),-18).dp(t.decimalsOut,1)}catch(t){return i}}_tokenInForExactTokenOut(t,n){try{if(n.isZero())return i;const o=e(n.dp(18).toString(),18);let a=w(this.amp.toBigInt(),t.allBalancesScaled.map((t=>t.toBigInt())),t.tokenIndexIn,t.tokenIndexOut,o.toBigInt(),BigInt(0));const c=BigInt(10**(18-t.decimalsIn));a=(a+c-BigInt(1))/c;const d=this.addSwapFeeAmount(s.from(a),t.swapFee);return r(d.toString()).div(10**t.decimalsIn)}catch(t){return console.error(`_evminGivenOut: ${t.message}`),i}}_calcTokensOutGivenExactBptIn(t){const e=this.tokens.filter((t=>!d(t.address,this.address))).map((t=>l(t)));try{const n=T(e,t.toBigInt(),this.totalShares.toBigInt());return n.map(((t,e)=>m(t,this.tokens[e]))).map((t=>s.from(t)))}catch(t){return new Array(e.length).fill(i)}}_calcBptOutGivenExactTokensIn(t){try{const e=new Array(t.length).fill(BigInt(0)),n=new Array(t.length).fill(BigInt(0));this.tokens.filter((t=>!d(t.address,this.address))).forEach(((s,o)=>{e[o]=p(BigInt(t[o].toString()),s),n[o]=l(s)}));const o=B(this.amp.toBigInt(),n,e,this.totalShares.toBigInt(),this.swapFee.toBigInt());return s.from(o.toString())}catch(t){return a}}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){return I(e,t)}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){return k(e,t)}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){return f(e,t)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){return g(e,t)}subtractSwapFeeAmount(t,e){const n=t.mul(e).add(o.sub(1)).div(o);return t.sub(n)}addSwapFeeAmount(t,e){const n=o.sub(e);return t.mul(o).add(n.sub(1)).div(n)}}b.AMP_DECIMALS=3;export{b as StablePool};
//# sourceMappingURL=stablePool.js.map
