{"version":3,"file":"stableMath.js","sources":["../../../../../../src/pools/stablePool/stableMath.ts"],"sourcesContent":["import { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as EONE } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n} from '../../utils/bignumber';\nimport { StablePoolPairData } from './stablePool';\n// All functions are adapted from the solidity ones to be found on:\n// https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/pools/stable/StableMath.sol\n\n// TODO: implement all up and down rounding variations\n\n/**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant to compute                                                                  //\n    // A = amplifier                n * D^2 + A * n^n * S * (n^n * P / D^(n−1))                  //\n    // S = sum of balances         ____________________________________________                  //\n    // P = product of balances    (n+1) * D + ( A * n^n − 1)* (n^n * P / D^(n−1))                //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\nexport function _invariant(\n    A: BigNumber,\n    balances: OldBigNumber[] // balances\n): OldBigNumber {\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    for (let i = 0; i < totalCoins; i++) {\n        sum = sum.plus(balances[i]);\n    }\n    if (sum.isZero()) {\n        return ZERO;\n    }\n    let prevInv = ZERO;\n    let inv = sum;\n\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const ATimesNpowN = AAdjusted.times(totalCoins ** totalCoins); // A*n^n\n\n    for (let i = 0; i < 255; i++) {\n        let P_D = bnum(totalCoins).times(balances[0]);\n        for (let j = 1; j < totalCoins; j++) {\n            //P_D is rounded up\n            P_D = P_D.times(balances[j]).times(totalCoins).div(inv);\n        }\n        prevInv = inv;\n        //inv is rounded up\n        inv = bnum(totalCoins)\n            .times(inv)\n            .times(inv)\n            .plus(ATimesNpowN.times(sum).times(P_D))\n            .div(\n                bnum(totalCoins + 1)\n                    .times(inv)\n                    .plus(ATimesNpowN.minus(1).times(P_D))\n            );\n        // Equality with the precision of 1\n        if (inv.gt(prevInv)) {\n            if (inv.minus(prevInv).lt(bnum(10 ** -18))) {\n                break;\n            }\n        } else if (prevInv.minus(inv).lt(bnum(10 ** -18))) {\n            break;\n        }\n    }\n    //Result is rounded up\n    return inv;\n}\n\n// Adapted from StableMath.sol, _outGivenIn()\n// * Added swap fee at very first line\n/**********************************************************************************************\n    // outGivenIn token x for y - polynomial equation to solve                                   //\n    // ay = amount out to calculate                                                              //\n    // by = balance token out                                                                    //\n    // y = by - ay                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               y^2 + ( S - ----------  - 1) * y -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but y                                                           //\n    // P = product of final balances but y                                                       //\n    **********************************************************************************************/\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    let tokenAmountIn = amount;\n    tokenAmountIn = tokenAmountIn\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexIn) {\n            x = balances[i].plus(tokenAmountIn);\n        } else if (i != tokenIndexOut) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate out balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded down\n    // return balances[tokenIndexOut] > y ? balances[tokenIndexOut].minus(y) : 0;\n    return balances[tokenIndexOut].minus(y);\n}\n\n// Adapted from StableMath.sol, _inGivenOut()\n// * Added swap fee at very last line\n/**********************************************************************************************\n    // inGivenOut token x for y - polynomial equation to solve                                   //\n    // ax = amount in to calculate                                                               //\n    // bx = balance token in                                                                     //\n    // x = bx + ax                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               x^2 + ( S - ----------  - 1) * x -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but x                                                           //\n    // P = product of final balances but x                                                       //\n    **********************************************************************************************/\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexOut) {\n            x = balances[i].minus(tokenAmountOut);\n        } else if (i != tokenIndexIn) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate in balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded up\n    return y\n        .minus(balances[tokenIndexIn])\n        .multipliedBy(EONE.toString())\n        .div(EONE.sub(swapFee).toString());\n}\n\n//This function calcuates the analytical solution to find the balance required\nexport function _solveAnalyticalBalance(\n    sum: OldBigNumber,\n    inv: OldBigNumber,\n    A: BigNumber,\n    n_pow_n: OldBigNumber,\n    p: OldBigNumber\n): OldBigNumber {\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const oldBN_A = bnum(formatFixed(A, 3));\n    //Round up p\n    p = p.times(inv).div(oldBN_A.times(n_pow_n).times(n_pow_n));\n    //Round down b\n    const b = sum.plus(inv.div(oldBN_A.times(n_pow_n)));\n    const c = inv\n        .minus(b)\n        .plus(inv.minus(b).times(inv.minus(b)).plus(p.times(4)).sqrt());\n    //Round up y\n    return c.div(2);\n}\n\n//////////////////////\n////  These functions have been added exclusively for the SORv2\n//////////////////////\n\nfunction _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S = S.plus(balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const a = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const b = S.minus(D).times(a).plus(D);\n    const twoaxy = bnum(2).times(a).times(x).times(y);\n    const partial_x = twoaxy.plus(a.times(y).times(y)).plus(b.times(y));\n    const partial_y = twoaxy.plus(a.times(x).times(x)).plus(b.times(x));\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(partial_y);\n    } else {\n        const partial_xx = bnum(2).times(a).times(y);\n        const partial_yy = bnum(2).times(a).times(x);\n        const partial_xy = partial_xx.plus(partial_yy).plus(b);\n        const numerator = bnum(2)\n            .times(partial_x)\n            .times(partial_y)\n            .times(partial_xy)\n            .minus(partial_xx.times(partial_y.pow(2)))\n            .minus(partial_yy.times(partial_x.pow(2)));\n        const denominator = partial_x.pow(2).times(partial_y);\n        ans = numerator.div(denominator);\n        if (wrt_out) {\n            ans = ans.times(partial_y).div(partial_x);\n        }\n    }\n    return ans;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        false\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    const feeFactor = EONE.div(swapFee).toString();\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        true\n    ).div(feeFactor);\n}\n\n// The following are used in front-end helper functions\n\nfunction _feeFactor(\n    balances: OldBigNumber[],\n    tokenIndex: number,\n    swapFee: BigNumber\n): OldBigNumber {\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n    const currentWeight = balances[tokenIndex].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n    return ONE.minus(\n        tokenBalancePercentageExcess\n            .times(swapFee.toString())\n            .div(EONE.toString())\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, tokenIndexIn, decimalsOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnum(formatFixed(balanceOut, decimalsOut)).plus(amount),\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n/*\nFlow of calculations:\namountBPTOut -> newInvariant -> (amountInProportional, amountInAfterFee) ->\namountInPercentageExcess -> amountIn\n*/\nfunction _tokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: StablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountOut = amount;\n\n    /**********************************************************************************************\n    // TODO description                            //\n    **********************************************************************************************/\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const newInvariant = allBalances[tokenIndexOut]\n        .plus(bptAmountOut)\n        .div(allBalances[tokenIndexOut])\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // get amountInAfterFee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInAfterFee = newBalanceTokenIndex.minus(balances[tokenIndexIn]);\n\n    // Get tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n\n    // return amountIn\n    return amountInAfterFee.div(\n        ONE.minus(\n            tokenBalancePercentageExcess\n                .times(swapFee.toString())\n                .div(EONE.toString())\n        )\n    );\n}\n\n//This function calculates the balance of a given token (tokenIndex)\n// given all the other balances and the invariant\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    inv: OldBigNumber,\n    tokenIndex: number\n): OldBigNumber {\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    let nPowN = ONE;\n    let x = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        nPowN = nPowN.times(totalCoins);\n        if (i != tokenIndex) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    // Calculate token balance\n    return _solveAnalyticalBalance(sum, inv, A, nPowN, p);\n}\n\nfunction _poolDerivativesBPT(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    bptSupply: OldBigNumber,\n    tokenIndexIn: number,\n    is_first_derivative: boolean,\n    is_BPT_out: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    let D_P = D.div(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S.plus(balances[i]);\n            D_P = D_P.times(D).div(balances[i].times(totalCoins));\n        }\n    }\n    const x = balances[tokenIndexIn];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const alpha = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const beta = alpha.times(S);\n    const gamma = ONE.minus(alpha);\n    const partial_x = bnum(2)\n        .times(alpha)\n        .times(x)\n        .plus(beta)\n        .plus(gamma.times(D));\n    const minus_partial_D = D_P.times(totalCoins + 1).minus(gamma.times(x));\n    const partial_D = ZERO.minus(minus_partial_D);\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(minus_partial_D).times(bptSupply).div(D);\n    } else {\n        const partial_xx = bnum(2).times(alpha);\n        const partial_xD = gamma;\n        const n_times_nplusone = totalCoins * (totalCoins + 1);\n        const partial_DD = ZERO.minus(D_P.times(n_times_nplusone).div(D));\n        if (is_BPT_out) {\n            const term1 = partial_xx.times(partial_D).div(partial_x.pow(2));\n            const term2 = bnum(2).times(partial_xD).div(partial_x);\n            const term3 = partial_DD.div(partial_D);\n            ans = term1.minus(term2).plus(term3).times(D).div(bptSupply);\n            if (wrt_out) {\n                const D_prime = ZERO.minus(partial_x.div(partial_D));\n                ans = ans.div(D_prime).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2)\n                .times(partial_xD)\n                .div(partial_D)\n                .minus(partial_DD.times(partial_x).div(partial_D.pow(2)))\n                .minus(partial_xx.div(partial_x));\n            if (wrt_out) {\n                ans = ans\n                    .times(partial_x)\n                    .div(minus_partial_D)\n                    .times(bptSupply)\n                    .div(D);\n            }\n        }\n    }\n    return ans;\n}\n"],"names":["_invariant","A","balances","sum","ZERO","totalCoins","length","i","plus","isZero","prevInv","inv","ATimesNpowN","bnum","formatFixed","times","P_D","j","div","minus","gt","lt","_exactTokenInForTokenOut","amount","poolPairData","amp","allBalances","tokenIndexIn","tokenIndexOut","swapFee","n","tokenAmountIn","EONE","sub","toString","p","n_pow_n","ONE","x","y","_solveAnalyticalBalance","_tokenInForExactTokenOut","tokenAmountOut","multipliedBy","oldBN_A","b","sqrt","_poolDerivatives","is_first_derivative","wrt_out","D","S","a","twoaxy","partial_x","partial_y","ans","partial_xx","partial_yy","partial_xy","numerator","pow","denominator","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","_in","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","feeFactor","_spotPriceAfterSwapTokenInForExactBPTOut","balanceOut","decimalsOut","bptAmountOut","currentInvariant","newInvariant","sumBalances","newBalanceTokenIndex","tokenIndex","nPowN","_getTokenBalanceGivenInvariantAndAllOtherBalances","amountInAfterFee","currentWeight","tokenBalancePercentageExcess","_tokenInForExactBPTOut","_feeFactor","bptSupply","is_BPT_out","D_P","AAdjusted","alpha","beta","gamma","minus_partial_D","partial_D","partial_xD","n_times_nplusone","partial_DD","term1","term2","term3","D_prime","_poolDerivativesBPT"],"mappings":"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"}