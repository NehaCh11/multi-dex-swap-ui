{"version":3,"file":"stableMathBigInt.js","sources":["../../../../../../src/pools/stablePool/stableMathBigInt.ts"],"sourcesContent":["/*\nSwap outcome and \"spot price after swap\" formulas for weighted, stable and linear pools.\nAmounts are represented using bigint type. Swap outcomes formulas should\nmatch exactly those from smart contracts.\n\nTest cases are found in poolsMathWeighted.spec.ts, poolsMathStable.spec.ts poolsMathLinear.spec.ts.\n\nIt is necessary to review whether to use MathSol operations or native +,-,\\*,/ case by case. MathSol operations are able to reproduce overflows while native operations produce a much more readable code. For instance, for \"spot price after swap\" native operations\nare preferred since in this case there are not smart contract analogs, amount limits are assumed to have been checked elsewhere, and some formulas get complicated, specially for stable pools.\n*/\nimport { MathSol, BZERO } from '../../utils/basicOperations';\n\nconst AMP_PRECISION = BigInt(1e3);\n\nfunction _calculateInvariant(amp: bigint, balances: bigint[]): bigint {\n    /**********************************************************************************************\n      // invariant                                                                                 //\n      // D = invariant                                                  D^(n+1)                    //\n      // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n      // S = sum of balances                                             n^n P                     //\n      // P = product of balances                                                                   //\n      // n = number of tokens                                                                      //\n      *********x************************************************************************************/\n\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n\n    let sum = BZERO;\n    const numTokens = balances.length;\n    for (let i = 0; i < numTokens; i++) {\n        sum = sum + balances[i];\n    }\n    if (sum == BZERO) {\n        return BZERO;\n    }\n\n    let prevInvariant = BZERO;\n    let invariant = sum;\n    const ampTimesTotal = amp * BigInt(numTokens);\n\n    for (let i = 0; i < 255; i++) {\n        let D_P = invariant;\n        for (let j = 0; j < numTokens; j++) {\n            // (D_P * invariant) / (balances[j] * numTokens)\n            D_P = MathSol.divDown(\n                MathSol.mul(D_P, invariant),\n                MathSol.mul(balances[j], BigInt(numTokens))\n            );\n        }\n\n        prevInvariant = invariant;\n        invariant = MathSol.divDown(\n            MathSol.mul(\n                // (ampTimesTotal * sum) / AMP_PRECISION + D_P * numTokens\n                MathSol.divDown(\n                    MathSol.mul(ampTimesTotal, sum),\n                    AMP_PRECISION\n                ) + MathSol.mul(D_P, BigInt(numTokens)),\n                invariant\n            ),\n            // ((ampTimesTotal - _AMP_PRECISION) * invariant) / _AMP_PRECISION + (numTokens + 1) * D_P\n            MathSol.divDown(\n                MathSol.mul(ampTimesTotal - AMP_PRECISION, invariant),\n                AMP_PRECISION\n            ) + MathSol.mul(BigInt(numTokens + 1), D_P)\n        );\n\n        if (invariant > prevInvariant) {\n            if (invariant - prevInvariant <= 1) {\n                return invariant;\n            }\n        } else if (prevInvariant - invariant <= 1) {\n            return invariant;\n        }\n    }\n    throw new Error('Errors.STABLE_INVARIANT_DIDNT_CONVERGE');\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    amountIn = subtractFee(amountIn, fee);\n    const invariant = _calculateInvariant(amp, balances);\n\n    const initBalance = balances[tokenIndexIn];\n    balances[tokenIndexIn] = initBalance + amountIn;\n    const finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amp,\n        balances,\n        invariant,\n        tokenIndexOut\n    );\n    return balances[tokenIndexOut] - finalBalanceOut - BigInt(1);\n}\n\nexport function _calcInGivenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const invariant = _calculateInvariant(amp, balances);\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n\n    const finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        amp,\n        balances,\n        invariant,\n        tokenIndexIn\n    );\n\n    let amountIn = MathSol.add(\n        MathSol.sub(finalBalanceIn, balances[tokenIndexIn]),\n        BigInt(1)\n    );\n    amountIn = addFee(amountIn, fee);\n    return amountIn;\n}\n\n/**\n * _calcBptOutGivenExactTokensIn\n * @param amp Amplification parameter in EVM Scale\n * @param balances Token balances in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param amountsIn Token amounts in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param bptTotalSupply BPT total supply in EVM Scale\n * @param swapFeePercentage Swap fee percentage in EVM Scale\n * @returns BPT out in EVM Scale\n */\nexport function _calcBptOutGivenExactTokensIn(\n    amp: bigint,\n    balances: bigint[],\n    amountsIn: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT out, so we round down overall.\n\n    // First loop calculates the sum of all token balances, which will be used to calculate\n    // the current weights of each token, relative to this sum\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const balanceRatiosWithFee: bigint[] = new Array(amountsIn.length);\n    // The weighted sum of token balance ratios with fee\n    let invariantRatioWithFees = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divDownFixed(balances[i], sumBalances);\n        balanceRatiosWithFee[i] = MathSol.divDownFixed(\n            balances[i] + amountsIn[i],\n            balances[i]\n        );\n        invariantRatioWithFees =\n            invariantRatioWithFees +\n            MathSol.mulDownFixed(balanceRatiosWithFee[i], currentWeight);\n    }\n\n    // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n    const newBalances: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee: bigint;\n\n        // Check if the balance ratio is greater than the ideal ratio to charge fees or not\n        if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                invariantRatioWithFees - MathSol.ONE\n            );\n            const taxableAmount = amountsIn[i] - nonTaxableAmount;\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            amountInWithoutFee =\n                nonTaxableAmount +\n                MathSol.mulDownFixed(\n                    taxableAmount,\n                    MathSol.ONE - swapFeePercentage\n                );\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n        newBalances[i] = balances[i] + amountInWithoutFee;\n    }\n\n    // Get current and new invariants, taking swap fees into account\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = _calculateInvariant(amp, newBalances);\n\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    // If the invariant didn't increase for any reason, we simply don't mint BPT\n    if (invariantRatio > MathSol.ONE) {\n        return MathSol.mulDownFixed(\n            bptTotalSupply,\n            invariantRatio - MathSol.ONE\n        );\n    } else {\n        return BigInt(0);\n    }\n}\n\n/**\n * _calcTokenInGivenExactBptOut\n * @param amp Amplification parameter in EVM Scale\n * @param balances Token balances in EVM Scale normalised to 18 decimals (Should not have value for BPT token)\n * @param tokenIndexIn Index of token in (from tokens array without BPT)\n * @param bptAmountOut BPT amount out in EVM scale\n * @param bptTotalSupply BPT total supply in EVM Scale\n * @param fee Swap fee percentage in EVM Scale\n * @returns token in EVM Scale normalised to 18 decimals\n */\nexport function _calcTokenInGivenExactBptOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptAmountOut: bigint,\n    bptTotalSupply: bigint,\n    fee: bigint\n): bigint {\n    // Token in, so we round up overall.\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(\n            MathSol.add(bptTotalSupply, bptAmountOut),\n            bptTotalSupply\n        ),\n        currentInvariant\n    );\n\n    // Calculate amount in without fee.\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInWithoutFee = MathSol.sub(\n        newBalanceTokenIndex,\n        balances[tokenIndexIn]\n    );\n\n    // First calculate the sum of all token balances, which will be used to calculate\n    // the current weight of each token\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = MathSol.add(sumBalances, balances[i]);\n    }\n\n    // We can now compute how much extra balance is being deposited\n    // and used in virtual swaps, and charge swap fees accordingly.\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndexIn],\n        sumBalances\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n    const taxableAmount = MathSol.mulUpFixed(\n        amountInWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = MathSol.sub(amountInWithoutFee, taxableAmount);\n\n    return MathSol.add(\n        nonTaxableAmount,\n        MathSol.divUpFixed(taxableAmount, MathSol.sub(MathSol.ONE, fee))\n    );\n}\n\n/*\nFlow of calculations:\namountsTokenOut -> amountsOutProportional ->\namountOutPercentageExcess -> amountOutBeforeFee -> newInvariant -> amountBPTIn\n*/\nexport function _calcBptInGivenExactTokensOut(\n    amp: bigint,\n    balances: bigint[],\n    amountsOut: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT in, so we round up overall.\n\n    // First loop calculates the sum of all token balances, which will be used to calculate\n    // the current weights of each token relative to this sum\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const balanceRatiosWithoutFee: bigint[] = new Array(amountsOut.length);\n    let invariantRatioWithoutFees = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        const currentWeight = MathSol.divUpFixed(balances[i], sumBalances);\n        balanceRatiosWithoutFee[i] = MathSol.divUpFixed(\n            balances[i] - amountsOut[i],\n            balances[i]\n        );\n        invariantRatioWithoutFees =\n            invariantRatioWithoutFees +\n            MathSol.mulUpFixed(balanceRatiosWithoutFee[i], currentWeight);\n    }\n\n    // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n    const newBalances: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee: bigint;\n        if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.complementFixed(invariantRatioWithoutFees)\n            );\n            const taxableAmount = amountsOut[i] - nonTaxableAmount;\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            amountOutWithFee =\n                nonTaxableAmount +\n                MathSol.divUpFixed(\n                    taxableAmount,\n                    MathSol.ONE - swapFeePercentage\n                );\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n        newBalances[i] = balances[i] - amountOutWithFee;\n    }\n\n    // Get current and new invariants, taking into account swap fees\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = _calculateInvariant(amp, newBalances);\n    const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);\n\n    // return amountBPTIn\n    return MathSol.mulUpFixed(\n        bptTotalSupply,\n        MathSol.complementFixed(invariantRatio)\n    );\n}\n\nexport function _calcTokenOutGivenExactBptIn(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndex: number,\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // Token out, so we round down overall.\n\n    const currentInvariant = _calculateInvariant(amp, balances);\n    const newInvariant = MathSol.mulUpFixed(\n        MathSol.divUpFixed(bptTotalSupply - bptAmountIn, bptTotalSupply),\n        currentInvariant\n    );\n\n    // Calculate amount out without fee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            amp,\n            balances,\n            newInvariant,\n            tokenIndex\n        );\n    const amountOutWithoutFee = balances[tokenIndex] - newBalanceTokenIndex;\n\n    // First calculate the sum of all token balances, which will be used to calculate\n    // the current weight of each token\n    let sumBalances = BigInt(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances + balances[i];\n    }\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n    const currentWeight = MathSol.divDownFixed(\n        balances[tokenIndex],\n        sumBalances\n    );\n    const taxablePercentage = MathSol.complementFixed(currentWeight);\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = MathSol.mulUpFixed(\n        amountOutWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = amountOutWithoutFee - taxableAmount;\n\n    // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n    return (\n        nonTaxableAmount +\n        MathSol.mulDownFixed(taxableAmount, MathSol.ONE - swapFeePercentage)\n    );\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = tokenAmountOut             /        bptIn         \\                                  //\n    // b = tokenBalance      a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\     bptTotalSupply    /                                 //\n    // bpt = bptTotalSupply                                                                      //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, bptTotalSupply);\n\n    const amountsOut: bigint[] = new Array(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n    }\n\n    return amountsOut;\n}\n\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    amp: bigint,\n    balances: bigint[],\n    invariant: bigint,\n    tokenIndex: number\n): bigint {\n    // Rounds result up overall\n\n    const ampTimesTotal = amp * BigInt(balances.length);\n    let sum = balances[0];\n    let P_D = balances[0] * BigInt(balances.length);\n    for (let j = 1; j < balances.length; j++) {\n        P_D = MathSol.divDown(\n            MathSol.mul(MathSol.mul(P_D, balances[j]), BigInt(balances.length)),\n            invariant\n        );\n        sum = sum + balances[j];\n    }\n    // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n    sum = sum - balances[tokenIndex];\n\n    const inv2 = MathSol.mul(invariant, invariant);\n    // We remove the balance fromm c by multiplying it\n    const c = MathSol.mul(\n        MathSol.mul(\n            MathSol.divUp(inv2, MathSol.mul(ampTimesTotal, P_D)),\n            AMP_PRECISION\n        ),\n        balances[tokenIndex]\n    );\n    const b =\n        sum +\n        MathSol.mul(MathSol.divDown(invariant, ampTimesTotal), AMP_PRECISION);\n\n    // We iterate to find the balance\n    let prevTokenBalance = BZERO;\n    // We multiply the first iteration outside the loop with the invariant to set the value of the\n    // initial approximation.\n    let tokenBalance = MathSol.divUp(inv2 + c, invariant + b);\n\n    for (let i = 0; i < 255; i++) {\n        prevTokenBalance = tokenBalance;\n\n        tokenBalance = MathSol.divUp(\n            MathSol.mul(tokenBalance, tokenBalance) + c,\n            MathSol.mul(tokenBalance, BigInt(2)) + b - invariant\n        );\n\n        if (tokenBalance > prevTokenBalance) {\n            if (tokenBalance - prevTokenBalance <= 1) {\n                return tokenBalance;\n            }\n        } else if (prevTokenBalance - tokenBalance <= 1) {\n            return tokenBalance;\n        }\n    }\n    throw new Error('Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE');\n}\n\nfunction subtractFee(amount: bigint, fee: bigint): bigint {\n    const feeAmount = MathSol.mulUpFixed(amount, fee);\n    return amount - feeAmount;\n}\n\nfunction addFee(amount: bigint, fee: bigint): bigint {\n    return MathSol.divUpFixed(amount, MathSol.complementFixed(fee));\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    const feeComplement = MathSol.complementFixed(fee);\n    const balancesCopy = [...balances];\n    balances[tokenIndexIn] = MathSol.add(\n        balances[tokenIndexIn],\n        MathSol.mulUpFixed(amountIn, feeComplement)\n    );\n    balances[tokenIndexOut] = MathSol.sub(\n        balances[tokenIndexOut],\n        _calcOutGivenIn(\n            amp,\n            balancesCopy,\n            tokenIndexIn,\n            tokenIndexOut,\n            amountIn,\n            fee\n        )\n    );\n    let ans = _poolDerivatives(\n        amp,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = MathSol.divDownFixed(\n        MathSol.ONE,\n        MathSol.mulDownFixed(ans, feeComplement)\n    );\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const balancesCopy = [...balances];\n    const _in = _calcInGivenOut(\n        amp,\n        balancesCopy,\n        tokenIndexIn,\n        tokenIndexOut,\n        amountOut,\n        fee\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn] + _in;\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n    let ans = _poolDerivatives(\n        amp,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    const feeComplement = MathSol.complementFixed(fee);\n    ans = MathSol.divUpFixed(\n        MathSol.ONE,\n        MathSol.mulUpFixed(ans, feeComplement)\n    );\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptTotalSupply: bigint,\n    amountIn: bigint\n    // assuming zero fee\n): bigint {\n    balances[tokenIndexIn] = balances[tokenIndexIn] + amountIn;\n    // working\n    const amountsIn = balances.map((_value, index) =>\n        index == tokenIndexIn ? amountIn : BigInt(0)\n    );\n    const finalBPTSupply =\n        bptTotalSupply +\n        _calcBptOutGivenExactTokensIn(\n            amp,\n            balances,\n            amountsIn,\n            bptTotalSupply,\n            BigInt(0)\n        );\n    let ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        finalBPTSupply,\n        tokenIndexIn,\n        true,\n        true,\n        false\n    );\n    ans = MathSol.divUpFixed(MathSol.ONE, ans);\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    bptTotalSupply: bigint,\n    amountOut: bigint\n    // assuming zero fee\n): bigint {\n    const balancesCopy = [...balances];\n    const _in = _calcTokenInGivenExactBptOut(\n        amp,\n        balancesCopy,\n        tokenIndexIn,\n        amountOut,\n        bptTotalSupply,\n        BigInt(0)\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn] + _in;\n    let ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupply + amountOut,\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = MathSol.divUpFixed(MathSol.ONE, ans); // ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexOut: number,\n    bptTotalSupply: bigint,\n    amountIn: bigint\n    // assuming zero fee\n): bigint {\n    // balances copy not necessary?\n    const _out = _calcTokenOutGivenExactBptIn(\n        amp,\n        balances,\n        tokenIndexOut,\n        amountIn,\n        bptTotalSupply,\n        BigInt(0)\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut] - _out;\n    const bptTotalSupplyAfter = MathSol.sub(bptTotalSupply, amountIn);\n    const ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupplyAfter,\n        tokenIndexOut,\n        true,\n        false,\n        false\n    );\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexOut: number,\n    bptTotalSupply: bigint,\n    amountOut: bigint\n): bigint {\n    balances[tokenIndexOut] = MathSol.sub(balances[tokenIndexOut], amountOut);\n    const amountsOut = balances.map((_value, index) =>\n        index == tokenIndexOut ? amountOut : BigInt(0)\n    );\n    const bptTotalSupplyAfter =\n        bptTotalSupply -\n        _calcBptInGivenExactTokensOut(\n            amp,\n            balances,\n            amountsOut,\n            bptTotalSupply,\n            BigInt(0)\n        );\n    const ans = _poolDerivativesBPT(\n        amp,\n        balances,\n        bptTotalSupplyAfter,\n        tokenIndexOut,\n        true,\n        false,\n        true\n    );\n    return ans;\n}\n\nexport function _poolDerivatives(\n    amp: bigint,\n    balances: bigint[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): bigint {\n    const totalCoins = balances.length;\n    const D = _calculateInvariant(amp, balances);\n    let S = BigInt(0);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S += balances[i];\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    const a = amp * BigInt(totalCoins);\n    const b = a * (S - D) + D * AMP_PRECISION;\n    const twoaxy = BigInt(2) * a * x * y;\n    const partial_x = twoaxy + a * y * y + b * y;\n    const partial_y = twoaxy + a * x * x + b * x;\n    let ans: bigint;\n    if (is_first_derivative) {\n        ans = MathSol.divUpFixed(partial_x, partial_y);\n    } else {\n        // Untested case:\n        const partial_xx = BigInt(2) * a * y;\n        const partial_yy = BigInt(2) * a * x;\n        const partial_xy = partial_xx + partial_yy + b; // AMP_PRECISION missing\n        const numerator =\n            BigInt(2) * partial_x * partial_y * partial_xy -\n            partial_xx * partial_y * partial_y +\n            partial_yy * partial_x * partial_x;\n        const denominator = partial_x * partial_x * partial_y;\n        ans = MathSol.divUpFixed(numerator, denominator); // change the order to directly use integer operations\n        if (wrt_out) {\n            ans = MathSol.mulUpFixed(\n                MathSol.mulUpFixed(ans, partial_y),\n                partial_x\n            );\n        }\n    }\n    return ans;\n}\n\nexport function _poolDerivativesBPT(\n    amp: bigint,\n    balances: bigint[],\n    bptSupply: bigint,\n    tokenIndexIn: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    is_first_derivative: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    is_BPT_out: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    wrt_out: boolean\n): bigint {\n    const totalCoins = balances.length;\n    const D = _calculateInvariant(amp, balances);\n    let S = BigInt(0);\n    let D_P = D / BigInt(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S + balances[i];\n            D_P = (D_P * D) / (BigInt(totalCoins) * balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const alpha = amp * BigInt(totalCoins);\n    const beta = alpha * S; // units = 10 ** 21\n    const gamma = BigInt(AMP_PRECISION) - alpha;\n    const partial_x = BigInt(2) * alpha * x + beta + gamma * D;\n    const minus_partial_D =\n        D_P * BigInt(totalCoins + 1) * AMP_PRECISION - gamma * x;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const partial_D = -minus_partial_D;\n    const ans = MathSol.divUpFixed(\n        (partial_x * bptSupply) / minus_partial_D,\n        D\n    );\n    /*\n    if (is_first_derivative) {\n        ans = MathSol.divUpFixed((partial_x * bptSupply) / minus_partial_D, D);\n    } else {\n        let partial_xx = bnum(2).times(alpha);\n        let partial_xD = gamma;\n        let n_times_nplusone = totalCoins * (totalCoins + 1);\n        let partial_DD = bnum(0).minus( D_P.times(n_times_nplusone).div(D) );\n        if (is_BPT_out) {\n            let term1 = partial_xx.times(partial_D).div( partial_x.pow(2) );\n            let term2 = bnum(2).times(partial_xD).div(partial_x);\n            let term3 = partial_DD.div(partial_D);\n            ans = (term1.minus(term2).plus(term3)).times(D).div(bptSupply)\n            if (wrt_out) {\n                let D_prime = bnum(0).minus( partial_x.div(partial_D) );\n                ans = ans.div( D_prime ).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2).times(partial_xD).div(partial_D).minus(\n                partial_DD.times(partial_x).div(partial_D.pow(2)) ).minus(\n                partial_xx.div(partial_x) );\n            if (wrt_out) {\n                ans = ans.times(partial_x).div(minus_partial_D).times(bptSupply).div(D);\n            }\n        }\n    }\n*/\n    return ans;\n}\n"],"names":["AMP_PRECISION","BigInt","_calculateInvariant","amp","balances","sum","BZERO","numTokens","length","i","prevInvariant","invariant","ampTimesTotal","D_P","j","MathSol","divDown","mul","Error","_calcOutGivenIn","tokenIndexIn","tokenIndexOut","amountIn","fee","amount","feeAmount","mulUpFixed","subtractFee","initBalance","finalBalanceOut","_getTokenBalanceGivenInvariantAndAllOtherBalances","_calcInGivenOut","amountOut","sub","finalBalanceIn","add","divUpFixed","complementFixed","addFee","_calcBptOutGivenExactTokensIn","amountsIn","bptTotalSupply","swapFeePercentage","sumBalances","balanceRatiosWithFee","Array","invariantRatioWithFees","currentWeight","divDownFixed","mulDownFixed","newBalances","amountInWithoutFee","nonTaxableAmount","ONE","taxableAmount","currentInvariant","newInvariant","invariantRatio","_calcTokenInGivenExactBptOut","bptAmountOut","newBalanceTokenIndex","taxablePercentage","_calcBptInGivenExactTokensOut","amountsOut","balanceRatiosWithoutFee","invariantRatioWithoutFees","amountOutWithFee","_calcTokenOutGivenExactBptIn","tokenIndex","bptAmountIn","amountOutWithoutFee","_calcTokensOutGivenExactBptIn","bptRatio","P_D","inv2","c","divUp","b","prevTokenBalance","tokenBalance","_spotPriceAfterSwapExactTokenInForTokenOut","feeComplement","balancesCopy","ans","_poolDerivatives","_spotPriceAfterSwapTokenInForExactTokenOut","_in","_spotPriceAfterSwapExactTokenInForBPTOut","map","_value","index","_poolDerivativesBPT","_spotPriceAfterSwapTokenInForExactBPTOut","_spotPriceAfterSwapExactBPTInForTokenOut","_out","_spotPriceAfterSwapBPTInForExactTokenOut","is_first_derivative","wrt_out","totalCoins","D","S","x","y","a","twoaxy","partial_x","partial_y","partial_xx","partial_yy","partial_xy","numerator","denominator","bptSupply","is_BPT_out","alpha","beta","gamma","minus_partial_D"],"mappings":"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"}