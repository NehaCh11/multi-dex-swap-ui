{"version":3,"file":"phantomStablePool.js","sources":["../../../../../../src/pools/phantomStablePool/phantomStablePool.ts"],"sourcesContent":["import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport { isSameAddress } from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport {\n    PoolBase,\n    PoolTypes,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n} from '../../types';\nimport { getAddress } from '@ethersproject/address';\nimport {\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcOutGivenIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _calcInGivenOut,\n} from '../stablePool/stableMathBigInt';\nimport * as phantomStableMath from '../phantomStablePool/phantomStableMath';\nimport { MetaStablePoolPairData } from '../metaStablePool/metaStablePool';\nimport cloneDeep from 'lodash.clonedeep';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nexport enum PairTypes {\n    BptToToken,\n    TokenToBpt,\n    TokenToToken,\n}\n\nexport type PhantomStablePoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'priceRate'\n>;\n\nexport type PhantomStablePoolPairData = MetaStablePoolPairData & {\n    pairType: PairTypes;\n    bptIndex: number;\n    virtualBptSupply: BigNumber;\n};\n\nexport class PhantomStablePool implements PoolBase<PhantomStablePoolPairData> {\n    poolType: PoolTypes = PoolTypes.MetaStable;\n    id: string;\n    address: string;\n    amp: BigNumber;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: PhantomStablePoolToken[];\n    tokensList: string[];\n    ALMOST_ONE = parseFixed('0.99', 18);\n\n    static AMP_DECIMALS = 3;\n\n    static fromPool(pool: SubgraphPoolBase): PhantomStablePool {\n        if (!pool.amp) throw new Error('PhantomStablePool missing amp factor');\n        return new PhantomStablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    // Remove BPT from Balances and update indices\n    static removeBPT(\n        poolPairData: PhantomStablePoolPairData\n    ): PhantomStablePoolPairData {\n        const poolPairDataNoBpt = cloneDeep(poolPairData);\n        const bptIndex = poolPairData.bptIndex;\n        if (bptIndex != -1) {\n            poolPairDataNoBpt.allBalances.splice(bptIndex, 1);\n            poolPairDataNoBpt.allBalancesScaled.splice(bptIndex, 1);\n            if (bptIndex < poolPairData.tokenIndexIn)\n                poolPairDataNoBpt.tokenIndexIn -= 1;\n            if (bptIndex < poolPairData.tokenIndexOut)\n                poolPairDataNoBpt.tokenIndexOut -= 1;\n        }\n        return poolPairDataNoBpt;\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: PhantomStablePoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.amp = parseFixed(amp, PhantomStablePool.AMP_DECIMALS);\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n    }\n\n    parsePoolPairData(\n        tokenIn: string,\n        tokenOut: string\n    ): PhantomStablePoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = bnum(tI.balance)\n            .times(bnum(tI.priceRate))\n            .dp(tI.decimals)\n            .toString();\n        const decimalsIn = tI.decimals;\n        const tokenInPriceRate = parseFixed(tI.priceRate, 18);\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = bnum(tO.balance)\n            .times(bnum(tO.priceRate))\n            .dp(tO.decimals)\n            .toString();\n        const decimalsOut = tO.decimals;\n        const tokenOutPriceRate = parseFixed(tO.priceRate, 18);\n\n        // Get all token balances\n        const allBalances = this.tokens.map(({ balance, priceRate }) =>\n            bnum(balance).times(bnum(priceRate))\n        );\n        const allBalancesScaled = this.tokens.map(({ balance, priceRate }) =>\n            parseFixed(balance, 18).mul(parseFixed(priceRate, 18)).div(ONE)\n        );\n\n        // Phantom pools allow trading between token and pool BPT\n        let pairType: PairTypes;\n        if (isSameAddress(tokenIn, this.address)) {\n            pairType = PairTypes.BptToToken;\n        } else if (isSameAddress(tokenOut, this.address)) {\n            pairType = PairTypes.TokenToBpt;\n        } else {\n            pairType = PairTypes.TokenToToken;\n        }\n\n        const bptIndex = this.tokensList.indexOf(this.address);\n\n        // VirtualBPTSupply must be used for the maths\n        const virtualBptSupply = this.totalShares;\n\n        const poolPairData: PhantomStablePoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            pairType: pairType,\n            bptIndex: bptIndex,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            allBalances,\n            allBalancesScaled,\n            amp: this.amp,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            tokenInPriceRate,\n            tokenOutPriceRate,\n            virtualBptSupply,\n        };\n\n        return PhantomStablePool.removeBPT(poolPairData);\n    }\n\n    getNormalizedLiquidity(\n        poolPairData: PhantomStablePoolPairData\n    ): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PhantomStablePoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        // PoolPairData is using balances that have already been exchanged so need to convert back\n        if (swapType === SwapTypes.SwapExactIn) {\n            // Return max valid amount of tokenIn\n            // As an approx - use almost the total balance of token out as we can add any amount of tokenIn and expect some back\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(poolPairData.tokenOutPriceRate),\n                    poolPairData.decimalsOut\n                )\n            );\n        } else {\n            // Return max amount of tokenOut - approx is almost all balance\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut\n                        .mul(this.ALMOST_ONE)\n                        .div(poolPairData.tokenOutPriceRate),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n\n        // update total shares with BPT balance diff\n        if (isSameAddress(this.address, token)) {\n            const parsedTokenBalance = parseFixed(T.balance, T.decimals);\n            const diff = parsedTokenBalance.sub(newBalance);\n            const newTotalShares = this.totalShares.add(diff);\n            this.updateTotalShares(newTotalShares);\n        }\n        // update token balance with new balance\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // This code assumes that decimalsIn and decimalsOut is 18\n\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const amtWithFeeEvm = this.subtractSwapFeeAmount(\n                parseFixed(amount.dp(18).toString(), 18),\n                poolPairData.swapFee\n            );\n            const amountConvertedEvm = amtWithFeeEvm\n                .mul(poolPairData.tokenInPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                const amountsInBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsInBigInt[poolPairData.tokenIndexIn] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptOutGivenExactTokensIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsInBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnEvm = _calcTokenOutGivenExactBptIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else {\n                returnEvm = _calcOutGivenIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    BigInt(0)\n                );\n            }\n\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenOutPriceRate);\n\n            // Return human scaled\n            return bnum(formatFixed(returnEvmWithRate, 18));\n        } catch (err) {\n            // console.error(`PhantomStable _evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // This code assumes that decimalsIn and decimalsOut is 18\n\n            if (amount.isZero()) return ZERO;\n            // All values should use 1e18 fixed point\n            // i.e. 1USDC => 1e18 not 1e6\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenOutPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnEvm = _calcTokenInGivenExactBptOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0)\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                const amountsOutBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsOutBigInt[poolPairData.tokenIndexOut] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptInGivenExactTokensOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsOutBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    BigInt(0) // Fee is handled below\n                );\n            } else {\n                returnEvm = _calcInGivenOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    BigInt(0) // Fee is handled below\n                );\n            }\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenInPriceRate);\n\n            const returnEvmWithFee = this.addSwapFeeAmount(\n                returnEvmWithRate,\n                poolPairData.swapFee\n            );\n\n            // return human number\n            return bnum(formatFixed(returnEvmWithFee, 18));\n        } catch (err) {\n            console.error(`PhantomStable _evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // PhantomStables can only be exited by using BPT > token swaps\n        throw new Error(\n            'PhantomPool does not have exit pool (_calcTokensOutGivenExactBptIn).'\n        );\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // PhantomStables can only be joined by using token > BPT swaps\n        throw new Error(\n            'PhantomPool does not have join pool (_calcBptOutGivenExactTokensIn).'\n        );\n    }\n\n    // this is the multiplicative inverse of the derivative of _exactTokenInForTokenOut\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            bnum(formatFixed(poolPairData.tokenInPriceRate, 18))\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result = phantomStableMath._spotPriceAfterSwapExactTokenInForBPTOut(\n                amountConverted,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result = phantomStableMath._spotPriceAfterSwapExactBPTInForTokenOut(\n                amountConverted,\n                poolPairData\n            );\n        } else {\n            result =\n                phantomStableMath._spotPriceAfterSwapExactTokenInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    // this is the derivative of _tokenInForExactTokenOut\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result = phantomStableMath._spotPriceAfterSwapTokenInForExactBPTOut(\n                amountConverted,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result = phantomStableMath._spotPriceAfterSwapBPTInForExactTokenOut(\n                amountConverted,\n                poolPairData\n            );\n        } else {\n            result =\n                phantomStableMath._spotPriceAfterSwapTokenInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.times(priceRateOut);\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        const priceRateIn = bnum(\n            formatFixed(poolPairData.tokenInPriceRate, 18)\n        );\n        const priceRateOut = bnum(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        const amountConverted = amount.times(\n            formatFixed(poolPairData.tokenOutPriceRate, 18)\n        );\n        let result: OldBigNumber;\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        } else {\n            result =\n                phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                    amountConverted,\n                    poolPairData\n                );\n        }\n        return result.div(priceRateIn).times(priceRateOut).times(priceRateOut);\n    }\n\n    subtractSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L466\n        const feeAmount = amount.mul(swapFee).add(ONE.sub(1)).div(ONE);\n        return amount.sub(feeAmount);\n    }\n\n    addSwapFeeAmount(amount: BigNumber, swapFee: BigNumber): BigNumber {\n        // https://github.com/balancer-labs/balancer-v2-monorepo/blob/c18ff2686c61a8cbad72cdcfc65e9b11476fdbc3/pkg/pool-utils/contracts/BasePool.sol#L458\n        const feeAmount = ONE.sub(swapFee);\n        return amount.mul(ONE).add(feeAmount.sub(1)).div(feeAmount);\n    }\n}\n"],"names":["PairTypes","PhantomStablePool","static","pool","amp","Error","id","address","swapFee","totalShares","tokens","tokensList","poolPairData","poolPairDataNoBpt","cloneDeep","bptIndex","allBalances","splice","allBalancesScaled","tokenIndexIn","tokenIndexOut","constructor","this","poolType","PoolTypes","MetaStable","ALMOST_ONE","parseFixed","AMP_DECIMALS","parsePoolPairData","tokenIn","tokenOut","findIndex","t","getAddress","tI","balanceIn","bnum","balance","times","priceRate","dp","decimals","toString","decimalsIn","tokenInPriceRate","tO","balanceOut","decimalsOut","tokenOutPriceRate","map","mul","div","ONE","pairType","isSameAddress","BptToToken","TokenToBpt","TokenToToken","indexOf","virtualBptSupply","Number","removeBPT","getNormalizedLiquidity","universalNormalizedLiquidity","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","ZERO","getLimitAmountSwap","swapType","SwapTypes","SwapExactIn","formatFixed","updateTokenBalanceForPool","token","newBalance","T","find","diff","sub","newTotalShares","add","updateTotalShares","_exactTokenInForTokenOut","amount","isZero","amountConvertedEvm","subtractSwapFeeAmount","returnEvm","amountsInBigInt","Array","length","fill","BigInt","toBigInt","_calcBptOutGivenExactTokensIn","b","_calcTokenOutGivenExactBptIn","_calcOutGivenIn","returnEvmWithRate","BigNumber","from","err","_tokenInForExactTokenOut","_calcTokenInGivenExactBptOut","amountsOutBigInt","_calcBptInGivenExactTokensOut","_calcInGivenOut","returnEvmWithFee","addSwapFeeAmount","console","error","message","_calcTokensOutGivenExactBptIn","bptAmountIn","amountsIn","_spotPriceAfterSwapExactTokenInForTokenOut","priceRateIn","priceRateOut","amountConverted","result","phantomStableMath._spotPriceAfterSwapExactTokenInForBPTOut","phantomStableMath._spotPriceAfterSwapExactBPTInForTokenOut","phantomStableMath._spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","phantomStableMath._spotPriceAfterSwapTokenInForExactBPTOut","phantomStableMath._spotPriceAfterSwapBPTInForExactTokenOut","phantomStableMath._spotPriceAfterSwapTokenInForExactTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForBPTOut","phantomStableMath._derivativeSpotPriceAfterSwapExactBPTInForTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactBPTOut","phantomStableMath._derivativeSpotPriceAfterSwapBPTInForExactTokenOut","phantomStableMath._derivativeSpotPriceAfterSwapTokenInForExactTokenOut","feeAmount"],"mappings":"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"}