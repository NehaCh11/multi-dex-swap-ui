{"version":3,"file":"phantomStableMath.js","sources":["../../../../../../src/pools/phantomStablePool/phantomStableMath.ts"],"sourcesContent":["import { BigNumber, formatFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as EONE } from '@ethersproject/constants';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    ZERO,\n    ONE,\n} from '../../utils/bignumber';\nimport { PhantomStablePoolPairData } from './phantomStablePool';\n\n// All functions are adapted from the solidity ones to be found on:\n// https://github.com/balancer-labs/balancer-core-v2/blob/master/contracts/pools/stable/StableMath.sol\n\n// TODO: implement all up and down rounding variations\n\n/**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant to compute                                                                  //\n    // A = amplifier                n * D^2 + A * n^n * S * (n^n * P / D^(n−1))                  //\n    // S = sum of balances         ____________________________________________                  //\n    // P = product of balances    (n+1) * D + ( A * n^n − 1)* (n^n * P / D^(n−1))                //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\n\nconst AMP_PRECISION_BNUM = bnum(1000);\n\nexport function _invariant(\n    A: BigNumber,\n    balances: OldBigNumber[] // balances\n): OldBigNumber {\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    for (let i = 0; i < totalCoins; i++) {\n        sum = sum.plus(balances[i]);\n    }\n    if (sum.isZero()) {\n        return ZERO;\n    }\n    let prevInv = ZERO;\n    let inv = sum;\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const ATimesNpowN = AAdjusted.times(totalCoins ** totalCoins); // A*n^n\n\n    for (let i = 0; i < 255; i++) {\n        let P_D = bnum(totalCoins).times(balances[0]);\n        for (let j = 1; j < totalCoins; j++) {\n            //P_D is rounded up\n            P_D = P_D.times(balances[j]).times(totalCoins).div(inv);\n        }\n        prevInv = inv;\n        //inv is rounded up\n        inv = bnum(totalCoins)\n            .times(inv)\n            .times(inv)\n            .plus(ATimesNpowN.times(sum).times(P_D))\n            .div(\n                bnum(totalCoins + 1)\n                    .times(inv)\n                    .plus(ATimesNpowN.minus(1).times(P_D))\n            );\n        // Equality with the precision of 1\n        if (inv.gt(prevInv)) {\n            if (inv.minus(prevInv).lt(bnum(10 ** -18))) {\n                break;\n            }\n        } else if (prevInv.minus(inv).lt(bnum(10 ** -18))) {\n            break;\n        }\n    }\n    //Result is rounded up\n    return inv;\n}\n\n// Adapted from StableMath.sol, _outGivenIn()\n// * Added swap fee at very first line\n/**********************************************************************************************\n    // outGivenIn token x for y - polynomial equation to solve                                   //\n    // ay = amount out to calculate                                                              //\n    // by = balance token out                                                                    //\n    // y = by - ay                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               y^2 + ( S - ----------  - 1) * y -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but y                                                           //\n    // P = product of final balances but y                                                       //\n    **********************************************************************************************/\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    let tokenAmountIn = amount;\n    tokenAmountIn = tokenAmountIn\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexIn) {\n            x = balances[i].plus(tokenAmountIn);\n        } else if (i != tokenIndexOut) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate out balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded down\n    // return balances[tokenIndexOut] > y ? balances[tokenIndexOut].minus(y) : 0;\n    return balances[tokenIndexOut].minus(y);\n}\n\n// Adapted from StableMath.sol, _inGivenOut()\n// * Added swap fee at very last line\n/**********************************************************************************************\n    // inGivenOut token x for y - polynomial equation to solve                                   //\n    // ax = amount in to calculate                                                               //\n    // bx = balance token in                                                                     //\n    // x = bx + ax                                                                               //\n    // D = invariant                               D                     D^(n+1)                 //\n    // A = amplifier               x^2 + ( S - ----------  - 1) * x -  ------------- = 0         //\n    // n = number of tokens                    (A * n^n)               A * n^2n * P              //\n    // S = sum of final balances but x                                                           //\n    // P = product of final balances but x                                                       //\n    **********************************************************************************************/\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n    //Invariant is rounded up\n    const inv = _invariant(A, balances);\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = bnum(balances.length);\n    let n_pow_n = ONE;\n    let x = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        n_pow_n = n_pow_n.times(totalCoins);\n\n        if (i == tokenIndexOut) {\n            x = balances[i].minus(tokenAmountOut);\n        } else if (i != tokenIndexIn) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    //Calculate in balance\n    const y = _solveAnalyticalBalance(sum, inv, A, n_pow_n, p);\n\n    //Result is rounded up\n    return y\n        .minus(balances[tokenIndexIn])\n        .multipliedBy(EONE.toString())\n        .div(EONE.sub(swapFee).toString());\n}\n\n/*\nFlow of calculations:\namountBPTOut -> newInvariant -> (amountInProportional, amountInAfterFee) ->\namountInPercentageExcess -> amountIn\n*/\nexport function _tokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsOut,\n        tokenIndexIn,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountOut = amount;\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    const newInvariant = bnumBalanceOut\n        .plus(bptAmountOut)\n        .div(bnumBalanceOut)\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // get amountInAfterFee\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexIn\n        );\n    const amountInAfterFee = newBalanceTokenIndex.minus(balances[tokenIndexIn]);\n\n    // Get tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalancePercentageExcess = bnum(1).minus(currentWeight);\n\n    // return amountIn\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    return amountInAfterFee.div(\n        bnum(1).minus(tokenBalancePercentageExcess.times(bnumSwapFee))\n    );\n}\n\nexport function _BPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsIn,\n        tokenIndexOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const tokenAmountOut = amount;\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weights of each token relative to the sum of all balances\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const currentWeight = balances[tokenIndexOut].div(sumBalances);\n    const tokenBalanceRatioWithoutFee = balances[tokenIndexOut]\n        .minus(tokenAmountOut)\n        .div(balances[tokenIndexOut]);\n    const weightedBalanceRatio = bnum(1).minus(\n        bnum(1).minus(tokenBalanceRatioWithoutFee).times(currentWeight)\n    );\n\n    // calculate new amounts in taking into account the fee on the % excess\n    const tokenBalancePercentageExcess = weightedBalanceRatio\n        .minus(tokenBalanceRatioWithoutFee)\n        .div(bnum(1).minus(tokenBalanceRatioWithoutFee));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const amountOutBeforeFee = tokenAmountOut.div(\n        bnum(1).minus(bnumSwapFee.times(tokenBalancePercentageExcess))\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amountOutBeforeFee);\n\n    // get new invariant taking into account swap fees\n    const newInvariant = _invariant(A, balances);\n\n    // return amountBPTIn\n    const bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n    return bnumBalanceIn.times(\n        bnum(1).minus(newInvariant.div(currentInvariant))\n    );\n}\n\n//This function calculates the balance of a given token (tokenIndex)\n// given all the other balances and the invariant\nfunction _getTokenBalanceGivenInvariantAndAllOtherBalances(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    inv: OldBigNumber,\n    tokenIndex: number\n): OldBigNumber {\n    let p = inv;\n    let sum = ZERO;\n    const totalCoins = balances.length;\n    let nPowN = ONE;\n    let x = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        nPowN = nPowN.times(totalCoins);\n        if (i != tokenIndex) {\n            x = balances[i];\n        } else {\n            continue;\n        }\n        sum = sum.plus(x);\n        //Round up p\n        p = p.times(inv).div(x);\n    }\n\n    // Calculate token balance\n    return _solveAnalyticalBalance(sum, inv, A, nPowN, p);\n}\n\n//This function calcuates the analytical solution to find the balance required\nexport function _solveAnalyticalBalance(\n    sum: OldBigNumber,\n    inv: OldBigNumber,\n    A: BigNumber,\n    n_pow_n: OldBigNumber,\n    p: OldBigNumber\n): OldBigNumber {\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const oldBN_A = bnum(formatFixed(A, 3));\n    //Round up p\n    p = p.times(inv).div(oldBN_A.times(n_pow_n).times(n_pow_n));\n    //Round down b\n    const b = sum.plus(inv.div(oldBN_A.times(n_pow_n)));\n    //Round up c\n    // let c = inv >= b\n    //     ? inv.minus(b).plus(Math.sqrtUp(inv.minus(b).times(inv.minus(b)).plus(p.times(4))))\n    //     : Math.sqrtUp(b.minus(inv).times(b.minus(inv)).plus(p.times(4))).minus(b.minus(inv));\n    let c;\n    if (inv.gte(b)) {\n        c = inv\n            .minus(b)\n            .plus(inv.minus(b).times(inv.minus(b)).plus(p.times(4)).sqrt());\n    } else {\n        c = b\n            .minus(inv)\n            .times(b.minus(inv))\n            .plus(p.times(4))\n            .sqrt()\n            .minus(b.minus(inv));\n    }\n    //Round up y\n    return c.div(2);\n}\n\n//////////////////////\n////  These functions have been added exclusively for the SORv2\n//////////////////////\n\nexport function _exactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexIn,\n        swapFee,\n        decimalsOut,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const tokenAmountIn = amount;\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weights of each token relative to the sum of all balances\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    // Calculate the weighted balance ratio without considering fees\n    const currentWeight = balances[tokenIndexIn].div(sumBalances);\n    const tokenBalanceRatioWithoutFee = balances[tokenIndexIn]\n        .plus(tokenAmountIn)\n        .div(balances[tokenIndexIn]);\n    const weightedBalanceRatio = bnum(1).plus(\n        tokenBalanceRatioWithoutFee.minus(bnum(1)).times(currentWeight)\n    );\n\n    // calculate new amountIn taking into account the fee on the % excess\n    // Percentage of the amount supplied that will be implicitly swapped for other tokens in the pool\n    const tokenBalancePercentageExcess = tokenBalanceRatioWithoutFee\n        .minus(weightedBalanceRatio)\n        .div(tokenBalanceRatioWithoutFee.minus(bnum(1)));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const amountInAfterFee = tokenAmountIn.times(\n        bnum(1).minus(bnumSwapFee.times(tokenBalancePercentageExcess))\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(amountInAfterFee);\n\n    // get new invariant taking into account swap fees\n    const newInvariant = _invariant(A, balances);\n\n    const bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n\n    return bnumBalanceOut.times(\n        newInvariant.div(currentInvariant).minus(bnum(1))\n    );\n}\n\n/* \nFlow of calculations:\namountBPTin -> newInvariant -> (amountOutProportional, amountOutBeforeFee) ->\namountOutPercentageExcess -> amountOut\n*/\nexport function _exactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    // The formula below returns some dust (due to rounding errors) but when\n    // we input zero the output should be zero\n    if (amount.isZero()) return amount;\n\n    const { amp, allBalances, tokenIndexOut, swapFee } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const bptAmountIn = amount;\n\n    /**********************************************************************************************\n    // TODO description                            //\n    **********************************************************************************************/\n\n    // Get current invariant\n    const currentInvariant = _invariant(A, balances);\n    // Calculate new invariant\n    const bnumBalanceIn = bnum(formatFixed(poolPairData.virtualBptSupply, 18));\n    const newInvariant = bnumBalanceIn\n        .minus(bptAmountIn)\n        .div(bnumBalanceIn)\n        .times(currentInvariant);\n\n    // First calculate the sum of all token balances which will be used to calculate\n    // the current weight of token\n    let sumBalances = bnum(0);\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n\n    const newBalanceTokenIndex =\n        _getTokenBalanceGivenInvariantAndAllOtherBalances(\n            A,\n            balances,\n            newInvariant,\n            tokenIndexOut\n        );\n    const amountOutBeforeFee =\n        balances[tokenIndexOut].minus(newBalanceTokenIndex);\n\n    // Calculate tokenBalancePercentageExcess\n    const currentWeight = balances[tokenIndexOut].div(sumBalances);\n    const tokenBalancePercentageExcess = bnum(1).minus(currentWeight);\n    const ans = amountOutBeforeFee.times(\n        ONE.minus(\n            tokenBalancePercentageExcess\n                .times(swapFee.toString())\n                .div(EONE.toString())\n        )\n    );\n    return ans;\n}\n\nexport function _poolDerivatives(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    tokenIndexIn: number,\n    tokenIndexOut: number,\n    is_first_derivative: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn && i != tokenIndexOut) {\n            S = S.plus(balances[i]);\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const y = balances[tokenIndexOut];\n    // A is passed as an ethers bignumber while maths uses bignumber.js\n    const AAdjusted = bnum(formatFixed(A, 3));\n    const a = AAdjusted.times(totalCoins ** totalCoins); // = ATimesNpowN\n    const b = S.minus(D).times(a).plus(D);\n    const twoaxy = bnum(2).times(a).times(x).times(y);\n    const partial_x = twoaxy.plus(a.times(y).times(y)).plus(b.times(y));\n    const partial_y = twoaxy.plus(a.times(x).times(x)).plus(b.times(x));\n    let ans;\n    if (is_first_derivative) {\n        ans = partial_x.div(partial_y);\n    } else {\n        const partial_xx = bnum(2).times(a).times(y);\n        const partial_yy = bnum(2).times(a).times(x);\n        const partial_xy = partial_xx.plus(partial_yy).plus(b);\n        const numerator = bnum(2)\n            .times(partial_x)\n            .times(partial_y)\n            .times(partial_xy)\n            .minus(partial_xx.times(partial_y.pow(2)))\n            .minus(partial_yy.times(partial_x.pow(2)));\n        const denominator = partial_x.pow(2).times(partial_y);\n        ans = numerator.div(denominator);\n        if (wrt_out) {\n            ans = ans.times(partial_y).div(partial_x);\n        }\n    }\n    return ans;\n}\n\n/////////\n/// SpotPriceAfterSwap\n/////////\n\nexport function _poolDerivativesBPT(\n    A: BigNumber,\n    balances: OldBigNumber[],\n    bptSupply: OldBigNumber,\n    tokenIndexIn: number,\n    is_first_derivative: boolean,\n    is_BPT_out: boolean,\n    wrt_out: boolean\n): OldBigNumber {\n    const totalCoins = balances.length;\n    const D = _invariant(A, balances);\n    let S = ZERO;\n    let D_P = D.div(totalCoins);\n    for (let i = 0; i < totalCoins; i++) {\n        if (i != tokenIndexIn) {\n            S = S.plus(balances[i]);\n            D_P = D_P.times(D).div(balances[i].times(totalCoins));\n        }\n    }\n    const x = balances[tokenIndexIn];\n    const alpha = bnum(A.toString()).times(totalCoins ** totalCoins); // = ATimesNpowN\n    const beta = alpha.times(S);\n    const gamma = AMP_PRECISION_BNUM.minus(alpha);\n    const partial_x = bnum(2)\n        .times(alpha)\n        .times(x)\n        .plus(beta)\n        .plus(gamma.times(D));\n    const minus_partial_D = D_P.times(totalCoins + 1)\n        .times(AMP_PRECISION_BNUM)\n        .minus(gamma.times(x));\n    const partial_D = ZERO.minus(minus_partial_D);\n    let ans: OldBigNumber;\n    if (is_first_derivative) {\n        ans = partial_x.div(minus_partial_D).times(bptSupply).div(D);\n    } else {\n        const partial_xx = bnum(2).times(alpha);\n        const partial_xD = gamma;\n        const n_times_nplusone = totalCoins * (totalCoins + 1);\n        const partial_DD = ZERO.minus(D_P.times(n_times_nplusone).div(D));\n        if (is_BPT_out) {\n            const term1 = partial_xx.times(partial_D).div(partial_x.pow(2));\n            const term2 = bnum(2).times(partial_xD).div(partial_x);\n            const term3 = partial_DD.div(partial_D);\n            ans = term1.minus(term2).plus(term3).times(D).div(bptSupply);\n            if (wrt_out) {\n                const D_prime = ZERO.minus(partial_x.div(partial_D));\n                ans = ans.div(D_prime).times(D).div(bptSupply);\n            }\n        } else {\n            ans = bnum(2)\n                .times(partial_xD)\n                .div(partial_D)\n                .minus(partial_DD.times(partial_x).div(partial_D.pow(2)))\n                .minus(partial_xx.div(partial_x));\n            if (wrt_out) {\n                ans = ans\n                    .times(partial_x)\n                    .div(minus_partial_D)\n                    .times(bptSupply)\n                    .div(D);\n            }\n        }\n    }\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        false\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData)\n        .times(EONE.sub(swapFee).toString())\n        .div(EONE.toString());\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    let ans = _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(EONE.sub(swapFee).toString()).div(EONE.toString()));\n    return ans;\n}\n\nfunction _feeFactor(\n    balances: OldBigNumber[],\n    tokenIndex: number,\n    swapFee: BigNumber\n): OldBigNumber {\n    let sumBalances = ZERO;\n    for (let i = 0; i < balances.length; i++) {\n        sumBalances = sumBalances.plus(balances[i]);\n    }\n    const currentWeight = balances[tokenIndex].div(sumBalances);\n    const tokenBalancePercentageExcess = ONE.minus(currentWeight);\n    return ONE.minus(\n        tokenBalancePercentageExcess\n            .times(swapFee.toString())\n            .div(EONE.toString())\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsOut,\n        tokenIndexIn,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    let bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(feeFactor)\n    );\n    bnumBalanceOut = bnumBalanceOut.plus(\n        _exactTokenInForBPTOut(amount, poolPairData)\n    );\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        true,\n        true,\n        false\n    );\n    ans = bnum(1).div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexIn,\n        decimalsOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let bnumBalanceOut = bnum(formatFixed(virtualBptSupply, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(amount);\n    let ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        true,\n        true,\n        true\n    );\n    ans = ONE.div(ans.times(feeFactor));\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        tokenIndexOut,\n        swapFee,\n        decimalsIn,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _out = _exactBPTInForTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    let bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _out.div(feeFactor)\n    );\n    bnumBalanceIn = bnumBalanceIn.minus(amount);\n\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        true,\n        false,\n        false\n    ).div(feeFactor);\n    return ans;\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const {\n        amp,\n        allBalances,\n        virtualBptSupply,\n        decimalsIn,\n        tokenIndexOut,\n        swapFee,\n    } = poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        amount.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(virtualBptSupply, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(\n        _BPTInForExactTokenOut(amount, poolPairData)\n    );\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        true,\n        false,\n        true\n    ).div(feeFactor);\n    return ans;\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(EONE.sub(swapFee).toString()).div(EONE.toString())\n    );\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _exactTokenInForTokenOut(amount, poolPairData)\n    );\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        false\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, tokenIndexIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const bnumSwapFee = bnum(formatFixed(swapFee, 18));\n    const _in = _tokenInForExactTokenOut(amount, poolPairData).times(\n        bnum(1).minus(bnumSwapFee)\n    );\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(amount);\n    const feeFactor = bnum(1).minus(bnumSwapFee);\n    return _poolDerivatives(\n        A,\n        balances,\n        tokenIndexIn,\n        tokenIndexOut,\n        false,\n        true\n    ).div(feeFactor);\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, decimalsOut, tokenIndexIn, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(\n        amount.times(feeFactor)\n    );\n    let bnumBalanceOut = bnum(formatFixed(balanceOut, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(\n        _exactTokenInForBPTOut(amount, poolPairData)\n    );\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        false,\n        true,\n        false\n    );\n    return ans;\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceOut, decimalsOut, tokenIndexIn, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _in = _tokenInForExactBPTOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexIn, swapFee);\n    balances[tokenIndexIn] = balances[tokenIndexIn].plus(_in.times(feeFactor));\n    let bnumBalanceOut = bnum(formatFixed(balanceOut, decimalsOut));\n    bnumBalanceOut = bnumBalanceOut.plus(amount);\n    return _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceOut,\n        tokenIndexIn,\n        false,\n        true,\n        true\n    ).div(feeFactor);\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceIn, decimalsIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _in = _BPTInForExactTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        amount.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(balanceIn, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(_in);\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        false,\n        false,\n        true\n    );\n    return ans.div(feeFactor.pow(2));\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: PhantomStablePoolPairData\n): OldBigNumber {\n    const { amp, allBalances, balanceIn, decimalsIn, tokenIndexOut, swapFee } =\n        poolPairData;\n    const balances = [...allBalances];\n    const n = balances.length;\n    const A = amp.div(n ** (n - 1));\n\n    const _out = _exactBPTInForTokenOut(amount, poolPairData);\n    const feeFactor = _feeFactor(balances, tokenIndexOut, swapFee);\n    balances[tokenIndexOut] = balances[tokenIndexOut].minus(\n        _out.div(feeFactor)\n    );\n    let bnumBalanceIn = bnum(formatFixed(balanceIn, decimalsIn));\n    bnumBalanceIn = bnumBalanceIn.minus(amount);\n    const ans = _poolDerivativesBPT(\n        A,\n        balances,\n        bnumBalanceIn,\n        tokenIndexOut,\n        false,\n        false,\n        false\n    );\n    return ans.div(feeFactor);\n}\n"],"names":["AMP_PRECISION_BNUM","bnum","_invariant","A","balances","sum","ZERO","totalCoins","length","i","plus","isZero","prevInv","inv","ATimesNpowN","formatFixed","times","P_D","j","div","minus","gt","lt","_exactTokenInForTokenOut","amount","poolPairData","amp","allBalances","tokenIndexIn","tokenIndexOut","swapFee","n","tokenAmountIn","EONE","sub","toString","p","n_pow_n","ONE","x","y","_solveAnalyticalBalance","_tokenInForExactTokenOut","tokenAmountOut","multipliedBy","_tokenInForExactBPTOut","virtualBptSupply","decimalsOut","bptAmountOut","currentInvariant","bnumBalanceOut","newInvariant","sumBalances","amountInAfterFee","_getTokenBalanceGivenInvariantAndAllOtherBalances","currentWeight","tokenBalancePercentageExcess","bnumSwapFee","_BPTInForExactTokenOut","decimalsIn","tokenBalanceRatioWithoutFee","amountOutBeforeFee","tokenIndex","nPowN","oldBN_A","b","c","gte","sqrt","_exactTokenInForBPTOut","weightedBalanceRatio","_exactBPTInForTokenOut","bptAmountIn","bnumBalanceIn","newBalanceTokenIndex","_poolDerivatives","is_first_derivative","wrt_out","D","S","a","twoaxy","partial_x","partial_y","ans","partial_xx","partial_yy","partial_xy","numerator","pow","denominator","_poolDerivativesBPT","bptSupply","is_BPT_out","D_P","alpha","beta","gamma","minus_partial_D","partial_D","partial_xD","n_times_nplusone","partial_DD","term1","term2","term3","D_prime","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","_in","_feeFactor","_spotPriceAfterSwapExactTokenInForBPTOut","feeFactor","_spotPriceAfterSwapTokenInForExactBPTOut","_spotPriceAfterSwapExactBPTInForTokenOut","_out","_spotPriceAfterSwapBPTInForExactTokenOut","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","_derivativeSpotPriceAfterSwapExactTokenInForBPTOut","balanceOut","_derivativeSpotPriceAfterSwapTokenInForExactBPTOut","_derivativeSpotPriceAfterSwapBPTInForExactTokenOut","balanceIn","_derivativeSpotPriceAfterSwapExactBPTInForTokenOut"],"mappings":"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"}