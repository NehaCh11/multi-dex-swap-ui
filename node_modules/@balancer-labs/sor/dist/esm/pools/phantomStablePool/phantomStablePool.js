import{parseFixed as t,formatFixed as e,BigNumber as n}from"@ethersproject/bignumber";import{WeiPerEther as o}from"@ethersproject/constants";import{isSameAddress as a}from"../../utils/index.js";import{bnum as i,ZERO as s}from"../../utils/bignumber.js";import{PoolTypes as r,SwapTypes as p}from"../../types.js";import{getAddress as l}from"@ethersproject/address";import{_calcBptOutGivenExactTokensIn as c,_calcTokenOutGivenExactBptIn as d,_calcOutGivenIn as u,_calcTokenInGivenExactBptOut as m,_calcBptInGivenExactTokensOut as k,_calcInGivenOut as T}from"../stablePool/stableMathBigInt.js";import{_spotPriceAfterSwapExactTokenInForBPTOut as I,_spotPriceAfterSwapExactBPTInForTokenOut as B,_spotPriceAfterSwapExactTokenInForTokenOut as h,_spotPriceAfterSwapTokenInForExactBPTOut as S,_spotPriceAfterSwapBPTInForExactTokenOut as g,_spotPriceAfterSwapTokenInForExactTokenOut as P,_derivativeSpotPriceAfterSwapExactTokenInForBPTOut as O,_derivativeSpotPriceAfterSwapExactBPTInForTokenOut as x,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as f,_derivativeSpotPriceAfterSwapTokenInForExactBPTOut as v,_derivativeSpotPriceAfterSwapBPTInForExactTokenOut as b,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as y}from"./phantomStableMath.js";import"../../external/lodash.clonedeep/index.js";import{universalNormalizedLiquidity as w}from"../liquidity.js";import{exports as R}from"../../_virtual/index.js";var E;!function(t){t[t.BptToToken=0]="BptToToken",t[t.TokenToBpt=1]="TokenToBpt",t[t.TokenToToken=2]="TokenToToken"}(E||(E={}));class A{static fromPool(t){if(!t.amp)throw new Error("PhantomStablePool missing amp factor");return new A(t.id,t.address,t.amp,t.swapFee,t.totalShares,t.tokens,t.tokensList)}static removeBPT(t){const e=R(t),n=t.bptIndex;return-1!=n&&(e.allBalances.splice(n,1),e.allBalancesScaled.splice(n,1),n<t.tokenIndexIn&&(e.tokenIndexIn-=1),n<t.tokenIndexOut&&(e.tokenIndexOut-=1)),e}constructor(e,n,o,a,i,s,p){this.poolType=r.MetaStable,this.ALMOST_ONE=t("0.99",18),this.id=e,this.address=n,this.amp=t(o,A.AMP_DECIMALS),this.swapFee=t(a,18),this.totalShares=t(i,18),this.tokens=s,this.tokensList=p}parsePoolPairData(e,n){const s=this.tokens.findIndex((t=>l(t.address)===l(e)));if(s<0)throw"Pool does not contain tokenIn";const r=this.tokens[s],p=i(r.balance).times(i(r.priceRate)).dp(r.decimals).toString(),c=r.decimals,d=t(r.priceRate,18),u=this.tokens.findIndex((t=>l(t.address)===l(n)));if(u<0)throw"Pool does not contain tokenOut";const m=this.tokens[u],k=i(m.balance).times(i(m.priceRate)).dp(m.decimals).toString(),T=m.decimals,I=t(m.priceRate,18),B=this.tokens.map((({balance:t,priceRate:e})=>i(t).times(i(e)))),h=this.tokens.map((({balance:e,priceRate:n})=>t(e,18).mul(t(n,18)).div(o)));let S;S=a(e,this.address)?E.BptToToken:a(n,this.address)?E.TokenToBpt:E.TokenToToken;const g=this.tokensList.indexOf(this.address),P=this.totalShares,O={id:this.id,address:this.address,poolType:this.poolType,pairType:S,bptIndex:g,tokenIn:e,tokenOut:n,balanceIn:t(p,c),balanceOut:t(k,T),swapFee:this.swapFee,allBalances:B,allBalancesScaled:h,amp:this.amp,tokenIndexIn:s,tokenIndexOut:u,decimalsIn:Number(c),decimalsOut:Number(T),tokenInPriceRate:d,tokenOutPriceRate:I,virtualBptSupply:P};return A.removeBPT(O)}getNormalizedLiquidity(t){return w(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,s))}getLimitAmountSwap(t,n){return p.SwapExactIn,i(e(t.balanceOut.mul(this.ALMOST_ONE).div(t.tokenOutPriceRate),t.decimalsOut))}updateTokenBalanceForPool(n,o){const i=this.tokens.find((t=>a(t.address,n)));if(!i)throw Error("Pool does not contain this token");if(a(this.address,n)){const e=t(i.balance,i.decimals).sub(o),n=this.totalShares.add(e);this.updateTotalShares(n)}i.balance=e(o,i.decimals)}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(a,r){try{if(r.isZero())return s;const p=this.subtractSwapFeeAmount(t(r.dp(18).toString(),18),a.swapFee).mul(a.tokenInPriceRate).div(o);let l;if(a.pairType===E.TokenToBpt){const t=Array(a.allBalancesScaled.length).fill(BigInt(0));t[a.tokenIndexIn]=p.toBigInt(),l=c(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),t,a.virtualBptSupply.toBigInt(),BigInt(0))}else l=a.pairType===E.BptToToken?d(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexOut,p.toBigInt(),a.virtualBptSupply.toBigInt(),BigInt(0)):u(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,a.tokenIndexOut,p.toBigInt(),BigInt(0));const m=n.from(l).mul(o).div(a.tokenOutPriceRate);return i(e(m,18))}catch(t){return s}}_tokenInForExactTokenOut(a,r){try{if(r.isZero())return s;const p=t(r.dp(18).toString(),18).mul(a.tokenOutPriceRate).div(o);let l;if(a.pairType===E.TokenToBpt)l=m(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,p.toBigInt(),a.virtualBptSupply.toBigInt(),BigInt(0));else if(a.pairType===E.BptToToken){const t=Array(a.allBalancesScaled.length).fill(BigInt(0));t[a.tokenIndexOut]=p.toBigInt(),l=k(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),t,a.virtualBptSupply.toBigInt(),BigInt(0))}else l=T(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,a.tokenIndexOut,p.toBigInt(),BigInt(0));const c=n.from(l).mul(o).div(a.tokenInPriceRate),d=this.addSwapFeeAmount(c,a.swapFee);return i(e(d,18))}catch(t){return console.error(`PhantomStable _evminGivenOut: ${t.message}`),s}}_calcTokensOutGivenExactBptIn(t){throw new Error("PhantomPool does not have exit pool (_calcTokensOutGivenExactBptIn).")}_calcBptOutGivenExactTokensIn(t){throw new Error("PhantomPool does not have join pool (_calcBptOutGivenExactTokensIn).")}_spotPriceAfterSwapExactTokenInForTokenOut(t,n){const o=i(e(t.tokenInPriceRate,18)),a=i(e(t.tokenOutPriceRate,18)),s=n.times(i(e(t.tokenInPriceRate,18)));let r;return r=t.pairType===E.TokenToBpt?I(s,t):t.pairType===E.BptToToken?B(s,t):h(s,t),r.div(o).times(a)}_spotPriceAfterSwapTokenInForExactTokenOut(t,n){const o=i(e(t.tokenInPriceRate,18)),a=i(e(t.tokenOutPriceRate,18)),s=n.times(e(t.tokenOutPriceRate,18));let r;return r=t.pairType===E.TokenToBpt?S(s,t):t.pairType===E.BptToToken?g(s,t):P(s,t),r.div(o).times(a)}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,n){const o=i(e(t.tokenOutPriceRate,18)),a=n.times(e(t.tokenInPriceRate,18));let s;return s=t.pairType===E.TokenToBpt?O(a,t):t.pairType===E.BptToToken?x(a,t):f(a,t),s.times(o)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,n){const o=i(e(t.tokenInPriceRate,18)),a=i(e(t.tokenOutPriceRate,18)),s=n.times(e(t.tokenOutPriceRate,18));let r;return r=t.pairType===E.TokenToBpt?v(s,t):t.pairType===E.BptToToken?b(s,t):y(s,t),r.div(o).times(a).times(a)}subtractSwapFeeAmount(t,e){const n=t.mul(e).add(o.sub(1)).div(o);return t.sub(n)}addSwapFeeAmount(t,e){const n=o.sub(e);return t.mul(o).add(n.sub(1)).div(n)}}A.AMP_DECIMALS=3;export{E as PairTypes,A as PhantomStablePool};
//# sourceMappingURL=phantomStablePool.js.map
