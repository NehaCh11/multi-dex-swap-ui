import{getAddress as t}from"@ethersproject/address";import{WeiPerEther as e,Zero as a}from"@ethersproject/constants";import{formatFixed as s}from"@ethersproject/bignumber";import{ZERO as o,bnum as r}from"../../utils/bignumber.js";import{PoolTypes as n,SwapTypes as i}from"../../types.js";import{balancesFromTokenInOut as d,virtualOffset0 as h,virtualOffset1 as c,reduceFee as m,addFee as l}from"../gyroEPool/gyroEMath/gyroEMathHelpers.js";import{safeParseFixed as k,isSameAddress as u}from"../../utils/index.js";import{divDown as I,mulDown as p}from"../gyroHelpers/gyroSignedFixedPoint.js";import{calculateInvariantWithError as y,calcOutGivenIn as E,calcInGivenOut as P,calcSpotPriceAfterSwapOutGivenIn as T,calcSpotPriceAfterSwapInGivenOut as g,calcDerivativePriceAfterSwapOutGivenIn as b,calcDerivativeSpotPriceAfterSwapInGivenOut as v}from"../gyroEPool/gyroEMath/gyroEMath.js";import{SWAP_LIMIT_FACTOR as w}from"../gyroHelpers/constants.js";import{universalNormalizedLiquidity as O}from"../liquidity.js";import{normalizeBalances as f}from"./gyroEV2Math/gyroEV2MathHelpers.js";const S=d;class x{static fromPool(t){const{alpha:e,beta:a,c:s,s:o,lambda:r,tauAlphaX:n,tauAlphaY:i,tauBetaX:d,tauBetaY:h,u:c,v:m,w:l,z:k,dSq:u,tokenRates:I}=t,p={alpha:e,beta:a,c:s,s:o,lambda:r},y={tauAlphaX:n,tauAlphaY:i,tauBetaX:d,tauBetaY:h,u:c,v:m,w:l,z:k,dSq:u};if(!Object.values(p).every((t=>t))||!Object.values(y).every((t=>t)))throw new Error("Pool missing GyroE params and/or GyroE derived params");if(!I)throw new Error("GyroEV2 Pool missing tokenRates");return new x(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,p,y,I)}constructor(t,e,a,s,o,r,i,d,h){this.poolType=n.GyroE,this.id=t,this.address=e,this.swapFee=k(a,18),this.totalShares=k(s,18),this.tokens=o,this.tokensList=r,this.tokenRates=[k(h[0],18),k(h[1],18)],this.gyroEParams={alpha:k(i.alpha,18),beta:k(i.beta,18),c:k(i.c,18),s:k(i.s,18),lambda:k(i.lambda,18)},this.derivedGyroEParams={tauAlpha:{x:k(d.tauAlphaX,38),y:k(d.tauAlphaY,38)},tauBeta:{x:k(d.tauBetaX,38),y:k(d.tauBetaY,38)},u:k(d.u,38),v:k(d.v,38),w:k(d.w,38),z:k(d.z,38),dSq:k(d.dSq,38)}}parsePoolPairData(e,a){const s=this.tokens.findIndex((a=>t(a.address)===t(e)));if(s<0)throw"Pool does not contain tokenIn";const o=this.tokens[s],r=o.balance,n=o.decimals,i=this.tokens.findIndex((e=>t(e.address)===t(a)));if(i<0)throw"Pool does not contain tokenOut";const d=this.tokens[i],h=d.balance,c=d.decimals,m=0===s;return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:e,tokenOut:a,decimalsIn:Number(n),decimalsOut:Number(c),balanceIn:k(r,n),balanceOut:k(h,c),swapFee:this.swapFee,tokenInIsToken0:m}}getNormalizedLiquidity(t){return O(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,o))}getLimitAmountSwap(t,a){if(a===i.SwapExactIn){const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,m]=y(n,this.gyroEParams,this.derivedGyroEParams),l={x:i.add(m.mul(2)),y:i},k=t.tokenInIsToken0?h:c,u=k(this.gyroEParams,this.derivedGyroEParams,l).sub(k(this.gyroEParams,this.derivedGyroEParams,l,!0)),E=I(u.sub(o[0]),a[0]),P=I(E,e.sub(t.swapFee));return r(s(p(P,w),18))}return r(s(p(t.balanceOut,w),t.decimalsOut))}updateTokenBalanceForPool(t,e){if(u(this.address,t))this.updateTotalShares(e);else{const a=this.tokens.find((e=>u(e.address,t)));if(!a)throw Error("Pool does not contain this token");a.balance=s(e,a.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,e){try{const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,h]=y(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(h.mul(2)),y:i},l=k(e.toString(),18),u=m(l,t.swapFee),P=p(u,a[0]),T=E(n,P,t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c),g=I(T,a[1]);return r(s(g,18))}catch(t){return o}}_tokenInForExactTokenOut(t,e){try{const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,h]=y(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(h.mul(2)),y:i},m=k(e.toString(),18),u=p(m,a[1]),E=P(n,u,t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c),T=I(E,a[0]),g=l(T,t.swapFee);return r(s(g,18))}catch(t){return o}}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(a)}_calcBptOutGivenExactTokensIn(t){return a}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,h]=y(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(h.mul(2)),y:i},l=k(e.toString(),18),u=m(l,t.swapFee),E=p(u,a[0]),P=T(n,E,t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c,t.swapFee),g=I(p(P,a[1]),a[0]);return r(s(g,18))}catch(t){return o}}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,h]=y(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(h.mul(2)),y:i},m=k(e.toString(),18),l=p(m,a[1]),u=g(n,l,t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c,t.swapFee),E=I(p(u,a[1]),a[0]);return r(s(E,18))}catch(t){return o}}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const a=k(e.toString(),18),o=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),n=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],o),i=d(n[0],n[1],t.tokenInIsToken0),[h,c]=y(i,this.gyroEParams,this.derivedGyroEParams),l={x:h.add(c.mul(2)),y:h},u=b([i[0].add(m(p(a,o[0]),t.swapFee)),i[1]],t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,l,t.swapFee),I=p(u,o[1]);return r(s(I,18))}catch(t){return o}}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const a=S(this.tokenRates[0],this.tokenRates[1],t.tokenInIsToken0),o=f([t.balanceIn,t.balanceOut],[t.decimalsIn,t.decimalsOut],a),n=d(o[0],o[1],t.tokenInIsToken0),[i,h]=y(n,this.gyroEParams,this.derivedGyroEParams),c={x:i.add(h.mul(2)),y:i},m=k(e.toString(),18),l=v([n[0],n[1].sub(p(m,a[1]))],t.tokenInIsToken0,this.gyroEParams,this.derivedGyroEParams,c,t.swapFee),u=I(p(a[1],a[1]),a[0]),E=p(l,u);return r(s(E,18))}catch(t){return o}}}export{x as GyroEV2Pool};
//# sourceMappingURL=gyroEV2Pool.js.map
