{"version":3,"file":"gyroEV2Pool.js","sources":["../../../../../../src/pools/gyroEV2Pool/gyroEV2Pool.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { formatFixed, BigNumber } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\n\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphToken,\n    SwapTypes,\n    SubgraphPoolBase,\n} from '../../types';\nimport {\n    GyroEParams,\n    DerivedGyroEParams,\n    Vector2,\n    balancesFromTokenInOut,\n    reduceFee,\n    addFee,\n    virtualOffset0,\n    virtualOffset1,\n} from '../gyroEPool/gyroEMath/gyroEMathHelpers';\nimport { isSameAddress, safeParseFixed } from '../../utils';\nimport { mulDown, divDown } from '../gyroHelpers/gyroSignedFixedPoint';\nimport {\n    calculateInvariantWithError,\n    calcOutGivenIn,\n    calcInGivenOut,\n    calcSpotPriceAfterSwapOutGivenIn,\n    calcSpotPriceAfterSwapInGivenOut,\n    calcDerivativePriceAfterSwapOutGivenIn,\n    calcDerivativeSpotPriceAfterSwapInGivenOut,\n} from '../gyroEPool/gyroEMath/gyroEMath';\nimport { SWAP_LIMIT_FACTOR } from '../gyroHelpers/constants';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nimport { normalizeBalances } from './gyroEV2Math/gyroEV2MathHelpers';\n\n// Alias for code readability. Observe that `balancesFromTokenInOut()` is its own inverse.\nconst valuesInOutFrom01 = balancesFromTokenInOut;\n\nexport type GyroEPoolPairData = PoolPairBase & {\n    tokenInIsToken0: boolean;\n};\n\nexport type GyroEPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals'\n>;\n\ntype GyroEParamsFromSubgraph = {\n    alpha: string;\n    beta: string;\n    c: string;\n    s: string;\n    lambda: string;\n};\ntype DerivedGyroEParamsFromSubgraph = {\n    tauAlphaX: string;\n    tauAlphaY: string;\n    tauBetaX: string;\n    tauBetaY: string;\n    u: string;\n    v: string;\n    w: string;\n    z: string;\n    dSq: string;\n};\n\nexport class GyroEV2Pool implements PoolBase<GyroEPoolPairData> {\n    poolType: PoolTypes = PoolTypes.GyroE;\n    id: string;\n    address: string;\n    tokensList: string[];\n    tokens: GyroEPoolToken[];\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    gyroEParams: GyroEParams;\n    derivedGyroEParams: DerivedGyroEParams;\n    tokenRates: BigNumber[];\n\n    static fromPool(pool: SubgraphPoolBase): GyroEV2Pool {\n        const {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n            tokenRates,\n        } = pool;\n\n        const gyroEParams = {\n            alpha,\n            beta,\n            c,\n            s,\n            lambda,\n        };\n\n        const derivedGyroEParams = {\n            tauAlphaX,\n            tauAlphaY,\n            tauBetaX,\n            tauBetaY,\n            u,\n            v,\n            w,\n            z,\n            dSq,\n        };\n\n        if (\n            !Object.values(gyroEParams).every((el) => el) ||\n            !Object.values(derivedGyroEParams).every((el) => el)\n        )\n            throw new Error(\n                'Pool missing GyroE params and/or GyroE derived params'\n            );\n\n        if (!tokenRates) throw new Error('GyroEV2 Pool missing tokenRates');\n\n        return new GyroEV2Pool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens as GyroEPoolToken[],\n            pool.tokensList,\n            gyroEParams as GyroEParamsFromSubgraph,\n            derivedGyroEParams as DerivedGyroEParamsFromSubgraph,\n            tokenRates\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: GyroEPoolToken[],\n        tokensList: string[],\n        gyroEParams: GyroEParamsFromSubgraph,\n        derivedGyroEParams: DerivedGyroEParamsFromSubgraph,\n        tokenRates: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = safeParseFixed(swapFee, 18);\n        this.totalShares = safeParseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.tokenRates = [\n            safeParseFixed(tokenRates[0], 18),\n            safeParseFixed(tokenRates[1], 18),\n        ];\n\n        this.gyroEParams = {\n            alpha: safeParseFixed(gyroEParams.alpha, 18),\n            beta: safeParseFixed(gyroEParams.beta, 18),\n            c: safeParseFixed(gyroEParams.c, 18),\n            s: safeParseFixed(gyroEParams.s, 18),\n            lambda: safeParseFixed(gyroEParams.lambda, 18),\n        };\n\n        this.derivedGyroEParams = {\n            tauAlpha: {\n                x: safeParseFixed(derivedGyroEParams.tauAlphaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauAlphaY, 38),\n            },\n            tauBeta: {\n                x: safeParseFixed(derivedGyroEParams.tauBetaX, 38),\n                y: safeParseFixed(derivedGyroEParams.tauBetaY, 38),\n            },\n            u: safeParseFixed(derivedGyroEParams.u, 38),\n            v: safeParseFixed(derivedGyroEParams.v, 38),\n            w: safeParseFixed(derivedGyroEParams.w, 38),\n            z: safeParseFixed(derivedGyroEParams.z, 38),\n            dSq: safeParseFixed(derivedGyroEParams.dSq, 38),\n        };\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): GyroEPoolPairData {\n        const tokenInIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenInIndex < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenInIndex];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenOutIndex = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenOutIndex < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenOutIndex];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        const tokenInIsToken0 = tokenInIndex === 0;\n\n        const poolPairData: GyroEPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: safeParseFixed(balanceIn, decimalsIn),\n            balanceOut: safeParseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            tokenInIsToken0,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedLiquidity(poolPairData: GyroEPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: GyroEPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const virtualOffsetFunc = poolPairData.tokenInIsToken0\n                ? virtualOffset0\n                : virtualOffset1;\n            const maxAmountInAssetInPool = virtualOffsetFunc(\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            ).sub(\n                virtualOffsetFunc(\n                    this.gyroEParams,\n                    this.derivedGyroEParams,\n                    invariant,\n                    true\n                )\n            );\n            const limitAmountIn = divDown(\n                maxAmountInAssetInPool.sub(normalizedBalances[0]),\n                tokenRateInOut[0]\n            );\n            const limitAmountInPlusSwapFee = divDown(\n                limitAmountIn,\n                ONE.sub(poolPairData.swapFee)\n            );\n            return bnum(\n                formatFixed(\n                    mulDown(limitAmountInPlusSwapFee, SWAP_LIMIT_FACTOR),\n                    18\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    mulDown(poolPairData.balanceOut, SWAP_LIMIT_FACTOR),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n            const inAmountLessFeeScaled = mulDown(\n                inAmountLessFee,\n                tokenRateInOut[0]\n            );\n            const outAmountScaled = calcOutGivenIn(\n                orderedNormalizedBalances,\n                inAmountLessFeeScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            );\n            const outAmount = divDown(outAmountScaled, tokenRateInOut[1]);\n            return bnum(formatFixed(outAmount, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const outAmountScaled = mulDown(outAmount, tokenRateInOut[1]);\n\n            const inAmountScaledLessFee = calcInGivenOut(\n                orderedNormalizedBalances,\n                outAmountScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant\n            );\n            const inAmountLessFee = divDown(\n                inAmountScaledLessFee,\n                tokenRateInOut[0]\n            );\n            const inAmount = addFee(inAmountLessFee, poolPairData.swapFee);\n            return bnum(formatFixed(inAmount, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Missing maths for this\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Missing maths for this\n        return Zero;\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const inAmountLessFee = reduceFee(inAmount, poolPairData.swapFee);\n            const inAmountLessFeeScaled = mulDown(\n                inAmountLessFee,\n                tokenRateInOut[0]\n            );\n            const newSpotPriceScaled = calcSpotPriceAfterSwapOutGivenIn(\n                orderedNormalizedBalances,\n                inAmountLessFeeScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const newSpotPrice = divDown(\n                mulDown(newSpotPriceScaled, tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const outAmountScaled = mulDown(outAmount, tokenRateInOut[1]);\n            const newSpotPriceScaled = calcSpotPriceAfterSwapInGivenOut(\n                orderedNormalizedBalances,\n                outAmountScaled,\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const newSpotPrice = divDown(\n                mulDown(newSpotPriceScaled, tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            return bnum(formatFixed(newSpotPrice, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const inAmount = safeParseFixed(amount.toString(), 18);\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n\n            const derivativeScaled = calcDerivativePriceAfterSwapOutGivenIn(\n                [\n                    orderedNormalizedBalances[0].add(\n                        reduceFee(\n                            mulDown(inAmount, tokenRateInOut[0]),\n                            poolPairData.swapFee\n                        )\n                    ),\n                    orderedNormalizedBalances[1],\n                ],\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const derivative = mulDown(derivativeScaled, tokenRateInOut[1]);\n            return bnum(formatFixed(derivative, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: GyroEPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            const tokenRateInOut = valuesInOutFrom01(\n                this.tokenRates[0],\n                this.tokenRates[1],\n                poolPairData.tokenInIsToken0\n            );\n            const normalizedBalances = normalizeBalances(\n                [poolPairData.balanceIn, poolPairData.balanceOut],\n                [poolPairData.decimalsIn, poolPairData.decimalsOut],\n                tokenRateInOut\n            );\n            const orderedNormalizedBalances = balancesFromTokenInOut(\n                normalizedBalances[0],\n                normalizedBalances[1],\n                poolPairData.tokenInIsToken0\n            );\n            const [currentInvariant, invErr] = calculateInvariantWithError(\n                orderedNormalizedBalances,\n                this.gyroEParams,\n                this.derivedGyroEParams\n            );\n            const invariant: Vector2 = {\n                x: currentInvariant.add(invErr.mul(2)),\n                y: currentInvariant,\n            };\n            const outAmount = safeParseFixed(amount.toString(), 18);\n            const derivativeScaled = calcDerivativeSpotPriceAfterSwapInGivenOut(\n                [\n                    orderedNormalizedBalances[0],\n                    orderedNormalizedBalances[1].sub(\n                        mulDown(outAmount, tokenRateInOut[1])\n                    ),\n                ],\n                poolPairData.tokenInIsToken0,\n                this.gyroEParams,\n                this.derivedGyroEParams,\n                invariant,\n                poolPairData.swapFee\n            );\n            const rateAdjFactor = divDown(\n                mulDown(tokenRateInOut[1], tokenRateInOut[1]),\n                tokenRateInOut[0]\n            );\n            const derivative = mulDown(derivativeScaled, rateAdjFactor);\n            return bnum(formatFixed(derivative, 18));\n        } catch (err) {\n            return ZERO;\n        }\n    }\n}\n"],"names":["valuesInOutFrom01","balancesFromTokenInOut","GyroEV2Pool","static","pool","alpha","beta","c","s","lambda","tauAlphaX","tauAlphaY","tauBetaX","tauBetaY","u","v","w","z","dSq","tokenRates","gyroEParams","derivedGyroEParams","Object","values","every","el","Error","id","address","swapFee","totalShares","tokens","tokensList","constructor","this","poolType","PoolTypes","GyroE","safeParseFixed","tauAlpha","x","y","tauBeta","parsePoolPairData","tokenIn","tokenOut","tokenInIndex","findIndex","t","getAddress","tI","balanceIn","balance","decimalsIn","decimals","tokenOutIndex","tO","balanceOut","decimalsOut","tokenInIsToken0","Number","getNormalizedLiquidity","poolPairData","universalNormalizedLiquidity","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","ZERO","getLimitAmountSwap","swapType","SwapTypes","SwapExactIn","tokenRateInOut","normalizedBalances","normalizeBalances","orderedNormalizedBalances","currentInvariant","invErr","calculateInvariantWithError","invariant","add","mul","virtualOffsetFunc","virtualOffset0","virtualOffset1","maxAmountInAssetInPool","sub","limitAmountIn","divDown","limitAmountInPlusSwapFee","ONE","bnum","formatFixed","mulDown","SWAP_LIMIT_FACTOR","updateTokenBalanceForPool","token","newBalance","isSameAddress","updateTotalShares","T","find","newTotalShares","_exactTokenInForTokenOut","amount","inAmount","toString","inAmountLessFee","reduceFee","inAmountLessFeeScaled","outAmountScaled","calcOutGivenIn","outAmount","err","_tokenInForExactTokenOut","inAmountScaledLessFee","calcInGivenOut","addFee","_calcTokensOutGivenExactBptIn","bptAmountIn","Array","length","fill","Zero","_calcBptOutGivenExactTokensIn","amountsIn","_spotPriceAfterSwapExactTokenInForTokenOut","newSpotPriceScaled","calcSpotPriceAfterSwapOutGivenIn","newSpotPrice","_spotPriceAfterSwapTokenInForExactTokenOut","calcSpotPriceAfterSwapInGivenOut","derivativeScaled","calcDerivativePriceAfterSwapOutGivenIn","derivative","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","calcDerivativeSpotPriceAfterSwapInGivenOut","rateAdjFactor"],"mappings":"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"}