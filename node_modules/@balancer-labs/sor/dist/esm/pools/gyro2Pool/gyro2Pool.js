import{getAddress as t}from"@ethersproject/address";import{WeiPerEther as e,Zero as r}from"@ethersproject/constants";import{formatFixed as s}from"@ethersproject/bignumber";import{ZERO as a,bnum as n}from"../../utils/bignumber.js";import{PoolTypes as o,SwapTypes as i}from"../../types.js";import{safeParseFixed as c,isSameAddress as l}from"../../utils/index.js";import{_calculateInvariant as p,_findVirtualParams as h,_calcOutGivenIn as u,_calcInGivenOut as d,_calculateNewSpotPrice as m,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as q,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as k}from"./gyro2Math.js";import{_normalizeBalances as I,_reduceFee as b,_addFee as O}from"../gyroHelpers/helpers.js";import{divDown as w,mulDown as A}from"../gyroHelpers/gyroSignedFixedPoint.js";import{SWAP_LIMIT_FACTOR as f}from"../gyroHelpers/constants.js";import{universalNormalizedLiquidity as B}from"../liquidity.js";class F{static fromPool(t){if(!t.sqrtAlpha||!t.sqrtBeta)throw new Error("Pool missing Gyro2 sqrtAlpha and/or sqrtBeta params");return new F(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,t.sqrtAlpha,t.sqrtBeta)}constructor(t,e,r,s,a,n,i,l){this.poolType=o.Gyro2,this.id=t,this.address=e,this.swapFee=c(r,18),this.totalShares=c(s,18),this.tokens=a,this.tokensList=n,this.sqrtAlpha=c(i,18),this.sqrtBeta=c(l,18)}parsePoolPairData(r,s){const a=this.tokens.findIndex((e=>t(e.address)===t(r)));if(a<0)throw"Pool does not contain tokenIn";const n=this.tokens[a],o=n.balance,i=n.decimals,l=this.tokens.findIndex((e=>t(e.address)===t(s)));if(l<0)throw"Pool does not contain tokenOut";const p=this.tokens[l],h=p.balance,u=p.decimals,d=0===a;return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:r,tokenOut:s,decimalsIn:Number(i),decimalsOut:Number(u),balanceIn:c(o,i),balanceOut:c(h,u),swapFee:this.swapFee,sqrtAlpha:d?this.sqrtAlpha:w(e,this.sqrtBeta),sqrtBeta:d?this.sqrtBeta:w(e,this.sqrtAlpha)}}getNormalizedLiquidity(t){return B(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,a))}getLimitAmountSwap(t,r){if(r===i.SwapExactIn){const r=[t.balanceIn,t.balanceOut],a=I(r,[t.decimalsIn,t.decimalsOut]),o=p(a,t.sqrtAlpha,t.sqrtBeta),i=A(o,w(e,t.sqrtAlpha).sub(w(e,t.sqrtBeta))).sub(a[0]),c=w(i,e.sub(t.swapFee));return n(s(A(c,f),18))}return n(s(A(t.balanceOut,f),t.decimalsOut))}updateTokenBalanceForPool(t,e){if(l(this.address,t))this.updateTotalShares(e);else{const r=this.tokens.find((e=>l(e.address,t)));if(!r)throw Error("Pool does not contain this token");r.balance=s(e,r.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut],a=I(r,[t.decimalsIn,t.decimalsOut]),o=p(a,t.sqrtAlpha,t.sqrtBeta),[i,l]=h(o,t.sqrtAlpha,t.sqrtBeta),d=c(e.toString(),18),m=b(d,t.swapFee),q=u(a[0],a[1],m,i,l);return n(s(q,18))}catch(t){return n(0)}}_tokenInForExactTokenOut(t,e){try{const r=c(e.toString(),18),a=[t.balanceIn,t.balanceOut],o=I(a,[t.decimalsIn,t.decimalsOut]),i=p(o,t.sqrtAlpha,t.sqrtBeta),[l,u]=h(i,t.sqrtAlpha,t.sqrtBeta),m=d(o[0],o[1],r,l,u),q=O(m,t.swapFee);return n(s(q,18))}catch(t){return n(0)}}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(r)}_calcBptOutGivenExactTokensIn(t){return r}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut],a=I(r,[t.decimalsIn,t.decimalsOut]),o=p(a,t.sqrtAlpha,t.sqrtBeta),[i,l]=h(o,t.sqrtAlpha,t.sqrtBeta),d=c(e.toString(),18),q=b(d,t.swapFee),k=u(a[0],a[1],q,i,l),O=m(a,d,k,i,l,t.swapFee);return n(s(O,18))}catch(t){return n(0)}}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const r=c(e.toString(),18),a=[t.balanceIn,t.balanceOut],o=I(a,[t.decimalsIn,t.decimalsOut]),i=p(o,t.sqrtAlpha,t.sqrtBeta),[l,u]=h(i,t.sqrtAlpha,t.sqrtBeta),q=d(o[0],o[1],r,l,u),k=O(q,t.swapFee),b=m(o,k,r,l,u,t.swapFee);return n(s(b,18))}catch(t){return n(0)}}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut],a=I(r,[t.decimalsIn,t.decimalsOut]),o=p(a,t.sqrtAlpha,t.sqrtBeta),[i,l]=h(o,t.sqrtAlpha,t.sqrtBeta),d=c(e.toString(),18),m=b(d,t.swapFee),k=u(a[0],a[1],m,i,l),O=q(a,k,l);return n(s(O,18))}catch(t){return n(0)}}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const r=c(e.toString(),18),a=[t.balanceIn,t.balanceOut],o=I(a,[t.decimalsIn,t.decimalsOut]),i=p(o,t.sqrtAlpha,t.sqrtBeta),[l,u]=h(i,t.sqrtAlpha,t.sqrtBeta),m=d(o[0],o[1],r,l,u),q=O(m,t.swapFee),b=k(o,q,r,l,u,t.swapFee);return n(s(b,18))}catch(t){return n(0)}}}export{F as Gyro2Pool};
//# sourceMappingURL=gyro2Pool.js.map
