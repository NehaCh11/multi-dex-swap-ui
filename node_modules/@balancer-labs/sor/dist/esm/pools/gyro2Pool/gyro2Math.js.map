{"version":3,"file":"gyro2Math.js","sources":["../../../../../../src/pools/gyro2Pool/gyro2Math.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    sqrt,\n    mulUp,\n    divUp,\n    mulDown,\n    divDown,\n} from '../gyroHelpers/gyroSignedFixedPoint';\n\n/////////\n/// Virtual Parameter calculations\n/////////\n\nexport function _findVirtualParams(\n    invariant: BigNumber,\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): [BigNumber, BigNumber] {\n    return [divDown(invariant, sqrtBeta), mulDown(invariant, sqrtAlpha)];\n}\n\n/////////\n/// Invariant Calculation\n/////////\n\nexport function _calculateInvariant(\n    balances: BigNumber[], // balances\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Calculate with quadratic formula\n        // 0 = (1-sqrt(alpha/beta)*L^2 - (y/sqrt(beta)+x*sqrt(alpha))*L - x*y)\n        // 0 = a*L^2 + b*L + c\n        // here a > 0, b < 0, and c < 0, which is a special case that works well w/o negative numbers\n        // taking mb = -b and mc = -c:                            (1/2)\n        //                                  mb + (mb^2 + 4 * a * mc)^                   //\n        //                   L =    ------------------------------------------          //\n        //                                          2 * a                               //\n        //                                                                              //\n        **********************************************************************************************/\n    const [a, mb, bSquare, mc] = _calculateQuadraticTerms(\n        balances,\n        sqrtAlpha,\n        sqrtBeta\n    );\n\n    const invariant = _calculateQuadratic(a, mb, bSquare, mc);\n\n    return invariant;\n}\n\nexport function _calculateQuadraticTerms(\n    balances: BigNumber[],\n    sqrtAlpha: BigNumber,\n    sqrtBeta: BigNumber\n): [BigNumber, BigNumber, BigNumber, BigNumber] {\n    const a = ONE.sub(divDown(sqrtAlpha, sqrtBeta));\n    const bterm0 = divDown(balances[1], sqrtBeta);\n    const bterm1 = mulDown(balances[0], sqrtAlpha);\n    const mb = bterm0.add(bterm1);\n    const mc = mulDown(balances[0], balances[1]);\n\n    // For better fixed point precision, calculate in expanded form w/ re-ordering of multiplications\n    // b^2 = x^2 * alpha + x*y*2*sqrt(alpha/beta) + y^2 / beta\n    let bSquare = mulDown(\n        mulDown(mulDown(balances[0], balances[0]), sqrtAlpha),\n        sqrtAlpha\n    );\n    const bSq2 = divDown(\n        mulDown(\n            mulDown(mulDown(balances[0], balances[1]), ONE.mul(2)),\n            sqrtAlpha\n        ),\n        sqrtBeta\n    );\n\n    const bSq3 = divDown(\n        mulDown(balances[1], balances[1]),\n        mulUp(sqrtBeta, sqrtBeta)\n    );\n\n    bSquare = bSquare.add(bSq2).add(bSq3);\n\n    return [a, mb, bSquare, mc];\n}\n\nexport function _calculateQuadratic(\n    a: BigNumber,\n    mb: BigNumber,\n    bSquare: BigNumber,\n    mc: BigNumber\n): BigNumber {\n    const denominator = mulUp(a, ONE.mul(2));\n    // order multiplications for fixed point precision\n    const addTerm = mulDown(mulDown(mc, ONE.mul(4)), a);\n    // The minus sign in the radicand cancels out in this special case, so we add\n    const radicand = bSquare.add(addTerm);\n    const sqrResult = sqrt(radicand, BigNumber.from(5));\n    // The minus sign in the numerator cancels out in this special case\n    const numerator = mb.add(sqrResult);\n    const invariant = divDown(numerator, denominator);\n\n    return invariant;\n}\n\n/////////\n/// Swap functions\n/////////\n\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountIn: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Y = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // L  = inv.Liq                   /              L^2            \\                            //\n        //                   - dy = y' - |   --------------------------  |                           //\n        //  x' = virtIn                   \\          ( x' + dX)         /                            //\n        //  y' = virtOut                                                                             //\n        // Note that -dy > 0 is what the trader receives.                                            //\n        // We exploit the fact that this formula is symmetric up to virtualParam{X,Y}.               //\n        **********************************************************************************************/\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18.\n    const virtInOver = balanceIn.add(mulUp(virtualParamIn, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualParamOut, ONE.sub(1)));\n\n    const amountOut = divDown(\n        mulDown(virtOutUnder, amountIn),\n        virtInOver.add(amountIn)\n    );\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    return amountOut;\n}\n// SwapType = 'swapExactOut'\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountOut: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n      // dX = incrX  = amountIn  > 0                                                               //\n      // dY = incrY  = amountOut < 0                                                               //\n      // x = balanceIn             x' = x +  virtualParamX                                         //\n      // y = balanceOut            y' = y +  virtualParamY                                         //\n      // x = balanceIn                                                                             //\n      // L  = inv.Liq                /              L^2             \\                              //\n      //                     dx =   |   --------------------------  |  -  x'                       //\n      // x' = virtIn                \\         ( y' + dy)           /                               //\n      // y' = virtOut                                                                              //\n      // Note that dy < 0 < dx.                                                                    //\n      **********************************************************************************************/\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18.\n    const virtInOver = balanceIn.add(mulUp(virtualParamIn, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualParamOut, ONE.sub(1)));\n\n    const amountIn = divUp(\n        mulUp(virtInOver, amountOut),\n        virtOutUnder.sub(amountOut)\n    );\n\n    return amountIn;\n}\n\n// /////////\n// ///  Spot price function\n// /////////\n\nexport function _calculateNewSpotPrice(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1   /     x' + (1 - s) * dx        \\                          //\n        //                     p_y =  --- |   --------------------------  |                          //\n        // x' = virtIn                1-s  \\         y' + dy              /                          //\n        // y' = virtOut                                                                              //\n        // Note that dy < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualParamIn); // x + virtualParamX = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualParamOut); // y + virtualParamY = y'\n    const denominator = mulDown(afterFeeMultiplier, virtOut.sub(outAmount)); // (1 - s) * (y' + dy)\n    const newSpotPrice = divDown(numerator, denominator);\n\n    return newSpotPrice;\n}\n\n// /////////\n// ///  Derivatives of spotPriceAfterSwap\n// /////////\n\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    balances: BigNumber[],\n    outAmount: BigNumber,\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************                                                        \n        // dy = incrY  = amountOut < 0                                                               //\n                                                                                                     //\n        // y = balanceOut            y' = y +  virtualParamY = virtOut                               //\n        //                                                                                           //\n        //                                 /              1               \\                          //\n        //                  (p_y)' =   2  |   --------------------------  |                          //\n        //                                 \\           y' + dy            /                          //\n        //                                                                                           //\n        // Note that dy < 0                                                                          //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const virtOut = balances[1].add(virtualParamOut); // y' = y + virtualParamY\n    const denominator = virtOut.sub(outAmount); // y' + dy\n\n    const derivative = divDown(TWO, denominator);\n\n    return derivative;\n}\n\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualParamIn: BigNumber,\n    virtualParamOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dY = incrY  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualParamX                                         //\n        // y = balanceOut            y' = y +  virtualParamY                                         //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1       /     x' + (1 - s) * dx        \\                      //\n        //                     p_y =  --- (2) |   --------------------------  |                      //\n        // x' = virtIn                1-s      \\         (y' + dy)^2          /                      //\n        // y' = virtOut                                                                              //\n        // Note that dy < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualParamIn); // x + virtualParamX = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualParamOut); // y + virtualParamY = y'\n    const denominator = mulDown(virtOut.sub(outAmount), virtOut.sub(outAmount)); // (y' + dy)^2\n    const factor = divDown(TWO, afterFeeMultiplier); // 2 / (1 - s)\n\n    const derivative = mulDown(factor, divDown(numerator, denominator));\n\n    return derivative;\n}\n\n// /////////\n// ///  Normalized Liquidity measured with respect to the in-asset.\n// /////////\nexport function _getNormalizedLiquidity(\n    balances: BigNumber[],\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // x = balanceOut             x' = x +  virtualParamOut                                      //\n    // s = swapFee                                                                               //\n    //                                                                                           //\n    //                             normalizedLiquidity =  0.5 * x'                               //\n    //                                                                                           //\n    // x' = virtOut                                                                              //\n    // Note that balances = [balanceIn, balanceOut].                                             //\n    **********************************************************************************************/\n\n    const virtOut = balances[1].add(virtualParamOut);\n    return virtOut.div(2);\n}\n"],"names":["_findVirtualParams","invariant","sqrtAlpha","sqrtBeta","divDown","mulDown","_calculateInvariant","balances","a","mb","bSquare","mc","_calculateQuadraticTerms","_calculateQuadratic","ONE","sub","bterm0","bterm1","add","bSq2","mul","bSq3","mulUp","denominator","addTerm","radicand","sqrResult","sqrt","BigNumber","from","numerator","_calcOutGivenIn","balanceIn","balanceOut","amountIn","virtualParamIn","virtualParamOut","virtInOver","virtOutUnder","amountOut","gt","Error","_calcInGivenOut","divUp","_calculateNewSpotPrice","inAmount","outAmount","swapFee","afterFeeMultiplier","virtOut","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","TWO","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","factor","_getNormalizedLiquidity","div"],"mappings":"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"}