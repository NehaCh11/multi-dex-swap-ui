{"version":3,"file":"fxPool.js","sources":["../../../../../../src/pools/xaveFxPool/fxPool.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { Zero } from '@ethersproject/constants';\nimport { BigNumber as OldBigNumber, ZERO, bnum } from '../../utils/bignumber';\nimport { isSameAddress } from '../../utils';\nimport { universalNormalizedLiquidity } from '../liquidity';\nimport {\n    PoolBase,\n    PoolPairBase,\n    PoolTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n    SwapTypes,\n} from '../../types';\nimport {\n    poolBalancesToNumeraire,\n    viewRawAmount,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n    _exactTokenInForTokenOut,\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _tokenInForExactTokenOut,\n} from './fxPoolMath';\n\ntype FxPoolToken = Pick<\n    SubgraphToken,\n    'address' | 'balance' | 'decimals' | 'token'\n>;\n\nexport type FxPoolPairData = PoolPairBase & {\n    alpha: BigNumber;\n    beta: BigNumber;\n    lambda: BigNumber;\n    delta: BigNumber;\n    epsilon: BigNumber;\n    tokenInLatestFXPrice: OldBigNumber;\n    tokenOutLatestFXPrice: OldBigNumber;\n};\n\nexport class FxPool implements PoolBase<FxPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Fx;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: FxPoolToken[];\n    tokensList: string[];\n    alpha: BigNumber;\n    beta: BigNumber;\n    lambda: BigNumber;\n    delta: BigNumber;\n    epsilon: BigNumber;\n\n    static fromPool(pool: SubgraphPoolBase): FxPool {\n        if (\n            !pool.alpha ||\n            !pool.beta ||\n            !pool.lambda ||\n            !pool.delta ||\n            !pool.epsilon\n        )\n            throw new Error('FX Pool Missing Subgraph Field');\n        return new FxPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList,\n            pool.alpha,\n            pool.beta,\n            pool.lambda,\n            pool.delta,\n            pool.epsilon\n        );\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: FxPoolToken[],\n        tokensList: string[],\n        alpha: string,\n        beta: string,\n        lambda: string,\n        delta: string,\n        epsilon: string\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.alpha = parseFixed(alpha, 18);\n        this.beta = parseFixed(beta, 18);\n        this.lambda = parseFixed(lambda, 18);\n        this.delta = parseFixed(delta, 18);\n        this.epsilon = parseFixed(epsilon, 18);\n    }\n    updateTotalShares: (newTotalShares: BigNumber) => void;\n    mainIndex?: number | undefined;\n    isLBP?: boolean | undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // Will copy over other implementations, not supporting BPT tokens atm\n        return new Array(this.tokens.length).fill(Zero);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        // Will copy over other implementations, not supporting BPT tokens atm\n        return Zero;\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): FxPoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n\n        if (!tO.token?.latestFXPrice || !tI.token?.latestFXPrice)\n            throw 'FX Pool Missing LatestFxPrice';\n\n        const poolPairData: FxPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            swapFee: this.swapFee,\n            alpha: this.alpha,\n            beta: this.beta,\n            lambda: this.lambda,\n            delta: this.delta,\n            epsilon: this.epsilon,\n            tokenInLatestFXPrice: bnum(tI.token.latestFXPrice), // decimals is formatted from subgraph in rate we get from the chainlink oracle\n            tokenOutLatestFXPrice: bnum(tO.token.latestFXPrice), // decimals is formatted from subgraph in rate we get from the chainlink oracle\n        };\n\n        return poolPairData;\n    }\n\n    // Normalized liquidity is an abstract term that can be thought of the\n    // inverse of the slippage. It is proportional to the token balances in the\n    // pool but also depends on the shape of the invariant curve.\n    // As a standard, we define normalized liquidity in tokenOut\n    getNormalizedLiquidity(poolPairData: FxPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    /*\n    Fx pool logic has an alpha region where it halts swaps.\n    maxLimit  = [(1 + alpha) * oGLiq * 0.5] - token value in numeraire\n    */\n    getLimitAmountSwap(\n        poolPairData: FxPoolPairData,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        try {\n            const parsedReserves = poolBalancesToNumeraire(poolPairData);\n\n            const alphaValue = Number(formatFixed(poolPairData.alpha, 18));\n\n            const maxLimit = (1 + alphaValue) * parsedReserves._oGLiq * 0.5;\n\n            if (swapType === SwapTypes.SwapExactIn) {\n                const maxLimitAmount =\n                    maxLimit - parsedReserves.tokenInReservesInNumeraire;\n\n                return bnum(\n                    viewRawAmount(\n                        maxLimitAmount,\n                        poolPairData.tokenInLatestFXPrice.toNumber()\n                    ).toString()\n                );\n            } else {\n                const maxLimitAmount =\n                    maxLimit - parsedReserves.tokenOutReservesInNumeraire;\n\n                return bnum(\n                    viewRawAmount(\n                        maxLimitAmount,\n                        poolPairData.tokenOutLatestFXPrice.toNumber()\n                    ).toString()\n                );\n            }\n        } catch {\n            return ZERO;\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (this.address == token) {\n            this.totalShares = newBalance;\n        } else {\n            // token is underlying in the pool\n            const T = this.tokens.find((t) => isSameAddress(t.address, token));\n            if (!T) throw Error('Pool does not contain this token');\n            T.balance = formatFixed(newBalance, T.decimals);\n        }\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _exactTokenInForTokenOut(amount, poolPairData);\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _tokenInForExactTokenOut(amount, poolPairData);\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _spotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                amount\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _spotPriceAfterSwapTokenInForExactTokenOut(\n                poolPairData,\n                amount\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: FxPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        } catch {\n            return ZERO;\n        }\n    }\n}\n"],"names":["FxPool","static","pool","alpha","beta","lambda","delta","epsilon","Error","id","address","swapFee","totalShares","tokens","tokensList","constructor","this","poolType","PoolTypes","Fx","parseFixed","_calcTokensOutGivenExactBptIn","bptAmountIn","Array","length","fill","Zero","_calcBptOutGivenExactTokensIn","amountsIn","parsePoolPairData","tokenIn","tokenOut","tokenIndexIn","findIndex","t","getAddress","tI","balanceIn","balance","decimalsIn","decimals","tokenIndexOut","tO","balanceOut","decimalsOut","_a","token","latestFXPrice","_b","Number","tokenInLatestFXPrice","bnum","tokenOutLatestFXPrice","getNormalizedLiquidity","poolPairData","universalNormalizedLiquidity","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","ZERO","getLimitAmountSwap","swapType","parsedReserves","poolBalancesToNumeraire","maxLimit","formatFixed","_oGLiq","SwapTypes","SwapExactIn","maxLimitAmount","tokenInReservesInNumeraire","viewRawAmount","toNumber","toString","tokenOutReservesInNumeraire","updateTokenBalanceForPool","newBalance","T","find","isSameAddress","_exactTokenInForTokenOut","amount","_tokenInForExactTokenOut","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut"],"mappings":"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"}