{"version":3,"file":"fxPoolMath.js","sources":["../../../../../../src/pools/xaveFxPool/fxPoolMath.ts"],"sourcesContent":["import { BigNumber as OldBigNumber, bnum, scale } from '../../utils/bignumber';\nimport { FxPoolPairData } from './fxPool';\nimport { formatFixed } from '@ethersproject/bignumber';\n\n// Constants\nexport const CURVEMATH_MAX_DIFF = -0.000001000000000000024;\nexport const NEGATIVE_ONE = bnum('-1');\nexport const ONE = bnum('1');\nexport const ONE_TO_THE_SECOND_NUM = 100;\nexport const ONE_TO_THE_SECOND = BigInt(`${ONE_TO_THE_SECOND_NUM}`);\nexport const ONE_TO_THE_EIGHT_NUM = 100000000;\nexport const ONE_TO_THE_EIGHT = BigInt(`${ONE_TO_THE_EIGHT_NUM}`);\nexport const ONE_TO_THE_SIX_NUM = 1000000;\nexport const ONE_TO_THE_SIX = BigInt(`${ONE_TO_THE_SIX_NUM}`);\nexport const ONE_TO_THE_THIRTEEN_NUM = 10000000000000;\nexport const ONE_TO_THE_THIRTEEN = BigInt(`${ONE_TO_THE_THIRTEEN_NUM}`);\nexport const ONE_ETHER = scale(bnum('1'), 18);\nexport const ALMOST_ZERO = 0.0000000000000000001; // swapping within beta region has no slippage\nconst CURVEMATH_MAX = 0.25; //CURVEMATH MAX from contract\n\nexport enum CurveMathRevert {\n    LowerHalt = 'CurveMath/lower-halt',\n    UpperHalt = 'CurveMath/upper-halt',\n    SwapInvariantViolation = 'CurveMath/swap-invariant-violation',\n    SwapConvergenceFailed = 'CurveMath/swap-convergence-failed',\n    CannotSwap = 'CannotSwap',\n}\n\ninterface ParsedFxPoolData {\n    alpha: number;\n    beta: number;\n    delta: number;\n    epsilon: number;\n    lambda: number;\n    baseTokenRate: number;\n    _oGLiq: number;\n    _nGLiq: number;\n    _oBals: number[];\n    _nBals: number[];\n    givenAmountInNumeraire: number;\n}\n\ninterface ReservesInNumeraire {\n    tokenInReservesInNumeraire: number;\n    tokenOutReservesInNumeraire: number;\n    _oGLiq: number;\n}\n\nconst isUSDC = (address: string) => {\n    if (\n        address == '0x2791bca1f2de4661ed88a30c99a7a9449aa84174' ||\n        address == '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nconst calculateGivenAmountInNumeraire = (\n    isOriginSwap: boolean,\n    poolPairData: FxPoolPairData,\n    amount: number\n) => {\n    let calculatedNumeraireAmount;\n\n    if (isOriginSwap) {\n        // tokenIn is given\n        calculatedNumeraireAmount = viewNumeraireAmount(\n            amount,\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        );\n    } else {\n        // tokenOut is given\n        calculatedNumeraireAmount = viewNumeraireAmount(\n            amount,\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        );\n    }\n\n    return calculatedNumeraireAmount;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const convertToNumber = (\n    amount: number,\n    baseDecimal: number | string\n) => {\n    if (typeof baseDecimal === 'string') {\n        return Number(bnum(amount).div(bnum(ONE_ETHER)));\n    } else {\n        return amount / baseDecimal;\n    }\n};\n\nexport const poolBalancesToNumeraire = (\n    poolPairData: FxPoolPairData\n): ReservesInNumeraire => {\n    let tokenInNumeraire, tokenOutNumeraire;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        tokenInNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceIn),\n                poolPairData.tokenInLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsIn)\n        );\n        tokenOutNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceOut),\n                poolPairData.tokenOutLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsOut)\n        );\n    } else {\n        tokenInNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceOut),\n                poolPairData.tokenOutLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsOut)\n        );\n\n        tokenOutNumeraire = convertToNumber(\n            viewNumeraireAmount(\n                Number(poolPairData.balanceIn),\n                poolPairData.tokenInLatestFXPrice.toNumber()\n            ),\n            getBaseDecimals(poolPairData.decimalsIn)\n        );\n    }\n\n    return {\n        tokenInReservesInNumeraire: tokenInNumeraire,\n        tokenOutReservesInNumeraire: tokenOutNumeraire,\n        _oGLiq: tokenInNumeraire + tokenOutNumeraire,\n    };\n};\n// everything is in order of USDC, base token\nconst getParsedFxPoolData = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData,\n    isOriginSwap: boolean\n): ParsedFxPoolData => {\n    // reserves are in raw amount, they converted to numeraire\n    const baseReserves = isUSDC(poolPairData.tokenIn)\n        ? convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceOut),\n                  poolPairData.tokenOutLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsOut)\n          )\n        : convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceIn),\n                  poolPairData.tokenInLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsIn)\n          );\n\n    // reserves are not in wei\n    const usdcReserves = isUSDC(poolPairData.tokenIn)\n        ? convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceIn),\n                  poolPairData.tokenInLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsIn)\n          )\n        : convertToNumber(\n              viewNumeraireAmount(\n                  Number(poolPairData.balanceOut),\n                  poolPairData.tokenOutLatestFXPrice.toNumber()\n              ),\n              getBaseDecimals(poolPairData.decimalsOut)\n          );\n\n    // rate is converted from chainlink to the actual rate in decimals\n    const baseTokenRate = isUSDC(poolPairData.tokenIn)\n        ? poolPairData.tokenOutLatestFXPrice.toNumber()\n        : poolPairData.tokenInLatestFXPrice.toNumber();\n\n    // given amount in or out converted to numeraire\n    const givenAmountInNumeraire = calculateGivenAmountInNumeraire(\n        isOriginSwap,\n        poolPairData,\n        Number(amount.toString())\n    );\n\n    return {\n        alpha: Number(formatFixed(poolPairData.alpha, 18)),\n        beta: Number(formatFixed(poolPairData.beta, 18)),\n        delta: Number(formatFixed(poolPairData.delta, 18)),\n        epsilon: Number(formatFixed(poolPairData.epsilon, 18)),\n        lambda: Number(formatFixed(poolPairData.lambda, 18)),\n        baseTokenRate: baseTokenRate,\n        _oGLiq: baseReserves + usdcReserves,\n        _nGLiq: baseReserves + usdcReserves,\n        _oBals: [usdcReserves, baseReserves],\n        _nBals: isUSDC(poolPairData.tokenIn)\n            ? [\n                  usdcReserves + givenAmountInNumeraire,\n                  baseReserves - givenAmountInNumeraire,\n              ]\n            : [\n                  usdcReserves - givenAmountInNumeraire,\n                  baseReserves + givenAmountInNumeraire,\n              ],\n\n        givenAmountInNumeraire: givenAmountInNumeraire,\n    };\n};\n\n// get base decimals for\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const getBaseDecimals = (decimals: number) => {\n    switch (decimals) {\n        case 6: {\n            return ONE_TO_THE_SIX_NUM;\n        }\n\n        case 2: {\n            return ONE_TO_THE_SECOND_NUM;\n        }\n\n        case 18: {\n            return ONE_ETHER.toString();\n        }\n\n        default: {\n            return ONE_ETHER.toString();\n        }\n    }\n};\n\n// Base Assimilator Functions\n// calculations are from the BaseToUsdAssimilator\nexport const viewRawAmount = (_amount: number, rate: number): OldBigNumber => {\n    return bnum(_amount / rate);\n};\n\nconst viewNumeraireAmount = (_amount: number, rate: number): number => {\n    return _amount * rate;\n};\n\n// Curve Math\n// calculations are from CurveMath.sol\nconst calculateMicroFee = (\n    _bal: number,\n    _ideal: number,\n    _beta: number,\n    _delta: number\n): number => {\n    let _threshold, _feeMargin;\n    let fee_ = 0;\n\n    if (_bal < _ideal) {\n        _threshold = _ideal * (1 - _beta); // CURVEMATH ONE\n\n        if (_bal < _threshold) {\n            _feeMargin = _threshold - _bal;\n            fee_ = _feeMargin / _ideal;\n            fee_ = fee_ * _delta;\n\n            if (fee_ > CURVEMATH_MAX) {\n                fee_ = CURVEMATH_MAX;\n            }\n\n            fee_ = fee_ * _feeMargin;\n        } else {\n            fee_ = 0;\n        }\n    } else {\n        _threshold = _ideal * (1 + _beta); // CURVEMATH_ONE\n\n        if (_bal > _threshold) {\n            _feeMargin = _bal - _threshold;\n\n            fee_ = _feeMargin / _ideal;\n            fee_ = fee_ * _delta;\n\n            if (fee_ > CURVEMATH_MAX) fee_ = CURVEMATH_MAX;\n\n            fee_ = fee_ * _feeMargin;\n        } else {\n            fee_ = 0;\n        }\n    }\n\n    return fee_;\n};\n\nconst calculateFee = (\n    _gLiq: number,\n    _bals: number[],\n    _beta: number,\n    _delta: number,\n    _weights: number[]\n): number => {\n    const _length = _bals.length;\n    let psi_ = 0;\n\n    for (let i = 0; i < _length; i++) {\n        const _ideal = _gLiq * _weights[i];\n\n        // keep away from wei values like how the contract do it\n        psi_ = psi_ + calculateMicroFee(_bals[i], _ideal, _beta, _delta);\n    }\n\n    return psi_;\n};\n\n// return outputAmount and ngliq\nconst calculateTrade = (\n    _oGLiq: number,\n    _nGLiq: number,\n    _oBals: number[],\n    _nBals: number[],\n    _inputAmt: number,\n    _outputIndex: number,\n    poolPairData: ParsedFxPoolData\n): [number, number] => {\n    let outputAmt_;\n    const _weights: number[] = [0.5, 0.5]; // const for now since all weights are 0.5\n\n    const alpha = poolPairData.alpha;\n    const beta = poolPairData.beta;\n    const delta = poolPairData.delta;\n    const lambda = poolPairData.lambda;\n\n    outputAmt_ = -_inputAmt;\n\n    const _omega = calculateFee(_oGLiq, _oBals, beta, delta, _weights);\n\n    let _psi: number;\n\n    for (let i = 0; i < 32; i++) {\n        _psi = calculateFee(_nGLiq, _nBals, beta, delta, _weights);\n\n        const prevAmount = outputAmt_;\n\n        outputAmt_ =\n            _omega < _psi\n                ? -(_inputAmt + (_omega - _psi))\n                : -(_inputAmt + lambda * (_omega - _psi));\n\n        if (\n            outputAmt_ / ONE_TO_THE_THIRTEEN_NUM ==\n            prevAmount / ONE_TO_THE_THIRTEEN_NUM\n        ) {\n            _nGLiq = _oGLiq + _inputAmt + outputAmt_;\n\n            _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\n\n            // throws error already, removed if statement\n            enforceSwapInvariant(_oGLiq, _omega, _nGLiq, _psi);\n            enforceHalts(_oGLiq, _nGLiq, _oBals, _nBals, _weights, alpha);\n\n            return [outputAmt_, _nGLiq];\n        } else {\n            _nGLiq = _oGLiq + _inputAmt + outputAmt_;\n\n            _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;\n        }\n    }\n\n    throw new Error(CurveMathRevert.SwapConvergenceFailed);\n};\n\n// invariant enforcement\nconst enforceHalts = (\n    _oGLiq: number,\n    _nGLiq: number,\n    _oBals: number[],\n    _nBals: number[],\n    _weights: number[],\n    alpha: number\n): boolean => {\n    const _length = _nBals.length;\n    const _alpha = alpha;\n\n    for (let i = 0; i < _length; i++) {\n        const _nIdeal = _nGLiq * _weights[i];\n\n        if (_nBals[i] > _nIdeal) {\n            const _upperAlpha = 1 + _alpha;\n\n            const _nHalt = _nIdeal * _upperAlpha;\n\n            if (_nBals[i] > _nHalt) {\n                const _oHalt = _oGLiq * _weights[i] * _upperAlpha;\n\n                if (_oBals[i] < _oHalt) {\n                    throw new Error(CurveMathRevert.UpperHalt);\n                }\n                if (_nBals[i] - _nHalt > _oBals[i] - _oHalt) {\n                    throw new Error(CurveMathRevert.UpperHalt);\n                }\n            }\n        } else {\n            const _lowerAlpha = 1 - _alpha;\n\n            const _nHalt = _nIdeal * _lowerAlpha;\n\n            if (_nBals[i] < _nHalt) {\n                let _oHalt = _oGLiq * _weights[i];\n                _oHalt = _oHalt * _lowerAlpha;\n\n                if (_oBals[i] > _oHalt) {\n                    throw new Error(CurveMathRevert.LowerHalt);\n                }\n                if (_nHalt - _nBals[i] > _oHalt - _oBals[i]) {\n                    throw new Error(CurveMathRevert.LowerHalt);\n                }\n            }\n        }\n    }\n    return true;\n};\n\nconst enforceSwapInvariant = (\n    _oGLiq: number,\n    _omega: number,\n    _nGLiq: number,\n    _psi: number\n): boolean => {\n    const _nextUtil = _nGLiq - _psi;\n\n    const _prevUtil = _oGLiq - _omega;\n\n    const _diff = _nextUtil - _prevUtil;\n\n    // from int128 private constant MAX_DIFF = -0x10C6F7A0B5EE converted to plain decimals\n    if (0 < _diff || _diff >= CURVEMATH_MAX_DIFF) {\n        return true;\n    } else {\n        throw new Error(CurveMathRevert.SwapInvariantViolation);\n    }\n};\n\n// Exported functions\n\n// origin swap\nexport function _exactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const targetAmountInNumeraire = parsedFxPoolData.givenAmountInNumeraire;\n\n    if (poolPairData.tokenIn === poolPairData.tokenOut) {\n        return viewRawAmount(\n            targetAmountInNumeraire,\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const _amt = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 1 : 0, // if USDC return base token (index 1), else return 0 for USDC out\n        parsedFxPoolData\n    );\n\n    if (_amt === undefined) {\n        throw new Error(CurveMathRevert.CannotSwap);\n    } else {\n        const epsilon = parsedFxPoolData.epsilon;\n        const _amtWithFee = _amt[0] * (1 - epsilon); // fee retained by the pool\n\n        return viewRawAmount(\n            Math.abs(_amtWithFee),\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        );\n    }\n}\n\n// target swap\nexport function _tokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber {\n    // const amountIn = scale(amount, poolPairData.decimalsOut);\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, false);\n    const targetAmountInNumeraire = -parsedFxPoolData.givenAmountInNumeraire;\n\n    if (poolPairData.tokenIn === poolPairData.tokenOut) {\n        viewRawAmount(\n            // poolPairData.tokenOut as TokenSymbol,\n            targetAmountInNumeraire,\n            poolPairData.tokenOutLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const _amt = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire,\n        isUSDC(poolPairData.tokenIn) ? 0 : 1, // if USDC return 0 else return 1 for base token\n        parsedFxPoolData\n    );\n\n    if (_amt === undefined) {\n        throw new Error(CurveMathRevert.CannotSwap);\n    } else {\n        const epsilon = Number(formatFixed(poolPairData.epsilon, 18));\n\n        const _amtWithFee = _amt[0] * (1 + epsilon); // fee retained by the pool\n\n        return viewRawAmount(\n            Math.abs(_amtWithFee),\n            poolPairData.tokenInLatestFXPrice.toNumber()\n        ); // must be the token out\n    }\n}\n\nexport const spotPriceBeforeSwap = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    // input amount 1 XSGD to get the output in USDC\n    const inputAmountInNumeraire = 1;\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n    const _nBals = parsedFxPoolData._nBals;\n\n    const outputAmountInNumeraire = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        1, // input amount\n        0, // always output in USDC\n        parsedFxPoolData\n    );\n\n    return bnum(\n        ((Math.abs(outputAmountInNumeraire[0]) *\n            (1 - parsedFxPoolData.epsilon)) /\n            Math.abs(inputAmountInNumeraire)) *\n            parsedFxPoolData.baseTokenRate\n    );\n};\n\n// spot price after origin swap\nexport const _spotPriceAfterSwapExactTokenInForTokenOut = (\n    poolPairData: FxPoolPairData,\n    amount: OldBigNumber\n): OldBigNumber => {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, true);\n\n    const targetAmountInNumeraire = parsedFxPoolData.givenAmountInNumeraire;\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nBals = parsedFxPoolData._nBals;\n    const currentRate = parsedFxPoolData.baseTokenRate;\n    const beta = parsedFxPoolData.beta;\n    const epsilon = parsedFxPoolData.epsilon;\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n\n    const outputAfterTrade = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 1 : 0, // if USDC return base token (index 1), else return 0 for USDC out\n        parsedFxPoolData\n    );\n\n    const outputAmount = outputAfterTrade[0];\n\n    const maxBetaLimit: number = (1 + beta) * 0.5 * _oGLiq;\n\n    const minBetaLimit: number = (1 - beta) * 0.5 * _oGLiq;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        // token[0] to token [1] in originswap\n        const oBals0after = _nBals[0];\n\n        const oBals1after = _nBals[1];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            // returns 0 because  Math.abs(targetAmountInNumeraire)) * currentRate\n            // used that function with a 0 amount to get a market spot price for the pool\n            // which is used in front end display.\n\n            return amount.isZero()\n                ? spotPriceBeforeSwap(amount, poolPairData)\n                : bnum(\n                      (Math.abs(outputAmount * (1 - epsilon)) /\n                          Math.abs(targetAmountInNumeraire)) *\n                          currentRate\n                  );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    } else {\n        // if usdc is tokenOut\n        //  token[1] to token [0] in originswap\n        const oBals0after = _nBals[1];\n\n        const oBals1after = _nBals[0];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            if (amount.isZero())\n                return spotPriceBeforeSwap(amount, poolPairData);\n\n            const ratioOfOutputAndInput =\n                Math.abs(outputAmount * (1 - epsilon)) /\n                Math.abs(targetAmountInNumeraire);\n\n            return bnum(ratioOfOutputAndInput * currentRate);\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    }\n};\n\n// spot price after target swap\n// the less the normalized liquidity\n// we must have a absolute of the derivative price\nexport const _spotPriceAfterSwapTokenInForExactTokenOut = (\n    poolPairData: FxPoolPairData,\n    amount: OldBigNumber\n): OldBigNumber => {\n    const parsedFxPoolData = getParsedFxPoolData(amount, poolPairData, false);\n\n    const targetAmountInNumeraire = -parsedFxPoolData.givenAmountInNumeraire;\n\n    const _oGLiq = parsedFxPoolData._oGLiq;\n    const _nBals = parsedFxPoolData._nBals;\n    const currentRate = parsedFxPoolData.baseTokenRate;\n\n    const beta = parsedFxPoolData.beta;\n    const epsilon = parsedFxPoolData.epsilon;\n\n    const _nGLiq = parsedFxPoolData._nGLiq;\n    const _oBals = parsedFxPoolData._oBals;\n\n    const outputAfterTrade = calculateTrade(\n        _oGLiq, // _oGLiq\n        _nGLiq, // _nGLiq\n        _oBals, // _oBals\n        _nBals, // _nBals\n        targetAmountInNumeraire, // input amount\n        isUSDC(poolPairData.tokenIn) ? 0 : 1, // if USDC return 0 else return 1 for base token\n        parsedFxPoolData\n    );\n\n    const outputAmount = outputAfterTrade[0];\n\n    const maxBetaLimit: number = (1 + beta) * 0.5 * _oGLiq;\n\n    const minBetaLimit: number = (1 - beta) * 0.5 * _oGLiq;\n\n    if (isUSDC(poolPairData.tokenIn)) {\n        // token[0] to token [1] in originswap\n        const oBals0after = _nBals[0];\n        const oBals1after = _nBals[1];\n\n        if (oBals1after < minBetaLimit && oBals0after > maxBetaLimit) {\n            return bnum(\n                (Math.abs(targetAmountInNumeraire) /\n                    Math.abs(outputAmount * (1 + epsilon))) *\n                    currentRate\n            );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    } else {\n        //  token[1] to token [0] in originswap\n        const oBals0after = _nBals[0];\n        const oBals1after = _nBals[1];\n\n        const isBeyondMinBeta = oBals0after < minBetaLimit;\n        const isBeyondMaxBeta = oBals1after > maxBetaLimit;\n\n        if (isBeyondMinBeta && isBeyondMaxBeta) {\n            return bnum(\n                (Math.abs(targetAmountInNumeraire) /\n                    Math.abs(outputAmount * (1 + epsilon))) *\n                    currentRate\n            );\n        } else {\n            return bnum(currentRate * (1 - epsilon));\n        }\n    }\n};\n\n// origin swap\nexport const _derivativeSpotPriceAfterSwapExactTokenInForTokenOut = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    const x = spotPriceBeforeSwap(bnum('1'), poolPairData);\n    const y = _spotPriceAfterSwapExactTokenInForTokenOut(poolPairData, amount);\n    const yMinusX = y.minus(x);\n    const ans = yMinusX.div(x);\n    return ans.isZero() ? bnum(ALMOST_ZERO) : ans.abs();\n};\n\n// target swap\nexport const _derivativeSpotPriceAfterSwapTokenInForExactTokenOut = (\n    amount: OldBigNumber,\n    poolPairData: FxPoolPairData\n): OldBigNumber => {\n    const x = spotPriceBeforeSwap(bnum('1'), poolPairData);\n    const y = _spotPriceAfterSwapTokenInForExactTokenOut(poolPairData, amount);\n    const yMinusX = y.minus(x);\n    const ans = yMinusX.div(x);\n    return ans.abs();\n};\n"],"names":["CURVEMATH_MAX_DIFF","bnum","ONE_TO_THE_SECOND_NUM","BigInt","ONE_TO_THE_EIGHT_NUM","ONE_TO_THE_SIX_NUM","ONE_TO_THE_THIRTEEN_NUM","ONE_ETHER","scale","ALMOST_ZERO","CURVEMATH_MAX","CurveMathRevert","isUSDC","address","convertToNumber","amount","baseDecimal","Number","div","poolBalancesToNumeraire","poolPairData","tokenInNumeraire","tokenOutNumeraire","tokenIn","viewNumeraireAmount","balanceIn","tokenInLatestFXPrice","toNumber","getBaseDecimals","decimalsIn","balanceOut","tokenOutLatestFXPrice","decimalsOut","tokenInReservesInNumeraire","tokenOutReservesInNumeraire","_oGLiq","getParsedFxPoolData","isOriginSwap","baseReserves","usdcReserves","baseTokenRate","givenAmountInNumeraire","calculatedNumeraireAmount","calculateGivenAmountInNumeraire","toString","alpha","formatFixed","beta","delta","epsilon","lambda","_nGLiq","_oBals","_nBals","decimals","viewRawAmount","_amount","rate","calculateMicroFee","_bal","_ideal","_beta","_delta","_threshold","_feeMargin","fee_","calculateFee","_gLiq","_bals","_weights","_length","length","psi_","i","calculateTrade","_inputAmt","_outputIndex","outputAmt_","_omega","_psi","prevAmount","enforceSwapInvariant","enforceHalts","Error","SwapConvergenceFailed","_alpha","_nIdeal","_upperAlpha","_nHalt","_oHalt","UpperHalt","_lowerAlpha","LowerHalt","_diff","SwapInvariantViolation","_exactTokenInForTokenOut","parsedFxPoolData","targetAmountInNumeraire","tokenOut","_amt","undefined","CannotSwap","_amtWithFee","Math","abs","_tokenInForExactTokenOut","spotPriceBeforeSwap","outputAmountInNumeraire","_spotPriceAfterSwapExactTokenInForTokenOut","currentRate","outputAmount","maxBetaLimit","minBetaLimit","oBals0after","isZero","ratioOfOutputAndInput","_spotPriceAfterSwapTokenInForExactTokenOut","oBals1after","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","x","ans","minus","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut"],"mappings":"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"}