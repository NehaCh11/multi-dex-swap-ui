import{getAddress as t}from"@ethersproject/address";import{parseFixed as e,formatFixed as r}from"@ethersproject/bignumber";import{Zero as o}from"@ethersproject/constants";import{bnum as n,ZERO as s}from"../../utils/bignumber.js";import{isSameAddress as a}from"../../utils/index.js";import{universalNormalizedLiquidity as i}from"../liquidity.js";import{PoolTypes as c,SwapTypes as l}from"../../types.js";import{poolBalancesToNumeraire as d,viewRawAmount as h,_exactTokenInForTokenOut as u,_tokenInForExactTokenOut as p,_spotPriceAfterSwapExactTokenInForTokenOut as k,_spotPriceAfterSwapTokenInForExactTokenOut as m,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as f,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as b}from"./fxPoolMath.js";class F{static fromPool(t){if(!(t.alpha&&t.beta&&t.lambda&&t.delta&&t.epsilon))throw new Error("FX Pool Missing Subgraph Field");return new F(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,t.alpha,t.beta,t.lambda,t.delta,t.epsilon)}constructor(t,r,o,n,s,a,i,l,d,h,u){this.poolType=c.Fx,this.id=t,this.address=r,this.swapFee=e(o,18),this.totalShares=e(n,18),this.tokens=s,this.tokensList=a,this.alpha=e(i,18),this.beta=e(l,18),this.lambda=e(d,18),this.delta=e(h,18),this.epsilon=e(u,18)}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(o)}_calcBptOutGivenExactTokensIn(t){return o}parsePoolPairData(r,o){var s,a;const i=this.tokens.findIndex((e=>t(e.address)===t(r)));if(i<0)throw"Pool does not contain tokenIn";const c=this.tokens[i],l=c.balance,d=c.decimals,h=this.tokens.findIndex((e=>t(e.address)===t(o)));if(h<0)throw"Pool does not contain tokenOut";const u=this.tokens[h],p=u.balance,k=u.decimals;if(!(null===(s=u.token)||void 0===s?void 0:s.latestFXPrice)||!(null===(a=c.token)||void 0===a?void 0:a.latestFXPrice))throw"FX Pool Missing LatestFxPrice";return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:r,tokenOut:o,decimalsIn:Number(d),decimalsOut:Number(k),balanceIn:e(l,d),balanceOut:e(p,k),swapFee:this.swapFee,alpha:this.alpha,beta:this.beta,lambda:this.lambda,delta:this.delta,epsilon:this.epsilon,tokenInLatestFXPrice:n(c.token.latestFXPrice),tokenOutLatestFXPrice:n(u.token.latestFXPrice)}}getNormalizedLiquidity(t){return i(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,s))}getLimitAmountSwap(t,e){try{const o=d(t),s=(1+Number(r(t.alpha,18)))*o._oGLiq*.5;if(e===l.SwapExactIn){const e=s-o.tokenInReservesInNumeraire;return n(h(e,t.tokenInLatestFXPrice.toNumber()).toString())}{const e=s-o.tokenOutReservesInNumeraire;return n(h(e,t.tokenOutLatestFXPrice.toNumber()).toString())}}catch(t){return s}}updateTokenBalanceForPool(t,e){if(this.address==t)this.totalShares=e;else{const o=this.tokens.find((e=>a(e.address,t)));if(!o)throw Error("Pool does not contain this token");o.balance=r(e,o.decimals)}}_exactTokenInForTokenOut(t,e){try{return u(e,t)}catch(t){return s}}_tokenInForExactTokenOut(t,e){try{return p(e,t)}catch(t){return s}}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){try{return k(t,e)}catch(t){return s}}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){try{return m(t,e)}catch(t){return s}}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){try{return f(e,t)}catch(t){return s}}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){try{return b(e,t)}catch(t){return s}}}export{F as FxPool};
//# sourceMappingURL=fxPool.js.map
