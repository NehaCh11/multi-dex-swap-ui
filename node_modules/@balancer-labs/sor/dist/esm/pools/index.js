import{WeightedPool as o}from"./weightedPool/weightedPool.js";import{StablePool as e}from"./stablePool/stablePool.js";import{MetaStablePool as l}from"./metaStablePool/metaStablePool.js";import{LinearPool as r}from"./linearPool/linearPool.js";import{ElementPool as t}from"./elementPool/elementPool.js";import{PhantomStablePool as p}from"./phantomStablePool/phantomStablePool.js";import{ComposableStablePool as i}from"./composableStable/composableStablePool.js";import{Gyro2Pool as m}from"./gyro2Pool/gyro2Pool.js";import{Gyro3Pool as s}from"./gyro3Pool/gyro3Pool.js";import{GyroEPool as n}from"./gyroEPool/gyroEPool.js";import{GyroEV2Pool as f}from"./gyroEV2Pool/gyroEV2Pool.js";import{FxPool as a}from"./xaveFxPool/fxPool.js";import{ZERO as P,scale as y,INFINITY as T}from"../utils/bignumber.js";import{PoolFilter as b,SwapTypes as c,PoolTypes as u}from"../types.js";function g(P,y=0){if(!P.swapEnabled)return;let T;try{const c=P.poolType.toString().includes("Linear");if(!c&&!(P.poolType in b))return void console.error(`Unsupported pool type: ${P.poolType} ${P.id}`);if("Weighted"===P.poolType||"Investment"===P.poolType)T=o.fromPool(P,!1);else if("LiquidityBootstrapping"===P.poolType)T=o.fromPool(P,!0);else if("Stable"===P.poolType)T=e.fromPool(P);else if("MetaStable"===P.poolType)T=l.fromPool(P);else if("Element"===P.poolType)T=t.fromPool(P),T.setCurrentBlockTimestamp(y);else if(c)T=r.fromPool(P);else if("StablePhantom"===P.poolType)T=p.fromPool(P);else if("ComposableStable"===P.poolType)T=i.fromPool(P);else if("Gyro2"===P.poolType)T=m.fromPool(P);else if("Gyro3"===P.poolType)T=s.fromPool(P);else if("GyroE"===P.poolType)T=2===P.poolTypeVersion?f.fromPool(P):n.fromPool(P);else{if("FX"!==P.poolType)return void console.error(`Unknown pool type or type field missing: ${P.poolType} ${P.id}`);T=a.fromPool(P)}}catch(o){return void console.error(`parseNewPool: ${o.message}`)}return T}function d(o,e,l,r){return l===c.SwapExactIn?e.poolType!==u.Linear&&e.balanceIn.isZero()?P:o._exactTokenInForTokenOut(e,r):e.balanceOut.isZero()?P:y(r,e.decimalsOut).gte(e.balanceOut.toString())?T:o._tokenInForExactTokenOut(e,r)}export{d as getOutputAmountSwap,g as parseNewPool};
//# sourceMappingURL=index.js.map
