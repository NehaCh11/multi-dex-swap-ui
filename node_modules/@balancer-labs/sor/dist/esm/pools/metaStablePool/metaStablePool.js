import{parseFixed as t,formatFixed as e,BigNumber as n}from"@ethersproject/bignumber";import{WeiPerEther as o,Zero as i}from"@ethersproject/constants";import{isSameAddress as a,normaliseBalance as s,denormaliseAmount as r,normaliseAmount as c}from"../../utils/index.js";import{bnum as d,ZERO as l}from"../../utils/bignumber.js";import{PoolTypes as m,SwapTypes as u}from"../../types.js";import{getAddress as p}from"@ethersproject/address";import{_spotPriceAfterSwapExactTokenInForTokenOut as I,_spotPriceAfterSwapTokenInForExactTokenOut as h,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as k,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as g}from"../stablePool/stableMath.js";import{_calcOutGivenIn as f,_calcInGivenOut as O,_calcTokensOutGivenExactBptIn as P,_calcBptOutGivenExactTokensIn as S}from"../stablePool/stableMathBigInt.js";import{universalNormalizedLiquidity as B}from"../liquidity.js";class b{static fromPool(t){if(!t.amp)throw new Error("MetaStablePool missing amp factor");return new b(t.id,t.address,t.amp,t.swapFee,t.totalShares,t.tokens,t.tokensList)}constructor(e,n,o,i,a,s,r){this.poolType=m.MetaStable,this.MAX_IN_RATIO=t("0.3",18),this.MAX_OUT_RATIO=t("0.3",18),this.id=e,this.address=n,this.amp=t(o,b.AMP_DECIMALS),this.swapFee=t(i,18),this.totalShares=t(a,18),this.tokens=s,this.tokensList=r}parsePoolPairData(n,i){const a=this.tokens.findIndex((t=>p(t.address)===p(n)));if(a<0)throw"Pool does not contain tokenIn";const s=this.tokens[a],r=s.decimals,c=t(s.priceRate,18),l=e(t(s.balance,r).mul(c).div(o),r),m=this.tokens.findIndex((t=>p(t.address)===p(i)));if(m<0)throw"Pool does not contain tokenOut";const u=this.tokens[m],I=u.decimals,h=t(u.priceRate,18),k=e(t(u.balance,I).mul(h).div(o),I),g=this.tokens.map((({balance:t,priceRate:e})=>d(t).times(d(e)))),f=this.tokens.map((({balance:e,priceRate:n})=>t(e,18).mul(t(n,18)).div(o)));return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:n,tokenOut:i,balanceIn:t(l,r),balanceOut:t(k,I),swapFee:this.swapFee,allBalances:g,allBalancesScaled:f,amp:this.amp,tokenIndexIn:a,tokenIndexOut:m,decimalsIn:Number(r),decimalsOut:Number(I),tokenInPriceRate:c,tokenOutPriceRate:h}}getNormalizedLiquidity(t){return B(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,l))}getLimitAmountSwap(t,n){return n===u.SwapExactIn?d(e(t.balanceIn.mul(this.MAX_IN_RATIO).div(t.tokenInPriceRate),t.decimalsIn)):d(e(t.balanceOut.mul(this.MAX_OUT_RATIO).div(t.tokenOutPriceRate),t.decimalsOut))}updateTokenBalanceForPool(t,n){if(a(this.address,t))this.updateTotalShares(n);else{const o=this.tokens.find((e=>a(e.address,t)));if(!o)throw Error("Pool does not contain this token");o.balance=e(n,o.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(i,a){try{if(a.isZero())return l;const s=this.subtractSwapFeeAmount(t(a.dp(i.decimalsIn).toString(),i.decimalsIn),i.swapFee).mul(i.tokenInPriceRate).div(o),r=f(this.amp.toBigInt(),i.allBalancesScaled.map((t=>t.toBigInt())),i.tokenIndexIn,i.tokenIndexOut,s.toBigInt(),BigInt(0)),c=n.from(r).mul(o).div(i.tokenOutPriceRate);return d(e(c,18))}catch(t){return l}}_tokenInForExactTokenOut(t,e){try{if(e.isZero())return l;const o=t.decimalsIn,i=t.decimalsOut,a=t.tokenInPriceRate.toBigInt()*BigInt(10**(18-o)),s=t.tokenOutPriceRate.toBigInt()*BigInt(10**(18-i)),r=BigInt(e.times(10**i).dp(0).toString())*s/BigInt(10**18),c=O(this.amp.toBigInt(),t.allBalancesScaled.map((t=>t.toBigInt())),t.tokenIndexIn,t.tokenIndexOut,r,BigInt(0))*BigInt(10**18)/a,m=this.addSwapFeeAmount(n.from(c),t.swapFee);return d(m.toString()).div(10**t.decimalsIn)}catch(t){return console.error(`_evminGivenOut: ${t.message}`),l}}_calcTokensOutGivenExactBptIn(t){const e=this.tokens.filter((t=>!a(t.address,this.address))).map((t=>s(t)));try{const o=P(e,t.toBigInt(),this.totalShares.toBigInt());return o.map(((t,e)=>n.from(r(t,this.tokens[e]).toString())))}catch(t){return new Array(e.length).fill(l)}}_calcBptOutGivenExactTokensIn(t){try{const e=new Array(t.length).fill(BigInt(0)),o=new Array(t.length).fill(BigInt(0));this.tokens.filter((t=>!a(t.address,this.address))).forEach(((n,i)=>{e[i]=c(BigInt(t[i].toString()),n),o[i]=s(n)}));const i=S(this.amp.toBigInt(),o,e,this.totalShares.toBigInt(),this.swapFee.toBigInt());return n.from(i.toString())}catch(t){return i}}_spotPriceAfterSwapExactTokenInForTokenOut(t,n){const o=d(e(t.tokenInPriceRate,18)),i=d(e(t.tokenOutPriceRate,18)),a=n.times(e(t.tokenInPriceRate,18));return I(a,t).div(o).times(i)}_spotPriceAfterSwapTokenInForExactTokenOut(t,n){const o=d(e(t.tokenInPriceRate,18)),i=d(e(t.tokenOutPriceRate,18)),a=n.times(e(t.tokenOutPriceRate,18));return h(a,t).div(o).times(i)}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,n){const o=d(e(t.tokenOutPriceRate,18));return k(n,t).times(o)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,n){const o=d(e(t.tokenInPriceRate,18)),i=d(e(t.tokenOutPriceRate,18));return g(n,t).div(o).times(i).times(i)}subtractSwapFeeAmount(t,e){const n=t.mul(e).add(o.sub(1)).div(o);return t.sub(n)}addSwapFeeAmount(t,e){const n=o.sub(e);return t.mul(o).add(n.sub(1)).div(n)}}b.AMP_DECIMALS=3;export{b as MetaStablePool};
//# sourceMappingURL=metaStablePool.js.map
