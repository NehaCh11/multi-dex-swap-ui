{"version":3,"file":"composableStablePool.js","sources":["../../../../../../src/pools/composableStable/composableStablePool.ts"],"sourcesContent":["import { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport { BigNumber as OldBigNumber, bnum, ZERO } from '../../utils/bignumber';\nimport { SubgraphPoolBase } from '../../types';\nimport {\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcOutGivenIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _calcInGivenOut,\n    _calcTokensOutGivenExactBptIn,\n} from '../stablePool/stableMathBigInt';\nimport {\n    PhantomStablePool,\n    PhantomStablePoolPairData,\n    PhantomStablePoolToken,\n    PairTypes,\n} from '../phantomStablePool/phantomStablePool';\nexport class ComposableStablePool extends PhantomStablePool {\n    constructor(\n        id: string,\n        address: string,\n        amp: string,\n        swapFee: string,\n        totalShares: string,\n        tokens: PhantomStablePoolToken[],\n        tokensList: string[]\n    ) {\n        super(id, address, amp, swapFee, totalShares, tokens, tokensList);\n    }\n\n    static fromPool(pool: SubgraphPoolBase): ComposableStablePool {\n        if (!pool.amp)\n            throw new Error('ComposableStablePool missing amp factor');\n        return new ComposableStablePool(\n            pool.id,\n            pool.address,\n            pool.amp,\n            pool.swapFee,\n            pool.totalShares,\n            pool.tokens,\n            pool.tokensList\n        );\n    }\n\n    _exactTokenInForTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n\n            if (amount.isZero()) return ZERO;\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenInPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                const amountsInBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsInBigInt[poolPairData.tokenIndexIn] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptOutGivenExactTokensIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsInBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnEvm = _calcTokenOutGivenExactBptIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else {\n                returnEvm = _calcOutGivenIn(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            }\n\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenOutPriceRate);\n\n            // Return human scaled\n            return bnum(formatFixed(returnEvmWithRate, 18)).dp(\n                poolPairData.decimalsOut\n            );\n        } catch (err) {\n            // console.error(`PhantomStable _evmoutGivenIn: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    _tokenInForExactTokenOut(\n        poolPairData: PhantomStablePoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        try {\n            if (amount.isZero()) return ZERO;\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountConvertedEvm = parseFixed(amount.dp(18).toString(), 18)\n                .mul(poolPairData.tokenOutPriceRate)\n                .div(ONE);\n\n            let returnEvm: bigint;\n\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnEvm = _calcTokenInGivenExactBptOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                const amountsOutBigInt = Array(\n                    poolPairData.allBalancesScaled.length\n                ).fill(BigInt(0));\n                amountsOutBigInt[poolPairData.tokenIndexOut] =\n                    amountConvertedEvm.toBigInt();\n\n                returnEvm = _calcBptInGivenExactTokensOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    amountsOutBigInt,\n                    poolPairData.virtualBptSupply.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            } else {\n                returnEvm = _calcInGivenOut(\n                    this.amp.toBigInt(),\n                    poolPairData.allBalancesScaled.map((b) => b.toBigInt()),\n                    poolPairData.tokenIndexIn,\n                    poolPairData.tokenIndexOut,\n                    amountConvertedEvm.toBigInt(),\n                    poolPairData.swapFee.toBigInt()\n                );\n            }\n            // In Phantom Pools every time there is a swap (token per token, bpt per token or token per bpt), we substract the fee from the amount in\n            const returnEvmWithRate = BigNumber.from(returnEvm)\n                .mul(ONE)\n                .div(poolPairData.tokenInPriceRate);\n\n            // return human number\n            return bnum(formatFixed(returnEvmWithRate, 18)).dp(\n                poolPairData.decimalsOut\n            );\n        } catch (err) {\n            console.error(`PhantomStable _evminGivenOut: ${err.message}`);\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        // takes price rate into account\n        const tokensWithoutBpt = this.tokens.filter(\n            (t) => !isSameAddress(t.address, this.address)\n        );\n        const balancesNormalised = tokensWithoutBpt.map((t) =>\n            normaliseBalance(t)\n        );\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, tokensWithoutBpt[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale (Should not have value for BPT token)\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            // takes price rate into account\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                this.amp.toBigInt(),\n                balancesNormalised,\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            console.error(err);\n            return Zero;\n        }\n    }\n}\n"],"names":["ComposableStablePool","PhantomStablePool","constructor","id","address","amp","swapFee","totalShares","tokens","tokensList","super","static","pool","Error","_exactTokenInForTokenOut","poolPairData","amount","isZero","ZERO","amountConvertedEvm","parseFixed","dp","toString","mul","tokenInPriceRate","div","ONE","returnEvm","pairType","PairTypes","TokenToBpt","amountsInBigInt","Array","allBalancesScaled","length","fill","BigInt","tokenIndexIn","toBigInt","_calcBptOutGivenExactTokensIn","this","map","b","virtualBptSupply","BptToToken","_calcTokenOutGivenExactBptIn","tokenIndexOut","_calcOutGivenIn","returnEvmWithRate","BigNumber","from","tokenOutPriceRate","bnum","formatFixed","decimalsOut","err","_tokenInForExactTokenOut","_calcTokenInGivenExactBptOut","amountsOutBigInt","_calcBptInGivenExactTokensOut","_calcInGivenOut","console","error","message","_calcTokensOutGivenExactBptIn","bptAmountIn","tokensWithoutBpt","filter","t","isSameAddress","balancesNormalised","normaliseBalance","amountsOutNormalised","a","i","denormaliseAmount","amountsIn","amountsInNormalised","forEach","token","normaliseAmount","bptAmountOut","Zero"],"mappings":"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"}