import{parseFixed as t,BigNumber as e,formatFixed as n}from"@ethersproject/bignumber";import{WeiPerEther as o,Zero as a}from"@ethersproject/constants";import{isSameAddress as i,normaliseBalance as r,denormaliseAmount as s,normaliseAmount as l}from"../../utils/index.js";import{ZERO as p,bnum as c}from"../../utils/bignumber.js";import{_calcBptOutGivenExactTokensIn as B,_calcTokenOutGivenExactBptIn as I,_calcOutGivenIn as g,_calcTokenInGivenExactBptOut as m,_calcBptInGivenExactTokensOut as u,_calcInGivenOut as d,_calcTokensOutGivenExactBptIn as h}from"../stablePool/stableMathBigInt.js";import{PhantomStablePool as f,PairTypes as k}from"../phantomStablePool/phantomStablePool.js";class S extends f{constructor(t,e,n,o,a,i,r){super(t,e,n,o,a,i,r)}static fromPool(t){if(!t.amp)throw new Error("ComposableStablePool missing amp factor");return new S(t.id,t.address,t.amp,t.swapFee,t.totalShares,t.tokens,t.tokensList)}_exactTokenInForTokenOut(a,i){try{if(i.isZero())return p;const r=t(i.dp(18).toString(),18).mul(a.tokenInPriceRate).div(o);let s;if(a.pairType===k.TokenToBpt){const t=Array(a.allBalancesScaled.length).fill(BigInt(0));t[a.tokenIndexIn]=r.toBigInt(),s=B(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),t,a.virtualBptSupply.toBigInt(),a.swapFee.toBigInt())}else s=a.pairType===k.BptToToken?I(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexOut,r.toBigInt(),a.virtualBptSupply.toBigInt(),a.swapFee.toBigInt()):g(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,a.tokenIndexOut,r.toBigInt(),a.swapFee.toBigInt());const l=e.from(s).mul(o).div(a.tokenOutPriceRate);return c(n(l,18)).dp(a.decimalsOut)}catch(t){return p}}_tokenInForExactTokenOut(a,i){try{if(i.isZero())return p;const r=t(i.dp(18).toString(),18).mul(a.tokenOutPriceRate).div(o);let s;if(a.pairType===k.TokenToBpt)s=m(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,r.toBigInt(),a.virtualBptSupply.toBigInt(),a.swapFee.toBigInt());else if(a.pairType===k.BptToToken){const t=Array(a.allBalancesScaled.length).fill(BigInt(0));t[a.tokenIndexOut]=r.toBigInt(),s=u(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),t,a.virtualBptSupply.toBigInt(),a.swapFee.toBigInt())}else s=d(this.amp.toBigInt(),a.allBalancesScaled.map((t=>t.toBigInt())),a.tokenIndexIn,a.tokenIndexOut,r.toBigInt(),a.swapFee.toBigInt());const l=e.from(s).mul(o).div(a.tokenInPriceRate);return c(n(l,18)).dp(a.decimalsOut)}catch(t){return console.error(`PhantomStable _evminGivenOut: ${t.message}`),p}}_calcTokensOutGivenExactBptIn(t){const n=this.tokens.filter((t=>!i(t.address,this.address))),o=n.map((t=>r(t)));try{const a=h(o,t.toBigInt(),this.totalShares.toBigInt());return a.map(((t,e)=>s(t,n[e]))).map((t=>e.from(t)))}catch(t){return new Array(o.length).fill(p)}}_calcBptOutGivenExactTokensIn(t){try{const n=new Array(t.length).fill(BigInt(0)),o=new Array(t.length).fill(BigInt(0));this.tokens.filter((t=>!i(t.address,this.address))).forEach(((e,a)=>{n[a]=l(BigInt(t[a].toString()),e),o[a]=r(e)}));const a=B(this.amp.toBigInt(),o,n,this.totalShares.toBigInt(),this.swapFee.toBigInt());return e.from(a.toString())}catch(t){return console.error(t),a}}}export{S as ComposableStablePool};
//# sourceMappingURL=composableStablePool.js.map
