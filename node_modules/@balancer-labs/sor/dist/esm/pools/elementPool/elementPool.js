import{parseFixed as t,formatFixed as e}from"@ethersproject/bignumber";import{WeiPerEther as i,Zero as r}from"@ethersproject/constants";import{isSameAddress as o}from"../../utils/index.js";import{ZERO as s,bnum as n}from"../../utils/bignumber.js";import{PoolTypes as a,SwapTypes as c}from"../../types.js";import{getAddress as l}from"@ethersproject/address";import{getTimeTillExpiry as m,_exactTokenInForTokenOut as p,_tokenInForExactTokenOut as u,_spotPriceAfterSwapExactTokenInForTokenOut as h,_spotPriceAfterSwapTokenInForExactTokenOut as k,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as d,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as T}from"./elementMath.js";import{universalNormalizedLiquidity as f}from"../liquidity.js";class S{static fromPool(t){if(!t.expiryTime)throw new Error("ElementPool missing expiryTime");if(!t.unitSeconds)throw new Error("ElementPool missing unitSeconds");if(!t.principalToken)throw new Error("ElementPool missing principalToken");if(!t.baseToken)throw new Error("ElementPool missing baseToken");return new S(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,t.expiryTime,t.unitSeconds,t.principalToken,t.baseToken)}constructor(e,i,r,o,s,n,c,l,m,p){this.poolType=a.Element,this.id=e,this.address=i,this.swapFee=t(r,18),this.totalShares=t(o,18),this.tokens=s,this.tokensList=n,this.expiryTime=c,this.unitSeconds=l,this.principalToken=m,this.baseToken=p,this.currentBlockTimestamp=0}setCurrentBlockTimestamp(t){this.currentBlockTimestamp=t}parsePoolPairData(e,i){const r=this.tokens.findIndex((t=>l(t.address)===l(e)));if(r<0)throw"Pool does not contain tokenIn";const o=this.tokens[r],s=o.decimals,n=this.tokens.findIndex((t=>l(t.address)===l(i)));if(n<0)throw"Pool does not contain tokenOut";const a=this.tokens[n],c=a.decimals,m=t(o.balance,s),p=t(a.balance,c);let u=m,h=p;e==this.principalToken?u=m.add(this.totalShares):i==this.principalToken&&(h=p.add(this.totalShares));return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:e,tokenOut:i,principalToken:this.principalToken,baseToken:this.baseToken,decimalsIn:Number(s),decimalsOut:Number(c),balanceIn:u,balanceOut:h,swapFee:this.swapFee,totalShares:this.totalShares,expiryTime:this.expiryTime,unitSeconds:this.unitSeconds,currentBlockTimestamp:this.currentBlockTimestamp}}getNormalizedLiquidity(t){return f(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,s))}getLimitAmountSwap(r,o){const s=t("0.3",18);if(o===c.SwapExactIn){const t=parseFloat(e(r.balanceIn,r.decimalsIn)),i=parseFloat(e(r.balanceOut,r.decimalsOut)),o=m(this.expiryTime,this.currentBlockTimestamp,this.unitSeconds);return n((t**(1-o)+i**(1-o))**(1/(1-o))-t)}return n(e(r.balanceOut.mul(s).div(i),r.decimalsOut))}updateTokenBalanceForPool(t,i){if(o(this.address,t))this.updateTotalShares(i);else{const r=this.tokens.find((e=>o(e.address,t)));if(!r)throw Error("Pool does not contain this token");r.balance=e(i,r.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,p(e,t)}_tokenInForExactTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,u(e,t)}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(r)}_calcBptOutGivenExactTokensIn(t){return r}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,h(e,t)}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,k(e,t)}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,d(e,t)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){return t.currentBlockTimestamp=this.currentBlockTimestamp,T(e,t)}}export{S as ElementPool};
//# sourceMappingURL=elementPool.js.map
