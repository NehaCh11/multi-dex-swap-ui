import{getAddress as t}from"@ethersproject/address";import{ZERO as e,bnum as o,scale as i}from"../../utils/bignumber.js";import{isSameAddress as n,normaliseBalance as r,denormaliseAmount as s,normaliseAmount as a}from"../../utils/index.js";import{PoolTypes as p,SwapTypes as h}from"../../types.js";import{_calcBptOutGivenExactTokensIn as T,_calcTokenOutGivenExactBptIn as l,_calcOutGivenIn as c,_calcTokenInGivenExactBptOut as d,_calcBptInGivenExactTokensOut as g,_calcInGivenOut as u,_calcTokensOutGivenExactBptIn as k,_spotPriceAfterSwapExactTokenInForBPTOut as I,_spotPriceAfterSwapExactBPTInForTokenOut as m,_spotPriceAfterSwapExactTokenInForTokenOut as B,_spotPriceAfterSwapTokenInForExactBPTOut as f,_spotPriceAfterSwapBPTInForExactTokenOut as w,_spotPriceAfterSwapTokenInForExactTokenOut as O,_derivativeSpotPriceAfterSwapExactTokenInForBPTOut as S,_derivativeSpotPriceAfterSwapExactBPTInForTokenOut as y,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as b,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as A}from"./weightedMath.js";import{parseFixed as _,formatFixed as F,BigNumber as P}from"@ethersproject/bignumber";import{WeiPerEther as v,Zero as x}from"@ethersproject/constants";import{MathSol as E}from"../../utils/basicOperations.js";import{universalNormalizedLiquidity as N}from"../liquidity.js";var W;!function(t){t[t.BptToToken=0]="BptToToken",t[t.TokenToBpt=1]="TokenToBpt",t[t.TokenToToken=2]="TokenToToken"}(W||(W={}));class j{static fromPool(t,e){if(!t.totalWeight)throw new Error("WeightedPool missing totalWeight");const o=new j(t.id,t.address,t.swapFee,t.totalWeight,t.totalShares,t.tokens,t.tokensList);return e&&(o.isLBP=!0),o}constructor(t,e,o,i,n,r,s){this.poolType=p.Weighted,this.MAX_IN_RATIO=_("0.3",18),this.MAX_OUT_RATIO=_("0.3",18),this.isLBP=!1,this.id=t,this.address=e,this.swapFee=_(o,18),this.totalShares=_(n,18),this.tokens=r,this.tokensList=s,this.totalWeight=_(i,18)}parsePoolPairData(e,o){const i=this.tokens.findIndex((o=>t(o.address)===t(e)));if(i<0)throw"Pool does not contain tokenIn";const n=this.tokens[i],r=n.balance,s=n.decimals,a=_(n.weight,18).mul(v).div(this.totalWeight),p=this.tokens.findIndex((e=>t(e.address)===t(o)));if(p<0)throw"Pool does not contain tokenOut";const h=this.tokens[p],T=h.balance,l=h.decimals,c=_(h.weight,18).mul(v).div(this.totalWeight);let d;d=e==this.address?W.BptToToken:o==this.address?W.TokenToBpt:W.TokenToToken;return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:e,tokenOut:o,decimalsIn:Number(s),decimalsOut:Number(l),balanceIn:_(r,s),balanceOut:_(T,l),pairType:d,weightIn:a,weightOut:c,swapFee:this.swapFee}}getNormalizedWeights(){return this.tokens.map((t=>_(t.weight,18).mul(v).div(this.totalWeight).toBigInt()))}getNormalizedLiquidity(t){return N(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e))}getLimitAmountSwap(t,e){return e===h.SwapExactIn?o(F(t.balanceIn.mul(this.MAX_IN_RATIO).div(v),t.decimalsIn)):o(F(t.balanceOut.mul(this.MAX_OUT_RATIO).div(v),t.decimalsOut))}updateTokenBalanceForPool(t,e){n(this.address,t)&&this.updateTotalShares(e);const o=this.tokens.find((e=>n(e.address,t)));if(!o)throw Error("Pool does not contain this token");o.balance=F(e,o.decimals)}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,n){if(n.isNaN())return n;const r=_(n.dp(18,1).toString(),18).toBigInt(),s=t.decimalsIn,a=t.decimalsOut,p=_(t.balanceIn.toString(),18-s).toBigInt(),h=_(t.balanceOut.toString(),18-a).toBigInt(),d=t.weightIn.toBigInt(),g=t.weightOut.toBigInt(),u=t.swapFee.toBigInt();let k;try{return k=t.pairType===W.TokenToBpt?T([p,BigInt(1)],[d,E.ONE-d],[r,BigInt(0)],h,u):t.pairType===W.BptToToken?l(h,g,r,p,u):c(p,d,h,g,r,u),i(o(k.toString()),-18)}catch(t){return e}}_tokenInForExactTokenOut(t,n){if(n.isNaN())return n;const r=_(n.dp(18,1).toString(),18).toBigInt(),s=t.decimalsIn,a=t.decimalsOut,p=_(t.balanceIn.toString(),18-s).toBigInt(),h=_(t.balanceOut.toString(),18-a).toBigInt(),T=t.weightIn.toBigInt(),l=t.weightOut.toBigInt(),c=t.swapFee.toBigInt();let k;try{return k=t.pairType===W.TokenToBpt?d(p,T,r,h,c):t.pairType===W.BptToToken?g([h,BigInt(1)],[l,E.ONE-l],[r,BigInt(0)],p,c):u(p,T,h,l,r,c),i(o(k.toString()),-18)}catch(t){return e}}_calcTokensOutGivenExactBptIn(t){const o=this.tokens.filter((t=>!n(t.address,this.address))).map((t=>r(t)));try{const e=k(o,t.toBigInt(),this.totalShares.toBigInt());return e.map(((t,e)=>s(t,this.tokens[e]))).map((t=>P.from(t)))}catch(t){return new Array(o.length).fill(e)}}_calcBptOutGivenExactTokensIn(t){try{const e=new Array(t.length).fill(BigInt(0)),o=new Array(t.length).fill(BigInt(0));this.tokens.filter((t=>!n(t.address,this.address))).forEach(((i,n)=>{e[n]=a(BigInt(t[n].toString()),i),o[n]=r(i)}));const i=T(o,this.getNormalizedWeights(),e,this.totalShares.toBigInt(),this.swapFee.toBigInt());return P.from(i.toString())}catch(t){return x}}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){return t.pairType===W.TokenToBpt?I(e,t):t.pairType===W.BptToToken?m(e,t):B(e,t)}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){return t.pairType===W.TokenToBpt?f(e,t):t.pairType===W.BptToToken?w(e,t):O(e,t)}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){return t.pairType===W.TokenToBpt?S(e,t):t.pairType===W.BptToToken?y(e,t):b(e,t)}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){return A(e,t)}}export{j as WeightedPool};
//# sourceMappingURL=weightedPool.js.map
