{"version":3,"file":"weightedMath.js","sources":["../../../../../../src/pools/weightedPool/weightedMath.ts"],"sourcesContent":["import { formatFixed } from '@ethersproject/bignumber';\nimport { BigNumber as OldBigNumber, bnum } from '../../utils/bignumber';\nimport { WeightedPoolPairData } from './weightedPool';\nimport { MathSol, BZERO } from '../../utils/basicOperations';\n\nconst MAX_INVARIANT_RATIO = BigInt('3000000000000000000'); // 3e18\n\n// The following function are BigInt versions implemented by Sergio.\n// BigInt was requested from integrators as it is more efficient.\n// Swap outcomes formulas should match exactly those from smart contracts.\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _calcOutGivenIn(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    // is it necessary to check ranges of variables? same for the other functions\n    amountIn = subtractFee(amountIn, fee);\n    const exponent = MathSol.divDownFixed(weightIn, weightOut);\n    const denominator = MathSol.add(balanceIn, amountIn);\n    const base = MathSol.divUpFixed(balanceIn, denominator);\n    const power = MathSol.powUpFixed(base, exponent);\n    return MathSol.mulDownFixed(balanceOut, MathSol.complementFixed(power));\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _calcInGivenOut(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    const base = MathSol.divUpFixed(balanceOut, balanceOut - amountOut);\n    const exponent = MathSol.divUpFixed(weightOut, weightIn);\n    const power = MathSol.powUpFixed(base, exponent);\n    const ratio = MathSol.sub(power, MathSol.ONE);\n    const amountIn = MathSol.mulUpFixed(balanceIn, ratio);\n    return addFee(amountIn, fee);\n}\n\nfunction subtractFee(amount: bigint, fee: bigint): bigint {\n    const feeAmount = MathSol.mulUpFixed(amount, fee);\n    return amount - feeAmount;\n}\n\nfunction addFee(amount: bigint, fee: bigint): bigint {\n    return MathSol.divUpFixed(amount, MathSol.complementFixed(fee));\n}\n\n// TO DO - Swap old versions of these in Pool for the BigInt version\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOutBigInt(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountIn: bigint,\n    fee: bigint\n): bigint {\n    const numerator = MathSol.mulUpFixed(balanceIn, weightOut);\n    let denominator = MathSol.mulUpFixed(balanceOut, weightIn);\n    const feeComplement = MathSol.complementFixed(fee);\n    denominator = MathSol.mulUpFixed(denominator, feeComplement);\n    const base = MathSol.divUpFixed(\n        balanceIn,\n        MathSol.add(MathSol.mulUpFixed(amountIn, feeComplement), balanceIn)\n    );\n    const exponent = MathSol.divUpFixed(weightIn + weightOut, weightOut);\n    denominator = MathSol.mulUpFixed(\n        denominator,\n        MathSol.powUpFixed(base, exponent)\n    );\n    return MathSol.divUpFixed(numerator, denominator);\n    //        -(\n    //            (Bi * wo) /\n    //            (Bo * (-1 + f) * (Bi / (Ai + Bi - Ai * f)) ** ((wi + wo) / wo) * wi)\n    //        )\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOutBigInt(\n    balanceIn: bigint,\n    weightIn: bigint,\n    balanceOut: bigint,\n    weightOut: bigint,\n    amountOut: bigint,\n    fee: bigint\n): bigint {\n    let numerator = MathSol.mulUpFixed(balanceIn, weightOut);\n    const feeComplement = MathSol.complementFixed(fee);\n    const base = MathSol.divUpFixed(\n        balanceOut,\n        MathSol.sub(balanceOut, amountOut)\n    );\n    const exponent = MathSol.divUpFixed(weightIn + weightOut, weightIn);\n    numerator = MathSol.mulUpFixed(\n        numerator,\n        MathSol.powUpFixed(base, exponent)\n    );\n    const denominator = MathSol.mulUpFixed(\n        MathSol.mulUpFixed(balanceOut, weightIn),\n        feeComplement\n    );\n    return MathSol.divUpFixed(numerator, denominator);\n    //        -(\n    //            (Bi * (Bo / (-Ao + Bo)) ** ((wi + wo) / wi) * wo) /\n    //            (Bo * (-1 + f) * wi)\n    //        )\n}\n\n/**\n * Calculates BPT for given tokens in. Note all numbers use upscaled amounts. e.g. 1USDC = 1e18.\n * @param balances Pool balances.\n * @param normalizedWeights Token weights.\n * @param amountsIn Amount of each token.\n * @param bptTotalSupply Total BPT of pool.\n * @param swapFeePercentage Swap fee percentage.\n * @returns BPT out.\n */\nexport function _calcBptOutGivenExactTokensIn(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsIn: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    const balanceRatiosWithFee = new Array<bigint>(amountsIn.length);\n\n    let invariantRatioWithFees = BZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithFee[i] = MathSol.divDownFixed(\n            MathSol.add(balances[i], amountsIn[i]),\n            balances[i]\n        );\n        invariantRatioWithFees = MathSol.add(\n            invariantRatioWithFees,\n            MathSol.mulDownFixed(balanceRatiosWithFee[i], normalizedWeights[i])\n        );\n    }\n\n    let invariantRatio = MathSol.ONE;\n    for (let i = 0; i < balances.length; i++) {\n        let amountInWithoutFee: bigint;\n\n        if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.sub(invariantRatioWithFees, MathSol.ONE)\n            );\n            const taxableAmount = MathSol.sub(amountsIn[i], nonTaxableAmount);\n            const swapFee = MathSol.mulUpFixed(\n                taxableAmount,\n                swapFeePercentage\n            );\n            amountInWithoutFee = MathSol.add(\n                nonTaxableAmount,\n                MathSol.sub(taxableAmount, swapFee)\n            );\n        } else {\n            amountInWithoutFee = amountsIn[i];\n        }\n\n        const balanceRatio = MathSol.divDownFixed(\n            MathSol.add(balances[i], amountInWithoutFee),\n            balances[i]\n        );\n\n        invariantRatio = MathSol.mulDownFixed(\n            invariantRatio,\n            MathSol.powDown(balanceRatio, normalizedWeights[i])\n        );\n    }\n\n    if (invariantRatio > MathSol.ONE) {\n        return MathSol.mulDownFixed(\n            bptTotalSupply,\n            MathSol.sub(invariantRatio, MathSol.ONE)\n        );\n    } else {\n        return BZERO;\n    }\n}\n\nexport function _calcTokensOutGivenExactBptIn(\n    balances: bigint[],\n    bptAmountIn: bigint,\n    totalBPT: bigint\n): bigint[] {\n    /**********************************************************************************************\n    // exactBPTInForTokensOut                                                                    //\n    // (per token)                                                                               //\n    // aO = amountOut                  /        bptIn         \\                                  //\n    // b = balance           a0 = b * | ---------------------  |                                 //\n    // bptIn = bptAmountIn             \\       totalBPT       /                                  //\n    // bpt = totalBPT                                                                            //\n    **********************************************************************************************/\n\n    // Since we're computing an amount out, we round down overall. This means rounding down on both the\n    // multiplication and division.\n\n    const bptRatio = MathSol.divDownFixed(bptAmountIn, totalBPT);\n\n    const amountsOut = new Array<bigint>(balances.length);\n    for (let i = 0; i < balances.length; i++) {\n        amountsOut[i] = MathSol.mulDownFixed(balances[i], bptRatio);\n    }\n\n    return amountsOut;\n}\n\nexport function _calcTokenOutGivenExactBptIn(\n    balance: bigint,\n    normalizedWeight: bigint,\n    bptAmountIn: bigint,\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    /*****************************************************************************************\n        // exactBPTInForTokenOut                                                                //\n        // a = amountOut                                                                        //\n        // b = balance                     /      /    totalBPT - bptIn       \\    (1 / w)  \\   //\n        // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\n        // bpt = totalBPT                  \\      \\       totalBPT            /             /   //\n        // w = weight                                                                           //\n        *****************************************************************************************/\n\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\n    // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\n    const invariantRatio = MathSol.divUpFixed(\n        MathSol.sub(bptTotalSupply, bptAmountIn),\n        bptTotalSupply\n    );\n    // Calculate by how much the token balance has to decrease to match invariantRatio\n    const balanceRatio = MathSol.powUpFixed(\n        invariantRatio,\n        MathSol.divDownFixed(MathSol.ONE, normalizedWeight)\n    );\n\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\n    const amountOutWithoutFee = MathSol.mulDownFixed(\n        balance,\n        MathSol.complementFixed(balanceRatio)\n    );\n\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n    // in swap fees.\n\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n    const taxableAmount = MathSol.mulUpFixed(\n        amountOutWithoutFee,\n        MathSol.complementFixed(normalizedWeight)\n    );\n    const nonTaxableAmount = MathSol.sub(amountOutWithoutFee, taxableAmount);\n    const swapFee = MathSol.mulUpFixed(taxableAmount, swapFeePercentage);\n    const amountOut = MathSol.add(\n        nonTaxableAmount,\n        MathSol.sub(taxableAmount, swapFee)\n    );\n    return amountOut;\n}\n\nexport function _calcBptInGivenExactTokensOut(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsOut: bigint[],\n    bptTotalSupply: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    // BPT in, so we round up overall.\n    const balanceRatiosWithoutFee = new Array<bigint>(amountsOut.length);\n\n    let invariantRatioWithoutFees = BZERO;\n    for (let i = 0; i < balances.length; i++) {\n        balanceRatiosWithoutFee[i] = MathSol.divUpFixed(\n            MathSol.sub(balances[i], amountsOut[i]),\n            balances[i]\n        );\n        invariantRatioWithoutFees = MathSol.add(\n            invariantRatioWithoutFees,\n            MathSol.mulUpFixed(balanceRatiosWithoutFee[i], normalizedWeights[i])\n        );\n    }\n\n    const invariantRatio = _computeExitExactTokensOutInvariantRatio(\n        balances,\n        normalizedWeights,\n        amountsOut,\n        balanceRatiosWithoutFee,\n        invariantRatioWithoutFees,\n        swapFeePercentage\n    );\n\n    return MathSol.mulUpFixed(\n        bptTotalSupply,\n        MathSol.complementFixed(invariantRatio)\n    );\n}\n\nexport const _calcTokenInGivenExactBptOut = (\n    balance: bigint,\n    normalizedWeight: bigint,\n    bptAmountOut: bigint,\n    bptTotalSupply: bigint,\n    swapFee: bigint\n): bigint => {\n    /*****************************************************************************************\n    // tokenInForExactBptOut                                                                //\n    // a = amountIn                                                                         //\n    // b = balance                      /  /     bpt + bptOut     \\    (1 / w)      \\       //\n    // bptOut = bptAmountOut   a = b * |  | ---------------------- | ^          - 1  |      //\n    // bpt = bptTotalSupply             \\  \\         bpt          /                 /       //\n    // w = normalizedWeight                                                                 //\n    *****************************************************************************************/\n\n    // Token in, so we round up overall\n\n    // Calculate the factor by which the invariant will increase after minting `bptAmountOut`\n    const invariantRatio = MathSol.divUpFixed(\n        MathSol.add(bptTotalSupply, bptAmountOut),\n        bptTotalSupply\n    );\n    if (invariantRatio > MAX_INVARIANT_RATIO) {\n        throw new Error('MAX_OUT_BPT_FOR_TOKEN_IN');\n    }\n\n    // Calculate by how much the token balance has to increase to cause `invariantRatio`\n    const balanceRatio = MathSol.powUpFixed(\n        invariantRatio,\n        MathSol.divUpFixed(MathSol.ONE, normalizedWeight)\n    );\n    const amountInWithoutFee = MathSol.mulUpFixed(\n        balance,\n        MathSol.sub(balanceRatio, MathSol.ONE)\n    );\n    // We can now compute how much extra balance is being deposited and used in virtual swaps, and charge swap fees accordingly\n    const taxablePercentage = MathSol.complementFixed(normalizedWeight);\n    const taxableAmount = MathSol.mulUpFixed(\n        amountInWithoutFee,\n        taxablePercentage\n    );\n    const nonTaxableAmount = MathSol.sub(amountInWithoutFee, taxableAmount);\n\n    return MathSol.add(\n        nonTaxableAmount,\n        MathSol.divUpFixed(taxableAmount, MathSol.complementFixed(swapFee))\n    );\n};\n\n/**\n * @dev Intermediate function to avoid stack-too-deep errors.\n */\nfunction _computeExitExactTokensOutInvariantRatio(\n    balances: bigint[],\n    normalizedWeights: bigint[],\n    amountsOut: bigint[],\n    balanceRatiosWithoutFee: bigint[],\n    invariantRatioWithoutFees: bigint,\n    swapFeePercentage: bigint\n): bigint {\n    let invariantRatio = MathSol.ONE;\n\n    for (let i = 0; i < balances.length; i++) {\n        // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it to\n        // 'token out'. This results in slightly larger price impact.\n\n        let amountOutWithFee;\n        if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {\n            const nonTaxableAmount = MathSol.mulDownFixed(\n                balances[i],\n                MathSol.complementFixed(invariantRatioWithoutFees)\n            );\n            const taxableAmount = MathSol.sub(amountsOut[i], nonTaxableAmount);\n            const taxableAmountPlusFees = MathSol.divUpFixed(\n                taxableAmount,\n                MathSol.complementFixed(swapFeePercentage)\n            );\n\n            amountOutWithFee = MathSol.add(\n                nonTaxableAmount,\n                taxableAmountPlusFees\n            );\n        } else {\n            amountOutWithFee = amountsOut[i];\n        }\n\n        const balanceRatio = MathSol.divDownFixed(\n            MathSol.sub(balances[i], amountOutWithFee),\n            balances[i]\n        );\n\n        invariantRatio = MathSol.mulDownFixed(\n            invariantRatio,\n            MathSol.powDown(balanceRatio, normalizedWeights[i])\n        );\n    }\n    return invariantRatio;\n}\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\nexport function _calculateInvariant(\n    normalizedWeights: bigint[],\n    balances: bigint[]\n): bigint {\n    /**********************************************************************************************\n    // invariant               _____                                                             //\n    // wi = weight index i      | |      wi                                                      //\n    // bi = balance index i     | |  bi ^   = i                                                  //\n    // i = invariant                                                                             //\n    **********************************************************************************************/\n\n    let invariant = MathSol.ONE;\n    for (let i = 0; i < normalizedWeights.length; i++) {\n        invariant = MathSol.mulDownFixed(\n            invariant,\n            MathSol.powDown(balances[i], normalizedWeights[i])\n        );\n    }\n\n    if (invariant < 0) throw Error('Weighted Invariant < 0');\n\n    return invariant;\n}\n\nexport function _calcDueProtocolSwapFeeBptAmount(\n    totalSupply: bigint,\n    previousInvariant: bigint,\n    currentInvariant: bigint,\n    protocolSwapFeePercentage: bigint\n): bigint {\n    // We round down to prevent issues in the Pool's accounting, even if it means paying slightly less in protocol\n    // fees to the Vault.\n    const growth = MathSol.divDownFixed(currentInvariant, previousInvariant);\n\n    // Shortcut in case there was no growth when comparing the current against the previous invariant.\n    // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n    // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n    if (growth <= MathSol.ONE) {\n        return BZERO;\n    }\n\n    // Assuming the Pool is balanced and token weights have not changed, a growth of the invariant translates into\n    // proportional growth of all token balances. The protocol is due a percentage of that growth: more precisely,\n    // it is due `k = protocol fee * (growth - 1) * balance / growth` for each token.\n    // We compute the amount of BPT to mint for the protocol that would allow it to proportionally exit the Pool and\n    // receive these balances. Note that the total BPT supply will increase when minting, so we need to account for\n    // this in order to compute the percentage of Pool ownership the protocol will have.\n\n    // The formula is:\n    //\n    // toMint = supply * k / (1 - k)\n\n    // We compute protocol fee * (growth - 1) / growth, as we'll use that value twice.\n    // There is no need to use SafeMath since we already checked growth is strictly greater than one.\n    const k = MathSol.divDownFixed(\n        MathSol.mulDownFixed(protocolSwapFeePercentage, growth - MathSol.ONE),\n        growth\n    );\n    const numerator = MathSol.mulDownFixed(totalSupply, k);\n    const denominator = MathSol.complementFixed(k);\n\n    return denominator == BZERO\n        ? BZERO\n        : MathSol.divDownFixed(numerator, denominator);\n}\n\n// spotPriceAfterSwap\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * wo) /\n            (Bo * (-1 + f) * (Bi / (Ai + Bi - Ai * f)) ** ((wi + wo) / wo) * wi)\n        )\n    );\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * (Bo / (-Ao + Bo)) ** ((wi + wo) / wi) * wo) /\n            (Bo * (-1 + f) * wi)\n        )\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (Bi * ((Ai + Bi + Ai * f * (-1 + wi)) / Bi) ** (1 - wi)) /\n            (Bbpt * (1 + f * (-1 + wi)) * wi)\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapBptOutGivenExactTokenInBigInt(\n    balanceIn: bigint,\n    balanceOut: bigint,\n    weightIn: bigint,\n    amountIn: bigint,\n    swapFeeRatio: bigint\n): bigint {\n    const feeFactor =\n        MathSol.ONE -\n        MathSol.mulDownFixed(MathSol.complementFixed(weightIn), swapFeeRatio);\n    const denominatorFactor = MathSol.powDown(\n        MathSol.ONE + (amountIn * feeFactor) / balanceIn,\n        MathSol.complementFixed(weightIn)\n    );\n    return MathSol.divDownFixed(\n        MathSol.ONE,\n        (balanceOut * weightIn * feeFactor) / (balanceIn * denominatorFactor)\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _spotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Aibpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee));\n    return bnum(\n        ((1 - Aibpt / Bbpt) ** ((-1 + wo) / wo) *\n            Bbpt *\n            (1 + f * (-1 + wo)) *\n            wo) /\n            Bo\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (Bbpt *\n            (1 + f * (-1 + wo)) *\n            wo *\n            (1 + (Ao * (-1 + f - f * wo)) / Bo) ** (-1 + wo)) /\n            Bo\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _spotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceOut, 18));\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Aobpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        (((Aobpt + Bbpt) / Bbpt) ** (1 / wi) * Bi) /\n            ((Aobpt + Bbpt) * (1 + f * (-1 + wi)) * wi)\n    );\n}\n\n/////////\n///  Derivatives of spotPriceAfterSwap\n/////////\n\n// PairType = 'token->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum((wi + wo) / (Bo * (Bi / (Ai + Bi - Ai * f)) ** (wi / wo) * wi));\n}\n\n// PairType = 'token->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (Bi * (Bo / (-Ao + Bo)) ** (wo / wi) * wo * (wi + wo)) /\n            ((Ao - Bo) ** 2 * (-1 + f) * wi ** 2)\n        )\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceOut, 18));\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Ai = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -((-1 + wi) / (Bbpt * ((Ai + Bi + Ai * f * (-1 + wi)) / Bi) ** wi * wi))\n    );\n}\n\n// PairType = 'token->BPT'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactBPTOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bi = parseFloat(\n        formatFixed(poolPairData.balanceIn, poolPairData.decimalsIn)\n    );\n    const Bbpt = parseFloat(\n        formatFixed(poolPairData.balanceOut.toNumber(), 18)\n    );\n    const wi = parseFloat(formatFixed(poolPairData.weightIn, 18));\n    const Aobpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            (((Aobpt + Bbpt) / Bbpt) ** (1 / wi) * Bi * (-1 + wi)) /\n            ((Aobpt + Bbpt) ** 2 * (1 + f * (-1 + wi)) * wi ** 2)\n        )\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut, 18));\n    const Aibpt = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee, 18));\n    return bnum(\n        -(\n            ((1 + f * (-1 + wo)) * (-1 + wo)) /\n            ((1 - Aibpt / Bbpt) ** (1 / wo) * Bo)\n        )\n    );\n}\n\n// PairType = 'BPT->token'\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapBPTInForExactTokenOut(\n    amount: OldBigNumber,\n    poolPairData: WeightedPoolPairData\n): OldBigNumber {\n    const Bbpt = parseFloat(formatFixed(poolPairData.balanceIn, 18));\n    const Bo = parseFloat(\n        formatFixed(poolPairData.balanceOut, poolPairData.decimalsOut)\n    );\n    const wo = parseFloat(formatFixed(poolPairData.weightOut));\n    const Ao = amount.toNumber();\n    const f = parseFloat(formatFixed(poolPairData.swapFee));\n    return bnum(\n        -(\n            (Bbpt *\n                (1 + f * (-1 + wo)) ** 2 *\n                (-1 + wo) *\n                wo *\n                (1 + (Ao * (-1 + f - f * wo)) / Bo) ** (-2 + wo)) /\n            Bo ** 2\n        )\n    );\n}\n"],"names":["MAX_INVARIANT_RATIO","BigInt","_calcOutGivenIn","balanceIn","weightIn","balanceOut","weightOut","amountIn","fee","amount","feeAmount","MathSol","mulUpFixed","subtractFee","exponent","divDownFixed","denominator","add","base","divUpFixed","power","powUpFixed","mulDownFixed","complementFixed","_calcInGivenOut","amountOut","ratio","sub","ONE","addFee","_spotPriceAfterSwapExactTokenInForTokenOutBigInt","numerator","feeComplement","_spotPriceAfterSwapTokenInForExactTokenOutBigInt","_calcBptOutGivenExactTokensIn","balances","normalizedWeights","amountsIn","bptTotalSupply","swapFeePercentage","balanceRatiosWithFee","Array","length","invariantRatioWithFees","BZERO","i","invariantRatio","amountInWithoutFee","nonTaxableAmount","taxableAmount","swapFee","balanceRatio","powDown","_calcTokensOutGivenExactBptIn","bptAmountIn","totalBPT","bptRatio","amountsOut","_calcTokenOutGivenExactBptIn","balance","normalizedWeight","amountOutWithoutFee","_calcBptInGivenExactTokensOut","balanceRatiosWithoutFee","invariantRatioWithoutFees","amountOutWithFee","taxableAmountPlusFees","_computeExitExactTokensOutInvariantRatio","_calcTokenInGivenExactBptOut","bptAmountOut","Error","taxablePercentage","_calculateInvariant","invariant","_calcDueProtocolSwapFeeBptAmount","totalSupply","previousInvariant","currentInvariant","protocolSwapFeePercentage","growth","k","_spotPriceAfterSwapExactTokenInForTokenOut","poolPairData","Bi","parseFloat","formatFixed","decimalsIn","Bo","decimalsOut","wi","wo","Ai","toNumber","f","bnum","_spotPriceAfterSwapTokenInForExactTokenOut","Ao","_spotPriceAfterSwapExactTokenInForBPTOut","Bbpt","_spotPriceAfterSwapBptOutGivenExactTokenInBigInt","swapFeeRatio","feeFactor","denominatorFactor","_spotPriceAfterSwapExactBPTInForTokenOut","Aibpt","_spotPriceAfterSwapBPTInForExactTokenOut","_spotPriceAfterSwapTokenInForExactBPTOut","Aobpt","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","_derivativeSpotPriceAfterSwapExactTokenInForBPTOut","_derivativeSpotPriceAfterSwapTokenInForExactBPTOut","_derivativeSpotPriceAfterSwapExactBPTInForTokenOut","_derivativeSpotPriceAfterSwapBPTInForExactTokenOut"],"mappings":"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"}