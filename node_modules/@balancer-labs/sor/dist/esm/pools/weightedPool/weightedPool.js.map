{"version":3,"file":"weightedPool.js","sources":["../../../../../../src/pools/weightedPool/weightedPool.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address';\nimport {\n    BigNumber as OldBigNumber,\n    bnum,\n    scale,\n    ZERO,\n} from '../../utils/bignumber';\nimport {\n    isSameAddress,\n    normaliseBalance,\n    normaliseAmount,\n    denormaliseAmount,\n} from '../../utils';\nimport {\n    PoolBase,\n    PoolTypes,\n    PoolPairBase,\n    SwapTypes,\n    SubgraphPoolBase,\n    SubgraphToken,\n    NoNullableField,\n} from '../../types';\nimport {\n    _calcOutGivenIn,\n    _calcInGivenOut,\n    _spotPriceAfterSwapExactTokenInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,\n    _calcBptOutGivenExactTokensIn,\n    _calcTokenOutGivenExactBptIn,\n    _calcTokenInGivenExactBptOut,\n    _calcBptInGivenExactTokensOut,\n    _spotPriceAfterSwapExactTokenInForBPTOut,\n    _spotPriceAfterSwapExactBPTInForTokenOut,\n    _spotPriceAfterSwapTokenInForExactBPTOut,\n    _spotPriceAfterSwapBPTInForExactTokenOut,\n    _derivativeSpotPriceAfterSwapExactBPTInForTokenOut,\n    _derivativeSpotPriceAfterSwapExactTokenInForBPTOut,\n    _calcTokensOutGivenExactBptIn,\n} from './weightedMath';\nimport { BigNumber, formatFixed, parseFixed } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE, Zero } from '@ethersproject/constants';\nimport { MathSol } from '../../utils/basicOperations';\nimport { universalNormalizedLiquidity } from '../liquidity';\n\nenum PairTypes {\n    BptToToken,\n    TokenToBpt,\n    TokenToToken,\n}\n\nexport type WeightedPoolToken = Pick<\n    NoNullableField<SubgraphToken>,\n    'address' | 'balance' | 'decimals' | 'weight'\n>;\n\nexport type WeightedPoolPairData = PoolPairBase & {\n    pairType: PairTypes;\n    weightIn: BigNumber;\n    weightOut: BigNumber;\n};\n\nexport class WeightedPool implements PoolBase<WeightedPoolPairData> {\n    poolType: PoolTypes = PoolTypes.Weighted;\n    id: string;\n    address: string;\n    swapFee: BigNumber;\n    totalShares: BigNumber;\n    tokens: WeightedPoolToken[];\n    totalWeight: BigNumber;\n    tokensList: string[];\n    MAX_IN_RATIO = parseFixed('0.3', 18);\n    MAX_OUT_RATIO = parseFixed('0.3', 18);\n    isLBP = false;\n\n    static fromPool(pool: SubgraphPoolBase, isLBP?: boolean): WeightedPool {\n        if (!pool.totalWeight)\n            throw new Error('WeightedPool missing totalWeight');\n        const weightedPool = new WeightedPool(\n            pool.id,\n            pool.address,\n            pool.swapFee,\n            pool.totalWeight,\n            pool.totalShares,\n            pool.tokens as WeightedPoolToken[],\n            pool.tokensList\n        );\n        if (isLBP) weightedPool.isLBP = true;\n        return weightedPool;\n    }\n\n    constructor(\n        id: string,\n        address: string,\n        swapFee: string,\n        totalWeight: string,\n        totalShares: string,\n        tokens: WeightedPoolToken[],\n        tokensList: string[]\n    ) {\n        this.id = id;\n        this.address = address;\n        this.swapFee = parseFixed(swapFee, 18);\n        this.totalShares = parseFixed(totalShares, 18);\n        this.tokens = tokens;\n        this.tokensList = tokensList;\n        this.totalWeight = parseFixed(totalWeight, 18);\n    }\n\n    parsePoolPairData(tokenIn: string, tokenOut: string): WeightedPoolPairData {\n        const tokenIndexIn = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenIn)\n        );\n        if (tokenIndexIn < 0) throw 'Pool does not contain tokenIn';\n        const tI = this.tokens[tokenIndexIn];\n        const balanceIn = tI.balance;\n        const decimalsIn = tI.decimals;\n        const weightIn = parseFixed(tI.weight, 18)\n            .mul(ONE)\n            .div(this.totalWeight);\n\n        const tokenIndexOut = this.tokens.findIndex(\n            (t) => getAddress(t.address) === getAddress(tokenOut)\n        );\n        if (tokenIndexOut < 0) throw 'Pool does not contain tokenOut';\n        const tO = this.tokens[tokenIndexOut];\n        const balanceOut = tO.balance;\n        const decimalsOut = tO.decimals;\n        const weightOut = parseFixed(tO.weight, 18)\n            .mul(ONE)\n            .div(this.totalWeight);\n\n        let pairType: PairTypes;\n        if (tokenIn == this.address) {\n            pairType = PairTypes.BptToToken;\n        } else if (tokenOut == this.address) {\n            pairType = PairTypes.TokenToBpt;\n        } else {\n            pairType = PairTypes.TokenToToken;\n        }\n\n        const poolPairData: WeightedPoolPairData = {\n            id: this.id,\n            address: this.address,\n            poolType: this.poolType,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            decimalsIn: Number(decimalsIn),\n            decimalsOut: Number(decimalsOut),\n            balanceIn: parseFixed(balanceIn, decimalsIn),\n            balanceOut: parseFixed(balanceOut, decimalsOut),\n            pairType: pairType,\n            weightIn: weightIn,\n            weightOut: weightOut,\n            swapFee: this.swapFee,\n        };\n\n        return poolPairData;\n    }\n\n    getNormalizedWeights(): bigint[] {\n        return this.tokens.map((t) =>\n            parseFixed(t.weight, 18).mul(ONE).div(this.totalWeight).toBigInt()\n        );\n    }\n\n    getNormalizedLiquidity(poolPairData: WeightedPoolPairData): OldBigNumber {\n        return universalNormalizedLiquidity(\n            this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                poolPairData,\n                ZERO\n            )\n        );\n    }\n\n    getLimitAmountSwap(\n        poolPairData: PoolPairBase,\n        swapType: SwapTypes\n    ): OldBigNumber {\n        if (swapType === SwapTypes.SwapExactIn) {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceIn.mul(this.MAX_IN_RATIO).div(ONE),\n                    poolPairData.decimalsIn\n                )\n            );\n        } else {\n            return bnum(\n                formatFixed(\n                    poolPairData.balanceOut.mul(this.MAX_OUT_RATIO).div(ONE),\n                    poolPairData.decimalsOut\n                )\n            );\n        }\n    }\n\n    // Updates the balance of a given token for the pool\n    updateTokenBalanceForPool(token: string, newBalance: BigNumber): void {\n        // token is BPT\n        if (isSameAddress(this.address, token)) {\n            this.updateTotalShares(newBalance);\n        }\n        // token is underlying in the pool\n        const T = this.tokens.find((t) => isSameAddress(t.address, token));\n        if (!T) throw Error('Pool does not contain this token');\n        T.balance = formatFixed(newBalance, T.decimals);\n    }\n\n    updateTotalShares(newTotalShares: BigNumber): void {\n        this.totalShares = newTotalShares;\n    }\n\n    // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n    // i.e. when using token with 2decimals 0.002 should be returned as 0\n    // Uses ROUND_DOWN mode (1)\n    // calcOutGivenIn\n    _exactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (amount.isNaN()) return amount;\n        const amountIn = parseFixed(amount.dp(18, 1).toString(), 18).toBigInt();\n        const decimalsIn = poolPairData.decimalsIn;\n        const decimalsOut = poolPairData.decimalsOut;\n        const balanceIn = parseFixed(\n            poolPairData.balanceIn.toString(),\n            18 - decimalsIn\n        ).toBigInt();\n        const balanceOut = parseFixed(\n            poolPairData.balanceOut.toString(),\n            18 - decimalsOut\n        ).toBigInt();\n        const normalizedWeightIn = poolPairData.weightIn.toBigInt();\n        const normalizedWeightOut = poolPairData.weightOut.toBigInt();\n        const swapFee = poolPairData.swapFee.toBigInt();\n        let returnAmt: bigint;\n        try {\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnAmt = _calcBptOutGivenExactTokensIn(\n                    [balanceIn, BigInt(1)],\n                    [normalizedWeightIn, MathSol.ONE - normalizedWeightIn],\n                    [amountIn, BigInt(0)],\n                    balanceOut,\n                    swapFee\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnAmt = _calcTokenOutGivenExactBptIn(\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountIn,\n                    balanceIn,\n                    swapFee\n                );\n            } else {\n                returnAmt = _calcOutGivenIn(\n                    balanceIn,\n                    normalizedWeightIn,\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountIn,\n                    swapFee\n                );\n            }\n            // return human scaled\n            return scale(bnum(returnAmt.toString()), -18);\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    // Using BigNumber.js decimalPlaces (dp), allows us to consider token decimal accuracy correctly,\n    // i.e. when using token with 2decimals 0.002 should be returned as 0\n    // Uses ROUND_UP mode (0)\n    // calcInGivenOut\n    _tokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (amount.isNaN()) return amount;\n        const amountOut = parseFixed(\n            amount.dp(18, 1).toString(),\n            18\n        ).toBigInt();\n        const decimalsIn = poolPairData.decimalsIn;\n        const decimalsOut = poolPairData.decimalsOut;\n        const balanceIn = parseFixed(\n            poolPairData.balanceIn.toString(),\n            18 - decimalsIn\n        ).toBigInt();\n        const balanceOut = parseFixed(\n            poolPairData.balanceOut.toString(),\n            18 - decimalsOut\n        ).toBigInt();\n        const normalizedWeightIn = poolPairData.weightIn.toBigInt();\n        const normalizedWeightOut = poolPairData.weightOut.toBigInt();\n        const swapFee = poolPairData.swapFee.toBigInt();\n        let returnAmt: bigint;\n        try {\n            if (poolPairData.pairType === PairTypes.TokenToBpt) {\n                returnAmt = _calcTokenInGivenExactBptOut(\n                    balanceIn,\n                    normalizedWeightIn,\n                    amountOut,\n                    balanceOut,\n                    swapFee\n                );\n            } else if (poolPairData.pairType === PairTypes.BptToToken) {\n                returnAmt = _calcBptInGivenExactTokensOut(\n                    [balanceOut, BigInt(1)],\n                    [normalizedWeightOut, MathSol.ONE - normalizedWeightOut],\n                    [amountOut, BigInt(0)],\n                    balanceIn,\n                    swapFee\n                );\n            } else {\n                returnAmt = _calcInGivenOut(\n                    balanceIn,\n                    normalizedWeightIn,\n                    balanceOut,\n                    normalizedWeightOut,\n                    amountOut,\n                    swapFee\n                );\n            }\n            // return human scaled\n            return scale(bnum(returnAmt.toString()), -18);\n        } catch (err) {\n            return ZERO;\n        }\n    }\n\n    /**\n     * _calcTokensOutGivenExactBptIn\n     * @param bptAmountIn EVM scale.\n     * @returns EVM scale.\n     */\n    _calcTokensOutGivenExactBptIn(bptAmountIn: BigNumber): BigNumber[] {\n        // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n        const balancesNormalised = this.tokens\n            .filter((t) => !isSameAddress(t.address, this.address))\n            .map((t) => normaliseBalance(t));\n        try {\n            const amountsOutNormalised = _calcTokensOutGivenExactBptIn(\n                balancesNormalised,\n                bptAmountIn.toBigInt(),\n                this.totalShares.toBigInt()\n            );\n            // We want to return denormalised amounts. e.g. 1USDC => 1e6 not 1e18\n            const amountsOut = amountsOutNormalised.map((a, i) =>\n                denormaliseAmount(a, this.tokens[i])\n            );\n            return amountsOut.map((a) => BigNumber.from(a));\n        } catch (err) {\n            return new Array(balancesNormalised.length).fill(ZERO);\n        }\n    }\n\n    /**\n     * _calcBptOutGivenExactTokensIn\n     * @param amountsIn EVM Scale\n     * @returns EVM Scale\n     */\n    _calcBptOutGivenExactTokensIn(amountsIn: BigNumber[]): BigNumber {\n        try {\n            // balances and amounts must be normalized to 1e18 fixed point - e.g. 1USDC => 1e18 not 1e6\n            const amountsInNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            const balancesNormalised = new Array(amountsIn.length).fill(\n                BigInt(0)\n            );\n            this.tokens\n                .filter((t) => !isSameAddress(t.address, this.address))\n                .forEach((token, i) => {\n                    amountsInNormalised[i] = normaliseAmount(\n                        BigInt(amountsIn[i].toString()),\n                        token\n                    );\n                    balancesNormalised[i] = normaliseBalance(token);\n                });\n            const bptAmountOut = _calcBptOutGivenExactTokensIn(\n                balancesNormalised,\n                this.getNormalizedWeights(),\n                amountsInNormalised,\n                this.totalShares.toBigInt(),\n                this.swapFee.toBigInt()\n            );\n            return BigNumber.from(bptAmountOut.toString());\n        } catch (err) {\n            return Zero;\n        }\n    }\n\n    _spotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _spotPriceAfterSwapExactTokenInForBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _spotPriceAfterSwapExactBPTInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _spotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _spotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _spotPriceAfterSwapTokenInForExactBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _spotPriceAfterSwapBPTInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _spotPriceAfterSwapTokenInForExactTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        if (poolPairData.pairType === PairTypes.TokenToBpt) {\n            return _derivativeSpotPriceAfterSwapExactTokenInForBPTOut(\n                amount,\n                poolPairData\n            );\n        } else if (poolPairData.pairType === PairTypes.BptToToken) {\n            return _derivativeSpotPriceAfterSwapExactBPTInForTokenOut(\n                amount,\n                poolPairData\n            );\n        } else {\n            return _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n                amount,\n                poolPairData\n            );\n        }\n    }\n\n    _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n        poolPairData: WeightedPoolPairData,\n        amount: OldBigNumber\n    ): OldBigNumber {\n        return _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n            amount,\n            poolPairData\n        );\n    }\n}\n"],"names":["PairTypes","WeightedPool","static","pool","isLBP","totalWeight","Error","weightedPool","id","address","swapFee","totalShares","tokens","tokensList","constructor","this","poolType","PoolTypes","Weighted","MAX_IN_RATIO","parseFixed","MAX_OUT_RATIO","parsePoolPairData","tokenIn","tokenOut","tokenIndexIn","findIndex","t","getAddress","tI","balanceIn","balance","decimalsIn","decimals","weightIn","weight","mul","ONE","div","tokenIndexOut","tO","balanceOut","decimalsOut","weightOut","pairType","BptToToken","TokenToBpt","TokenToToken","Number","getNormalizedWeights","map","toBigInt","getNormalizedLiquidity","poolPairData","universalNormalizedLiquidity","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","ZERO","getLimitAmountSwap","swapType","SwapTypes","SwapExactIn","bnum","formatFixed","updateTokenBalanceForPool","token","newBalance","isSameAddress","updateTotalShares","T","find","newTotalShares","_exactTokenInForTokenOut","amount","isNaN","amountIn","dp","toString","normalizedWeightIn","normalizedWeightOut","returnAmt","_calcBptOutGivenExactTokensIn","BigInt","MathSol","_calcTokenOutGivenExactBptIn","_calcOutGivenIn","scale","err","_tokenInForExactTokenOut","amountOut","_calcTokenInGivenExactBptOut","_calcBptInGivenExactTokensOut","_calcInGivenOut","_calcTokensOutGivenExactBptIn","bptAmountIn","balancesNormalised","filter","normaliseBalance","amountsOutNormalised","a","i","denormaliseAmount","BigNumber","from","Array","length","fill","amountsIn","amountsInNormalised","forEach","normaliseAmount","bptAmountOut","Zero","_spotPriceAfterSwapExactTokenInForTokenOut","_spotPriceAfterSwapExactTokenInForBPTOut","_spotPriceAfterSwapExactBPTInForTokenOut","_spotPriceAfterSwapTokenInForExactTokenOut","_spotPriceAfterSwapTokenInForExactBPTOut","_spotPriceAfterSwapBPTInForExactTokenOut","_derivativeSpotPriceAfterSwapExactTokenInForBPTOut","_derivativeSpotPriceAfterSwapExactBPTInForTokenOut","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut"],"mappings":"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"}