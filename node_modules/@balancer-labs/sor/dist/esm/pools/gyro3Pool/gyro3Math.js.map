{"version":3,"file":"gyro3Math.js","sources":["../../../../../../src/pools/gyro3Pool/gyro3Math.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { WeiPerEther as ONE } from '@ethersproject/constants';\nimport {\n    _INVARIANT_MIN_ITERATIONS,\n    _INVARIANT_SHRINKING_FACTOR_PER_STEP,\n} from './constants';\nimport { _safeLargePow3ADown } from './helpers';\nimport {\n    mulUp,\n    divUp,\n    mulDown,\n    divDown,\n    sqrt,\n} from '../gyroHelpers/gyroSignedFixedPoint';\n\n/////////\n/// Invariant Calculation\n/////////\n\n// Invariant is used to collect protocol swap fees by comparing its value between two times.\n// So we can round always to the same direction. It is also used to initiate the BPT amount\n// and, because there is a minimum BPT, we round down the invariant.\n// Argument root3Alpha = cube root of the lower price bound (symmetric across assets)\n// Note: all price bounds for the pool are alpha and 1/alpha\n\nexport function _calculateInvariant(\n    balances: BigNumber[],\n    root3Alpha: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n// Calculate root of cubic:\n// (1-alpha)L^3 - (x+y+z) * alpha^(2/3) * L^2 - (x*y + y*z + x*z) * alpha^(1/3) * L - x*y*z = 0\n// These coefficients are a,b,c,d respectively\n// here, a > 0, b < 0, c < 0, and d < 0\n// taking mb = -b and mc = -c\n/**********************************************************************************************/\n    const [a, mb, mc, md] = _calculateCubicTerms(balances, root3Alpha);\n    return _calculateCubic(a, mb, mc, md, root3Alpha);\n}\n\n/** @dev Prepares quadratic terms for input to _calculateCubic\n *  assumes a > 0, b < 0, c <= 0, and d <= 0 and returns a, -b, -c, -d\n *  terms come from cubic in Section 3.1.1\n *  argument root3Alpha = cube root of alpha\n */\nexport function _calculateCubicTerms(\n    balances: BigNumber[],\n    root3Alpha: BigNumber\n): [BigNumber, BigNumber, BigNumber, BigNumber] {\n    const alpha23: BigNumber = mulDown(root3Alpha, root3Alpha); // alpha to the power of (2/3)\n    const alpha = mulDown(alpha23, root3Alpha);\n    const a = ONE.sub(alpha);\n    const bterm = balances[0].add(balances[1]).add(balances[2]);\n    const mb = mulDown(mulDown(bterm, root3Alpha), root3Alpha);\n    const cterm = mulDown(balances[0], balances[1])\n        .add(mulDown(balances[1], balances[2]))\n        .add(mulDown(balances[2], balances[0]));\n    const mc = mulDown(cterm, root3Alpha);\n    const md = mulDown(mulDown(balances[0], balances[1]), balances[2]);\n\n    return [a, mb, mc, md];\n}\n\n/** @dev Calculate the maximal root of the polynomial a L^3 - mb L^2 - mc L - md.\n *   This root is always non-negative, and it is the unique positive root unless mb == mc == md == 0. */\nexport function _calculateCubic(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber\n): BigNumber {\n    let rootEst = _calculateCubicStartingPoint(a, mb, mc);\n    rootEst = _runNewtonIteration(a, mb, mc, md, root3Alpha, rootEst);\n    return rootEst;\n}\n\n/** @dev Starting point for Newton iteration. Safe with all cubic polynomials where the coefficients have the appropriate\n *   signs, but calibrated to the particular polynomial for computing the invariant. */\nexport function _calculateCubicStartingPoint(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber\n): BigNumber {\n    const radic = mulUp(mb, mb).add(mulUp(mulUp(a, mc), ONE.mul(3)));\n    const lmin = divUp(mb, a.mul(3)).add(\n        divUp(sqrt(radic, BigNumber.from(5)), a.mul(3))\n    );\n    // This formula has been found experimentally. It is exact for alpha -> 1, where the factor is 1.5. All\n    // factors > 1 are safe. For small alpha values, it is more efficient to fallback to a larger factor.\n    const alpha = ONE.sub(a); // We know that a is in [0, 1].\n    const factor = alpha.gte(ONE.div(2)) ? ONE.mul(3).div(2) : ONE.mul(2);\n    const l0 = mulUp(lmin, factor);\n    return l0;\n}\n\n/** @dev Find a root of the given polynomial with the given starting point l.\n *   Safe iff l > the local minimum.\n *   Note that f(l) may be negative for the first iteration and will then be positive (up to rounding errors).\n *   f'(l) is always positive for the range of values we consider.\n *   See write-up, Appendix A. */\nexport function _runNewtonIteration(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber,\n    rootEst: BigNumber\n): BigNumber {\n    let deltaAbsPrev = BigNumber.from(0);\n    for (let iteration = 0; iteration < 255; ++iteration) {\n        // The delta to the next step can be positive or negative, so we represent a positive and a negative part\n        // separately. The signed delta is delta_plus - delta_minus, but we only ever consider its absolute value.\n        const [deltaAbs, deltaIsPos] = _calcNewtonDelta(\n            a,\n            mb,\n            mc,\n            md,\n            root3Alpha,\n            rootEst\n        );\n\n        // ^ Note: If we ever set _INVARIANT_MIN_ITERATIONS=0, the following should include `iteration >= 1`.\n        if (\n            deltaAbs.lte(1) ||\n            (iteration >= _INVARIANT_MIN_ITERATIONS && deltaIsPos)\n        )\n            // This should mathematically never happen. Thus, the numerical error dominates at this point.\n            return rootEst;\n        if (\n            iteration >= _INVARIANT_MIN_ITERATIONS &&\n            deltaAbs.gte(\n                deltaAbsPrev.div(\n                    BigNumber.from(_INVARIANT_SHRINKING_FACTOR_PER_STEP)\n                )\n            )\n        ) {\n            // The iteration has stalled and isn't making significant progress anymore.\n            return rootEst;\n        }\n        deltaAbsPrev = deltaAbs;\n        if (deltaIsPos) rootEst = rootEst.add(deltaAbs);\n        else rootEst = rootEst.sub(deltaAbs);\n    }\n\n    throw new Error(\n        'Gyro3Pool: Newton Method did not converge on required invariant'\n    );\n}\n\n// -f(l)/f'(l), represented as an absolute value and a sign. Require that l is sufficiently large so that f is strictly increasing.\nexport function _calcNewtonDelta(\n    a: BigNumber,\n    mb: BigNumber,\n    mc: BigNumber,\n    md: BigNumber,\n    root3Alpha: BigNumber,\n    rootEst: BigNumber\n): [BigNumber, boolean] {\n    // The following is equal to dfRootEst^3 * a but with an order of operations optimized for precision.\n    // Subtraction does not underflow since rootEst is chosen so that it's always above the (only) local minimum.\n    let dfRootEst = BigNumber.from(0);\n\n    const rootEst2 = mulDown(rootEst, rootEst);\n    dfRootEst = rootEst2.mul(3);\n    dfRootEst = dfRootEst.sub(\n        mulDown(mulDown(mulDown(dfRootEst, root3Alpha), root3Alpha), root3Alpha)\n    );\n    dfRootEst = dfRootEst.sub(mulDown(rootEst, mb).mul(2)).sub(mc);\n\n    const deltaMinus = _safeLargePow3ADown(rootEst, root3Alpha, dfRootEst);\n\n    // NB: We could order the operations here in much the same way we did above to reduce errors. But tests show\n    // that this has no significant effect, and it would lead to more complex code.\n    let deltaPlus = mulDown(mulDown(rootEst, rootEst), mb);\n    deltaPlus = divDown(deltaPlus.add(mulDown(rootEst, mc)), dfRootEst);\n    deltaPlus = deltaPlus.add(divDown(md, dfRootEst));\n\n    const deltaIsPos = deltaPlus.gte(deltaMinus);\n    const deltaAbs = deltaIsPos\n        ? deltaPlus.sub(deltaMinus)\n        : deltaMinus.sub(deltaPlus);\n\n    return [deltaAbs, deltaIsPos];\n}\n\n/////////\n/// Swap Amount Calculations\n/////////\n\n/** @dev Computes how many tokens can be taken out of a pool if `amountIn` are sent, given the\n * current balances and weights.\n * Changed signs compared to original algorithm to account for amountOut < 0.\n * See Proposition 12 in 3.1.4.*/\nexport function _calcOutGivenIn(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountIn: BigNumber,\n    virtualOffset: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Z = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualOffset                                         //\n        // z = balanceOut            z' = z +  virtualOffset                                         //\n        // L  = inv.Liq                   /            x' * z'          \\                            //\n        //                   - dZ = z' - |   --------------------------  |                           //\n        //  x' = virtIn                   \\          ( x' + dX)         /                            //\n        //  z' = virtOut                                                                             //\n        // Note that -dz > 0 is what the trader receives.                                            //\n        // We exploit the fact that this formula is symmetric up to virtualParam{X,Y,Z}.             //\n        **********************************************************************************************/\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18, compensating for the maximum multiplicative error in the invariant\n    // computation.\n\n    const virtInOver = balanceIn.add(mulUp(virtualOffset, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualOffset, ONE.sub(1)));\n    const amountOut = virtOutUnder.mul(amountIn).div(virtInOver.add(amountIn));\n\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    return amountOut;\n}\n\n/** @dev Computes how many tokens must be sent to a pool in order to take `amountOut`, given the\n * currhent balances and weights.\n * Similar to the one before but adapting bc negative values (amountOut would be negative).*/\nexport function _calcInGivenOut(\n    balanceIn: BigNumber,\n    balanceOut: BigNumber,\n    amountOut: BigNumber,\n    virtualOffset: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // Described for X = `in' asset and Z = `out' asset, but equivalent for the other case       //\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ = amountOut < 0                                                                //\n        // x = balanceIn             x' = x +  virtualOffset                                         //\n        // z = balanceOut            z' = z +  virtualOffset                                         //\n        // L  = inv.Liq            /            x' * z'          \\             x' * dZ               //\n        //                   dX = |   --------------------------  | - x' = ---------------           //\n        //  x' = virtIn            \\          ( z' + dZ)         /             z' - dZ               //\n        //  z' = virtOut                                                                             //\n        // Note that dz < 0 < dx.                                                                    //\n        // We exploit the fact that this formula is symmetric and does not depend on which asset is  //\n        // which.\n        // We assume that the virtualOffset carries a relative +/- 3e-18 error due to the invariant  //\n        // calculation add an appropriate safety margin.                                             //\n        **********************************************************************************************/\n\n    // Note that this in particular reverts if amountOut > balanceOut, i.e., if the trader tries to take more out of\n    // the pool than is in it.\n    if (amountOut.gt(balanceOut)) throw new Error('ASSET_BOUNDS_EXCEEDED');\n\n    // The factors in total lead to a multiplicative \"safety margin\" between the employed virtual offsets\n    // very slightly larger than 3e-18, compensating for the maximum multiplicative error in the invariant\n    // computation.\n    const virtInOver = balanceIn.add(mulUp(virtualOffset, ONE.add(2)));\n    const virtOutUnder = balanceOut.add(mulDown(virtualOffset, ONE.sub(1)));\n\n    const amountIn = divUp(\n        mulUp(virtInOver, amountOut),\n        virtOutUnder.sub(amountOut)\n    );\n\n    return amountIn;\n}\n\n// /////////\n// ///  Spot price function\n// /////////\n\nexport function _calculateNewSpotPrice(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualOffsetInOut                                     //\n        // z = balanceOut            z' = z +  virtualOffsetInOut                                     //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1   /     x' + (1 - s) * dx        \\                          //\n        //                     p_z =  --- |   --------------------------  |                          //\n        // x' = virtIn                1-s  \\         z' + dz              /                          //\n        // z' = virtOut                                                                              //\n        // Note that dz < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualOffsetInOut); // x + virtualOffsetInOut = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n\n    const virtOut = balances[1].add(virtualOffsetInOut); // z + virtualOffsetInOut = y'\n    const denominator = mulDown(afterFeeMultiplier, virtOut.sub(outAmount)); // (1 - s) * (z' + dz)\n\n    const newSpotPrice = divDown(numerator, denominator);\n\n    return newSpotPrice;\n}\n\n// /////////\n// ///  Derivatives of spotPriceAfterSwap\n// /////////\n\n// SwapType = 'swapExactIn'\nexport function _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(\n    balances: BigNumber[],\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************                                                        \n        // dz = incrZ  = amountOut < 0                                                               //\n                                                                                                     //\n        // z = balanceOut            z' = z +  virtualOffsetInOut = virtOut                          //\n        //                                                                                           //\n        //                                 /              1               \\                          //\n        //                  (p_z)' =   2  |   --------------------------  |                          //\n        //                                 \\           z' + dz            /                          //\n        //                                                                                           //\n        // Note that dz < 0                                                                          //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const virtOut = balances[1].add(virtualOffsetInOut); // z' = z + virtualOffsetInOut\n    const denominator = virtOut.sub(outAmount); // z' + dz\n\n    const derivative = divDown(TWO, denominator);\n\n    return derivative;\n}\n\n// SwapType = 'swapExactOut'\nexport function _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(\n    balances: BigNumber[],\n    inAmount: BigNumber,\n    outAmount: BigNumber,\n    virtualOffsetInOut: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n        // dX = incrX  = amountIn  > 0                                                               //\n        // dZ = incrZ  = amountOut < 0                                                               //\n        // x = balanceIn             x' = x +  virtualOffsetInOut                                    //\n        // z = balanceOut            z' = z +  virtualOffsetInOut                                    //\n        // s = swapFee                                                                               //\n        // L  = inv.Liq                1       /     x' + (1 - s) * dx        \\                      //\n        //                     p_z =  --- (2) |   --------------------------  |                      //\n        // x' = virtIn                1-s      \\         (z' + dz)^2          /                      //\n        // z' = virtOut                                                                              //\n        // Note that dz < 0 < dx.                                                                    //\n        **********************************************************************************************/\n\n    const TWO = BigNumber.from(2).mul(ONE);\n    const afterFeeMultiplier = ONE.sub(swapFee); // 1 - s\n    const virtIn = balances[0].add(virtualOffsetInOut); // x + virtualOffsetInOut = x'\n    const numerator = virtIn.add(mulDown(afterFeeMultiplier, inAmount)); // x' + (1 - s) * dx\n    const virtOut = balances[1].add(virtualOffsetInOut); // z + virtualOffsetInOut = z'\n    const denominator = mulDown(virtOut.sub(outAmount), virtOut.sub(outAmount));\n    // (z' + dz)^2\n    const factor = divDown(TWO, afterFeeMultiplier); // 2 / (1 - s)\n\n    const derivative = mulDown(factor, divDown(numerator, denominator));\n\n    return derivative;\n}\n\n// /////////\n// ///  Normalized Liquidity measured with respect to the out-asset.\n// ///  NB This is the same function as for the 2-CLP because the marginal trading curve of the 3-CLP\n// ///  is a 2-CLP curve. We use different virtual offsets, of course.\n// /////////\nexport function _getNormalizedLiquidity(\n    balances: BigNumber[],\n    virtualParamOut: BigNumber\n): BigNumber {\n    /**********************************************************************************************\n    // x = balanceOut             x' = x +  virtualParamOut                                      //\n    // s = swapFee                                                                               //\n    //                                                                                           //\n    //                             normalizedLiquidity = 0.5 * x'                                //\n    //                                                                                           //\n    // x' = virtOut                                                                              //\n    // Note that balances = [balanceIn, balanceOut, balanceTertiary].                            //\n    **********************************************************************************************/\n\n    const virtOut = balances[1].add(virtualParamOut);\n    return virtOut.div(2);\n}\n"],"names":["_calculateInvariant","balances","root3Alpha","a","mb","mc","md","_calculateCubicTerms","_calculateCubic","alpha23","mulDown","alpha","ONE","sub","bterm","add","cterm","rootEst","_calculateCubicStartingPoint","_runNewtonIteration","radic","mulUp","mul","lmin","divUp","sqrt","BigNumber","from","factor","gte","div","deltaAbsPrev","iteration","deltaAbs","deltaIsPos","_calcNewtonDelta","lte","_INVARIANT_MIN_ITERATIONS","_INVARIANT_SHRINKING_FACTOR_PER_STEP","Error","dfRootEst","deltaMinus","_safeLargePow3ADown","deltaPlus","divDown","_calcOutGivenIn","balanceIn","balanceOut","amountIn","virtualOffset","virtInOver","amountOut","gt","_calcInGivenOut","virtOutUnder","_calculateNewSpotPrice","inAmount","outAmount","virtualOffsetInOut","swapFee","afterFeeMultiplier","numerator","virtOut","denominator","_derivativeSpotPriceAfterSwapExactTokenInForTokenOut","TWO","_derivativeSpotPriceAfterSwapTokenInForExactTokenOut","_getNormalizedLiquidity","virtualParamOut"],"mappings":"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"}