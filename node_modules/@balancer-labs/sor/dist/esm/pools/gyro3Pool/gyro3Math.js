import{BigNumber as r}from"@ethersproject/bignumber";import{WeiPerEther as t}from"@ethersproject/constants";import{_INVARIANT_MIN_ITERATIONS as n,_INVARIANT_SHRINKING_FACTOR_PER_STEP as o}from"./constants.js";import{_safeLargePow3ADown as d}from"./helpers.js";import{mulDown as u,mulUp as e,divUp as s,sqrt as i,divDown as a}from"../gyroHelpers/gyroSignedFixedPoint.js";function c(r,t){const[n,o,d,u]=f(r,t);return m(n,o,d,u,t)}function f(r,n){const o=u(n,n),d=u(o,n),e=t.sub(d),s=r[0].add(r[1]).add(r[2]),i=u(u(s,n),n),a=u(r[0],r[1]).add(u(r[1],r[2])).add(u(r[2],r[0]));return[e,i,u(a,n),u(u(r[0],r[1]),r[2])]}function m(r,t,n,o,d){let u=b(r,t,n);return u=l(r,t,n,o,d,u),u}function b(n,o,d){const u=e(o,o).add(e(e(n,d),t.mul(3))),a=s(o,n.mul(3)).add(s(i(u,r.from(5)),n.mul(3))),c=t.sub(n).gte(t.div(2))?t.mul(3).div(2):t.mul(2);return e(a,c)}function l(t,d,u,e,s,i){let a=r.from(0);for(let c=0;c<255;++c){const[f,m]=E(t,d,u,e,s,i);if(f.lte(1)||c>=n&&m)return i;if(c>=n&&f.gte(a.div(r.from(o))))return i;a=f,i=m?i.add(f):i.sub(f)}throw new Error("Gyro3Pool: Newton Method did not converge on required invariant")}function E(t,n,o,e,s,i){let c=r.from(0);c=u(i,i).mul(3),c=c.sub(u(u(u(c,s),s),s)),c=c.sub(u(i,n).mul(2)).sub(o);const f=d(i,s,c);let m=u(u(i,i),n);m=a(m.add(u(i,o)),c),m=m.add(a(e,c));const b=m.gte(f);return[b?m.sub(f):f.sub(m),b]}function g(r,n,o,d){const s=r.add(e(d,t.add(2))),i=n.add(u(d,t.sub(1))).mul(o).div(s.add(o));if(i.gt(n))throw new Error("ASSET_BOUNDS_EXCEEDED");return i}function p(r,n,o,d){if(o.gt(n))throw new Error("ASSET_BOUNDS_EXCEEDED");const i=r.add(e(d,t.add(2))),a=n.add(u(d,t.sub(1)));return s(e(i,o),a.sub(o))}function h(r,n,o,d,e){const s=t.sub(e),i=r[0].add(d).add(u(s,n)),c=r[1].add(d),f=u(s,c.sub(o));return a(i,f)}function v(n,o,d){const u=r.from(2).mul(t),e=n[1].add(d).sub(o);return a(u,e)}function w(n,o,d,e,s){const i=r.from(2).mul(t),c=t.sub(s),f=n[0].add(e).add(u(c,o)),m=n[1].add(e),b=u(m.sub(d),m.sub(d)),l=a(i,c);return u(l,a(f,b))}function S(r,t){return r[1].add(t).div(2)}export{p as _calcInGivenOut,E as _calcNewtonDelta,g as _calcOutGivenIn,m as _calculateCubic,b as _calculateCubicStartingPoint,f as _calculateCubicTerms,c as _calculateInvariant,h as _calculateNewSpotPrice,v as _derivativeSpotPriceAfterSwapExactTokenInForTokenOut,w as _derivativeSpotPriceAfterSwapTokenInForExactTokenOut,S as _getNormalizedLiquidity,l as _runNewtonIteration};
//# sourceMappingURL=gyro3Math.js.map
