import{getAddress as t}from"@ethersproject/address";import{WeiPerEther as e,Zero as r}from"@ethersproject/constants";import{formatFixed as a}from"@ethersproject/bignumber";import{ZERO as o,bnum as n}from"../../utils/bignumber.js";import{PoolTypes as s,SwapTypes as i}from"../../types.js";import{safeParseFixed as l,isSameAddress as c}from"../../utils/index.js";import{_calculateInvariant as h,_calcOutGivenIn as d,_calcInGivenOut as p,_calculateNewSpotPrice as u,_derivativeSpotPriceAfterSwapExactTokenInForTokenOut as m,_derivativeSpotPriceAfterSwapTokenInForExactTokenOut as T}from"./gyro3Math.js";import{_normalizeBalances as b,_reduceFee as k,_addFee as y}from"../gyroHelpers/helpers.js";import{mulDown as w,divDown as f}from"../gyroHelpers/gyroSignedFixedPoint.js";import{SWAP_LIMIT_FACTOR as I}from"../gyroHelpers/constants.js";import{universalNormalizedLiquidity as O}from"../liquidity.js";class A{static findToken(e,r,a){const o=e.find((e=>t(e.address)===t(r)));if(!o)throw new Error(a);return o}static fromPool(t){if(!t.root3Alpha)throw new Error("Pool missing root3Alpha");if(l(t.root3Alpha,18).lte(0)||l(t.root3Alpha,18).gte(e))throw new Error("Invalid root3Alpha parameter");if(3!==t.tokens.length)throw new Error("Gyro3Pool must contain three tokens only");return new A(t.id,t.address,t.swapFee,t.totalShares,t.tokens,t.tokensList,t.root3Alpha)}constructor(t,e,r,a,o,n,i){this.poolType=s.Gyro3,this.id=t,this.address=e,this.swapFee=l(r,18),this.totalShares=l(a,18),this.tokens=o,this.tokensList=n,this.root3Alpha=l(i,18)}parsePoolPairData(e,r){const a=A.findToken(this.tokens,e,"Pool does not contain tokenIn"),o=a.balance,n=a.decimals,s=A.findToken(this.tokens,r,"Pool does not contain tokenOut"),i=s.balance,c=s.decimals,h=this.tokens.find((a=>t(a.address)!==t(r)&&t(a.address)!==t(e)));if(!h)throw new Error("Pool does not contain a valid third token");const d=h.balance,p=h.decimals;return{id:this.id,address:this.address,poolType:this.poolType,tokenIn:e,tokenOut:r,decimalsIn:Number(n),decimalsOut:Number(c),decimalsTertiary:Number(p),balanceIn:l(o,n),balanceOut:l(i,c),balanceTertiary:l(d,p),swapFee:this.swapFee}}getNormalizedLiquidity(t){return O(this._derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,o))}getLimitAmountSwap(t,r){if(r===i.SwapExactIn){const r=[t.balanceIn,t.balanceOut,t.balanceTertiary],o=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],s=b(r,o),i=h(s,this.root3Alpha),l=w(i,this.root3Alpha),c=f(w(s[0].add(l),s[1].add(l)),l).sub(l).sub(s[0]),d=f(c,e.sub(t.swapFee));return n(a(w(d,I),18))}return n(a(w(t.balanceOut,I),t.decimalsOut))}updateTokenBalanceForPool(t,e){if(c(this.address,t))this.updateTotalShares(e);else{const r=this.tokens.find((e=>c(e.address,t)));if(!r)throw Error("Pool does not contain this token");r.balance=a(e,r.decimals)}}updateTotalShares(t){this.totalShares=t}_exactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut,t.balanceTertiary],o=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],s=b(r,o),i=h(s,this.root3Alpha),c=w(i,this.root3Alpha),p=l(e.toString(),18),u=k(p,t.swapFee),m=d(s[0],s[1],u,c);return n(a(m,18))}catch(t){return n(0)}}_tokenInForExactTokenOut(t,e){try{const r=l(e.toString(),18),o=[t.balanceIn,t.balanceOut,t.balanceTertiary],s=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],i=b(o,s),c=h(i,this.root3Alpha),d=w(c,this.root3Alpha),u=p(i[0],i[1],r,d),m=y(u,t.swapFee);return n(a(m,18))}catch(t){return n(0)}}_calcTokensOutGivenExactBptIn(t){return new Array(this.tokens.length).fill(r)}_calcBptOutGivenExactTokensIn(t){return r}_spotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut,t.balanceTertiary],o=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],s=b(r,o),i=h(s,this.root3Alpha),c=w(i,this.root3Alpha),p=l(e.toString(),18),m=k(p,t.swapFee),T=d(s[0],s[1],m,c),y=u(s,p,T,c,t.swapFee);return n(a(y,18))}catch(t){return n(0)}}_spotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const r=l(e.toString(),18),o=[t.balanceIn,t.balanceOut,t.balanceTertiary],s=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],i=b(o,s),c=h(i,this.root3Alpha),d=w(c,this.root3Alpha),m=p(i[0],i[1],r,d),T=y(m,t.swapFee),k=u(i,T,r,d,t.swapFee);return n(a(k,18))}catch(t){return n(0)}}_derivativeSpotPriceAfterSwapExactTokenInForTokenOut(t,e){try{const r=[t.balanceIn,t.balanceOut,t.balanceTertiary],o=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],s=b(r,o),i=h(s,this.root3Alpha),c=w(i,this.root3Alpha),p=l(e.toString(),18),u=k(p,t.swapFee),T=d(s[0],s[1],u,c),y=m(s,T,c);return n(a(y,18))}catch(t){return n(0)}}_derivativeSpotPriceAfterSwapTokenInForExactTokenOut(t,e){try{const r=l(e.toString(),18),o=[t.balanceIn,t.balanceOut,t.balanceTertiary],s=[t.decimalsIn,t.decimalsOut,t.decimalsTertiary],i=b(o,s),c=h(i,this.root3Alpha),d=w(c,this.root3Alpha),u=p(i[0],i[1],r,d),m=y(u,t.swapFee),k=T(i,m,r,d,t.swapFee);return n(a(k,18))}catch(t){return n(0)}}}export{A as Gyro3Pool};
//# sourceMappingURL=gyro3Pool.js.map
