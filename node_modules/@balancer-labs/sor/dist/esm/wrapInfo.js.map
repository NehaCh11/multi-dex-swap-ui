{"version":3,"file":"wrapInfo.js","sources":["../../../../src/wrapInfo.ts"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { Provider } from '@ethersproject/providers';\nimport { AddressZero, WeiPerEther as ONE } from '@ethersproject/constants';\nimport { Lido, getStEthRate } from './pools/lido';\nimport { SwapTypes, SwapInfo, SorConfig } from './types';\nimport {\n    TokensToUnbuttonWrapperMap,\n    getWrapperRate as getUnbuttonWrapperRate,\n} from './wrappers/unbutton';\nimport { isSameAddress } from './utils';\n\nexport interface WrappedInfo {\n    swapAmountOriginal: BigNumber;\n    swapAmountForSwaps: BigNumber;\n    tokenIn: TokenInfo;\n    tokenOut: TokenInfo;\n}\n\nexport interface TokenInfo {\n    addressOriginal: string;\n    addressForSwaps: string;\n    wrapType: WrapTypes;\n    rate: BigNumber;\n}\n\nexport enum WrapTypes {\n    None,\n    ETH, // ETH -> WETH\n    stETH, // stETH -> wSTETH\n    Unbutton, // [rebasing Token] -> ubToken\n}\n\nexport async function getWrappedInfo(\n    provider: Provider,\n    swapType: SwapTypes,\n    tokenIn: string,\n    tokenOut: string,\n    config: SorConfig,\n    swapAmount: BigNumber\n): Promise<WrappedInfo> {\n    // The Subgraph returns tokens in lower case format so we must match this\n    tokenIn = tokenIn.toLowerCase();\n    tokenOut = tokenOut.toLowerCase();\n\n    let swapAmountForSwaps = swapAmount;\n    let tokenInForSwaps = tokenIn;\n    let tokenInWrapType = WrapTypes.None;\n    let tokenOutForSwaps = tokenOut;\n    let tokenOutWrapType = WrapTypes.None;\n    let tokenInRate = ONE;\n    let tokenOutRate = ONE;\n\n    //--------------------------------------------------------------------------\n    // ETH/WETH\n\n    // Handle ETH wrapping\n    if (tokenIn === AddressZero) {\n        tokenInForSwaps = config.weth.toLowerCase();\n        tokenInWrapType = WrapTypes.ETH;\n    }\n\n    // Handle WETH unwrapping\n    if (tokenOut === AddressZero) {\n        tokenOutForSwaps = config.weth.toLowerCase();\n        tokenOutWrapType = WrapTypes.ETH;\n    }\n\n    //--------------------------------------------------------------------------\n    // stETH/wstETH\n\n    // Handle stETH wrapping\n    if (tokenIn === Lido.stETH[config.chainId]) {\n        tokenInForSwaps = Lido.wstETH[config.chainId];\n        tokenInWrapType = WrapTypes.stETH;\n        const rate = await getStEthRate(provider, config.chainId);\n        tokenInRate = rate;\n        if (swapType === SwapTypes.SwapExactIn)\n            swapAmountForSwaps = swapAmount.mul(rate).div(ONE);\n    }\n\n    // Handle wstETH unwrapping\n    if (tokenOut === Lido.stETH[config.chainId]) {\n        tokenOutForSwaps = Lido.wstETH[config.chainId];\n        tokenOutWrapType = WrapTypes.stETH;\n        const rate = await getStEthRate(provider, config.chainId);\n        tokenOutRate = rate;\n        if (swapType === SwapTypes.SwapExactOut)\n            swapAmountForSwaps = swapAmount.mul(rate).div(ONE);\n    }\n\n    //--------------------------------------------------------------------------\n    // ubTokens\n\n    // Gets a list of all the tokens and their unbutton wrappers\n    const tokensToUBWrapperMap =\n        TokensToUnbuttonWrapperMap[config.chainId] || {};\n\n    // Handle token unbutton wrapping\n    if (tokensToUBWrapperMap[tokenIn]) {\n        tokenInForSwaps = tokensToUBWrapperMap[tokenIn];\n        tokenInWrapType = WrapTypes.Unbutton;\n        tokenInRate = await getUnbuttonWrapperRate(provider, tokenInForSwaps);\n        if (swapType === SwapTypes.SwapExactIn)\n            swapAmountForSwaps = swapAmount.mul(tokenInRate).div(ONE);\n    }\n\n    // Handle unbutton token unwrapping\n    if (tokensToUBWrapperMap[tokenOut]) {\n        tokenOutForSwaps = tokensToUBWrapperMap[tokenOut];\n        tokenOutWrapType = WrapTypes.Unbutton;\n        tokenOutRate = await getUnbuttonWrapperRate(provider, tokenOutForSwaps);\n        if (swapType === SwapTypes.SwapExactOut)\n            swapAmountForSwaps = swapAmount.mul(tokenOutRate).div(ONE);\n    }\n\n    //--------------------------------------------------------------------------\n\n    return {\n        swapAmountOriginal: swapAmount,\n        swapAmountForSwaps: swapAmountForSwaps,\n        tokenIn: {\n            addressOriginal: tokenIn,\n            addressForSwaps: tokenInForSwaps,\n            wrapType: tokenInWrapType,\n            rate: tokenInRate,\n        },\n        tokenOut: {\n            addressOriginal: tokenOut,\n            addressForSwaps: tokenOutForSwaps,\n            wrapType: tokenOutWrapType,\n            rate: tokenOutRate,\n        },\n    };\n}\n\nexport function setWrappedInfo(\n    swapInfo: SwapInfo,\n    swapType: SwapTypes,\n    wrappedInfo: WrappedInfo,\n    config: SorConfig\n): SwapInfo {\n    if (swapInfo.swaps.length === 0) return swapInfo;\n\n    swapInfo.tokenIn = wrappedInfo.tokenIn.addressOriginal;\n    swapInfo.tokenOut = wrappedInfo.tokenOut.addressOriginal;\n\n    swapInfo.swapAmountForSwaps = swapInfo.swapAmount;\n    swapInfo.returnAmountFromSwaps = swapInfo.returnAmount;\n\n    swapInfo.tokenInForSwaps = wrappedInfo.tokenIn.addressForSwaps;\n    swapInfo.tokenOutFromSwaps = wrappedInfo.tokenOut.addressForSwaps;\n\n    // No wrapping required\n    if (\n        wrappedInfo.tokenIn.wrapType === WrapTypes.None &&\n        wrappedInfo.tokenOut.wrapType === WrapTypes.None\n    ) {\n        return swapInfo;\n    }\n\n    //--------------------------------------------------------------------------\n    // Wrappers which are 1:1 (ETH/WETH), ie UnscaledWrappers\n    // Replace weth with ZERO/ETH in assets for Vault to handle ETH directly\n    if (\n        wrappedInfo.tokenIn.wrapType === WrapTypes.ETH ||\n        wrappedInfo.tokenOut.wrapType === WrapTypes.ETH\n    ) {\n        swapInfo.tokenAddresses = swapInfo.tokenAddresses.map((addr) =>\n            isSameAddress(addr, config.weth) ? AddressZero : addr\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // Wrappers which are NOT 1:1 (stETH/wstETH, AMPL/WAMPL, all ubTokens etc)\n    // ie ScaledWrappers\n\n    const isScaledWrapper = (wrapType) =>\n        wrapType === WrapTypes.stETH || wrapType === WrapTypes.Unbutton;\n\n    // Scaling required for wrappers which don't scale 1:1 with the underlying token\n    // swap amount and return amounts are scaled if swap type is SwapExact\n\n    // Handle swap amount scaling\n    if (\n        (isScaledWrapper(wrappedInfo.tokenIn.wrapType) &&\n            swapType === SwapTypes.SwapExactIn) ||\n        (isScaledWrapper(wrappedInfo.tokenOut.wrapType) &&\n            swapType === SwapTypes.SwapExactOut)\n    ) {\n        swapInfo.swapAmount = wrappedInfo.swapAmountOriginal;\n        swapInfo.swapAmountForSwaps = wrappedInfo.swapAmountForSwaps;\n    }\n\n    // Handle return amount scaling\n    // SwapExactIn, unwrapped out, returnAmount is unwrapped amount out, returnAmountForSwaps is wrapped amount out\n    if (\n        swapType === SwapTypes.SwapExactIn &&\n        isScaledWrapper(wrappedInfo.tokenOut.wrapType)\n    ) {\n        swapInfo.returnAmount = swapInfo.returnAmount\n            .mul(ONE)\n            .div(wrappedInfo.tokenOut.rate);\n\n        swapInfo.returnAmountConsideringFees =\n            swapInfo.returnAmountConsideringFees\n                .mul(ONE)\n                .div(wrappedInfo.tokenOut.rate);\n    }\n\n    // SwapExactOut, unwrapped in, returnAmount us unwrapped amount in, returnAmountForSwaps is wrapped amount in\n    if (\n        swapType === SwapTypes.SwapExactOut &&\n        isScaledWrapper(wrappedInfo.tokenIn.wrapType)\n    ) {\n        swapInfo.returnAmount = swapInfo.returnAmount\n            .mul(ONE)\n            .div(wrappedInfo.tokenIn.rate);\n\n        swapInfo.returnAmountConsideringFees =\n            swapInfo.returnAmountConsideringFees\n                .mul(ONE)\n                .div(wrappedInfo.tokenIn.rate);\n    }\n\n    return swapInfo;\n}\n"],"names":["WrapTypes","getWrappedInfo","provider","swapType","tokenIn","tokenOut","config","swapAmount","toLowerCase","swapAmountForSwaps","tokenInForSwaps","tokenInWrapType","None","tokenOutForSwaps","tokenOutWrapType","tokenInRate","ONE","tokenOutRate","AddressZero","weth","ETH","Lido","stETH","chainId","wstETH","rate","getStEthRate","SwapTypes","SwapExactIn","mul","div","SwapExactOut","tokensToUBWrapperMap","TokensToUnbuttonWrapperMap","Unbutton","getUnbuttonWrapperRate","swapAmountOriginal","addressOriginal","addressForSwaps","wrapType","setWrappedInfo","swapInfo","wrappedInfo","swaps","length","returnAmountFromSwaps","returnAmount","tokenOutFromSwaps","tokenAddresses","map","addr","isSameAddress","isScaledWrapper","returnAmountConsideringFees"],"mappings":"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"}