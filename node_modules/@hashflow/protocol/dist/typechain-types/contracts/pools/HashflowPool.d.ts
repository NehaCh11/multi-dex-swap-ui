import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../common";
export declare namespace IQuote {
    type RFQTQuoteStruct = {
        pool: PromiseOrValue<string>;
        externalAccount: PromiseOrValue<string>;
        trader: PromiseOrValue<string>;
        effectiveTrader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        effectiveBaseTokenAmount: PromiseOrValue<BigNumberish>;
        maxBaseTokenAmount: PromiseOrValue<BigNumberish>;
        maxQuoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        nonce: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
    };
    type RFQTQuoteStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string
    ] & {
        pool: string;
        externalAccount: string;
        trader: string;
        effectiveTrader: string;
        baseToken: string;
        quoteToken: string;
        effectiveBaseTokenAmount: BigNumber;
        maxBaseTokenAmount: BigNumber;
        maxQuoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        nonce: BigNumber;
        txid: string;
        signature: string;
    };
    type RFQMQuoteStruct = {
        pool: PromiseOrValue<string>;
        externalAccount: PromiseOrValue<string>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        takerSignature: PromiseOrValue<BytesLike>;
        makerSignature: PromiseOrValue<BytesLike>;
    };
    type RFQMQuoteStructOutput = [
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string
    ] & {
        pool: string;
        externalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        txid: string;
        takerSignature: string;
        makerSignature: string;
    };
    type XChainRFQTQuoteStruct = {
        srcChainId: PromiseOrValue<BigNumberish>;
        dstChainId: PromiseOrValue<BigNumberish>;
        srcPool: PromiseOrValue<string>;
        dstPool: PromiseOrValue<BytesLike>;
        srcExternalAccount: PromiseOrValue<string>;
        dstExternalAccount: PromiseOrValue<BytesLike>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        nonce: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
    };
    type XChainRFQTQuoteStructOutput = [
        number,
        number,
        string,
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string
    ] & {
        srcChainId: number;
        dstChainId: number;
        srcPool: string;
        dstPool: string;
        srcExternalAccount: string;
        dstExternalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        nonce: BigNumber;
        txid: string;
        signature: string;
    };
    type XChainRFQMQuoteStruct = {
        srcChainId: PromiseOrValue<BigNumberish>;
        dstChainId: PromiseOrValue<BigNumberish>;
        srcPool: PromiseOrValue<string>;
        dstPool: PromiseOrValue<BytesLike>;
        srcExternalAccount: PromiseOrValue<string>;
        dstExternalAccount: PromiseOrValue<BytesLike>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        takerSignature: PromiseOrValue<BytesLike>;
        makerSignature: PromiseOrValue<BytesLike>;
    };
    type XChainRFQMQuoteStructOutput = [
        number,
        number,
        string,
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string
    ] & {
        srcChainId: number;
        dstChainId: number;
        srcPool: string;
        dstPool: string;
        srcExternalAccount: string;
        dstExternalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        txid: string;
        takerSignature: string;
        makerSignature: string;
    };
}
export declare namespace IHashflowPool {
    type AuthorizedXChainPoolStruct = {
        chainId: PromiseOrValue<BigNumberish>;
        pool: PromiseOrValue<BytesLike>;
    };
    type AuthorizedXChainPoolStructOutput = [number, string] & {
        chainId: number;
        pool: string;
    };
}
export interface HashflowPoolInterface extends utils.Interface {
    functions: {
        "authorizedRouters(address)": FunctionFragment;
        "fillXChain(address,bytes32,address,address,uint256,uint8)": FunctionFragment;
        "getReserves(address)": FunctionFragment;
        "governance()": FunctionFragment;
        "hTokens(uint8,address)": FunctionFragment;
        "killswitchOperations(bool)": FunctionFragment;
        "migrateRouterAuthorization(address,address)": FunctionFragment;
        "name()": FunctionFragment;
        "nonces(address)": FunctionFragment;
        "operations()": FunctionFragment;
        "redeemXChainTokens(address,uint256)": FunctionFragment;
        "signerConfiguration()": FunctionFragment;
        "symbol()": FunctionFragment;
        "trade((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,bytes32,bytes))": FunctionFragment;
        "tradeRFQm((address,address,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes))": FunctionFragment;
        "tradeXChain((uint16,uint16,address,bytes32,address,bytes32,address,address,address,uint256,uint256,uint256,uint256,bytes32,bytes))": FunctionFragment;
        "tradeXChainRFQm((uint16,uint16,address,bytes32,address,bytes32,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes))": FunctionFragment;
        "updateRouterPermissions(address,bool)": FunctionFragment;
        "updateSigner(address)": FunctionFragment;
        "updateWithdrawalAccount(address[],bool)": FunctionFragment;
        "updateXChainPoolAuthorization((uint16,bytes32)[],uint8[],bool)": FunctionFragment;
        "updateXChainUa()": FunctionFragment;
        "xChainUa()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "authorizedRouters" | "fillXChain" | "getReserves" | "governance" | "hTokens" | "killswitchOperations" | "migrateRouterAuthorization" | "name" | "nonces" | "operations" | "redeemXChainTokens" | "signerConfiguration" | "symbol" | "trade" | "tradeRFQm" | "tradeXChain" | "tradeXChainRFQm" | "updateRouterPermissions" | "updateSigner" | "updateWithdrawalAccount" | "updateXChainPoolAuthorization" | "updateXChainUa" | "xChainUa"): FunctionFragment;
    encodeFunctionData(functionFragment: "authorizedRouters", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "fillXChain", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "getReserves", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "governance", values?: undefined): string;
    encodeFunctionData(functionFragment: "hTokens", values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "killswitchOperations", values: [PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "migrateRouterAuthorization", values: [PromiseOrValue<string>, PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "name", values?: undefined): string;
    encodeFunctionData(functionFragment: "nonces", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "operations", values?: undefined): string;
    encodeFunctionData(functionFragment: "redeemXChainTokens", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "signerConfiguration", values?: undefined): string;
    encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
    encodeFunctionData(functionFragment: "trade", values: [IQuote.RFQTQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeRFQm", values: [IQuote.RFQMQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeXChain", values: [IQuote.XChainRFQTQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeXChainRFQm", values: [IQuote.XChainRFQMQuoteStruct]): string;
    encodeFunctionData(functionFragment: "updateRouterPermissions", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "updateSigner", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "updateWithdrawalAccount", values: [PromiseOrValue<string>[], PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "updateXChainPoolAuthorization", values: [
        IHashflowPool.AuthorizedXChainPoolStruct[],
        PromiseOrValue<BigNumberish>[],
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "updateXChainUa", values?: undefined): string;
    encodeFunctionData(functionFragment: "xChainUa", values?: undefined): string;
    decodeFunctionResult(functionFragment: "authorizedRouters", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fillXChain", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getReserves", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "killswitchOperations", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "migrateRouterAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "operations", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redeemXChainTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "signerConfiguration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "trade", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeRFQm", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeXChain", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeXChainRFQm", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateRouterPermissions", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateSigner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateWithdrawalAccount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateXChainPoolAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateXChainUa", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "xChainUa", data: BytesLike): Result;
    events: {
        "AddLiquidity(address,address,uint256,uint256)": EventFragment;
        "Initialized(uint8)": EventFragment;
        "ListAsset(address,address,address)": EventFragment;
        "RemoveLiquidity(address,address,uint256,uint256)": EventFragment;
        "Trade(address,bytes32,address,address,uint256,uint256)": EventFragment;
        "UpdateRouterPermissions(address,bool)": EventFragment;
        "UpdateSigner(address,address)": EventFragment;
        "UpdateWithdrawalAccount(address,bool)": EventFragment;
        "UpdateXChainUA(address,address)": EventFragment;
        "XChainTrade(uint16,bytes32,address,bytes32,address,address,uint256,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AddLiquidity"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ListAsset"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RemoveLiquidity"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Trade"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateRouterPermissions"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateSigner"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateWithdrawalAccount"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateXChainUA"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "XChainTrade"): EventFragment;
}
export interface AddLiquidityEventObject {
    token: string;
    liquidityProvider: string;
    depositAmount: BigNumber;
    hTokenAmount: BigNumber;
}
export declare type AddLiquidityEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], AddLiquidityEventObject>;
export declare type AddLiquidityEventFilter = TypedEventFilter<AddLiquidityEvent>;
export interface InitializedEventObject {
    version: number;
}
export declare type InitializedEvent = TypedEvent<[number], InitializedEventObject>;
export declare type InitializedEventFilter = TypedEventFilter<InitializedEvent>;
export interface ListAssetEventObject {
    token: string;
    hTokenXChain: string;
    hTokenLp: string;
}
export declare type ListAssetEvent = TypedEvent<[
    string,
    string,
    string
], ListAssetEventObject>;
export declare type ListAssetEventFilter = TypedEventFilter<ListAssetEvent>;
export interface RemoveLiquidityEventObject {
    token: string;
    liquidityProvider: string;
    withdrawAmount: BigNumber;
    burnAmount: BigNumber;
}
export declare type RemoveLiquidityEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber
], RemoveLiquidityEventObject>;
export declare type RemoveLiquidityEventFilter = TypedEventFilter<RemoveLiquidityEvent>;
export interface TradeEventObject {
    trader: string;
    txid: string;
    baseToken: string;
    quoteToken: string;
    baseTokenAmount: BigNumber;
    quoteTokenAmount: BigNumber;
}
export declare type TradeEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber
], TradeEventObject>;
export declare type TradeEventFilter = TypedEventFilter<TradeEvent>;
export interface UpdateRouterPermissionsEventObject {
    router: string;
    authorized: boolean;
}
export declare type UpdateRouterPermissionsEvent = TypedEvent<[
    string,
    boolean
], UpdateRouterPermissionsEventObject>;
export declare type UpdateRouterPermissionsEventFilter = TypedEventFilter<UpdateRouterPermissionsEvent>;
export interface UpdateSignerEventObject {
    signer: string;
    prevSigner: string;
}
export declare type UpdateSignerEvent = TypedEvent<[
    string,
    string
], UpdateSignerEventObject>;
export declare type UpdateSignerEventFilter = TypedEventFilter<UpdateSignerEvent>;
export interface UpdateWithdrawalAccountEventObject {
    account: string;
    authorized: boolean;
}
export declare type UpdateWithdrawalAccountEvent = TypedEvent<[
    string,
    boolean
], UpdateWithdrawalAccountEventObject>;
export declare type UpdateWithdrawalAccountEventFilter = TypedEventFilter<UpdateWithdrawalAccountEvent>;
export interface UpdateXChainUAEventObject {
    xChainUa: string;
    prevXChainUa: string;
}
export declare type UpdateXChainUAEvent = TypedEvent<[
    string,
    string
], UpdateXChainUAEventObject>;
export declare type UpdateXChainUAEventFilter = TypedEventFilter<UpdateXChainUAEvent>;
export interface XChainTradeEventObject {
    dstChainId: number;
    dstPool: string;
    trader: string;
    txid: string;
    baseToken: string;
    quoteToken: string;
    baseTokenAmount: BigNumber;
    quoteTokenAmount: BigNumber;
}
export declare type XChainTradeEvent = TypedEvent<[
    number,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber
], XChainTradeEventObject>;
export declare type XChainTradeEventFilter = TypedEventFilter<XChainTradeEvent>;
export interface HashflowPool extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: HashflowPoolInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        authorizedRouters(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        fillXChain(externalAccount: PromiseOrValue<string>, txid: PromiseOrValue<BytesLike>, trader: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, quoteTokenAmount: PromiseOrValue<BigNumberish>, protocol: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        getReserves(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        governance(overrides?: CallOverrides): Promise<[string]>;
        hTokens(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string]>;
        killswitchOperations(enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        migrateRouterAuthorization(newRouter: PromiseOrValue<string>, oldRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        name(overrides?: CallOverrides): Promise<[string]>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        operations(overrides?: CallOverrides): Promise<[string]>;
        redeemXChainTokens(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        signerConfiguration(overrides?: CallOverrides): Promise<[string, boolean] & {
            signer: string;
            enabled: boolean;
        }>;
        symbol(overrides?: CallOverrides): Promise<[string]>;
        trade(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateRouterPermissions(router: PromiseOrValue<string>, permissions: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateSigner(newSigner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateWithdrawalAccount(withdrawalAccounts: PromiseOrValue<string>[], authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateXChainPoolAuthorization(pools: IHashflowPool.AuthorizedXChainPoolStruct[], protocols: PromiseOrValue<BigNumberish>[], status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateXChainUa(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        xChainUa(overrides?: CallOverrides): Promise<[string]>;
    };
    authorizedRouters(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    fillXChain(externalAccount: PromiseOrValue<string>, txid: PromiseOrValue<BytesLike>, trader: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, quoteTokenAmount: PromiseOrValue<BigNumberish>, protocol: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    getReserves(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    governance(overrides?: CallOverrides): Promise<string>;
    hTokens(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
    killswitchOperations(enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    migrateRouterAuthorization(newRouter: PromiseOrValue<string>, oldRouter: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    name(overrides?: CallOverrides): Promise<string>;
    nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    operations(overrides?: CallOverrides): Promise<string>;
    redeemXChainTokens(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    signerConfiguration(overrides?: CallOverrides): Promise<[string, boolean] & {
        signer: string;
        enabled: boolean;
    }>;
    symbol(overrides?: CallOverrides): Promise<string>;
    trade(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateRouterPermissions(router: PromiseOrValue<string>, permissions: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateSigner(newSigner: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateWithdrawalAccount(withdrawalAccounts: PromiseOrValue<string>[], authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateXChainPoolAuthorization(pools: IHashflowPool.AuthorizedXChainPoolStruct[], protocols: PromiseOrValue<BigNumberish>[], status: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateXChainUa(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    xChainUa(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        authorizedRouters(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        fillXChain(externalAccount: PromiseOrValue<string>, txid: PromiseOrValue<BytesLike>, trader: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, quoteTokenAmount: PromiseOrValue<BigNumberish>, protocol: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string, BigNumber]>;
        getReserves(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        governance(overrides?: CallOverrides): Promise<string>;
        hTokens(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string>;
        killswitchOperations(enabled: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        migrateRouterAuthorization(newRouter: PromiseOrValue<string>, oldRouter: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        name(overrides?: CallOverrides): Promise<string>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        operations(overrides?: CallOverrides): Promise<string>;
        redeemXChainTokens(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        signerConfiguration(overrides?: CallOverrides): Promise<[string, boolean] & {
            signer: string;
            enabled: boolean;
        }>;
        symbol(overrides?: CallOverrides): Promise<string>;
        trade(quote: IQuote.RFQTQuoteStruct, overrides?: CallOverrides): Promise<boolean>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: CallOverrides): Promise<boolean>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, overrides?: CallOverrides): Promise<boolean>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, overrides?: CallOverrides): Promise<boolean>;
        updateRouterPermissions(router: PromiseOrValue<string>, permissions: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updateSigner(newSigner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        updateWithdrawalAccount(withdrawalAccounts: PromiseOrValue<string>[], authorized: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updateXChainPoolAuthorization(pools: IHashflowPool.AuthorizedXChainPoolStruct[], protocols: PromiseOrValue<BigNumberish>[], status: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updateXChainUa(overrides?: CallOverrides): Promise<void>;
        xChainUa(overrides?: CallOverrides): Promise<string>;
    };
    filters: {
        "AddLiquidity(address,address,uint256,uint256)"(token?: null, liquidityProvider?: null, depositAmount?: null, hTokenAmount?: null): AddLiquidityEventFilter;
        AddLiquidity(token?: null, liquidityProvider?: null, depositAmount?: null, hTokenAmount?: null): AddLiquidityEventFilter;
        "Initialized(uint8)"(version?: null): InitializedEventFilter;
        Initialized(version?: null): InitializedEventFilter;
        "ListAsset(address,address,address)"(token?: null, hTokenXChain?: null, hTokenLp?: null): ListAssetEventFilter;
        ListAsset(token?: null, hTokenXChain?: null, hTokenLp?: null): ListAssetEventFilter;
        "RemoveLiquidity(address,address,uint256,uint256)"(token?: null, liquidityProvider?: null, withdrawAmount?: null, burnAmount?: null): RemoveLiquidityEventFilter;
        RemoveLiquidity(token?: null, liquidityProvider?: null, withdrawAmount?: null, burnAmount?: null): RemoveLiquidityEventFilter;
        "Trade(address,bytes32,address,address,uint256,uint256)"(trader?: null, txid?: null, baseToken?: null, quoteToken?: null, baseTokenAmount?: null, quoteTokenAmount?: null): TradeEventFilter;
        Trade(trader?: null, txid?: null, baseToken?: null, quoteToken?: null, baseTokenAmount?: null, quoteTokenAmount?: null): TradeEventFilter;
        "UpdateRouterPermissions(address,bool)"(router?: null, authorized?: null): UpdateRouterPermissionsEventFilter;
        UpdateRouterPermissions(router?: null, authorized?: null): UpdateRouterPermissionsEventFilter;
        "UpdateSigner(address,address)"(signer?: null, prevSigner?: null): UpdateSignerEventFilter;
        UpdateSigner(signer?: null, prevSigner?: null): UpdateSignerEventFilter;
        "UpdateWithdrawalAccount(address,bool)"(account?: null, authorized?: null): UpdateWithdrawalAccountEventFilter;
        UpdateWithdrawalAccount(account?: null, authorized?: null): UpdateWithdrawalAccountEventFilter;
        "UpdateXChainUA(address,address)"(xChainUa?: null, prevXChainUa?: null): UpdateXChainUAEventFilter;
        UpdateXChainUA(xChainUa?: null, prevXChainUa?: null): UpdateXChainUAEventFilter;
        "XChainTrade(uint16,bytes32,address,bytes32,address,address,uint256,uint256)"(dstChainId?: null, dstPool?: null, trader?: null, txid?: null, baseToken?: null, quoteToken?: null, baseTokenAmount?: null, quoteTokenAmount?: null): XChainTradeEventFilter;
        XChainTrade(dstChainId?: null, dstPool?: null, trader?: null, txid?: null, baseToken?: null, quoteToken?: null, baseTokenAmount?: null, quoteTokenAmount?: null): XChainTradeEventFilter;
    };
    estimateGas: {
        authorizedRouters(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        fillXChain(externalAccount: PromiseOrValue<string>, txid: PromiseOrValue<BytesLike>, trader: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, quoteTokenAmount: PromiseOrValue<BigNumberish>, protocol: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        getReserves(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        governance(overrides?: CallOverrides): Promise<BigNumber>;
        hTokens(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        killswitchOperations(enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        migrateRouterAuthorization(newRouter: PromiseOrValue<string>, oldRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        name(overrides?: CallOverrides): Promise<BigNumber>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        operations(overrides?: CallOverrides): Promise<BigNumber>;
        redeemXChainTokens(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        signerConfiguration(overrides?: CallOverrides): Promise<BigNumber>;
        symbol(overrides?: CallOverrides): Promise<BigNumber>;
        trade(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateRouterPermissions(router: PromiseOrValue<string>, permissions: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateSigner(newSigner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateWithdrawalAccount(withdrawalAccounts: PromiseOrValue<string>[], authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateXChainPoolAuthorization(pools: IHashflowPool.AuthorizedXChainPoolStruct[], protocols: PromiseOrValue<BigNumberish>[], status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateXChainUa(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        xChainUa(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        authorizedRouters(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        fillXChain(externalAccount: PromiseOrValue<string>, txid: PromiseOrValue<BytesLike>, trader: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, quoteTokenAmount: PromiseOrValue<BigNumberish>, protocol: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        getReserves(token: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        hTokens(arg0: PromiseOrValue<BigNumberish>, arg1: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        killswitchOperations(enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        migrateRouterAuthorization(newRouter: PromiseOrValue<string>, oldRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        name(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        nonces(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        operations(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        redeemXChainTokens(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        signerConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        trade(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateRouterPermissions(router: PromiseOrValue<string>, permissions: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateSigner(newSigner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateWithdrawalAccount(withdrawalAccounts: PromiseOrValue<string>[], authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateXChainPoolAuthorization(pools: IHashflowPool.AuthorizedXChainPoolStruct[], protocols: PromiseOrValue<BigNumberish>[], status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateXChainUa(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        xChainUa(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
