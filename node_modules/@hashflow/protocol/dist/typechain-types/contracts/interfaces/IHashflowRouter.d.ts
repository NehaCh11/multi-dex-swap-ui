import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../../common";
export declare namespace IQuote {
    type DepositStruct = {
        pool: PromiseOrValue<string>;
        token: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish>;
        nonce: PromiseOrValue<BigNumberish>;
        signature: PromiseOrValue<BytesLike>;
    };
    type DepositStructOutput = [
        string,
        string,
        BigNumber,
        BigNumber,
        string
    ] & {
        pool: string;
        token: string;
        amount: BigNumber;
        nonce: BigNumber;
        signature: string;
    };
    type RFQTQuoteStruct = {
        pool: PromiseOrValue<string>;
        externalAccount: PromiseOrValue<string>;
        trader: PromiseOrValue<string>;
        effectiveTrader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        effectiveBaseTokenAmount: PromiseOrValue<BigNumberish>;
        maxBaseTokenAmount: PromiseOrValue<BigNumberish>;
        maxQuoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        nonce: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
    };
    type RFQTQuoteStructOutput = [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string
    ] & {
        pool: string;
        externalAccount: string;
        trader: string;
        effectiveTrader: string;
        baseToken: string;
        quoteToken: string;
        effectiveBaseTokenAmount: BigNumber;
        maxBaseTokenAmount: BigNumber;
        maxQuoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        nonce: BigNumber;
        txid: string;
        signature: string;
    };
    type RFQMQuoteStruct = {
        pool: PromiseOrValue<string>;
        externalAccount: PromiseOrValue<string>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        takerSignature: PromiseOrValue<BytesLike>;
        makerSignature: PromiseOrValue<BytesLike>;
    };
    type RFQMQuoteStructOutput = [
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string
    ] & {
        pool: string;
        externalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        txid: string;
        takerSignature: string;
        makerSignature: string;
    };
    type XChainRFQTQuoteStruct = {
        srcChainId: PromiseOrValue<BigNumberish>;
        dstChainId: PromiseOrValue<BigNumberish>;
        srcPool: PromiseOrValue<string>;
        dstPool: PromiseOrValue<BytesLike>;
        srcExternalAccount: PromiseOrValue<string>;
        dstExternalAccount: PromiseOrValue<BytesLike>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        nonce: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        signature: PromiseOrValue<BytesLike>;
    };
    type XChainRFQTQuoteStructOutput = [
        number,
        number,
        string,
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string
    ] & {
        srcChainId: number;
        dstChainId: number;
        srcPool: string;
        dstPool: string;
        srcExternalAccount: string;
        dstExternalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        nonce: BigNumber;
        txid: string;
        signature: string;
    };
    type XChainRFQMQuoteStruct = {
        srcChainId: PromiseOrValue<BigNumberish>;
        dstChainId: PromiseOrValue<BigNumberish>;
        srcPool: PromiseOrValue<string>;
        dstPool: PromiseOrValue<BytesLike>;
        srcExternalAccount: PromiseOrValue<string>;
        dstExternalAccount: PromiseOrValue<BytesLike>;
        trader: PromiseOrValue<string>;
        baseToken: PromiseOrValue<string>;
        quoteToken: PromiseOrValue<string>;
        baseTokenAmount: PromiseOrValue<BigNumberish>;
        quoteTokenAmount: PromiseOrValue<BigNumberish>;
        quoteExpiry: PromiseOrValue<BigNumberish>;
        txid: PromiseOrValue<BytesLike>;
        takerSignature: PromiseOrValue<BytesLike>;
        makerSignature: PromiseOrValue<BytesLike>;
    };
    type XChainRFQMQuoteStructOutput = [
        number,
        number,
        string,
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string
    ] & {
        srcChainId: number;
        dstChainId: number;
        srcPool: string;
        dstPool: string;
        srcExternalAccount: string;
        dstExternalAccount: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: BigNumber;
        quoteTokenAmount: BigNumber;
        quoteExpiry: BigNumber;
        txid: string;
        takerSignature: string;
        makerSignature: string;
    };
}
export interface IHashflowRouterInterface extends utils.Interface {
    functions: {
        "addLiquidityPrivatePool(address,address,uint256)": FunctionFragment;
        "addLiquidityPublicPool((address,address,uint256,uint256,bytes))": FunctionFragment;
        "isPoolAuthorized(address)": FunctionFragment;
        "killswitchPool(address,bool)": FunctionFragment;
        "migratePoolAuthorization(address)": FunctionFragment;
        "removeLiquidityPublicPool(address,address,uint256)": FunctionFragment;
        "removeLiquidityPublicPoolWithPermit(address,address,uint256,uint256,uint8,bytes32,bytes32,bool)": FunctionFragment;
        "tradeMultiHop((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,bytes32,bytes)[],address,address)": FunctionFragment;
        "tradeRFQm((address,address,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes))": FunctionFragment;
        "tradeRFQmWithPermit((address,address,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes),uint256,uint8,bytes32,bytes32,bool)": FunctionFragment;
        "tradeSingleHop((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,bytes32,bytes))": FunctionFragment;
        "tradeXChain((uint16,uint16,address,bytes32,address,bytes32,address,address,address,uint256,uint256,uint256,uint256,bytes32,bytes),uint8)": FunctionFragment;
        "tradeXChainRFQm((uint16,uint16,address,bytes32,address,bytes32,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes),uint8)": FunctionFragment;
        "tradeXChainRFQmWithPermit((uint16,uint16,address,bytes32,address,bytes32,address,address,address,uint256,uint256,uint256,bytes32,bytes,bytes),uint8,uint256,uint8,bytes32,bytes32,bool)": FunctionFragment;
        "updateGovernance(address)": FunctionFragment;
        "updateMigrationRouterStatus(address,bool)": FunctionFragment;
        "updatePoolAuthorization(address,bool)": FunctionFragment;
        "updateXChainUa(address)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "addLiquidityPrivatePool" | "addLiquidityPublicPool" | "isPoolAuthorized" | "killswitchPool" | "migratePoolAuthorization" | "removeLiquidityPublicPool" | "removeLiquidityPublicPoolWithPermit" | "tradeMultiHop" | "tradeRFQm" | "tradeRFQmWithPermit" | "tradeSingleHop" | "tradeXChain" | "tradeXChainRFQm" | "tradeXChainRFQmWithPermit" | "updateGovernance" | "updateMigrationRouterStatus" | "updatePoolAuthorization" | "updateXChainUa"): FunctionFragment;
    encodeFunctionData(functionFragment: "addLiquidityPrivatePool", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "addLiquidityPublicPool", values: [IQuote.DepositStruct]): string;
    encodeFunctionData(functionFragment: "isPoolAuthorized", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "killswitchPool", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "migratePoolAuthorization", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "removeLiquidityPublicPool", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "removeLiquidityPublicPoolWithPermit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "tradeMultiHop", values: [
        IQuote.RFQTQuoteStruct[],
        PromiseOrValue<string>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "tradeRFQm", values: [IQuote.RFQMQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeRFQmWithPermit", values: [
        IQuote.RFQMQuoteStruct,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "tradeSingleHop", values: [IQuote.RFQTQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeXChain", values: [IQuote.XChainRFQTQuoteStruct, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "tradeXChainRFQm", values: [IQuote.XChainRFQMQuoteStruct, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "tradeXChainRFQmWithPermit", values: [
        IQuote.XChainRFQMQuoteStruct,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<boolean>
    ]): string;
    encodeFunctionData(functionFragment: "updateGovernance", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "updateMigrationRouterStatus", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "updatePoolAuthorization", values: [PromiseOrValue<string>, PromiseOrValue<boolean>]): string;
    encodeFunctionData(functionFragment: "updateXChainUa", values: [PromiseOrValue<string>]): string;
    decodeFunctionResult(functionFragment: "addLiquidityPrivatePool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addLiquidityPublicPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isPoolAuthorized", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "killswitchPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "migratePoolAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeLiquidityPublicPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeLiquidityPublicPoolWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeMultiHop", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeRFQm", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeRFQmWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeSingleHop", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeXChain", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeXChainRFQm", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeXChainRFQmWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateMigrationRouterStatus", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updatePoolAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateXChainUa", data: BytesLike): Result;
    events: {
        "UpdateGovernance(address,address)": EventFragment;
        "UpdateMigrationRouterStatus(address,bool)": EventFragment;
        "UpdatePoolAuthorizaton(address,bool)": EventFragment;
        "UpdateXChainUA(address,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "UpdateGovernance"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateMigrationRouterStatus"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdatePoolAuthorizaton"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateXChainUA"): EventFragment;
}
export interface UpdateGovernanceEventObject {
    governance: string;
    prevGovernance: string;
}
export declare type UpdateGovernanceEvent = TypedEvent<[
    string,
    string
], UpdateGovernanceEventObject>;
export declare type UpdateGovernanceEventFilter = TypedEventFilter<UpdateGovernanceEvent>;
export interface UpdateMigrationRouterStatusEventObject {
    migrationRouter: string;
    authorized: boolean;
}
export declare type UpdateMigrationRouterStatusEvent = TypedEvent<[
    string,
    boolean
], UpdateMigrationRouterStatusEventObject>;
export declare type UpdateMigrationRouterStatusEventFilter = TypedEventFilter<UpdateMigrationRouterStatusEvent>;
export interface UpdatePoolAuthorizatonEventObject {
    pool: string;
    authorized: boolean;
}
export declare type UpdatePoolAuthorizatonEvent = TypedEvent<[
    string,
    boolean
], UpdatePoolAuthorizatonEventObject>;
export declare type UpdatePoolAuthorizatonEventFilter = TypedEventFilter<UpdatePoolAuthorizatonEvent>;
export interface UpdateXChainUAEventObject {
    xChainUa: string;
    prevXChainUa: string;
}
export declare type UpdateXChainUAEvent = TypedEvent<[
    string,
    string
], UpdateXChainUAEventObject>;
export declare type UpdateXChainUAEventFilter = TypedEventFilter<UpdateXChainUAEvent>;
export interface IHashflowRouter extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IHashflowRouterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        addLiquidityPrivatePool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        addLiquidityPublicPool(deposit: IQuote.DepositStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        isPoolAuthorized(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;
        killswitchPool(pool: PromiseOrValue<string>, enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        migratePoolAuthorization(migrationRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        removeLiquidityPublicPool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        removeLiquidityPublicPoolWithPermit(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeMultiHop(quotes: IQuote.RFQTQuoteStruct[], baseToken: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeRFQmWithPermit(quote: IQuote.RFQMQuoteStruct, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeSingleHop(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        tradeXChainRFQmWithPermit(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateGovernance(governance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateMigrationRouterStatus(router: PromiseOrValue<string>, status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updatePoolAuthorization(pool: PromiseOrValue<string>, authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        updateXChainUa(xChainUa: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    addLiquidityPrivatePool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    addLiquidityPublicPool(deposit: IQuote.DepositStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    isPoolAuthorized(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    killswitchPool(pool: PromiseOrValue<string>, enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    migratePoolAuthorization(migrationRouter: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    removeLiquidityPublicPool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    removeLiquidityPublicPoolWithPermit(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeMultiHop(quotes: IQuote.RFQTQuoteStruct[], baseToken: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeRFQmWithPermit(quote: IQuote.RFQMQuoteStruct, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeSingleHop(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    tradeXChainRFQmWithPermit(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateGovernance(governance: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateMigrationRouterStatus(router: PromiseOrValue<string>, status: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updatePoolAuthorization(pool: PromiseOrValue<string>, authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    updateXChainUa(xChainUa: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        addLiquidityPrivatePool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        addLiquidityPublicPool(deposit: IQuote.DepositStruct, overrides?: CallOverrides): Promise<void>;
        isPoolAuthorized(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
        killswitchPool(pool: PromiseOrValue<string>, enabled: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        migratePoolAuthorization(migrationRouter: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        removeLiquidityPublicPool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        removeLiquidityPublicPoolWithPermit(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        tradeMultiHop(quotes: IQuote.RFQTQuoteStruct[], baseToken: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: CallOverrides): Promise<void>;
        tradeRFQmWithPermit(quote: IQuote.RFQMQuoteStruct, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        tradeSingleHop(quote: IQuote.RFQTQuoteStruct, overrides?: CallOverrides): Promise<void>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        tradeXChainRFQmWithPermit(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updateGovernance(governance: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        updateMigrationRouterStatus(router: PromiseOrValue<string>, status: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updatePoolAuthorization(pool: PromiseOrValue<string>, authorized: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<void>;
        updateXChainUa(xChainUa: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "UpdateGovernance(address,address)"(governance?: null, prevGovernance?: null): UpdateGovernanceEventFilter;
        UpdateGovernance(governance?: null, prevGovernance?: null): UpdateGovernanceEventFilter;
        "UpdateMigrationRouterStatus(address,bool)"(migrationRouter?: null, authorized?: null): UpdateMigrationRouterStatusEventFilter;
        UpdateMigrationRouterStatus(migrationRouter?: null, authorized?: null): UpdateMigrationRouterStatusEventFilter;
        "UpdatePoolAuthorizaton(address,bool)"(pool?: null, authorized?: null): UpdatePoolAuthorizatonEventFilter;
        UpdatePoolAuthorizaton(pool?: null, authorized?: null): UpdatePoolAuthorizatonEventFilter;
        "UpdateXChainUA(address,address)"(xChainUa?: null, prevXChainUa?: null): UpdateXChainUAEventFilter;
        UpdateXChainUA(xChainUa?: null, prevXChainUa?: null): UpdateXChainUAEventFilter;
    };
    estimateGas: {
        addLiquidityPrivatePool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        addLiquidityPublicPool(deposit: IQuote.DepositStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        isPoolAuthorized(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        killswitchPool(pool: PromiseOrValue<string>, enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        migratePoolAuthorization(migrationRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        removeLiquidityPublicPool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        removeLiquidityPublicPoolWithPermit(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeMultiHop(quotes: IQuote.RFQTQuoteStruct[], baseToken: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeRFQmWithPermit(quote: IQuote.RFQMQuoteStruct, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeSingleHop(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        tradeXChainRFQmWithPermit(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateGovernance(governance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateMigrationRouterStatus(router: PromiseOrValue<string>, status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updatePoolAuthorization(pool: PromiseOrValue<string>, authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        updateXChainUa(xChainUa: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        addLiquidityPrivatePool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        addLiquidityPublicPool(deposit: IQuote.DepositStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        isPoolAuthorized(pool: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        killswitchPool(pool: PromiseOrValue<string>, enabled: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        migratePoolAuthorization(migrationRouter: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        removeLiquidityPublicPool(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        removeLiquidityPublicPoolWithPermit(pool: PromiseOrValue<string>, token: PromiseOrValue<string>, burnAmount: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeMultiHop(quotes: IQuote.RFQTQuoteStruct[], baseToken: PromiseOrValue<string>, quoteToken: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeRFQm(quote: IQuote.RFQMQuoteStruct, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeRFQmWithPermit(quote: IQuote.RFQMQuoteStruct, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeSingleHop(quote: IQuote.RFQTQuoteStruct, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeXChain(quote: IQuote.XChainRFQTQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeXChainRFQm(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        tradeXChainRFQmWithPermit(quote: IQuote.XChainRFQMQuoteStruct, protocol: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, v: PromiseOrValue<BigNumberish>, r: PromiseOrValue<BytesLike>, s: PromiseOrValue<BytesLike>, approveMax: PromiseOrValue<boolean>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateGovernance(governance: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateMigrationRouterStatus(router: PromiseOrValue<string>, status: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updatePoolAuthorization(pool: PromiseOrValue<string>, authorized: PromiseOrValue<boolean>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        updateXChainUa(xChainUa: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
