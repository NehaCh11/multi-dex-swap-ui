"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHexPrefixed = exports.stripHexPrefix = exports.padToEven = exports.hexToBuf = exports.buf2hex = exports.concatRSV = exports.hashMessage = exports.mineBlock = exports.DELAY = void 0;
const hardhat_1 = require("hardhat");
exports.DELAY = 60 * 60 * 24 * 2;
function mineBlock(timestamp) {
    return __awaiter(this, void 0, void 0, function* () {
        return hardhat_1.ethers.provider.send('evm_mine', [timestamp]);
    });
}
exports.mineBlock = mineBlock;
function hashMessage(message) {
    return hardhat_1.ethers.utils.solidityKeccak256(['string'], [message]);
}
exports.hashMessage = hashMessage;
function concatRSV(r, s, v) {
    return ('0x' +
        stripHexPrefix(buf2hex(r)) +
        stripHexPrefix(buf2hex(s)) +
        stripHexPrefix(v.toString(16)));
}
exports.concatRSV = concatRSV;
function buf2hex(input) {
    return '0x' + input.toString('hex');
}
exports.buf2hex = buf2hex;
function hexToBuf(v) {
    const output = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
    return output;
}
exports.hexToBuf = hexToBuf;
function padToEven(a) {
    if (a.length % 2) {
        a = `0${a}`;
    }
    return a;
}
exports.padToEven = padToEven;
function stripHexPrefix(str) {
    return isHexPrefixed(str) ? str.slice(2) : str;
}
exports.stripHexPrefix = stripHexPrefix;
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
exports.isHexPrefixed = isHexPrefixed;
