"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const utils_3 = require("../tasks/utils");
const index_1 = require("../typechain-types/index");
const contracts_1 = require("./contracts");
const xchain_1 = require("../xchain");
const IERC20Factory_1 = require("zksync-web3/build/typechain/IERC20Factory");
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const eth = ZERO_ADDRESS;
let contracts;
let privPoolAddress1;
let privPoolAddress2;
let privPoolContract1;
let privPoolContract2;
describe('X-Chain', () => {
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        contracts = yield contracts_1.ContractFactory.deployContracts();
        const { factory, owner, signer, router, tt1, tt2 } = contracts;
        yield factory.createPool('Hash Capital 1', 'HCL', signer, true);
        yield factory.createPool('Hash Capital 2', 'HCL', signer, true);
        const createPoolEvents = yield factory.queryFilter(factory.filters.CreatePool());
        const pools = createPoolEvents
            .filter((evt) => evt.args.operations === owner)
            .map((evt) => evt.args.pool);
        privPoolAddress1 = pools[0];
        privPoolAddress2 = pools[1];
        privPoolContract1 = yield hardhat_1.ethers.getContractAt('HashflowPrivatePool', privPoolAddress1);
        privPoolContract2 = yield hardhat_1.ethers.getContractAt('HashflowPrivatePool', privPoolAddress2);
        yield privPoolContract1.listAsset(eth);
        yield privPoolContract2.listAsset(eth);
        // Deposit assets into the pool
        yield router.addLiquidityPrivatePool(privPoolAddress1, eth, (0, utils_2.expandTo18Decimals)(10), {
            value: (0, utils_2.expandTo18Decimals)(10),
        });
        yield router.addLiquidityPrivatePool(privPoolAddress2, eth, (0, utils_2.expandTo18Decimals)(10), {
            value: (0, utils_2.expandTo18Decimals)(10),
        });
        yield tt1.approve(router.address, (0, utils_2.expandTo18Decimals)(10000));
        yield tt2.approve(router.address, (0, utils_2.expandTo18Decimals)(10000));
        yield privPoolContract1.listAsset(tt1.address);
        yield privPoolContract2.listAsset(tt1.address);
        yield router.addLiquidityPrivatePool(privPoolAddress1, tt1.address, (0, utils_2.expandTo18Decimals)(10));
        yield router.addLiquidityPrivatePool(privPoolAddress2, tt1.address, (0, utils_2.expandTo18Decimals)(10));
        yield privPoolContract1.listAsset(tt2.address);
        yield privPoolContract2.listAsset(tt2.address);
        yield router.addLiquidityPrivatePool(privPoolAddress1, tt2.address, (0, utils_2.expandTo18Decimals)(10));
        yield router.addLiquidityPrivatePool(privPoolAddress2, tt2.address, (0, utils_2.expandTo18Decimals)(10));
    }));
    describe('Trade', () => __awaiter(void 0, void 0, void 0, function* () {
        it('should trade x-chain', () => __awaiter(void 0, void 0, void 0, function* () {
            const { router, signers, trader, tt1, xChainUa } = contracts;
            const traderRouter = router.connect(signers[3]);
            const { timestamp: now } = yield hardhat_1.ethers.provider.getBlock('latest');
            const txid1 = (0, utils_1.hashMessage)('dgsgevav');
            const txid2 = (0, utils_1.hashMessage)('adjlhlss');
            const quote1 = {
                srcChainId: 1,
                dstChainId: 1,
                srcPool: privPoolAddress1,
                dstPool: '0x' + (0, utils_3.padAddressTo32Bytes)(privPoolAddress2).toString('hex'),
                srcExternalAccount: ZERO_ADDRESS,
                dstExternalAccount: '0x' + (0, utils_3.padAddressTo32Bytes)(ZERO_ADDRESS).toString('hex'),
                trader,
                baseToken: eth,
                quoteToken: tt1.address,
                baseTokenAmount: (0, utils_2.expandTo18Decimals)(1),
                quoteTokenAmount: (0, utils_2.expandTo18Decimals)(5),
                quoteExpiry: now + 60 * 60,
                nonce: now,
                txid: txid1,
            };
            const quote2 = Object.assign(Object.assign({}, quote1), { baseTokenAmount: (0, utils_2.expandTo18Decimals)(1), quoteTokenAmount: (0, utils_2.expandTo18Decimals)(10), nonce: now + 1, txid: txid2 });
            (0, chai_1.expect)(yield privPoolContract1.getReserves(eth)).to.equal((0, utils_2.expandTo18Decimals)(10));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(tt1.address)).to.equal((0, utils_2.expandTo18Decimals)(10));
            yield privPoolContract2.updateXChainPoolAuthorization([
                {
                    chainId: 1,
                    pool: (0, utils_3.padAddressTo32Bytes)(privPoolAddress1),
                },
            ], [xchain_1.XChainProtocol.LAYER_ZERO], // We enable LayerZero only.
            true);
            yield traderRouter.tradeXChain(Object.assign(Object.assign({}, quote1), { signature: yield (0, utils_2.signQuoteXChain)(quote1, signers[2]) }), xchain_1.XChainProtocol.LAYER_ZERO, {
                value: (0, utils_2.expandTo18Decimals)(2),
            });
            yield traderRouter.tradeXChain(Object.assign(Object.assign({}, quote2), { signature: yield (0, utils_2.signQuoteXChain)(quote2, signers[2]) }), xchain_1.XChainProtocol.LAYER_ZERO, {
                value: (0, utils_2.expandTo18Decimals)(2),
            });
            (0, chai_1.expect)(yield privPoolContract1.getReserves(eth)).to.equal((0, utils_2.expandTo18Decimals)(12));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(tt1.address)).to.equal((0, utils_2.expandTo18Decimals)(0));
            // Mints H-Tokens, as quote value is less than pool balance.
            const hTokenAddress = yield privPoolContract2.hTokens(1, tt1.address);
            const hToken = IERC20Factory_1.IERC20Factory.connect(hTokenAddress, signers[0]);
            (0, chai_1.expect)(yield hToken.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(5));
            (0, chai_1.expect)(yield tt1.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(110));
            // Number of H-Tokens minted should be in the event.
            const eventFilter = xChainUa.filters.XChainMessageSuccess();
            const events = yield xChainUa.queryFilter(eventFilter);
            (0, chai_1.expect)(events.length).to.equal(2);
            (0, chai_1.expect)(events[1].args.hToken).to.equal(hTokenAddress);
            (0, chai_1.expect)(events[1].args.hTokenAmountMinted.toString()).to.equal((0, utils_2.expandTo18Decimals)(5).toString());
        }));
        it('should trade x-chain RFQ-m', () => __awaiter(void 0, void 0, void 0, function* () {
            const { router, signers, trader, tt1, tt2 } = contracts;
            const relayerRouter = router.connect(signers[2]);
            const { timestamp: now } = yield hardhat_1.ethers.provider.getBlock('latest');
            const txid = (0, utils_1.hashMessage)('vvvvvv');
            const quote = {
                srcChainId: 1,
                dstChainId: 1,
                srcPool: privPoolAddress1,
                dstPool: '0x' + (0, utils_3.padAddressTo32Bytes)(privPoolAddress2).toString('hex'),
                srcExternalAccount: ZERO_ADDRESS,
                dstExternalAccount: '0x' + (0, utils_3.padAddressTo32Bytes)(ZERO_ADDRESS).toString('hex'),
                trader,
                baseToken: tt1.address,
                quoteToken: tt2.address,
                baseTokenAmount: (0, utils_2.expandTo18Decimals)(5),
                quoteTokenAmount: (0, utils_2.expandTo18Decimals)(5),
                quoteExpiry: now + 60 * 60,
                txid,
            };
            (0, chai_1.expect)(yield privPoolContract1.getReserves(tt1.address)).to.equal((0, utils_2.expandTo18Decimals)(10));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(tt2.address)).to.equal((0, utils_2.expandTo18Decimals)(10));
            // Set allowance for TT1, so that it can be traded.
            yield tt1
                .connect(signers[3])
                .approve(router.address, (0, utils_2.expandTo18Decimals)(10));
            yield relayerRouter.tradeXChainRFQm(Object.assign(Object.assign({}, quote), { takerSignature: yield (0, utils_2.signQuoteXChainRFQMTaker)(quote, 31337, router.address, signers[3]), makerSignature: yield (0, utils_2.signQuoteXChainRFQMMaker)(quote, signers[2]) }), xchain_1.XChainProtocol.LAYER_ZERO, {
                value: (0, utils_2.expandTo18Decimals)(1),
            });
            (0, chai_1.expect)(yield privPoolContract1.getReserves(tt1.address)).to.equal((0, utils_2.expandTo18Decimals)(15));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(tt2.address)).to.equal((0, utils_2.expandTo18Decimals)(5));
            (0, chai_1.expect)(yield tt1.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(105));
            (0, chai_1.expect)(yield tt2.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(105));
            const quote2 = Object.assign(Object.assign({}, quote), { txid: (0, utils_1.hashMessage)(txid) });
            const permitDeadline = now + 60 * 60;
            const permitNonce = 0;
            const permit = yield (0, utils_2.signERC20Permit)(trader, router.address, permitNonce, ethers_1.BigNumber.from(2).pow(256).sub(1), permitDeadline, tt1.address, yield tt1.name(), '1', 31337, signers[3]);
            const r = '0x' + permit.slice(2, 2 + 64);
            const s = '0x' + permit.slice(2 + 64, 2 + 128);
            const v = parseInt(permit.slice(2 + 128, 132), 16);
            yield relayerRouter.tradeXChainRFQmWithPermit(Object.assign(Object.assign({}, quote2), { takerSignature: yield (0, utils_2.signQuoteXChainRFQMTaker)(quote2, 31337, router.address, signers[3]), makerSignature: yield (0, utils_2.signQuoteXChainRFQMMaker)(quote2, signers[2]) }), xchain_1.XChainProtocol.LAYER_ZERO, permitDeadline, v, r, s, true, {
                value: (0, utils_2.expandTo18Decimals)(1),
            });
            (0, chai_1.expect)(yield tt1.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(100));
            (0, chai_1.expect)(yield tt2.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(110));
        }));
        it('should burn H-Tokens for ERC-20 tokens', () => __awaiter(void 0, void 0, void 0, function* () {
            const { signers, trader, tt1 } = contracts;
            const hTokenAddress = yield privPoolContract2.hTokens(1, tt1.address);
            const hToken = IERC20Factory_1.IERC20Factory.connect(hTokenAddress, signers[0]);
            // We cannot redeem until the balance has been replenished.
            yield (0, chai_1.expect)(privPoolContract2
                .connect(signers[3])
                .redeemXChainTokens(tt1.address, (0, utils_2.expandTo18Decimals)(3))).to.be.revertedWith('ERC20: transfer amount exceeds balance');
            // We cannot redeem more than the XC H-Token balance.
            yield tt1.transfer(privPoolAddress2, (0, utils_2.expandTo18Decimals)(10));
            yield (0, chai_1.expect)(privPoolContract2
                .connect(signers[3])
                .redeemXChainTokens(tt1.address, (0, utils_2.expandTo18Decimals)(6))).to.be.revertedWith('ERC20: burn amount exceeds balance');
            yield privPoolContract2
                .connect(signers[3])
                .redeemXChainTokens(tt1.address, (0, utils_2.expandTo18Decimals)(3));
            (0, chai_1.expect)(yield hToken.balanceOf(trader)).to.equal((0, utils_2.expandTo18Decimals)(2));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(tt1.address)).to.equal((0, utils_2.expandTo18Decimals)(7));
            (0, chai_1.expect)(yield hToken.totalSupply()).to.equal((0, utils_2.expandTo18Decimals)(2));
        }));
        it('should burn H-tokens for native tokens', () => __awaiter(void 0, void 0, void 0, function* () {
            const { router, signers, trader, tt1 } = contracts;
            const traderRouter = router.connect(signers[3]);
            const { timestamp: now } = yield hardhat_1.ethers.provider.getBlock('latest');
            const txid = (0, utils_1.hashMessage)('lkhjdfgklh');
            const quote = {
                srcChainId: 1,
                dstChainId: 1,
                srcPool: privPoolAddress1,
                dstPool: '0x' + (0, utils_3.padAddressTo32Bytes)(privPoolAddress2).toString('hex'),
                srcExternalAccount: ZERO_ADDRESS,
                dstExternalAccount: '0x' + (0, utils_3.padAddressTo32Bytes)(ZERO_ADDRESS).toString('hex'),
                trader,
                baseToken: tt1.address,
                quoteToken: eth,
                baseTokenAmount: (0, utils_2.expandTo18Decimals)(2),
                quoteTokenAmount: (0, utils_2.expandTo18Decimals)(15),
                quoteExpiry: now + 60 * 60,
                nonce: now,
                txid,
            };
            (0, chai_1.expect)(yield privPoolContract2.getReserves(eth)).to.equal((0, utils_2.expandTo18Decimals)(10));
            yield traderRouter.tradeXChain(Object.assign(Object.assign({}, quote), { signature: yield (0, utils_2.signQuoteXChain)(quote, signers[2]) }), 0, {
                value: (0, utils_2.expandTo18Decimals)(2),
            });
            const poolBalance = yield privPoolContract2.getReserves(eth);
            (0, chai_1.expect)(poolBalance).to.equal((0, utils_2.expandTo18Decimals)(0));
            yield (0, chai_1.expect)(privPoolContract2
                .connect(signers[3])
                .redeemXChainTokens(eth, (0, utils_2.expandTo18Decimals)(3))).to.be.revertedWith('Address: insufficient balance');
            yield router.addLiquidityPrivatePool(privPoolAddress2, eth, (0, utils_2.expandTo18Decimals)(10), {
                value: (0, utils_2.expandTo18Decimals)(10),
            });
            yield privPoolContract2
                .connect(signers[3])
                .redeemXChainTokens(eth, (0, utils_2.expandTo18Decimals)(3));
            (0, chai_1.expect)(yield privPoolContract2.getReserves(eth)).to.equal((0, utils_2.expandTo18Decimals)(7));
            const ethHTokenAddress = yield privPoolContract2.hTokens(1, eth);
            const ethHToken = IERC20Factory_1.IERC20Factory.connect(ethHTokenAddress, signers[0]);
            (0, chai_1.expect)(yield ethHToken.totalSupply()).to.equal((0, utils_2.expandTo18Decimals)(2));
            (0, chai_1.expect)(yield ethHToken.balanceOf(signers[3].address)).to.equal((0, utils_2.expandTo18Decimals)(2));
        }));
        it('should trade x-chain with external accounts', () => __awaiter(void 0, void 0, void 0, function* () {
            const { mmExternalAccount, mmExternalAccount2, router, trader, tt1, tt2, signers, weth, } = contracts;
            const traderRouter = router.connect(signers[3]);
            const { timestamp: now } = yield hardhat_1.ethers.provider.getBlock('latest');
            const provider = signers[0].provider;
            if (!provider) {
                throw new Error('Could not get provider.');
            }
            const hTokenTt1Address = yield privPoolContract2.hTokens(1, tt1.address);
            const hTokenTt1 = index_1.IHashflowERC20__factory.connect(hTokenTt1Address, signers[0]);
            const txid1 = (0, utils_1.hashMessage)('adfhkjl');
            const quote1 = {
                srcChainId: 1,
                dstChainId: 1,
                srcPool: privPoolAddress1,
                dstPool: '0x' + (0, utils_3.padAddressTo32Bytes)(privPoolAddress2).toString('hex'),
                srcExternalAccount: mmExternalAccount,
                dstExternalAccount: '0x' + (0, utils_3.padAddressTo32Bytes)(mmExternalAccount2).toString('hex'),
                trader,
                baseToken: eth,
                quoteToken: tt1.address,
                baseTokenAmount: (0, utils_2.expandTo18Decimals)(1),
                quoteTokenAmount: (0, utils_2.expandTo18Decimals)(5),
                quoteExpiry: now + 60 * 60,
                nonce: now,
                txid: txid1,
            };
            const traderEthBalance1 = yield provider.getBalance(trader);
            const traderTt1Balance1 = yield tt1.balanceOf(trader);
            const traderHTokenTt1Balance1 = yield hTokenTt1.balanceOf(trader);
            const hTokenTt1Supply1 = yield hTokenTt1.totalSupply();
            const externalAccount1EthBalance1 = yield provider.getBalance(mmExternalAccount);
            const externalAccount1WethBalance1 = yield weth.balanceOf(mmExternalAccount);
            const externalAccount2Tt1Balance1 = yield tt1.balanceOf(mmExternalAccount2);
            yield traderRouter.tradeXChain(Object.assign(Object.assign({}, quote1), { signature: yield (0, utils_2.signQuoteXChain)(quote1, signers[2]) }), xchain_1.XChainProtocol.LAYER_ZERO, {
                value: (0, utils_2.expandTo18Decimals)(2),
            });
            const traderEthBalance2 = yield provider.getBalance(trader);
            const traderTt1Balance2 = yield tt1.balanceOf(trader);
            const traderHTokenTt1Balance2 = yield hTokenTt1.balanceOf(trader);
            const hTokenTt1Supply2 = yield hTokenTt1.totalSupply();
            const externalAccount1EthBalance2 = yield provider.getBalance(mmExternalAccount);
            const externalAccount1WethBalance2 = yield weth.balanceOf(mmExternalAccount);
            const externalAccount2Tt1Balance2 = yield tt1.balanceOf(mmExternalAccount2);
            // externalAccount does not receive ETH, but receives WETH instead.
            (0, chai_1.expect)(externalAccount1EthBalance1).to.equal(externalAccount1EthBalance2);
            (0, chai_1.expect)(externalAccount1WethBalance2.sub(externalAccount1WethBalance1)).to.equal((0, utils_2.expandTo18Decimals)(1));
            // Trader did not receive TT1.
            (0, chai_1.expect)(traderTt1Balance1).to.equal(traderTt1Balance2);
            // Trader received hToken TT1.
            (0, chai_1.expect)(traderHTokenTt1Balance2.sub(traderHTokenTt1Balance1)).to.equal((0, utils_2.expandTo18Decimals)(5));
            // Trader was deducted the ETH.
            (0, chai_1.expect)(traderEthBalance1.sub(traderEthBalance2)).to.be.greaterThanOrEqual((0, utils_2.expandTo18Decimals)(2));
            // Since there is no allowance, H-Tokens were minted.
            (0, chai_1.expect)(hTokenTt1Supply2.sub(hTokenTt1Supply1)).to.equal((0, utils_2.expandTo18Decimals)(5));
            // Nothing was deducted from externalAccount 2.
            (0, chai_1.expect)(externalAccount2Tt1Balance1).to.equal(externalAccount2Tt1Balance2);
            const txid2 = (0, utils_1.hashMessage)(txid1);
            const quote2 = Object.assign(Object.assign({}, quote1), { txid: txid2, nonce: quote1.nonce + 1 });
            // We set allowance for 3 TT1.
            yield tt1
                .connect(signers[6]) // mmExternalAccount2
                .approve(privPoolAddress2, (0, utils_2.expandTo18Decimals)(3));
            yield traderRouter.tradeXChain(Object.assign(Object.assign({}, quote2), { signature: yield (0, utils_2.signQuoteXChain)(quote2, signers[2]) }), 0, {
                value: (0, utils_2.expandTo18Decimals)(2),
            });
            const traderEthBalance3 = yield provider.getBalance(trader);
            const traderTt1Balance3 = yield tt1.balanceOf(trader);
            const traderHTokenTt1Balance3 = yield hTokenTt1.balanceOf(trader);
            const hTokenTt1Supply3 = yield hTokenTt1.totalSupply();
            const externalAccount1EthBalance3 = yield provider.getBalance(mmExternalAccount);
            const externalAccount1WethBalance3 = yield weth.balanceOf(mmExternalAccount);
            const externalAccount2Tt1Balance3 = yield tt1.balanceOf(mmExternalAccount2);
            // externalAccount does not receive ETH, but receives WETH instead.
            (0, chai_1.expect)(externalAccount1EthBalance2).to.equal(externalAccount1EthBalance3);
            (0, chai_1.expect)(externalAccount1WethBalance3.sub(externalAccount1WethBalance2)).to.equal((0, utils_2.expandTo18Decimals)(1));
            // Trader received part of TT1.
            (0, chai_1.expect)(traderTt1Balance3.sub(traderTt1Balance2)).to.equal((0, utils_2.expandTo18Decimals)(3));
            // Trader received hToken TT1.
            (0, chai_1.expect)(traderHTokenTt1Balance3.sub(traderHTokenTt1Balance2)).to.equal((0, utils_2.expandTo18Decimals)(2));
            // Trader was deducted the ETH.
            (0, chai_1.expect)(traderEthBalance2.sub(traderEthBalance3)).to.be.greaterThanOrEqual((0, utils_2.expandTo18Decimals)(2));
            // Allowance was set for 3 TT1, so 2 were minted.
            (0, chai_1.expect)(hTokenTt1Supply3.sub(hTokenTt1Supply2)).to.equal((0, utils_2.expandTo18Decimals)(2));
            // Some TT1 was deducated from externalAccount2.
            (0, chai_1.expect)(externalAccount2Tt1Balance2.sub(externalAccount2Tt1Balance3)).to.equal((0, utils_2.expandTo18Decimals)(3));
            const txid3 = (0, utils_1.hashMessage)(txid2);
            const quote3 = Object.assign(Object.assign({}, quote2), { baseToken: tt2.address, txid: txid3, nonce: quote2.nonce + 1 });
            yield tt2
                .connect(signers[3])
                .approve(traderRouter.address, (0, utils_2.expandTo18Decimals)(1));
            yield tt1
                .connect(signers[6]) // mmExternalAccount2
                .approve(privPoolAddress2, (0, utils_2.expandTo18Decimals)(5));
            yield traderRouter.tradeXChainRFQm(Object.assign(Object.assign({}, quote3), { takerSignature: (0, utils_2.signQuoteXChainRFQMTaker)(quote3, 31337, traderRouter.address, signers[3]), makerSignature: (0, utils_2.signQuoteXChainRFQMMaker)(quote3, signers[2]) }), 0, {
                value: (0, utils_2.expandTo18Decimals)(1),
            });
            const traderEthBalance4 = yield provider.getBalance(trader);
            const traderTt1Balance4 = yield tt1.balanceOf(trader);
            const traderHTokenTt1Balance4 = yield hTokenTt1.balanceOf(trader);
            const hTokenTt1Supply4 = yield hTokenTt1.totalSupply();
            const externalAccount1EthBalance4 = yield provider.getBalance(mmExternalAccount);
            const externalAccount1WethBalance4 = yield weth.balanceOf(mmExternalAccount);
            const externalAccount2Tt1Balance4 = yield tt1.balanceOf(mmExternalAccount2);
            (0, chai_1.expect)(traderEthBalance3.sub(traderEthBalance4)).to.be.greaterThanOrEqual((0, utils_2.expandTo18Decimals)(1));
            (0, chai_1.expect)(traderTt1Balance4.sub(traderTt1Balance3)).to.equal((0, utils_2.expandTo18Decimals)(5));
            (0, chai_1.expect)(traderHTokenTt1Balance4).to.equal(traderHTokenTt1Balance3);
            (0, chai_1.expect)(hTokenTt1Supply4).to.equal(hTokenTt1Supply3);
            (0, chai_1.expect)(externalAccount1EthBalance4).to.equal(externalAccount1EthBalance3);
            (0, chai_1.expect)(externalAccount1WethBalance4).to.equal(externalAccount1WethBalance3);
            (0, chai_1.expect)(externalAccount2Tt1Balance3.sub(externalAccount2Tt1Balance4)).to.equal((0, utils_2.expandTo18Decimals)(5));
        }));
        it('should withdraw funds', () => __awaiter(void 0, void 0, void 0, function* () {
            const { xChainUa, signers, tt1 } = contracts;
            const provider = signers[0].provider;
            if (!provider) {
                throw new Error(`Missing provider`);
            }
            const balanceUa1 = yield provider.getBalance(xChainUa.address);
            const tokenBalanceUa1 = yield tt1.balanceOf(xChainUa.address);
            yield signers[0].sendTransaction({
                to: xChainUa.address,
                value: 1000000,
            });
            yield tt1.transfer(xChainUa.address, 1000000);
            const balanceUa2 = yield provider.getBalance(xChainUa.address);
            const tokenBalanceUa2 = yield tt1.balanceOf(xChainUa.address);
            yield xChainUa.withdrawFunds(eth);
            yield xChainUa.withdrawFunds(tt1.address);
            const balanceUa3 = yield provider.getBalance(xChainUa.address);
            const tokenBalanceUa3 = yield tt1.balanceOf(xChainUa.address);
            (0, chai_1.expect)(balanceUa2.sub(balanceUa1)).to.equal(1000000);
            (0, chai_1.expect)(balanceUa3).to.equal(0);
            (0, chai_1.expect)(tokenBalanceUa2.sub(tokenBalanceUa1)).to.equal(1000000);
            (0, chai_1.expect)(tokenBalanceUa3).to.equal(0);
        }));
    }));
});
