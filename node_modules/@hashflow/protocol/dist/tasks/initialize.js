"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomicfoundation/hardhat-toolbox");
const config_1 = require("hardhat/config");
const networks_1 = require("../networks");
const index_1 = require("../typechain-types/index");
const utils_1 = require("./utils");
(0, config_1.task)('initialize:all', 'Initializes all contracts').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('initialize:governance:all');
    yield hre.run('initialize:factory:all');
    yield hre.run('initialize:xchainua:all');
    yield hre.run('initialize:router:all');
}));
(0, config_1.task)('initialize:governance:all', 'Initializes the Governance Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('initialize:governance:router');
    yield hre.run('initialize:governance:factory');
    yield hre.run('initialize:governance:xchainua');
    yield hre.run('initialize:governance:withdrawperiod');
    yield hre.run('initialize:governance:withdrawlimit');
}));
(0, config_1.task)('initialize:factory:all', 'Initializes the Factory Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('initialize:factory:privpoolfactory');
    yield hre.run('initialize:factory:privpool');
    yield hre.run('initialize:factory:pubpoolfactory');
    yield hre.run('initialize:factory:pubpool');
    yield hre.run('initialize:factory:htoken');
}));
(0, config_1.task)('initialize:xchainua:all', 'Initializes the X-Chain UA').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('initialize:xchainua:router');
    yield hre.run('initialize:xchainua:layerzero-endpoint');
    yield hre.run('initialize:xchainua:layerzero-gas-estimate');
    yield hre.run('initialize:xchainua:wormhole-endpoint');
    yield hre.run('initialize:xchainua:wormhole-consistency');
    yield hre.run('initialize:xchainua:peer-networks');
    yield hre.run('initialize:xchainua:remotes');
}));
(0, config_1.task)('initialize:router:all', 'Initializes the Router').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('initialize:router:xchainua');
}));
(0, config_1.task)('initialize:governance:router', 'Initializes the Router Address in the Governance Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowGovernance = index_1.IHashflowGovernance__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowGovernance'), (yield hre.ethers.getSigners())[0]);
    const routerAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowRouter');
    const currentRouterAddress = yield hashflowGovernance.router();
    if (routerAddress.toLowerCase() !== currentRouterAddress.toLowerCase()) {
        yield (yield hashflowGovernance.updateRouter(routerAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.GOVERNANCE_CONTRACT)('Updated Router');
    }
}));
(0, config_1.task)('initialize:governance:factory', 'Initializes the Factory Address in the Governance Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowGovernance = index_1.IHashflowGovernance__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowGovernance'), (yield hre.ethers.getSigners())[0]);
    const currentFactoryAddress = yield hashflowGovernance.factory();
    const factoryAddress = zksync
        ? (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactoryZkSync')
        : (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactory');
    if (currentFactoryAddress.toLowerCase() !== factoryAddress.toLowerCase()) {
        yield (yield hashflowGovernance.updateFactory(factoryAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.GOVERNANCE_CONTRACT)('Updated Factory');
    }
}));
(0, config_1.task)('initialize:governance:xchainua', 'Initializes the X-Chain UA Address in the Governance Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowGovernance = index_1.IHashflowGovernance__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowGovernance'), (yield hre.ethers.getSigners())[0]);
    const xChainUaAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA');
    const currentXChainUa = yield hashflowGovernance.xChainUa();
    if (currentXChainUa.toLowerCase() !== xChainUaAddress.toLowerCase()) {
        yield (yield hashflowGovernance.updateXChainUa(xChainUaAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.GOVERNANCE_CONTRACT)('Updated X-Chain UA');
    }
}));
(0, config_1.task)('initialize:governance:withdrawperiod', 'Initializes the Public Pool Withdraw Period').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowGovernance = index_1.IHashflowGovernance__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowGovernance'), (yield hre.ethers.getSigners())[0]);
    const currentWithdrawPeriod = yield hashflowGovernance.withdrawPeriod();
    const WITHDRAW_PERIOD = 604800;
    if (currentWithdrawPeriod.toNumber() !== WITHDRAW_PERIOD) {
        yield (yield hashflowGovernance.updateWithdrawPeriod(WITHDRAW_PERIOD)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.GOVERNANCE_CONTRACT)(`Set Withdraw Period to ${WITHDRAW_PERIOD}`);
    }
}));
(0, config_1.task)('initialize:governance:withdrawlimit', 'Initializes the Public Pool Withdrawal Limit').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowGovernance = index_1.IHashflowGovernance__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowGovernance'), (yield hre.ethers.getSigners())[0]);
    const currentPercentWithdrawLimit = yield hashflowGovernance.percentWithdrawLimit();
    const WITHDRAW_LIMIT_PERCENT = 30;
    if (currentPercentWithdrawLimit.toNumber() !== WITHDRAW_LIMIT_PERCENT) {
        yield (yield hashflowGovernance.updatePercentWithdrawLimit(WITHDRAW_LIMIT_PERCENT)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.GOVERNANCE_CONTRACT)(`Set Withdrawal Limit to ${WITHDRAW_LIMIT_PERCENT}%`);
    }
}));
(0, config_1.task)('initialize:factory:privpool', 'Initializes the Private Pool Implementation Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (zksync) {
        return;
    }
    const hashflowFactory = index_1.HashflowFactory__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactory'), (yield hre.ethers.getSigners())[0]);
    const currentPrivatePoolAddress = yield hashflowFactory._privatePoolImpl();
    const privPoolAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowPrivatePool');
    if (currentPrivatePoolAddress.toLowerCase() !== privPoolAddress.toLowerCase()) {
        yield (yield hashflowFactory.updatePrivatePoolImpl(privPoolAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Updated Private Pool Implementation to ${privPoolAddress}`);
    }
}));
(0, config_1.task)('initialize:factory:privpoolfactory', 'Sets the Private Pool Factory (for ZkSync)').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (!zksync) {
        return;
    }
    const hashflowFactory = index_1.HashflowFactoryZkSync__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactoryZkSync'), (yield hre.ethers.getSigners())[0]);
    const currentPrivatePoolFactoryAddress = yield hashflowFactory.privatePoolFactory();
    const privatePoolFactoryAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowPrivatePoolFactoryZkSync');
    if (currentPrivatePoolFactoryAddress.toLowerCase() !==
        privatePoolFactoryAddress.toLowerCase()) {
        yield (yield hashflowFactory.updatePrivatePoolFactory(privatePoolFactoryAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Updated Private Pool Factory to ${privatePoolFactoryAddress}`);
    }
    else {
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Skipping Private Pool Factory update.`);
    }
}));
(0, config_1.task)('initialize:factory:pubpool', 'Initializes the Public Pool Implementation Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (zksync) {
        return;
    }
    const hashflowFactory = index_1.HashflowFactory__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactory'), (yield hre.ethers.getSigners())[0]);
    const currentPublicPoolAddress = yield hashflowFactory._publicPoolImpl();
    const pubPoolAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowPublicPool');
    if (currentPublicPoolAddress.toLowerCase() !== pubPoolAddress.toLowerCase()) {
        yield (yield hashflowFactory.updatePublicPoolImpl(pubPoolAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Updated Public Pool Implementation to ${pubPoolAddress}`);
    }
}));
(0, config_1.task)('initialize:factory:pubpoolfactory', 'Sets the Public Pool Factory (for ZkSync)').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (!zksync) {
        return;
    }
    const hashflowFactory = index_1.HashflowFactoryZkSync__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactoryZkSync'), (yield hre.ethers.getSigners())[0]);
    const currentPublicPoolFactoryAddress = yield hashflowFactory.publicPoolFactory();
    const publicPoolFactoryAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowPublicPoolFactoryZkSync');
    if (currentPublicPoolFactoryAddress.toLowerCase() !==
        publicPoolFactoryAddress.toLowerCase()) {
        yield (yield hashflowFactory.updatePublicPoolFactory(publicPoolFactoryAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Updated Public Pool Factory to ${publicPoolFactoryAddress}`);
    }
    else {
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Skipping Public Pool Factory update.`);
    }
}));
(0, config_1.task)('initialize:factory:htoken', 'Initializes the H-Token Implementation Contract').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, zksync } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (zksync) {
        return;
    }
    const hashflowFactory = index_1.HashflowFactory__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowFactory'), (yield hre.ethers.getSigners())[0]);
    const currentHTokenAddress = yield hashflowFactory._hTokenImpl();
    const hTokenAddress = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowERC20');
    if (currentHTokenAddress.toLowerCase() !== hTokenAddress.toLowerCase()) {
        yield (yield hashflowFactory.updateHTokenImpl(hTokenAddress)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.FACTORY_CONTRACT)(`Updated H-Token Implementation to ${hTokenAddress}`);
    }
}));
(0, config_1.task)('initialize:xchainua:layerzero-endpoint', 'Initializes the LayerZero endpoint').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    const layerZeroEndpoint = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].layerZeroEndpoint;
    if (layerZeroEndpoint) {
        const currentlySetLayerZeroEndpoint = yield hashflowXChainUa.lzEndpoint();
        if (currentlySetLayerZeroEndpoint !== layerZeroEndpoint) {
            yield (yield hashflowXChainUa.updateLzEndpoint(layerZeroEndpoint)).wait();
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set LayerZero endpoint to ${layerZeroEndpoint}`);
        }
    }
}));
(0, config_1.task)('initialize:xchainua:layerzero-gas-estimate', 'Initializes the LayerZero endpoint').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    const layerZeroGasEstimate = 100000;
    const currentlySetLayerZeroGasEstimate = yield hashflowXChainUa.lzGasEstimate();
    if (currentlySetLayerZeroGasEstimate.toNumber() !== layerZeroGasEstimate) {
        yield (yield hashflowXChainUa.updateLzGasEstimate(layerZeroGasEstimate)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set LayerZero gas estimate to ${layerZeroGasEstimate}`);
    }
}));
(0, config_1.task)('initialize:xchainua:wormhole-endpoint', 'Initializes the Wormhole endpoint').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    const wormholeEndpoint = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].wormholeEndpoint;
    if (wormholeEndpoint) {
        const currentlySetWormholeEndpoint = yield hashflowXChainUa.wormholeEndpoint();
        if (currentlySetWormholeEndpoint !== wormholeEndpoint) {
            yield (yield hashflowXChainUa.updateWormhole(wormholeEndpoint)).wait();
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set Wormhole endpoint to ${wormholeEndpoint}`);
        }
    }
}));
(0, config_1.task)('initialize:xchainua:wormhole-consistency', 'Initializes the Wormhole consistency for this chain').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    const wormholeConsistency = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].wormholeConsistency;
    if (wormholeConsistency) {
        const currentlySetWormholeConsistency = yield hashflowXChainUa.wormholeConsistencyLevel();
        if (currentlySetWormholeConsistency !== wormholeConsistency) {
            yield (yield hashflowXChainUa.updateWormholeConsistencyLevel(wormholeConsistency)).wait();
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set Wormhole Consistency Level to ${wormholeConsistency}`);
        }
        else {
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Skipping Wormhole Consistency Level setting. Not changed.`);
        }
    }
    else {
        yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Skipping Wormhole Consistency Level setting. Not available.`);
    }
}));
(0, config_1.task)('initialize:xchainua:router', 'Initializes the Router').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    const currentRouter = yield hashflowXChainUa.router();
    const updatedRouter = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowRouter');
    if (currentRouter !== updatedRouter) {
        yield (yield hashflowXChainUa.updateRouter(updatedRouter)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Updated Router to ${updatedRouter}`);
    }
}));
(0, config_1.task)('initialize:xchainua:peer-networks', 'Initializes data relayed to peer networks for X-Chain swaps').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const peerNetworksToInitialize = (0, utils_1.isHardhatMainnet)(networkName)
        ? networks_1.MAIN_NETWORK_NAMES
        : (0, utils_1.isHardhatTestnet)(networkName)
            ? networks_1.TEST_NETWORK_NAMES
            : (0, utils_1.isWormholeTestnet)(networkName)
                ? networks_1.WORMHOLE_NETWORK_NAMES
                : [networkName];
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    for (const peerNetworkName of peerNetworksToInitialize) {
        const peerHashflowChainId = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[peerNetworkName].hashflowChainId;
        const peerLayerZeroChainId = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[peerNetworkName].layerZeroChainId;
        const currentLayerZeroChainId = yield hashflowXChainUa.hChainIdToLzChainId(peerHashflowChainId);
        if (peerLayerZeroChainId &&
            currentLayerZeroChainId !== peerLayerZeroChainId) {
            yield (yield hashflowXChainUa.updateLzChainIdForHashflowChainId(peerHashflowChainId, peerLayerZeroChainId)).wait();
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set LZ Chain ID ${peerLayerZeroChainId} for Hashflow Chain ID ${peerHashflowChainId}`);
        }
        else {
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Skipping LZ Chain ID initialization to ${peerHashflowChainId}`);
        }
        const peerWormholeChainId = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[peerNetworkName].wormholeChainId;
        const currentWormholeChainId = yield hashflowXChainUa.hChainIdToWormholeChainId(peerHashflowChainId);
        if (peerWormholeChainId && currentWormholeChainId !== peerWormholeChainId) {
            yield (yield hashflowXChainUa.updateWormholeChainIdForHashflowChainId(peerHashflowChainId, peerWormholeChainId)).wait();
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set Wormhole Chain ID ${peerWormholeChainId} for Hashflow Chain ID ${peerHashflowChainId}`);
        }
        else {
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Skipping Wormhole Chain ID initialization to ${peerHashflowChainId}`);
        }
    }
}));
(0, config_1.task)('initialize:xchainua:remotes', 'Initializes the X-Chain Remotes').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const peerNetworksToInitialize = (0, utils_1.isHardhatMainnet)(networkName)
        ? networks_1.MAIN_NETWORK_NAMES
        : (0, utils_1.isHardhatTestnet)(networkName)
            ? networks_1.TEST_NETWORK_NAMES
            : (0, utils_1.isWormholeTestnet)(networkName)
                ? networks_1.WORMHOLE_NETWORK_NAMES
                : [networkName];
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    for (const peerNetworkName of peerNetworksToInitialize) {
        if (peerNetworkName === networkName) {
            continue;
        }
        const config = hre.config.networks[peerNetworkName];
        if (!config) {
            throw new Error(`Could not find Hardhat Config for network ${peerNetworkName}`);
        }
        const peerChainId = config.chainId;
        if (!peerChainId) {
            throw new Error(`Hardhat Network ${peerNetworkName} does not have a Chain ID.`);
        }
        const peerHashflowChainId = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[peerNetworkName].hashflowChainId;
        if ((0, utils_1.hasDeployedContractAddress)(peerChainId, 'HashflowXChainUA')) {
            const peerXChainUaAddress = (0, utils_1.getDeployedContractAddress)(peerChainId, 'HashflowXChainUA');
            const currentRemote = yield hashflowXChainUa.xchainRemotes(peerHashflowChainId);
            if (currentRemote.toLowerCase() !== peerXChainUaAddress.toLowerCase()) {
                yield (yield hashflowXChainUa.updateXChainRemoteAddress(peerHashflowChainId, peerXChainUaAddress)).wait();
                yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set X-Chain authorization to ${peerHashflowChainId}:${peerXChainUaAddress}`);
            }
            else {
                yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Chain ${peerHashflowChainId} remote already set. Skipping.`);
            }
        }
        else {
            yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Chain ${peerHashflowChainId} does not have a remote. Skipping.`);
        }
    }
}));
(0, config_1.task)('initialize:xchainua:layerzero-send-receive-version', 'Sets an explicit send/receive version for LayerZero')
    .addParam('layerZeroVersion', 'The Send / Receive version')
    .setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const lzVersion = Number(taskArgs.layerZeroVersion);
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    if (isNaN(lzVersion)) {
        throw new Error(`Invalid version`);
    }
    const hashflowXChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), (yield hre.ethers.getSigners())[0]);
    yield (yield hashflowXChainUa.setSendVersion(lzVersion)).wait();
    yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set Send Version to ${lzVersion}`);
    yield (yield hashflowXChainUa.setReceiveVersion(lzVersion)).wait();
    yield (0, utils_1.hlog)(hre, utils_1.XCHAIN_UA_CONTRACT)(`Set Receive Version to ${lzVersion}`);
}));
(0, config_1.task)('initialize:router:xchainua', 'Initializes the X-Chain UA in the Router').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_1.getHardhatRuntimeNetworkParams)(hre);
    const hashflowRouter = index_1.HashflowRouter__factory.connect((0, utils_1.getDeployedContractAddress)(chainId, 'HashflowRouter'), (yield hre.ethers.getSigners())[0]);
    const currentXChainUa = yield hashflowRouter._xChainUa();
    const updatedXChainUa = (0, utils_1.getDeployedContractAddress)(chainId, 'HashflowXChainUA');
    if (currentXChainUa.toLowerCase() !== updatedXChainUa.toLowerCase()) {
        yield (yield hashflowRouter.updateXChainUa(updatedXChainUa)).wait();
        yield (0, utils_1.hlog)(hre, utils_1.ROUTER_CONTRACT)(`Updated X-Chain UA to ${updatedXChainUa}`);
    }
}));
