"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WETH9_CONTRACT = exports.H_TOKEN_CONTRACT = exports.PUB_POOL_CONTRACT = exports.PRIV_POOL_CONTRACT = exports.XCHAIN_UA_CONTRACT = exports.ROUTER_CONTRACT = exports.FACTORY_CONTRACT = exports.GOVERNANCE_CONTRACT = exports.sleep = exports.hlog = exports.padAddressTo32Bytes = exports.isWormholeTestnet = exports.isHardhatTestnet = exports.isHardhatMainnet = exports.deployZkSyncContract = exports.deployContract = exports.getDeployedContractAddress = exports.hasDeployedContractAddress = exports.getHardhatRuntimeNetworkParams = void 0;
const fs_1 = __importDefault(require("fs"));
const zksync_web3_1 = require("zksync-web3");
const hardhat_zksync_deploy_1 = require("@matterlabs/hardhat-zksync-deploy");
const networks_1 = require("../networks");
function getHardhatRuntimeNetworkParams(hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const networkName = hre.hardhatArguments.network;
        if (!networkName) {
            throw new Error(`Could not resolve network.`);
        }
        const chainId = (yield hre.ethers.provider.getNetwork()).chainId;
        const networkConfig = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName];
        return {
            networkName,
            chainId,
            zksync: networkConfig.zksync,
        };
    });
}
exports.getHardhatRuntimeNetworkParams = getHardhatRuntimeNetworkParams;
function hasDeployedContractAddress(chainId, contractName) {
    const deployedContracts = JSON.parse(fs_1.default.readFileSync('deployed.json').toString());
    const contractInfo = deployedContracts[contractName];
    if (!contractInfo) {
        return false;
    }
    const chainDeploymentInfo = contractInfo[chainId];
    if (!chainDeploymentInfo) {
        return false;
    }
    const address = chainDeploymentInfo.address;
    if (!address) {
        return false;
    }
    return true;
}
exports.hasDeployedContractAddress = hasDeployedContractAddress;
function getDeployedContractAddress(chainId, contractName) {
    const deployedContracts = JSON.parse(fs_1.default.readFileSync('deployed.json').toString());
    const contractInfo = deployedContracts[contractName];
    if (!contractInfo) {
        throw new Error(`Could not find contract ${contractName}`);
    }
    const chainDeploymentInfo = contractInfo[chainId];
    if (!chainDeploymentInfo) {
        throw new Error(`Contract ${contractName} not deployed on chain ${chainId}`);
    }
    const address = chainDeploymentInfo.address;
    if (!address) {
        throw new Error(`Missing address for contract ${contractName} on chain ${chainId}`);
    }
    return address;
}
exports.getDeployedContractAddress = getDeployedContractAddress;
function deployContract(hre, name, deploymentFunc) {
    return __awaiter(this, void 0, void 0, function* () {
        yield hlog(hre, name)('Deploying');
        const factory = (yield hre.ethers.getContractFactory(name));
        const contract = yield deploymentFunc(factory);
        yield contract.deployed();
        yield hlog(hre, name)(`Deployed to ${contract.address}`);
        yield parseContract(hre, name, contract);
    });
}
exports.deployContract = deployContract;
function deployZkSyncContract(hre, name, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
constructorArguments = []) {
    return __awaiter(this, void 0, void 0, function* () {
        yield hlog(hre, name)('Deploying');
        const privateKey = process.env.PRIVATE_KEY;
        if (!privateKey) {
            throw new Error(`Missing Private Key`);
        }
        const zkSyncWallet = new zksync_web3_1.Wallet(privateKey);
        const zkSyncDeployer = new hardhat_zksync_deploy_1.Deployer(hre, zkSyncWallet);
        const contractArtifact = yield zkSyncDeployer.loadArtifact(name);
        const contract = yield zkSyncDeployer.deploy(contractArtifact, constructorArguments);
        yield parseContract(hre, name, contract);
    });
}
exports.deployZkSyncContract = deployZkSyncContract;
function isHardhatMainnet(networkName) {
    return networks_1.MAIN_NETWORK_NAMES.includes(networkName);
}
exports.isHardhatMainnet = isHardhatMainnet;
function isHardhatTestnet(networkName) {
    return networks_1.TEST_NETWORK_NAMES.includes(networkName);
}
exports.isHardhatTestnet = isHardhatTestnet;
function isWormholeTestnet(networkName) {
    return networks_1.WORMHOLE_NETWORK_NAMES.includes(networkName);
}
exports.isWormholeTestnet = isWormholeTestnet;
function parseContract(hre, contractName, contract) {
    return __awaiter(this, void 0, void 0, function* () {
        const { chainId } = yield getHardhatRuntimeNetworkParams(hre);
        yield hlog(hre, contractName)(`Parsing at address ${contract.address}`);
        const deployedContracts = JSON.parse(fs_1.default.readFileSync('deployed.json').toString());
        const info = {
            contractName: contractName,
            networks: {},
        };
        if (!deployedContracts[contractName]) {
            deployedContracts[contractName] = {};
        }
        deployedContracts[contractName][chainId] = {
            address: contract.address,
            transactionHash: contract.deployTransaction.hash,
        };
        info.networks = deployedContracts[contractName];
        info.networks[chainId] = {
            address: contract.address,
            transactionHash: contract.deployTransaction.hash,
        };
        fs_1.default.writeFileSync(`published_contracts/${contractName}.json`, JSON.stringify(info, null, 2));
        yield hlog(hre, contractName)(`Wrote ${contractName}.json`);
        fs_1.default.writeFileSync('deployed.json', JSON.stringify(deployedContracts, null, 2) + '\n');
        yield hlog(hre, contractName)(`Wrote deployed.json`);
    });
}
function padAddressTo32Bytes(address) {
    const strAddress = address.toString();
    let paddedAddress = strAddress.indexOf('0x') === -1 ? strAddress : strAddress.slice(2);
    while (paddedAddress.length < 64) {
        paddedAddress = `00${paddedAddress}`;
    }
    return Buffer.from(paddedAddress, 'hex');
}
exports.padAddressTo32Bytes = padAddressTo32Bytes;
function hlog(hre, contractName) {
    return (msg) => __awaiter(this, void 0, void 0, function* () {
        const { chainId, networkName } = yield getHardhatRuntimeNetworkParams(hre);
        console.log(`[${networkName}][${chainId}][${contractName}] ${msg}`);
    });
}
exports.hlog = hlog;
function sleep(timeMs) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            setTimeout(() => resolve(), timeMs);
        });
    });
}
exports.sleep = sleep;
exports.GOVERNANCE_CONTRACT = 'HashflowGovernance';
exports.FACTORY_CONTRACT = 'HashflowFactory';
exports.ROUTER_CONTRACT = 'HashflowRouter';
exports.XCHAIN_UA_CONTRACT = 'HashflowXChainUA';
exports.PRIV_POOL_CONTRACT = 'HashflowPrivPool';
exports.PUB_POOL_CONTRACT = 'HashflowSpotPubPool';
exports.H_TOKEN_CONTRACT = 'HashflowERC20';
exports.WETH9_CONTRACT = 'WETH9';
