"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("@nomicfoundation/hardhat-toolbox");
const ethers_1 = require("ethers");
const config_1 = require("hardhat/config");
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const utils_1 = require("../utils");
const utils_2 = require("../tasks/utils");
const index_1 = require("../typechain-types/index");
const networks_1 = require("../networks");
const utils_3 = require("../utils");
const xchain_1 = require("../xchain");
const WORMHOLE_METADATA_FILE_PATH = 'wormhole_test_metadata.json';
const POOL_ADDRESS = '0x24E36dd26156cBf9C723d4E1D46De176b0DEC3bA';
function getSigners(hre) {
    return __awaiter(this, void 0, void 0, function* () {
        const allSigners = yield hre.ethers.getSigners();
        return {
            mainSigner: allSigners[0],
            quoteSigner: allSigners[1],
            traderSigner: allSigners[2],
        };
    });
}
(0, config_1.task)('wormhole:trade', 'Trades the first leg of X-Chain.').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkName, chainId } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner, traderSigner, quoteSigner } = yield getSigners(hre);
    const provider = mainSigner.provider;
    if (!provider) {
        throw new Error(`Could not get provider.`);
    }
    const wormholeBridgeAddress = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].wormholeEndpoint;
    if (!wormholeBridgeAddress) {
        throw new Error(`Wormhole endpoint not configured.`);
    }
    const wormholeChainId = networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].wormholeChainId;
    if (!wormholeChainId) {
        throw new Error(`Wormhole chain ID not configured.`);
    }
    const wormholeNetworks = [networks_1.WORMHOLE1, networks_1.WORMHOLE2];
    const otherWormholeNetwork = wormholeNetworks.filter((n) => n.name !== networkName)[0];
    const router = index_1.IHashflowRouter__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'HashflowRouter'), traderSigner);
    const blockNumber = yield provider.getBlockNumber();
    const block = yield provider.getBlock(blockNumber);
    const poolBytes32 = (0, utils_2.padAddressTo32Bytes)(POOL_ADDRESS);
    const quoteExpiry = block.timestamp + 60 * 5; // 5 minutes
    const txid = Buffer.from(ethers_1.utils.keccak256(Buffer.from(`abcdef${Date.now()}`)).slice(2), 'hex');
    const nonce = Date.now();
    const xChainQuoteData = {
        srcChainId: networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].hashflowChainId,
        dstChainId: otherWormholeNetwork.hashflowChainId,
        srcPool: POOL_ADDRESS,
        dstPool: '0x' + poolBytes32.toString('hex'),
        srcExternalAccount: utils_1.ZERO_ADDRESS,
        dstExternalAccount: '0x' + (0, utils_2.padAddressTo32Bytes)(utils_1.ZERO_ADDRESS).toString('hex'),
        trader: yield traderSigner.getAddress(),
        baseToken: (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'),
        quoteToken: (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'),
        baseTokenAmount: ethers_1.BigNumber.from('2000000'),
        quoteTokenAmount: ethers_1.BigNumber.from('1000000'),
        quoteExpiry,
        nonce,
        txid: '0x' + txid.toString('hex'),
    };
    const signature = yield (0, utils_3.signQuoteXChain)(xChainQuoteData, quoteSigner);
    const quote = {
        srcChainId: networks_1.HARDHAT_NETWORK_CONFIG_BY_NAME[networkName].hashflowChainId,
        dstChainId: otherWormholeNetwork.hashflowChainId,
        srcPool: POOL_ADDRESS,
        dstPool: poolBytes32,
        srcExternalAccount: utils_1.ZERO_ADDRESS,
        dstExternalAccount: (0, utils_2.padAddressTo32Bytes)(utils_1.ZERO_ADDRESS),
        trader: yield traderSigner.getAddress(),
        baseToken: (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'),
        quoteToken: (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'),
        baseTokenAmount: '2000000',
        quoteTokenAmount: '1000000',
        quoteExpiry,
        nonce,
        txid,
        signature,
    };
    const tx = yield (yield router.tradeXChain(quote, xchain_1.XChainProtocol.WORMHOLE)).wait();
    const emitterAddr = (0, utils_2.padAddressTo32Bytes)((0, utils_2.getDeployedContractAddress)(chainId, 'HashflowXChainUA')).toString('hex');
    const wormholeEndpoint = index_1.IWormhole__factory.connect(wormholeBridgeAddress, mainSigner);
    const filter = wormholeEndpoint.filters.LogMessagePublished();
    const logs = yield wormholeEndpoint.queryFilter(filter, tx.blockNumber, tx.blockNumber);
    const txnLogs = logs.filter((l) => l.transactionHash === tx.transactionHash);
    if (txnLogs.length === 0) {
        throw new Error(`Could not find log.`);
    }
    const seq = txnLogs[0].args.sequence.toString();
    const vaaResponse = yield axios_1.default.get(`http://localhost:7071/v1/signed_vaa/${wormholeChainId}/${emitterAddr}/${seq}`);
    if (!(vaaResponse === null || vaaResponse === void 0 ? void 0 : vaaResponse.data)) {
        throw new Error(`Could not fetch VAA from Guardians.`);
    }
    const vaaBytes = vaaResponse.data.vaaBytes;
    if (!vaaBytes) {
        throw new Error(`Could not extract VAA`);
    }
    const payload = {
        vaaBytes,
        txid: '0x' + txid.toString('hex'),
        trader: yield traderSigner.getAddress(),
        quoteToken: (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'),
        quoteTokenAmount: quote.quoteTokenAmount.toString(),
        pool: POOL_ADDRESS,
    };
    fs_1.default.writeFileSync(WORMHOLE_METADATA_FILE_PATH, JSON.stringify(payload, null, 4));
    console.log('Gas Used', tx.gasUsed.toString());
    console.log(`Wrote`, JSON.stringify(payload, null, 4));
}));
(0, config_1.task)('wormhole:relay', 'Relays the VAA on the destination chain').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner } = yield getSigners(hre);
    const metadata = JSON.parse(fs_1.default.readFileSync(WORMHOLE_METADATA_FILE_PATH).toString());
    const quoteToken = index_1.IERC20__factory.connect(metadata.quoteToken, mainSigner);
    const traderBalanceBefore = yield quoteToken.balanceOf(metadata.trader);
    const poolBalanceBefore = yield quoteToken.balanceOf(metadata.pool);
    console.log('Pool Balance Before', poolBalanceBefore.toString());
    console.log('Trader Balance Before', traderBalanceBefore.toString());
    const xChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), mainSigner);
    const tx = yield (yield xChainUa.wormholeReceive(Buffer.from(metadata.vaaBytes, 'base64'))).wait();
    const traderBalanceAfter = yield quoteToken.balanceOf(metadata.trader);
    const poolBalanceAfter = yield quoteToken.balanceOf(metadata.pool);
    if (!traderBalanceAfter.eq(traderBalanceBefore.add(ethers_1.BigNumber.from(metadata.quoteTokenAmount)))) {
        throw new Error(`Incorrect amount trader`);
    }
    if (!poolBalanceAfter.eq(poolBalanceBefore.sub(ethers_1.BigNumber.from(metadata.quoteTokenAmount)))) {
        throw new Error(`Incorrect amount pool`);
    }
    console.log('Pool Balance After', poolBalanceAfter.toString());
    console.log('Trader Balance After', traderBalanceAfter.toString());
    console.log('Gas Used', tx.gasUsed.toString());
}));
(0, config_1.task)('wormhole:full-setup', 'Bootstraps the entire environment').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('deploy:all');
    yield hre.run('initialize:all');
    yield hre.run('wormhole:setup');
}));
(0, config_1.task)('wormhole:setup', 'Bootstraps the Wormhole EVM').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    yield hre.run('wormhole:fund-trader');
    yield hre.run('wormhole:set-trader-allowance');
    yield hre.run('wormhole:create-pool');
    yield hre.run('wormhole:list-tokens');
    yield hre.run('wormhole:fund-pool');
    yield hre.run('wormhole:authorize-xchain-pool');
}));
(0, config_1.task)('wormhole:create-pool', 'Creates a Pool For Trading').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner, quoteSigner } = yield getSigners(hre);
    const factory = index_1.HashflowFactory__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'HashflowFactory'), mainSigner);
    const createPoolEventsBefore = yield factory.queryFilter(factory.filters.CreatePool());
    let pools = createPoolEventsBefore.map((evt) => evt.args.pool);
    const signer = yield quoteSigner.getAddress();
    if (pools.length > 0) {
        console.log('Skipping pool creation');
        return;
    }
    yield (yield factory.createPool('Hashflow Capital', 'HFC', signer, true)).wait();
    const createPoolEventsAfter = yield factory.queryFilter(factory.filters.CreatePool());
    pools = createPoolEventsAfter.map((evt) => evt.args.pool);
    if (pools.length !== 1) {
        throw new Error(`Incorrect number of pools ${pools.length}`);
    }
    if (pools[0] !== POOL_ADDRESS) {
        throw new Error(`Incorrect pool address: ${pools[0]}`);
    }
    console.log('Created Private Pool', pools[0]);
}));
(0, config_1.task)('wormhole:list-tokens', 'Lists Test Tokens for trading').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, networkName } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner } = yield getSigners(hre);
    const pool = index_1.HashflowPrivatePool__factory.connect(POOL_ADDRESS, mainSigner);
    const hToken1 = yield pool.hTokens(1, // X-Chain
    (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'));
    const hToken2 = yield pool.hTokens(1, // X-Chain
    (0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'));
    if (hToken1 === utils_1.ZERO_ADDRESS) {
        yield (yield pool.listAsset((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'))).wait();
        console.log(networkName, 'Listed Test Token 1');
    }
    else {
        console.log(networkName, 'Test Token 1 already listed.');
    }
    if (hToken2 === utils_1.ZERO_ADDRESS) {
        yield (yield pool.listAsset((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'))).wait();
        console.log(networkName, 'Listed Test Token 2');
    }
    else {
        console.log(networkName, 'Test Token 2 already listed.');
    }
}));
(0, config_1.task)('wormhole:fund-pool', 'Funds pool with Test Token 1 and Test Token 2').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, networkName } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner } = yield getSigners(hre);
    const tt1 = index_1.TestToken1__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'), mainSigner);
    const tt1Balance = yield tt1.balanceOf(POOL_ADDRESS);
    if (tt1Balance.eq(0)) {
        yield (yield tt1.transfer(POOL_ADDRESS, ethers_1.BigNumber.from(1000000000))).wait();
        console.log(networkName, 'Pool funded with Test Token 1.');
    }
    else {
        console.log(networkName, 'Pool already funded with Test Token 1. Skipping transfer.');
    }
    const tt2 = index_1.TestToken2__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'), mainSigner);
    const tt2Balance = yield tt2.balanceOf(POOL_ADDRESS);
    if (tt2Balance.eq(0)) {
        yield (yield tt2.transfer(POOL_ADDRESS, ethers_1.BigNumber.from(1000000000))).wait();
        console.log(networkName, 'Pool funded with Test Token 2.');
    }
    else {
        console.log(networkName, 'Pool already funded with Test Token 2. Skipping transfer.');
    }
}));
(0, config_1.task)('wormhole:authorize-xchain-pool', 'Authorizes the pool for Wormhole X-Chain trading').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, networkName } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner } = yield getSigners(hre);
    const pool = index_1.IHashflowPrivatePool__factory.connect(POOL_ADDRESS, mainSigner);
    const xChainUa = index_1.IHashflowXChainUA__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'HashflowXChainUA'), mainSigner);
    const wormholeNetworks = [networks_1.WORMHOLE1, networks_1.WORMHOLE2];
    for (const womrholeNetwork of wormholeNetworks) {
        if (womrholeNetwork.name !== networkName) {
            const poolBytes32 = (0, utils_2.padAddressTo32Bytes)(POOL_ADDRESS);
            const existingAuth = yield xChainUa.getXChainSenderPoolAuthorization(poolBytes32, womrholeNetwork.hashflowChainId, poolBytes32, 1);
            if (!existingAuth) {
                yield yield pool.updateXChainPoolAuthorization([
                    {
                        chainId: womrholeNetwork.hashflowChainId,
                        pool: poolBytes32,
                    },
                ], [xchain_1.XChainProtocol.WORMHOLE], true);
                console.log(networkName, `Authorized pool ${poolBytes32.toString('hex')} on ${womrholeNetwork.hashflowChainId}`);
            }
            else {
                console.log(networkName, 'Pool already authorized.');
            }
        }
    }
}));
(0, config_1.task)('wormhole:fund-trader', 'Funds account used by trader to swap').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, networkName } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { mainSigner, traderSigner } = yield getSigners(hre);
    const trader = yield traderSigner.getAddress();
    const traderBalance = yield traderSigner.getBalance();
    if (traderBalance.eq(0)) {
        const balance = yield mainSigner.getBalance();
        console.log(`Balance: ${balance.toString()}`);
        const tx = {
            to: trader,
            value: ethers_1.ethers.utils.parseEther('10'),
        };
        yield (yield mainSigner.sendTransaction(tx)).wait();
        console.log(`Sent 10 ETH to ${trader}`);
    }
    else {
        console.log('Trader has already been funded with ETH.');
    }
    const tt1 = index_1.TestToken1__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'), mainSigner);
    const tt2 = index_1.TestToken2__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'), mainSigner);
    if ((yield tt1.balanceOf(trader)).eq(0)) {
        yield (yield tt1.transfer(trader, 1000000000)).wait();
        console.log(networkName, 'Transferred Test Token 1 to trader');
    }
    else {
        console.log(networkName, 'Trader already has Test Token 1');
    }
    if ((yield tt2.balanceOf(trader)).eq(0)) {
        yield (yield tt2.transfer(trader, 1000000000)).wait();
        console.log(networkName, 'Transferred Test Token 2 to trader');
    }
    else {
        console.log(networkName, 'Trader already has Test Token 2');
    }
}));
(0, config_1.task)('wormhole:set-trader-allowance', 'Sets Test Token allowance to the Router').setAction((taskArgs, hre) => __awaiter(void 0, void 0, void 0, function* () {
    const { chainId, networkName } = yield (0, utils_2.getHardhatRuntimeNetworkParams)(hre);
    const { traderSigner } = yield getSigners(hre);
    const trader = yield traderSigner.getAddress();
    const tt1 = index_1.TestToken1__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken1'), traderSigner);
    const tt2 = index_1.TestToken2__factory.connect((0, utils_2.getDeployedContractAddress)(chainId, 'TestToken2'), traderSigner);
    const router = (0, utils_2.getDeployedContractAddress)(chainId, 'HashflowRouter');
    const tt1Allowance = yield tt1.allowance(trader, router);
    const tt2Allowance = yield tt2.allowance(trader, router);
    if (tt1Allowance.eq(0)) {
        yield (yield tt1.approve(router, 1000000000000)).wait();
        console.log(networkName, `Approved Test Token 1`);
    }
    else {
        console.log('Test Token 1 allowance already set.');
    }
    if (tt2Allowance.eq(0)) {
        yield (yield tt2.approve(router, 1000000000000)).wait();
        console.log(networkName, `Approved Test Token 2`);
    }
    else {
        console.log('Test Token 2 allowance already set.');
    }
}));
