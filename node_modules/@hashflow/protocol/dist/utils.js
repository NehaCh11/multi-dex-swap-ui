"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.expandTo18Decimals = exports.signERC20Permit = exports.hashQuoteXChainRFQMMaker = exports.hashQuoteXChain = exports.hashQuoteRFQMMaker = exports.hashQuote = exports.hashDeposit = exports.signQuoteXChainRFQMMaker = exports.signQuoteXChainRFQMTaker = exports.signQuoteRFQMMaker = exports.signQuoteRFQMTaker = exports.signDeposit = exports.signQuoteXChain = exports.signQuote = exports.ZERO_ADDRESS = void 0;
const ethers_1 = require("ethers");
exports.ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
function signQuote(quote, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = hashQuote(quote);
        return yield signer.signMessage(Buffer.from(digest.slice(2), 'hex'));
    });
}
exports.signQuote = signQuote;
function signQuoteXChain(quote, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = hashQuoteXChain(quote);
        return yield signer.signMessage(Buffer.from(digest.slice(2), 'hex'));
    });
}
exports.signQuoteXChain = signQuoteXChain;
function signDeposit(lp, depositData, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = hashDeposit(lp, depositData);
        return yield signer.signMessage(Buffer.from(digest.slice(2), 'hex'));
    });
}
exports.signDeposit = signDeposit;
function signQuoteRFQMTaker(quote, chainId, routerAddress, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const domain = {
            name: 'Hashflow - Router',
            version: '1.0',
            chainId,
            verifyingContract: routerAddress,
        };
        return yield signer._signTypedData(domain, {
            Quote: [
                { name: 'txid', type: 'bytes32' },
                { name: 'trader', type: 'address' },
                { name: 'baseToken', type: 'address' },
                { name: 'quoteToken', type: 'address' },
                { name: 'baseTokenAmount', type: 'uint256' },
                { name: 'quoteTokenAmount', type: 'uint256' },
                { name: 'quoteExpiry', type: 'uint256' },
            ],
        }, {
            txid: quote.txid,
            trader: quote.trader,
            baseToken: quote.baseToken,
            quoteToken: quote.quoteToken,
            baseTokenAmount: quote.baseTokenAmount,
            quoteTokenAmount: quote.quoteTokenAmount,
            quoteExpiry: quote.quoteExpiry,
        });
    });
}
exports.signQuoteRFQMTaker = signQuoteRFQMTaker;
function signQuoteRFQMMaker(quote, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = hashQuoteRFQMMaker(quote);
        return yield signer.signMessage(Buffer.from(digest.slice(2), 'hex'));
    });
}
exports.signQuoteRFQMMaker = signQuoteRFQMMaker;
function signQuoteXChainRFQMTaker(quote, chainId, routerAddress, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const domain = {
            name: 'Hashflow - Router',
            version: '1.0',
            chainId,
            verifyingContract: routerAddress,
        };
        return yield signer._signTypedData(domain, {
            XChainQuote: [
                { name: 'txid', type: 'bytes32' },
                { name: 'srcChainId', type: 'uint256' },
                { name: 'dstChainId', type: 'uint256' },
                { name: 'trader', type: 'address' },
                { name: 'baseToken', type: 'address' },
                { name: 'quoteToken', type: 'address' },
                { name: 'baseTokenAmount', type: 'uint256' },
                { name: 'quoteTokenAmount', type: 'uint256' },
                { name: 'quoteExpiry', type: 'uint256' },
            ],
        }, {
            txid: quote.txid,
            srcChainId: quote.srcChainId,
            dstChainId: quote.dstChainId,
            trader: quote.trader,
            baseToken: quote.baseToken,
            quoteToken: quote.quoteToken,
            baseTokenAmount: quote.baseTokenAmount,
            quoteTokenAmount: quote.quoteTokenAmount,
            quoteExpiry: quote.quoteExpiry,
        });
    });
}
exports.signQuoteXChainRFQMTaker = signQuoteXChainRFQMTaker;
function signQuoteXChainRFQMMaker(quote, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const digest = hashQuoteXChainRFQMMaker(quote);
        return yield signer.signMessage(Buffer.from(digest.slice(2), 'hex'));
    });
}
exports.signQuoteXChainRFQMMaker = signQuoteXChainRFQMMaker;
function hashDeposit(lp, depositData) {
    return ethers_1.ethers.utils.solidityKeccak256(['address', 'address', 'address', 'uint256', 'uint256', 'uint256'], [
        lp,
        depositData.pool,
        depositData.token,
        depositData.amount,
        depositData.nonce,
        31337,
    ]);
}
exports.hashDeposit = hashDeposit;
function hashQuote(quote) {
    return ethers_1.ethers.utils.solidityKeccak256([
        'address',
        'address',
        'address',
        'address',
        'address',
        'address',
        'uint256',
        'uint256',
        'uint256',
        'uint256',
        'bytes32',
        'uint256',
    ], [
        quote.pool,
        quote.trader,
        quote.effectiveTrader,
        quote.externalAccount,
        quote.baseToken,
        quote.quoteToken,
        quote.maxBaseTokenAmount,
        quote.maxQuoteTokenAmount,
        quote.nonce,
        quote.quoteExpiry,
        quote.txid,
        31337,
    ]);
}
exports.hashQuote = hashQuote;
function hashQuoteRFQMMaker(quote) {
    return ethers_1.ethers.utils.solidityKeccak256([
        'address',
        'address',
        'address',
        'address',
        'uint256',
        'uint256',
        'uint256',
        'bytes32',
        'uint256',
    ], [
        quote.pool,
        quote.externalAccount,
        quote.baseToken,
        quote.quoteToken,
        quote.baseTokenAmount,
        quote.quoteTokenAmount,
        quote.quoteExpiry,
        quote.txid,
        31337,
    ]);
}
exports.hashQuoteRFQMMaker = hashQuoteRFQMMaker;
function hashQuoteXChain(quote) {
    return ethers_1.ethers.utils.solidityKeccak256([
        'uint16',
        'uint16',
        'address',
        'address',
        'bytes32',
        'address',
        'bytes32',
        'address',
        'address',
        'uint256',
        'uint256',
        'uint256',
        'uint256',
        'bytes32',
    ], [
        quote.srcChainId,
        quote.dstChainId,
        quote.trader,
        quote.srcPool,
        quote.dstPool,
        quote.srcExternalAccount,
        quote.dstExternalAccount,
        quote.baseToken,
        quote.quoteToken,
        quote.baseTokenAmount,
        quote.quoteTokenAmount,
        quote.quoteExpiry,
        quote.nonce,
        quote.txid,
    ]);
}
exports.hashQuoteXChain = hashQuoteXChain;
function hashQuoteXChainRFQMMaker(quote) {
    return ethers_1.ethers.utils.solidityKeccak256([
        'uint16',
        'uint16',
        'address',
        'address',
        'address',
        'address',
        'address',
        'address',
        'uint256',
        'uint256',
        'uint256',
        'bytes32',
    ], [
        quote.srcChainId,
        quote.dstChainId,
        quote.srcPool,
        quote.dstPool,
        quote.srcExternalAccount,
        quote.dstExternalAccount,
        quote.baseToken,
        quote.quoteToken,
        quote.baseTokenAmount,
        quote.quoteTokenAmount,
        quote.quoteExpiry,
        quote.txid,
    ]);
}
exports.hashQuoteXChainRFQMMaker = hashQuoteXChainRFQMMaker;
function signERC20Permit(owner, spender, nonce, amount, deadline, tokenAddress, tokenName, tokenVersion, chainId, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        const domain = {
            name: tokenName,
            version: tokenVersion,
            chainId,
            verifyingContract: tokenAddress,
        };
        return yield signer._signTypedData(domain, {
            Permit: [
                { name: 'owner', type: 'address' },
                { name: 'spender', type: 'address' },
                { name: 'value', type: 'uint256' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
            ],
        }, {
            owner,
            spender,
            value: amount,
            nonce,
            deadline,
        });
    });
}
exports.signERC20Permit = signERC20Permit;
function expandTo18Decimals(n) {
    return ethers_1.BigNumber.from(n).mul(ethers_1.BigNumber.from(10).pow(18));
}
exports.expandTo18Decimals = expandTo18Decimals;
