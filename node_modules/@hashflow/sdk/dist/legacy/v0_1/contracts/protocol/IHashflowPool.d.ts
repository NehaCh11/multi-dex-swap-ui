import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common";
export declare namespace IQuote {
    type QuoteStruct = {
        rfqType: BigNumberish;
        pool: AddressLike;
        eoa: AddressLike;
        trader: AddressLike;
        effectiveTrader: AddressLike;
        baseToken: AddressLike;
        quoteToken: AddressLike;
        effectiveBaseTokenAmount: BigNumberish;
        maxBaseTokenAmount: BigNumberish;
        maxQuoteTokenAmount: BigNumberish;
        fees: BigNumberish;
        quoteExpiry: BigNumberish;
        nonce: BigNumberish;
        txid: BytesLike;
        signedQuote: BytesLike;
    };
    type QuoteStructOutput = [
        rfqType: bigint,
        pool: string,
        eoa: string,
        trader: string,
        effectiveTrader: string,
        baseToken: string,
        quoteToken: string,
        effectiveBaseTokenAmount: bigint,
        maxBaseTokenAmount: bigint,
        maxQuoteTokenAmount: bigint,
        fees: bigint,
        quoteExpiry: bigint,
        nonce: bigint,
        txid: string,
        signedQuote: string
    ] & {
        rfqType: bigint;
        pool: string;
        eoa: string;
        trader: string;
        effectiveTrader: string;
        baseToken: string;
        quoteToken: string;
        effectiveBaseTokenAmount: bigint;
        maxBaseTokenAmount: bigint;
        maxQuoteTokenAmount: bigint;
        fees: bigint;
        quoteExpiry: bigint;
        nonce: bigint;
        txid: string;
        signedQuote: string;
    };
    type LzQuoteStruct = {
        rfqType: BigNumberish;
        srcChainId: BigNumberish;
        dstChainId: BigNumberish;
        srcPool: AddressLike;
        dstPool: AddressLike;
        trader: AddressLike;
        baseToken: AddressLike;
        quoteToken: AddressLike;
        baseTokenAmount: BigNumberish;
        quoteTokenAmount: BigNumberish;
        fees: BigNumberish;
        quoteExpiry: BigNumberish;
        txid: BytesLike;
        signedQuote: BytesLike;
    };
    type LzQuoteStructOutput = [
        rfqType: bigint,
        srcChainId: bigint,
        dstChainId: bigint,
        srcPool: string,
        dstPool: string,
        trader: string,
        baseToken: string,
        quoteToken: string,
        baseTokenAmount: bigint,
        quoteTokenAmount: bigint,
        fees: bigint,
        quoteExpiry: bigint,
        txid: string,
        signedQuote: string
    ] & {
        rfqType: bigint;
        srcChainId: bigint;
        dstChainId: bigint;
        srcPool: string;
        dstPool: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: bigint;
        quoteTokenAmount: bigint;
        fees: bigint;
        quoteExpiry: bigint;
        txid: string;
        signedQuote: string;
    };
}
export interface IHashflowPoolInterface extends Interface {
    getFunction(nameOrSignature: "authorizeLzPool" | "fillXChain" | "getGovernance" | "getNonce" | "getOperations" | "getPoolName" | "getReserves" | "getRouterPermissions" | "getSigner" | "getTracker" | "trade" | "tradeLz" | "updateHedgingAccount" | "updateRouterPermissions" | "updateSigner"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "LzTrade" | "Trade" | "UpdateHedgingAccount" | "UpdateRouterPermissions" | "UpdateSigner"): EventFragment;
    encodeFunctionData(functionFragment: "authorizeLzPool", values: [BigNumberish, AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "fillXChain", values: [AddressLike, AddressLike, BigNumberish, AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "getGovernance", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNonce", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "getOperations", values?: undefined): string;
    encodeFunctionData(functionFragment: "getPoolName", values?: undefined): string;
    encodeFunctionData(functionFragment: "getReserves", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "getRouterPermissions", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "getSigner", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTracker", values?: undefined): string;
    encodeFunctionData(functionFragment: "trade", values: [IQuote.QuoteStruct, AddressLike]): string;
    encodeFunctionData(functionFragment: "tradeLz", values: [IQuote.LzQuoteStruct, AddressLike]): string;
    encodeFunctionData(functionFragment: "updateHedgingAccount", values: [AddressLike[], boolean]): string;
    encodeFunctionData(functionFragment: "updateRouterPermissions", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "updateSigner", values: [AddressLike]): string;
    decodeFunctionResult(functionFragment: "authorizeLzPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fillXChain", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getOperations", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getPoolName", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getReserves", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRouterPermissions", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getSigner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTracker", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "trade", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeLz", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateHedgingAccount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateRouterPermissions", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateSigner", data: BytesLike): Result;
}
export declare namespace LzTradeEvent {
    type InputTuple = [
        srcChainId: BigNumberish,
        dstChainId: BigNumberish,
        srcPool: AddressLike,
        dstPool: AddressLike,
        trader: AddressLike,
        txid: BytesLike,
        baseToken: AddressLike,
        quoteToken: AddressLike,
        baseTokenAmount: BigNumberish,
        quoteTokenAmount: BigNumberish,
        fees: BigNumberish
    ];
    type OutputTuple = [
        srcChainId: bigint,
        dstChainId: bigint,
        srcPool: string,
        dstPool: string,
        trader: string,
        txid: string,
        baseToken: string,
        quoteToken: string,
        baseTokenAmount: bigint,
        quoteTokenAmount: bigint,
        fees: bigint
    ];
    interface OutputObject {
        srcChainId: bigint;
        dstChainId: bigint;
        srcPool: string;
        dstPool: string;
        trader: string;
        txid: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: bigint;
        quoteTokenAmount: bigint;
        fees: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TradeEvent {
    type InputTuple = [
        pool: AddressLike,
        trader: AddressLike,
        txid: BytesLike,
        baseToken: AddressLike,
        quoteToken: AddressLike,
        baseTokenAmount: BigNumberish,
        quoteTokenAmount: BigNumberish,
        fees: BigNumberish
    ];
    type OutputTuple = [
        pool: string,
        trader: string,
        txid: string,
        baseToken: string,
        quoteToken: string,
        baseTokenAmount: bigint,
        quoteTokenAmount: bigint,
        fees: bigint
    ];
    interface OutputObject {
        pool: string;
        trader: string;
        txid: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: bigint;
        quoteTokenAmount: bigint;
        fees: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace UpdateHedgingAccountEvent {
    type InputTuple = [
        pool: AddressLike,
        recipient: AddressLike[],
        status: boolean
    ];
    type OutputTuple = [
        pool: string,
        recipient: string[],
        status: boolean
    ];
    interface OutputObject {
        pool: string;
        recipient: string[];
        status: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace UpdateRouterPermissionsEvent {
    type InputTuple = [
        pool: AddressLike,
        router: AddressLike,
        permissions: boolean
    ];
    type OutputTuple = [
        pool: string,
        router: string,
        permissions: boolean
    ];
    interface OutputObject {
        pool: string;
        router: string;
        permissions: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace UpdateSignerEvent {
    type InputTuple = [pool: AddressLike, signer: AddressLike];
    type OutputTuple = [pool: string, signer: string];
    interface OutputObject {
        pool: string;
        signer: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface IHashflowPool extends BaseContract {
    connect(runner?: ContractRunner | null): IHashflowPool;
    waitForDeployment(): Promise<this>;
    interface: IHashflowPoolInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    authorizeLzPool: TypedContractMethod<[
        chainId: BigNumberish,
        pool: AddressLike,
        status: boolean
    ], [
        void
    ], "nonpayable">;
    fillXChain: TypedContractMethod<[
        trader: AddressLike,
        quoteToken: AddressLike,
        quoteTokenAmount: BigNumberish,
        hToken: AddressLike,
        hTokenBurn: boolean
    ], [
        void
    ], "nonpayable">;
    getGovernance: TypedContractMethod<[], [string], "view">;
    getNonce: TypedContractMethod<[sender: AddressLike], [bigint], "view">;
    getOperations: TypedContractMethod<[], [string], "view">;
    getPoolName: TypedContractMethod<[], [string], "view">;
    getReserves: TypedContractMethod<[token: AddressLike], [bigint], "view">;
    getRouterPermissions: TypedContractMethod<[
        router: AddressLike
    ], [
        boolean
    ], "view">;
    getSigner: TypedContractMethod<[], [string], "view">;
    getTracker: TypedContractMethod<[], [string], "view">;
    trade: TypedContractMethod<[
        quote: IQuote.QuoteStruct,
        relayer: AddressLike
    ], [
        boolean
    ], "payable">;
    tradeLz: TypedContractMethod<[
        quote: IQuote.LzQuoteStruct,
        relayer: AddressLike
    ], [
        boolean
    ], "payable">;
    updateHedgingAccount: TypedContractMethod<[
        hedgingAccount: AddressLike[],
        status: boolean
    ], [
        void
    ], "nonpayable">;
    updateRouterPermissions: TypedContractMethod<[
        router: AddressLike,
        permissions: boolean
    ], [
        void
    ], "nonpayable">;
    updateSigner: TypedContractMethod<[
        signer: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "authorizeLzPool"): TypedContractMethod<[
        chainId: BigNumberish,
        pool: AddressLike,
        status: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "fillXChain"): TypedContractMethod<[
        trader: AddressLike,
        quoteToken: AddressLike,
        quoteTokenAmount: BigNumberish,
        hToken: AddressLike,
        hTokenBurn: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "getGovernance"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getNonce"): TypedContractMethod<[sender: AddressLike], [bigint], "view">;
    getFunction(nameOrSignature: "getOperations"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getPoolName"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getReserves"): TypedContractMethod<[token: AddressLike], [bigint], "view">;
    getFunction(nameOrSignature: "getRouterPermissions"): TypedContractMethod<[router: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "getSigner"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getTracker"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "trade"): TypedContractMethod<[
        quote: IQuote.QuoteStruct,
        relayer: AddressLike
    ], [
        boolean
    ], "payable">;
    getFunction(nameOrSignature: "tradeLz"): TypedContractMethod<[
        quote: IQuote.LzQuoteStruct,
        relayer: AddressLike
    ], [
        boolean
    ], "payable">;
    getFunction(nameOrSignature: "updateHedgingAccount"): TypedContractMethod<[
        hedgingAccount: AddressLike[],
        status: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "updateRouterPermissions"): TypedContractMethod<[
        router: AddressLike,
        permissions: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "updateSigner"): TypedContractMethod<[signer: AddressLike], [void], "nonpayable">;
    getEvent(key: "LzTrade"): TypedContractEvent<LzTradeEvent.InputTuple, LzTradeEvent.OutputTuple, LzTradeEvent.OutputObject>;
    getEvent(key: "Trade"): TypedContractEvent<TradeEvent.InputTuple, TradeEvent.OutputTuple, TradeEvent.OutputObject>;
    getEvent(key: "UpdateHedgingAccount"): TypedContractEvent<UpdateHedgingAccountEvent.InputTuple, UpdateHedgingAccountEvent.OutputTuple, UpdateHedgingAccountEvent.OutputObject>;
    getEvent(key: "UpdateRouterPermissions"): TypedContractEvent<UpdateRouterPermissionsEvent.InputTuple, UpdateRouterPermissionsEvent.OutputTuple, UpdateRouterPermissionsEvent.OutputObject>;
    getEvent(key: "UpdateSigner"): TypedContractEvent<UpdateSignerEvent.InputTuple, UpdateSignerEvent.OutputTuple, UpdateSignerEvent.OutputObject>;
    filters: {
        "LzTrade(uint16,uint16,address,address,address,bytes32,address,address,uint256,uint256,uint256)": TypedContractEvent<LzTradeEvent.InputTuple, LzTradeEvent.OutputTuple, LzTradeEvent.OutputObject>;
        LzTrade: TypedContractEvent<LzTradeEvent.InputTuple, LzTradeEvent.OutputTuple, LzTradeEvent.OutputObject>;
        "Trade(address,address,bytes32,address,address,uint256,uint256,uint256)": TypedContractEvent<TradeEvent.InputTuple, TradeEvent.OutputTuple, TradeEvent.OutputObject>;
        Trade: TypedContractEvent<TradeEvent.InputTuple, TradeEvent.OutputTuple, TradeEvent.OutputObject>;
        "UpdateHedgingAccount(address,address[],bool)": TypedContractEvent<UpdateHedgingAccountEvent.InputTuple, UpdateHedgingAccountEvent.OutputTuple, UpdateHedgingAccountEvent.OutputObject>;
        UpdateHedgingAccount: TypedContractEvent<UpdateHedgingAccountEvent.InputTuple, UpdateHedgingAccountEvent.OutputTuple, UpdateHedgingAccountEvent.OutputObject>;
        "UpdateRouterPermissions(address,address,bool)": TypedContractEvent<UpdateRouterPermissionsEvent.InputTuple, UpdateRouterPermissionsEvent.OutputTuple, UpdateRouterPermissionsEvent.OutputObject>;
        UpdateRouterPermissions: TypedContractEvent<UpdateRouterPermissionsEvent.InputTuple, UpdateRouterPermissionsEvent.OutputTuple, UpdateRouterPermissionsEvent.OutputObject>;
        "UpdateSigner(address,address)": TypedContractEvent<UpdateSignerEvent.InputTuple, UpdateSignerEvent.OutputTuple, UpdateSignerEvent.OutputObject>;
        UpdateSigner: TypedContractEvent<UpdateSignerEvent.InputTuple, UpdateSignerEvent.OutputTuple, UpdateSignerEvent.OutputObject>;
    };
}
