import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common";
export declare namespace IQuote {
    type DepositStruct = {
        pool: AddressLike;
        token: AddressLike;
        amount: BigNumberish;
        nonce: BigNumberish;
        signedDeposit: BytesLike;
    };
    type DepositStructOutput = [
        pool: string,
        token: string,
        amount: bigint,
        nonce: bigint,
        signedDeposit: string
    ] & {
        pool: string;
        token: string;
        amount: bigint;
        nonce: bigint;
        signedDeposit: string;
    };
    type LzQuoteStruct = {
        rfqType: BigNumberish;
        srcChainId: BigNumberish;
        dstChainId: BigNumberish;
        srcPool: AddressLike;
        dstPool: AddressLike;
        trader: AddressLike;
        baseToken: AddressLike;
        quoteToken: AddressLike;
        baseTokenAmount: BigNumberish;
        quoteTokenAmount: BigNumberish;
        fees: BigNumberish;
        quoteExpiry: BigNumberish;
        txid: BytesLike;
        signedQuote: BytesLike;
    };
    type LzQuoteStructOutput = [
        rfqType: bigint,
        srcChainId: bigint,
        dstChainId: bigint,
        srcPool: string,
        dstPool: string,
        trader: string,
        baseToken: string,
        quoteToken: string,
        baseTokenAmount: bigint,
        quoteTokenAmount: bigint,
        fees: bigint,
        quoteExpiry: bigint,
        txid: string,
        signedQuote: string
    ] & {
        rfqType: bigint;
        srcChainId: bigint;
        dstChainId: bigint;
        srcPool: string;
        dstPool: string;
        trader: string;
        baseToken: string;
        quoteToken: string;
        baseTokenAmount: bigint;
        quoteTokenAmount: bigint;
        fees: bigint;
        quoteExpiry: bigint;
        txid: string;
        signedQuote: string;
    };
    type QuoteStruct = {
        rfqType: BigNumberish;
        pool: AddressLike;
        eoa: AddressLike;
        trader: AddressLike;
        effectiveTrader: AddressLike;
        baseToken: AddressLike;
        quoteToken: AddressLike;
        effectiveBaseTokenAmount: BigNumberish;
        maxBaseTokenAmount: BigNumberish;
        maxQuoteTokenAmount: BigNumberish;
        fees: BigNumberish;
        quoteExpiry: BigNumberish;
        nonce: BigNumberish;
        txid: BytesLike;
        signedQuote: BytesLike;
    };
    type QuoteStructOutput = [
        rfqType: bigint,
        pool: string,
        eoa: string,
        trader: string,
        effectiveTrader: string,
        baseToken: string,
        quoteToken: string,
        effectiveBaseTokenAmount: bigint,
        maxBaseTokenAmount: bigint,
        maxQuoteTokenAmount: bigint,
        fees: bigint,
        quoteExpiry: bigint,
        nonce: bigint,
        txid: string,
        signedQuote: string
    ] & {
        rfqType: bigint;
        pool: string;
        eoa: string;
        trader: string;
        effectiveTrader: string;
        baseToken: string;
        quoteToken: string;
        effectiveBaseTokenAmount: bigint;
        maxBaseTokenAmount: bigint;
        maxQuoteTokenAmount: bigint;
        fees: bigint;
        quoteExpiry: bigint;
        nonce: bigint;
        txid: string;
        signedQuote: string;
    };
}
export interface IHashflowRouterInterface extends Interface {
    getFunction(nameOrSignature: "addLiquidityPrivatePool" | "addLiquidityPublicPool" | "getGovernance" | "redeemXChainTokens" | "removeLiquidityPublicPool" | "removeLiquidityPublicPoolWithPermit" | "setWeth" | "tradeLz" | "tradeMultiHop" | "tradeSingleHop" | "updateGovernance"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "UpdateGovernance"): EventFragment;
    encodeFunctionData(functionFragment: "addLiquidityPrivatePool", values: [AddressLike, AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "addLiquidityPublicPool", values: [IQuote.DepositStruct]): string;
    encodeFunctionData(functionFragment: "getGovernance", values?: undefined): string;
    encodeFunctionData(functionFragment: "redeemXChainTokens", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "removeLiquidityPublicPool", values: [AddressLike, AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "removeLiquidityPublicPoolWithPermit", values: [
        AddressLike,
        AddressLike,
        BigNumberish,
        BigNumberish,
        boolean,
        BigNumberish,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "setWeth", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "tradeLz", values: [IQuote.LzQuoteStruct]): string;
    encodeFunctionData(functionFragment: "tradeMultiHop", values: [IQuote.QuoteStruct[], AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "tradeSingleHop", values: [IQuote.QuoteStruct]): string;
    encodeFunctionData(functionFragment: "updateGovernance", values: [AddressLike]): string;
    decodeFunctionResult(functionFragment: "addLiquidityPrivatePool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addLiquidityPublicPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGovernance", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "redeemXChainTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeLiquidityPublicPool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "removeLiquidityPublicPoolWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setWeth", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeLz", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeMultiHop", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "tradeSingleHop", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateGovernance", data: BytesLike): Result;
}
export declare namespace UpdateGovernanceEvent {
    type InputTuple = [governance: AddressLike];
    type OutputTuple = [governance: string];
    interface OutputObject {
        governance: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface IHashflowRouter extends BaseContract {
    connect(runner?: ContractRunner | null): IHashflowRouter;
    waitForDeployment(): Promise<this>;
    interface: IHashflowRouterInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    addLiquidityPrivatePool: TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        amount: BigNumberish
    ], [
        void
    ], "payable">;
    addLiquidityPublicPool: TypedContractMethod<[
        deposit: IQuote.DepositStruct
    ], [
        void
    ], "payable">;
    getGovernance: TypedContractMethod<[], [string], "view">;
    redeemXChainTokens: TypedContractMethod<[
        hToken: AddressLike,
        amount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    removeLiquidityPublicPool: TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        burnAmount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    removeLiquidityPublicPoolWithPermit: TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        burnAmount: BigNumberish,
        expiry: BigNumberish,
        approveMax: boolean,
        v: BigNumberish,
        r: BytesLike,
        s: BytesLike
    ], [
        void
    ], "nonpayable">;
    setWeth: TypedContractMethod<[weth: AddressLike], [void], "nonpayable">;
    tradeLz: TypedContractMethod<[
        quote: IQuote.LzQuoteStruct
    ], [
        void
    ], "payable">;
    tradeMultiHop: TypedContractMethod<[
        quotes: IQuote.QuoteStruct[],
        baseToken: AddressLike,
        quoteToken: AddressLike
    ], [
        void
    ], "payable">;
    tradeSingleHop: TypedContractMethod<[
        quote: IQuote.QuoteStruct
    ], [
        void
    ], "payable">;
    updateGovernance: TypedContractMethod<[
        governance: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "addLiquidityPrivatePool"): TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        amount: BigNumberish
    ], [
        void
    ], "payable">;
    getFunction(nameOrSignature: "addLiquidityPublicPool"): TypedContractMethod<[deposit: IQuote.DepositStruct], [void], "payable">;
    getFunction(nameOrSignature: "getGovernance"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "redeemXChainTokens"): TypedContractMethod<[
        hToken: AddressLike,
        amount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "removeLiquidityPublicPool"): TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        burnAmount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "removeLiquidityPublicPoolWithPermit"): TypedContractMethod<[
        pool: AddressLike,
        token: AddressLike,
        burnAmount: BigNumberish,
        expiry: BigNumberish,
        approveMax: boolean,
        v: BigNumberish,
        r: BytesLike,
        s: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setWeth"): TypedContractMethod<[weth: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "tradeLz"): TypedContractMethod<[quote: IQuote.LzQuoteStruct], [void], "payable">;
    getFunction(nameOrSignature: "tradeMultiHop"): TypedContractMethod<[
        quotes: IQuote.QuoteStruct[],
        baseToken: AddressLike,
        quoteToken: AddressLike
    ], [
        void
    ], "payable">;
    getFunction(nameOrSignature: "tradeSingleHop"): TypedContractMethod<[quote: IQuote.QuoteStruct], [void], "payable">;
    getFunction(nameOrSignature: "updateGovernance"): TypedContractMethod<[governance: AddressLike], [void], "nonpayable">;
    getEvent(key: "UpdateGovernance"): TypedContractEvent<UpdateGovernanceEvent.InputTuple, UpdateGovernanceEvent.OutputTuple, UpdateGovernanceEvent.OutputObject>;
    filters: {
        "UpdateGovernance(address)": TypedContractEvent<UpdateGovernanceEvent.InputTuple, UpdateGovernanceEvent.OutputTuple, UpdateGovernanceEvent.OutputObject>;
        UpdateGovernance: TypedContractEvent<UpdateGovernanceEvent.InputTuple, UpdateGovernanceEvent.OutputTuple, UpdateGovernanceEvent.OutputObject>;
    };
}
