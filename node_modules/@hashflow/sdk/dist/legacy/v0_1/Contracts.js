"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.contractAddressesByNetwork = exports.Contracts = void 0;
const governance_1 = require("./contracts/governance");
const protocol_1 = require("./contracts/protocol");
const Constants_1 = require("./lib/Constants");
const Claimer_json_1 = __importDefault(require("./published_contracts/Claimer.json"));
const HashflowFactory_json_1 = __importDefault(require("./published_contracts/HashflowFactory.json"));
const HashflowGovernance_json_1 = __importDefault(require("./published_contracts/HashflowGovernance.json"));
const HashflowLayerZeroUA_json_1 = __importDefault(require("./published_contracts/HashflowLayerZeroUA.json"));
const HashflowRouter_json_1 = __importDefault(require("./published_contracts/HashflowRouter.json"));
const HashflowTracker_json_1 = __importDefault(require("./published_contracts/HashflowTracker.json"));
const HFT_json_1 = __importDefault(require("./published_contracts/HFT.json"));
class Contracts {
    constructor(networkId, signer, provider) {
        if (signer) {
            this.signerOrProvider = signer;
            if (!signer.provider) {
                throw new Error(`Supplied Signer does not have a Provider.`);
            }
            this.provider = signer.provider;
        }
        else if (provider) {
            this.signerOrProvider = provider;
            this.provider = provider;
        }
        else {
            throw new Error('Missing provider or signer');
        }
        this.networkId = networkId;
        // Contracts
        if (HFT_json_1.default.networks[this.networkId]) {
            this.HFT = governance_1.IHFT__factory.connect(HFT_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        }
        if (Claimer_json_1.default.networks[this.networkId]) {
            this.hClaimer = governance_1.IClaimer__factory.connect(Claimer_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        }
        this.hGovernance = protocol_1.IHashflowGovernance__factory.connect(HashflowGovernance_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        this.hFactory = protocol_1.IHashflowFactory__factory.connect(HashflowFactory_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        this.hRouter = protocol_1.IHashflowRouter__factory.connect(HashflowRouter_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        this.hTracker = protocol_1.IHashflowTracker__factory.connect(HashflowTracker_json_1.default.networks[this.networkId].address, this.signerOrProvider);
        this.hLayerZeroUa = protocol_1.IHashflowLayerZeroUA__factory.connect(HashflowLayerZeroUA_json_1.default.networks[this.networkId]
            .address, this.signerOrProvider);
        if (Constants_1.layerZeroEndpointByNetwork[networkId]) {
            this.layerZeroEndpoint = protocol_1.ILayerZeroEndpoint__factory.connect(Constants_1.layerZeroEndpointByNetwork[networkId], this.signerOrProvider);
        }
        this.layerZeroUAsByNetwork = {};
        for (const networkIdStr of Object.keys(HashflowLayerZeroUA_json_1.default.networks)) {
            const networkId = Number(networkIdStr);
            this.layerZeroUAsByNetwork[networkId] = HashflowLayerZeroUA_json_1.default.networks[networkId].address;
        }
    }
}
exports.Contracts = Contracts;
exports.contractAddressesByNetwork = {
    hft: HFT_json_1.default.networks,
    claimer: Claimer_json_1.default.networks,
    governance: HashflowGovernance_json_1.default.networks,
    factory: HashflowFactory_json_1.default.networks,
    router: HashflowRouter_json_1.default.networks,
    tracker: HashflowTracker_json_1.default.networks,
    layerZeroUA: HashflowLayerZeroUA_json_1.default.networks,
};
//# sourceMappingURL=Contracts.js.map