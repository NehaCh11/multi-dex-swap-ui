"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashflowApi = void 0;
const contracts_evm_1 = require("@hashflow/contracts-evm");
const sdk_1 = require("@hashflow/sdk");
const axios_1 = __importDefault(require("axios"));
const validation_1 = require("./helpers/validation");
const rest_1 = require("./rest");
class HashflowApi {
    constructor(mode, name, authKey, environment = 'production') {
        switch (mode) {
            case 'wallet':
                this.source = 'api';
                this.wallet = name;
                break;
            case 'taker':
                this.source = name;
                break;
        }
        this.restApi = (0, rest_1.createRestApi)(environment, authKey);
        this.contractsApi = {};
    }
    handleError(err) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (axios_1.default.isAxiosError(err)) {
            const errorResponse = (_a = err.response) === null || _a === void 0 ? void 0 : _a.data;
            const errCode = (_d = (_c = (_b = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) === null || _b === void 0 ? void 0 : _b.code) !== null && _c !== void 0 ? _c : err.code) !== null && _d !== void 0 ? _d : 'Unknown code';
            const errMessage = (_g = (_f = (_e = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) === null || _e === void 0 ? void 0 : _e.message) !== null && _f !== void 0 ? _f : err.message) !== null && _g !== void 0 ? _g : `Unknown message ${JSON.stringify(err)}`;
            throw new Error(`REST API error: ${errCode}. ${errMessage}`);
        }
        else {
            throw new Error(`Unknown error occurred: ${err.toString()}`);
        }
    }
    getMarketMakers(baseChain, wallet, marketMaker) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.validateChain)(baseChain);
            try {
                const response = yield this.restApi.get('taker/v3/market-makers', {
                    params: Object.assign(Object.assign({ baseChainType: String(baseChain.chainType), baseChainId: String(baseChain.chainId), source: this.source }, (wallet ? { wallet } : {})), (marketMaker ? { marketMaker } : {})),
                });
                return response.data.marketMakers;
            }
            catch (err) {
                if (axios_1.default.isAxiosError(err)) {
                    const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : 'Unknown code';
                    const errMessage = (_b = err.message) !== null && _b !== void 0 ? _b : `Unknown message: ${JSON.stringify(err)}`;
                    throw new Error(`REST API error: ${errCode}. ${errMessage}`);
                }
                else {
                    throw new Error(`Unknown error occurred: ${err.toString()}`);
                }
            }
        });
    }
    getPriceLevels(baseChain, marketMakers, maybeQuoteChain) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.validateChain)(baseChain);
            const quoteChain = maybeQuoteChain !== null && maybeQuoteChain !== void 0 ? maybeQuoteChain : baseChain;
            (0, validation_1.validateChain)(quoteChain);
            const params = Object.assign({ source: this.source, baseChainType: String(baseChain.chainType), baseChainId: String(baseChain.chainId), quoteChainType: String(quoteChain.chainType), quoteChainId: String(quoteChain.chainId), marketMakers }, (!!this.wallet && { wallet: this.wallet }));
            try {
                const response = yield this.restApi.get('taker/v3/price-levels', { params });
                return response.data.levels;
            }
            catch (err) {
                return this.handleError(err);
            }
        });
    }
    getTradingPairs(baseChain, marketMaker) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.validateChain)(baseChain);
            const params = {
                baseChainId: baseChain.chainId.toString(),
                baseChainType: baseChain.chainType,
                source: this.source,
                marketMaker,
            };
            try {
                const response = yield this.restApi.get('taker/v3/trading-pairs', { params });
                return response.data;
            }
            catch (err) {
                return this.handleError(err);
            }
        });
    }
    requestQuote(input) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            (0, validation_1.validateChain)(input.baseChain);
            if (input.quoteChain) {
                (0, validation_1.validateChain)(input.quoteChain);
            }
            (0, validation_1.validateAddress)(input.baseChain, input.baseToken);
            (0, validation_1.validateAddress)((_a = input.quoteChain) !== null && _a !== void 0 ? _a : input.baseChain, input.quoteToken);
            if (input.baseTokenAmount) {
                (0, validation_1.validateNumberString)(input.baseTokenAmount);
            }
            if (input.quoteTokenAmount) {
                (0, validation_1.validateNumberString)(input.quoteTokenAmount);
            }
            const trader = (_b = input.wallet) !== null && _b !== void 0 ? _b : this.wallet;
            if (!trader) {
                throw new Error('Must specify wallet');
            }
            else {
                (0, validation_1.validateAddress)((_c = input.quoteChain) !== null && _c !== void 0 ? _c : input.baseChain, trader);
            }
            if (input.effectiveTrader) {
                (0, validation_1.validateAddress)((_d = input.quoteChain) !== null && _d !== void 0 ? _d : input.baseChain, input.effectiveTrader);
            }
            const body = {
                source: this.source,
                baseChain: input.baseChain,
                quoteChain: (_e = input.quoteChain) !== null && _e !== void 0 ? _e : input.baseChain,
                rfqs: [
                    {
                        trader,
                        baseToken: input.baseToken,
                        quoteToken: input.quoteToken,
                        baseTokenAmount: input.baseTokenAmount,
                        quoteTokenAmount: input.quoteTokenAmount,
                        effectiveTrader: input.effectiveTrader,
                        marketMakers: input.marketMakers,
                        feesBps: input.feesBps,
                    },
                ],
                debug: input.debug,
            };
            try {
                const response = yield this.restApi.post('taker/v3/rfq', body);
                return response.data;
            }
            catch (err) {
                return this.handleError(err);
            }
        });
    }
    executeTrade(signer, chainId, quoteData, signature, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (quoteData.quoteExpiry < Math.floor(Date.now() / 1000)) {
                throw new Error(`Payload expired for quote ${quoteData.txid}`);
            }
            if (!this.contractsApi[chainId]) {
                this.contractsApi[chainId] = new sdk_1.Hashflow({ chainId, signer });
            }
            const hashflow = this.contractsApi[chainId];
            const quoteStruct = {
                pool: quoteData.pool,
                externalAccount: (_a = quoteData.externalAccount) !== null && _a !== void 0 ? _a : contracts_evm_1.ZERO_ADDRESS,
                trader: quoteData.trader,
                effectiveTrader: (_b = quoteData.effectiveTrader) !== null && _b !== void 0 ? _b : quoteData.trader,
                baseToken: quoteData.baseToken,
                quoteToken: quoteData.quoteToken,
                effectiveBaseTokenAmount: quoteData.baseTokenAmount,
                baseTokenAmount: quoteData.baseTokenAmount,
                quoteTokenAmount: quoteData.quoteTokenAmount,
                quoteExpiry: quoteData.quoteExpiry,
                nonce: (_c = quoteData.nonce) !== null && _c !== void 0 ? _c : 0,
                txid: quoteData.txid,
                signature,
            };
            const value = quoteData.baseToken === contracts_evm_1.ZERO_ADDRESS ? quoteData.baseTokenAmount : '0';
            try {
                yield hashflow.contracts.hRouter.tradeRFQT.estimateGas(quoteStruct, {
                    value,
                });
            }
            catch (err) {
                throw new Error(`Gas Estimation failed ${quoteData.txid}: ${err.message}`);
            }
            try {
                const { hash } = yield hashflow.contracts.hRouter.tradeRFQT(quoteStruct, Object.assign(Object.assign({}, options), { value }));
                return hash;
            }
            catch (err) {
                throw new Error(`RPC submission failed: ${err.message}`);
            }
        });
    }
}
exports.HashflowApi = HashflowApi;
//# sourceMappingURL=api.js.map